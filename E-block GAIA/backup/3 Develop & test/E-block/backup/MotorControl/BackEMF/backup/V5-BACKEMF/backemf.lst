   1               		.file	"backemf.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  79               	.global	g_cmd_decode
  80               	.global	g_cmd_decode
  81               		.section .bss
  84               	g_cmd_decode:
  85 0000 00        		.skip 1,0
  86               	.global	g_pos
  87               	.global	g_pos
  90               	g_pos:
  91 0001 0000 0000 		.skip 8,0
  91      0000 0000 
  92               	.global	g_adc_channel
  93               		.data
  96               	g_adc_channel:
  97 0000 10        		.byte	16
  98 0001 1B        		.byte	27
  99               	.global	g_speed_table
 102               	g_speed_table:
 103 0002 78        		.byte	120
 104 0003 96        		.byte	-106
 105 0004 BE        		.byte	-66
 106 0005 C8        		.byte	-56
 107 0006 D2        		.byte	-46
 108 0007 DC        		.byte	-36
 109 0008 E6        		.byte	-26
 110 0009 F0        		.byte	-16
 111 000a FA        		.byte	-6
 112               	.global	g_mode
 113               	.global	g_mode
 114               		.section .bss
 117               	g_mode:
 118 0009 0000      		.skip 2,0
 119               		.text
 122               	.global	delay
 124               	delay:
   1:backemf.c     **** /*
   2:backemf.c     **** 
   3:backemf.c     ****  Module 				:   IO Test Module
   4:backemf.c     ****  Description 			:   IO  Test module for CHapter xxx
   5:backemf.c     ****  Original written for 	:   ATMEGA32
   6:backemf.c     ****  CPU port/tested		:   ATMEGA32
   7:backemf.c     ****  Hardware use			:   Dual 7 Segments common cathode module
   8:backemf.c     ****  Port use				:   E_PORTA (0-7), E_PORTB (0-1)
   9:backemf.c     ****  Memory	FLASH			:   XXX
  10:backemf.c     **** 		RAM				:   XXX
  11:backemf.c     **** 		EEPROM			:   XXX
  12:backemf.c     ****  Document				:   Document describe algorithm
  13:backemf.c     ****  Written by 			:   Wichai  wichai@geartronics.net
  14:backemf.c     ****  Date					:  	23/04/2006
  15:backemf.c     ****   
  16:backemf.c     ****  Update History
  17:backemf.c     ****  
  18:backemf.c     ****  Date			By 					Comments
  19:backemf.c     ****  ----			--					---------
  20:backemf.c     ****  
  21:backemf.c     ****  
  22:backemf.c     ****   */
  23:backemf.c     **** 
  24:backemf.c     **** #include <avr/interrupt.h>
  25:backemf.c     **** #include <avr/io.h>
  26:backemf.c     **** #include <avr/signal.h>
  27:backemf.c     **** #include <stdlib.h>
  28:backemf.c     **** #include "Dual_7Segment.h"
  29:backemf.c     **** #include "DC_motor.h"
  30:backemf.c     **** #include "ir_tv.h"
  31:backemf.c     **** #include "E_uart.h"
  32:backemf.c     **** #include "text_decode.h"
  33:backemf.c     **** #include  "adc.h"
  34:backemf.c     **** 
  35:backemf.c     **** 
  36:backemf.c     **** // Operation Mode
  37:backemf.c     **** #define DEBUG
  38:backemf.c     **** 
  39:backemf.c     **** 
  40:backemf.c     **** 
  41:backemf.c     **** 
  42:backemf.c     **** // Global variable
  43:backemf.c     **** 
  44:backemf.c     **** // Motor control
  45:backemf.c     **** 
  46:backemf.c     **** uint8_t  g_mode[MOTOR_MAX]  = {MOTOR_STOP,MOTOR_STOP};
  47:backemf.c     **** uint8_t  g_motor;             	// Motor number to process
  48:backemf.c     **** 
  49:backemf.c     **** uint16_t g_speed[MOTOR_MAX];				// Speed Motor
  50:backemf.c     **** uint8_t  g_speed_table[MOTOR_MAX_SPEED] = {120,150,190,200,210,220,230,240,250}; 
  51:backemf.c     **** 
  52:backemf.c     **** uint8_t  g_adc_channel[MOTOR_MAX] = {0x10,0x1b};  // ADC0-1 x1 Diff and ADC2-3 x1 Diff
  53:backemf.c     **** int32_t  g_pos[MOTOR_MAX] = {0,0};
  54:backemf.c     **** int32_t  g_angle[MOTOR_MAX];	            // Motor Angle	
  55:backemf.c     **** 
  56:backemf.c     **** // ------ UART
  57:backemf.c     **** uint8_t  g_rcv_buff[MAX_BUFF]; 
  58:backemf.c     **** uint8_t	 g_cmd_decode =0;				// 1 = Ready to decode 
  59:backemf.c     **** 
  60:backemf.c     **** 
  61:backemf.c     **** 
  62:backemf.c     **** void main(void);
  63:backemf.c     **** void init_board(void);
  64:backemf.c     **** 
  65:backemf.c     **** 
  66:backemf.c     **** 
  67:backemf.c     **** void delay ( uint16_t  time)
  68:backemf.c     **** {
 126               	.LM1:
 127               	/* prologue: frame size=0 */
 128               	/* prologue end (size=0) */
 129               	.L8:
  69:backemf.c     ****    uint16_t i;
  70:backemf.c     ****    for (i = 0 ; i < time; i++);
 131               	.LM2:
 132 0000 0097      		sbiw r24,0
 133 0002 11F0      		breq .L7
 135               	.LM3:
 136 0004 0197      		sbiw r24,1
 137 0006 FCCF      		rjmp .L8
 138               	.L7:
 139 0008 0895      		ret
 140               	/* epilogue: frame size=0 */
 141               	/* epilogue: noreturn */
 142               	/* epilogue end (size=0) */
 143               	/* function delay size 5 (5) */
 148               	.Lscope0:
 151               	.global	set_motor_parameter
 153               	set_motor_parameter:
  71:backemf.c     **** 
  72:backemf.c     **** }
  73:backemf.c     **** 
  74:backemf.c     **** void  set_motor_parameter ( uint8_t mode)
  75:backemf.c     **** {
 155               	.LM4:
 156               	/* prologue: frame size=0 */
 157               	/* prologue end (size=0) */
  76:backemf.c     ****    switch (mode)
 159               	.LM5:
 160 000a 9927      		clr r25
 161 000c 8230      		cpi r24,2
 162 000e 9105      		cpc r25,__zero_reg__
 163 0010 81F0      		breq .L12
 165               	.LM6:
 166 0012 8330      		cpi r24,3
 167 0014 9105      		cpc r25,__zero_reg__
 168 0016 2CF4      		brge .L17
 169 0018 0097      		sbiw r24,0
 170 001a 79F1      		breq .L16
 171 001c 0197      		sbiw r24,1
 172 001e 39F0      		breq .L11
 173 0020 2CC0      		rjmp .L16
 174               	.L17:
 175 0022 8430      		cpi r24,4
 176 0024 9105      		cpc r25,__zero_reg__
 177 0026 F9F0      		breq .L14
 178 0028 0597      		sbiw r24,5
 179 002a 11F1      		breq .L15
 180 002c 26C0      		rjmp .L16
 181               	.L11:
  77:backemf.c     ****    {
  78:backemf.c     ****     case  MOTOR_FORWARD:
  79:backemf.c     ****         g_mode[0] = MOTOR_FORWARD;		
 183               	.LM7:
 184 002e 81E0      		ldi r24,lo8(1)
 185 0030 01C0      		rjmp .L18
 186               	.L12:
  80:backemf.c     **** 		g_mode[1] = MOTOR_FORWARD;
  81:backemf.c     **** 		g_angle[0] = 1;
  82:backemf.c     **** 		g_angle[1] = 1;
  83:backemf.c     **** 		break;
  84:backemf.c     **** 	case  MOTOR_BACKWARD:
  85:backemf.c     **** 		g_mode[0] = MOTOR_BACKWARD;
 188               	.LM8:
 189 0032 82E0      		ldi r24,lo8(2)
 190               	.L18:
 191 0034 8093 0000 		sts g_mode,r24
 192               	.L19:
  86:backemf.c     **** 		g_mode[1] = MOTOR_BACKWARD;
 194               	.LM9:
 195 0038 8093 0000 		sts g_mode+1,r24
  87:backemf.c     **** 		g_angle[0] = 1;
 197               	.LM10:
 198 003c 81E0      		ldi r24,lo8(1)
 199 003e 90E0      		ldi r25,hi8(1)
 200 0040 A0E0      		ldi r26,hlo8(1)
 201 0042 B0E0      		ldi r27,hhi8(1)
 202 0044 8093 0000 		sts g_angle,r24
 203 0048 9093 0000 		sts (g_angle)+1,r25
 204 004c A093 0000 		sts (g_angle)+2,r26
 205 0050 B093 0000 		sts (g_angle)+3,r27
  88:backemf.c     **** 		g_angle[1] = 1;
 207               	.LM11:
 208 0054 8093 0000 		sts g_angle+4,r24
 209 0058 9093 0000 		sts (g_angle+4)+1,r25
 210 005c A093 0000 		sts (g_angle+4)+2,r26
 211 0060 B093 0000 		sts (g_angle+4)+3,r27
  89:backemf.c     **** 		break;
 213               	.LM12:
 214 0064 0895      		ret
 215               	.L14:
  90:backemf.c     ****     case MOTOR_STOP:
  91:backemf.c     **** 		g_mode[0]  = MOTOR_STOP;
  92:backemf.c     **** 		g_mode[1]  = MOTOR_STOP;
  93:backemf.c     **** 		g_angle[0] = 0;
  94:backemf.c     **** 		g_angle[1] = 0;
  95:backemf.c     **** 		break;
  96:backemf.c     **** 	case MOTOR_TURN_LEFT:
  97:backemf.c     **** 		g_mode[0] = MOTOR_FORWARD;		
 217               	.LM13:
 218 0066 81E0      		ldi r24,lo8(1)
 219 0068 8093 0000 		sts g_mode,r24
  98:backemf.c     **** 		g_mode[1] = MOTOR_BACKWARD;
 221               	.LM14:
 222 006c 82E0      		ldi r24,lo8(2)
 223 006e E4CF      		rjmp .L19
 224               	.L15:
  99:backemf.c     **** 		g_angle[0] = 1;
 100:backemf.c     **** 		g_angle[1] = 1;
 101:backemf.c     **** 		break;
 102:backemf.c     **** 	case MOTOR_TURN_RIGHT:
 103:backemf.c     **** 		g_mode[0] = MOTOR_BACKWARD;
 226               	.LM15:
 227 0070 82E0      		ldi r24,lo8(2)
 228 0072 8093 0000 		sts g_mode,r24
 104:backemf.c     **** 		g_mode[1] = MOTOR_FORWARD;
 230               	.LM16:
 231 0076 81E0      		ldi r24,lo8(1)
 232 0078 DFCF      		rjmp .L19
 233               	.L16:
 105:backemf.c     **** 		g_angle[0] = 1;
 106:backemf.c     **** 		g_angle[1] = 1;
 107:backemf.c     **** 		break;
 108:backemf.c     **** 	 default:
 109:backemf.c     **** 	 	g_mode[0]  = MOTOR_STOP;
 235               	.LM17:
 236 007a 1092 0000 		sts g_mode,__zero_reg__
 110:backemf.c     **** 		g_mode[1]  = MOTOR_STOP;
 238               	.LM18:
 239 007e 1092 0000 		sts g_mode+1,__zero_reg__
 111:backemf.c     **** 		g_angle[0] = 0;
 241               	.LM19:
 242 0082 1092 0000 		sts g_angle,__zero_reg__
 243 0086 1092 0000 		sts (g_angle)+1,__zero_reg__
 244 008a 1092 0000 		sts (g_angle)+2,__zero_reg__
 245 008e 1092 0000 		sts (g_angle)+3,__zero_reg__
 112:backemf.c     **** 		g_angle[1] = 0;
 247               	.LM20:
 248 0092 1092 0000 		sts g_angle+4,__zero_reg__
 249 0096 1092 0000 		sts (g_angle+4)+1,__zero_reg__
 250 009a 1092 0000 		sts (g_angle+4)+2,__zero_reg__
 251 009e 1092 0000 		sts (g_angle+4)+3,__zero_reg__
 252 00a2 0895      		ret
 253               	/* epilogue: frame size=0 */
 254 00a4 0895      		ret
 255               	/* epilogue end (size=1) */
 256               	/* function set_motor_parameter size 80 (79) */
 258               	.Lscope1:
 259               		.data
 260               	.LC0:
 261 000b 566F 6C74 		.string	"Voltage SUM 1"
 261      6167 6520 
 261      5355 4D20 
 261      3100 
 262               	.LC1:
 263 0019 566F 6C74 		.string	"Voltage SUM 2"
 263      6167 6520 
 263      5355 4D20 
 263      3200 
 264               		.text
 267               	.global	remote_decode
 269               	remote_decode:
 113:backemf.c     **** 		break;
 114:backemf.c     ****    }
 115:backemf.c     ****   
 116:backemf.c     **** }
 117:backemf.c     **** 
 118:backemf.c     **** /* This subroutine will handle IR remote decode by getting remote code from Interrupt handle for in
 119:backemf.c     **** and will response  to each remote key. For other applications user can modified here for different 
 120:backemf.c     **** However this routine support Sony remote control only
 121:backemf.c     ****    global effect   g_irint;
 122:backemf.c     **** */
 123:backemf.c     **** 
 124:backemf.c     **** void remote_decode ( uint16_t ircode)
 125:backemf.c     **** { 
 271               	.LM21:
 272               	/* prologue: frame size=0 */
 273 00a6 CF93      		push r28
 274               	/* prologue end (size=1) */
 126:backemf.c     **** 
 127:backemf.c     ****   uint8_t set_speed = 8 ;
 276               	.LM22:
 277 00a8 C8E0      		ldi r28,lo8(8)
 128:backemf.c     ****   switch ( ircode)
 279               	.LM23:
 280 00aa 26E0      		ldi r18,hi8(1552)
 281 00ac 8031      		cpi r24,lo8(1552)
 282 00ae 9207      		cpc r25,r18
 283 00b0 09F4      		brne .+2
 284 00b2 5EC0      		rjmp .L28
 286               	.LM24:
 287 00b4 26E0      		ldi r18,hi8(1553)
 288 00b6 8131      		cpi r24,lo8(1553)
 289 00b8 9207      		cpc r25,r18
 290 00ba 20F5      		brsh .L40
 291 00bc 21E0      		ldi r18,hi8(272)
 292 00be 8031      		cpi r24,lo8(272)
 293 00c0 9207      		cpc r25,r18
 294 00c2 09F4      		brne .+2
 295 00c4 94C0      		rjmp .L21
 296 00c6 21E0      		ldi r18,hi8(273)
 297 00c8 8131      		cpi r24,lo8(273)
 298 00ca 9207      		cpc r25,r18
 299 00cc 48F4      		brsh .L41
 300 00ce 8031      		cpi r24,16
 301 00d0 9105      		cpc r25,__zero_reg__
 302 00d2 09F4      		brne .+2
 303 00d4 41C0      		rjmp .L22
 304 00d6 8039      		cpi r24,144
 305 00d8 9105      		cpc r25,__zero_reg__
 306 00da 09F4      		brne .+2
 307 00dc 7FC0      		rjmp .L32
 308 00de 87C0      		rjmp .L21
 309               	.L41:
 310 00e0 24E0      		ldi r18,hi8(1040)
 311 00e2 8031      		cpi r24,lo8(1040)
 312 00e4 9207      		cpc r25,r18
 313 00e6 09F4      		brne .+2
 314 00e8 3BC0      		rjmp .L24
 315 00ea 24E0      		ldi r18,hi8(1041)
 316 00ec 8131      		cpi r24,lo8(1041)
 317 00ee 9207      		cpc r25,r18
 318 00f0 20F4      		brsh .L42
 319 00f2 8051      		subi r24,lo8(528)
 320 00f4 9240      		sbci r25,hi8(528)
 321 00f6 C1F1      		breq .L26
 322 00f8 7AC0      		rjmp .L21
 323               	.L42:
 324 00fa 8059      		subi r24,lo8(1168)
 325 00fc 9440      		sbci r25,hi8(1168)
 326 00fe 09F4      		brne .+2
 327 0100 71C0      		rjmp .L37
 328 0102 75C0      		rjmp .L21
 329               	.L40:
 330 0104 2AE0      		ldi r18,hi8(2576)
 331 0106 8031      		cpi r24,lo8(2576)
 332 0108 9207      		cpc r25,r18
 333 010a 81F1      		breq .L27
 334 010c 2AE0      		ldi r18,hi8(2577)
 335 010e 8131      		cpi r24,lo8(2577)
 336 0110 9207      		cpc r25,r18
 337 0112 88F4      		brsh .L43
 338 0114 28E0      		ldi r18,hi8(2192)
 339 0116 8039      		cpi r24,lo8(2192)
 340 0118 9207      		cpc r25,r18
 341 011a 09F4      		brne .+2
 342 011c 61C0      		rjmp .L33
 343 011e 28E0      		ldi r18,hi8(2193)
 344 0120 8139      		cpi r24,lo8(2193)
 345 0122 9207      		cpc r25,r18
 346 0124 20F4      		brsh .L44
 347 0126 8051      		subi r24,lo8(2064)
 348 0128 9840      		sbci r25,hi8(2064)
 349 012a C1F0      		breq .L23
 350 012c 60C0      		rjmp .L21
 351               	.L44:
 352 012e 8051      		subi r24,lo8(2320)
 353 0130 9940      		sbci r25,hi8(2320)
 354 0132 11F1      		breq .L31
 355 0134 5CC0      		rjmp .L21
 356               	.L43:
 357 0136 2CE0      		ldi r18,hi8(3216)
 358 0138 8039      		cpi r24,lo8(3216)
 359 013a 9207      		cpc r25,r18
 360 013c 09F4      		brne .+2
 361 013e 54C0      		rjmp .L38
 362 0140 2CE0      		ldi r18,hi8(3217)
 363 0142 8139      		cpi r24,lo8(3217)
 364 0144 9207      		cpc r25,r18
 365 0146 20F4      		brsh .L45
 366 0148 8051      		subi r24,lo8(3088)
 367 014a 9C40      		sbci r25,hi8(3088)
 368 014c 59F0      		breq .L25
 369 014e 4FC0      		rjmp .L21
 370               	.L45:
 371 0150 8051      		subi r24,lo8(3600)
 372 0152 9E40      		sbci r25,hi8(3600)
 373 0154 79F0      		breq .L29
 374 0156 4BC0      		rjmp .L21
 375               	.L22:
 129:backemf.c     **** 	   {
 130:backemf.c     **** 	    case IR_TV_1:	
 131:backemf.c     ****  			set_speed = 0;
 377               	.LM25:
 378 0158 C0E0      		ldi r28,lo8(0)
 132:backemf.c     **** 			 break;
 380               	.LM26:
 381 015a 49C0      		rjmp .L21
 382               	.L23:
 133:backemf.c     **** 		case IR_TV_2:
 134:backemf.c     **** 			set_speed =1;
 384               	.LM27:
 385 015c C1E0      		ldi r28,lo8(1)
 135:backemf.c     **** 			break;
 387               	.LM28:
 388 015e 47C0      		rjmp .L21
 389               	.L24:
 136:backemf.c     **** 	    case IR_TV_3:
 137:backemf.c     ****  			set_speed =2;			
 391               	.LM29:
 392 0160 C2E0      		ldi r28,lo8(2)
 138:backemf.c     **** 			break;
 394               	.LM30:
 395 0162 45C0      		rjmp .L21
 396               	.L25:
 139:backemf.c     **** 		case IR_TV_4:
 140:backemf.c     ****  			set_speed =3;			
 398               	.LM31:
 399 0164 C3E0      		ldi r28,lo8(3)
 141:backemf.c     **** 			 break;
 401               	.LM32:
 402 0166 43C0      		rjmp .L21
 403               	.L26:
 142:backemf.c     **** 	    case IR_TV_5:
 143:backemf.c     ****  			set_speed =4;			
 405               	.LM33:
 406 0168 C4E0      		ldi r28,lo8(4)
 144:backemf.c     **** 			 break;
 408               	.LM34:
 409 016a 41C0      		rjmp .L21
 410               	.L27:
 145:backemf.c     **** 		case IR_TV_6:
 146:backemf.c     ****  			set_speed = 5;			
 412               	.LM35:
 413 016c C5E0      		ldi r28,lo8(5)
 147:backemf.c     **** 			 break;
 415               	.LM36:
 416 016e 3FC0      		rjmp .L21
 417               	.L28:
 148:backemf.c     **** 	    case IR_TV_7:
 149:backemf.c     ****  			set_speed = 6;			
 419               	.LM37:
 420 0170 C6E0      		ldi r28,lo8(6)
 150:backemf.c     **** 			break;
 422               	.LM38:
 423 0172 3DC0      		rjmp .L21
 424               	.L29:
 151:backemf.c     **** 		case IR_TV_8:
 152:backemf.c     ****  			set_speed = 7;			
 426               	.LM39:
 427 0174 C7E0      		ldi r28,lo8(7)
 153:backemf.c     **** 			break;
 429               	.LM40:
 430 0176 3BC0      		rjmp .L21
 431               	.L31:
 154:backemf.c     **** 	    case IR_TV_9:
 155:backemf.c     ****  			set_speed =8;			
 156:backemf.c     **** 			break;
 157:backemf.c     **** 		case IR_TV_0:
 158:backemf.c     **** 			set_motor_parameter (MOTOR_STOP);
 433               	.LM41:
 434 0178 80E0      		ldi r24,lo8(0)
 435 017a 0E94 0000 		call set_motor_parameter
 159:backemf.c     **** 			uart_puts ("Voltage SUM 1");
 437               	.LM42:
 438 017e 80E0      		ldi r24,lo8(.LC0)
 439 0180 90E0      		ldi r25,hi8(.LC0)
 440 0182 0E94 0000 		call uart_puts
 160:backemf.c     **** 			debug_lvalue(g_pos[0],10);
 442               	.LM43:
 443 0186 4AE0      		ldi r20,lo8(10)
 444 0188 6091 0000 		lds r22,g_pos
 445 018c 7091 0000 		lds r23,(g_pos)+1
 446 0190 8091 0000 		lds r24,(g_pos)+2
 447 0194 9091 0000 		lds r25,(g_pos)+3
 448 0198 0E94 0000 		call debug_lvalue
 161:backemf.c     **** 			g_pos[0] =0;
 450               	.LM44:
 451 019c 1092 0000 		sts g_pos,__zero_reg__
 452 01a0 1092 0000 		sts (g_pos)+1,__zero_reg__
 453 01a4 1092 0000 		sts (g_pos)+2,__zero_reg__
 454 01a8 1092 0000 		sts (g_pos)+3,__zero_reg__
 162:backemf.c     **** 			uart_puts ("Voltage SUM 2");
 456               	.LM45:
 457 01ac 80E0      		ldi r24,lo8(.LC1)
 458 01ae 90E0      		ldi r25,hi8(.LC1)
 459 01b0 0E94 0000 		call uart_puts
 163:backemf.c     **** 			debug_lvalue(g_pos[1],10);
 461               	.LM46:
 462 01b4 4AE0      		ldi r20,lo8(10)
 463 01b6 6091 0000 		lds r22,g_pos+4
 464 01ba 7091 0000 		lds r23,(g_pos+4)+1
 465 01be 8091 0000 		lds r24,(g_pos+4)+2
 466 01c2 9091 0000 		lds r25,(g_pos+4)+3
 467 01c6 0E94 0000 		call debug_lvalue
 164:backemf.c     **** 			g_pos[1] =0;
 469               	.LM47:
 470 01ca 1092 0000 		sts g_pos+4,__zero_reg__
 471 01ce 1092 0000 		sts (g_pos+4)+1,__zero_reg__
 472 01d2 1092 0000 		sts (g_pos+4)+2,__zero_reg__
 473 01d6 1092 0000 		sts (g_pos+4)+3,__zero_reg__
 165:backemf.c     **** 			break;
 475               	.LM48:
 476 01da 09C0      		rjmp .L21
 477               	.L32:
 166:backemf.c     **** 		case IR_TV_CHUP:
 167:backemf.c     **** 			set_motor_parameter(MOTOR_FORWARD);
 479               	.LM49:
 480 01dc 81E0      		ldi r24,lo8(1)
 481 01de 05C0      		rjmp .L46
 482               	.L33:
 168:backemf.c     **** 			break;
 169:backemf.c     **** 		case IR_TV_CHDOWN:							
 170:backemf.c     **** 			set_motor_parameter(MOTOR_BACKWARD);
 484               	.LM50:
 485 01e0 82E0      		ldi r24,lo8(2)
 486 01e2 03C0      		rjmp .L46
 487               	.L37:
 171:backemf.c     **** 			break;
 172:backemf.c     **** 		case IR_TV_TVMUTE:
 173:backemf.c     **** 			break;
 174:backemf.c     **** 		case  IR_TV_TVPOWER:
 175:backemf.c     **** 		  	break;
 176:backemf.c     **** 		case   IR_TV_TVAV:
 177:backemf.c     **** 		    break;
 178:backemf.c     **** 		case  IR_TV_VOLUP:
 179:backemf.c     ****             set_motor_parameter(MOTOR_TURN_LEFT);
 489               	.LM51:
 490 01e4 84E0      		ldi r24,lo8(4)
 491 01e6 01C0      		rjmp .L46
 492               	.L38:
 180:backemf.c     **** 			break;
 181:backemf.c     **** 		case  IR_TV_VOLDOWN:                 			
 182:backemf.c     **** 		    set_motor_parameter(MOTOR_TURN_RIGHT);
 494               	.LM52:
 495 01e8 85E0      		ldi r24,lo8(5)
 496               	.L46:
 497 01ea 0E94 0000 		call set_motor_parameter
 498               	.L21:
 183:backemf.c     **** 			break;
 184:backemf.c     **** 		default:
 185:backemf.c     ****  //			set_motor_parameter (MOTOR_STOP);
 186:backemf.c     **** 			break;
 187:backemf.c     ****  	   }
 188:backemf.c     **** 	   g_speed[1] = g_speed_table[set_speed]; 
 500               	.LM53:
 501 01ee EC2F      		mov r30,r28
 502 01f0 FF27      		clr r31
 503 01f2 E050      		subi r30,lo8(-(g_speed_table))
 504 01f4 F040      		sbci r31,hi8(-(g_speed_table))
 505 01f6 8081      		ld r24,Z
 506 01f8 9927      		clr r25
 507 01fa 9093 0000 		sts (g_speed+2)+1,r25
 508 01fe 8093 0000 		sts g_speed+2,r24
 189:backemf.c     **** 	   g_speed[0] = g_speed[1];
 510               	.LM54:
 511 0202 9093 0000 		sts (g_speed)+1,r25
 512 0206 8093 0000 		sts g_speed,r24
 513               	/* epilogue: frame size=0 */
 514 020a CF91      		pop r28
 515 020c 0895      		ret
 516               	/* epilogue end (size=2) */
 517               	/* function remote_decode size 186 (183) */
 522               	.Lscope2:
 523               		.data
 524               	.LC2:
 525 0027 436F 6D6D 		.string	"Command :"
 525      616E 6420 
 525      3A00 
 526               	.LC3:
 527 0031 436F 6D6D 		.string	"Command not found "
 527      616E 6420 
 527      6E6F 7420 
 527      666F 756E 
 527      6420 00
 528               		.text
 530               	.global	cmd_decode
 532               	cmd_decode:
 190:backemf.c     **** 
 191:backemf.c     **** }
 192:backemf.c     **** 
 193:backemf.c     **** 
 194:backemf.c     **** 
 195:backemf.c     **** /* Command decode from g_rcv_buffer  will decode and action according to command in buffer
 196:backemf.c     ****  
 197:backemf.c     **** */
 198:backemf.c     **** 
 199:backemf.c     **** int16_t cmd_decode (void)
 200:backemf.c     **** {
 534               	.LM55:
 535               	/* prologue: frame size=0 */
 536 020e FF92      		push r15
 537 0210 0F93      		push r16
 538 0212 1F93      		push r17
 539 0214 CF93      		push r28
 540 0216 DF93      		push r29
 541               	/* prologue end (size=5) */
 542               	.L68:
 201:backemf.c     **** 
 202:backemf.c     ****  uint8_t  cmd_no =0;
 203:backemf.c     ****  uint8_t  *cmd_argument;
 204:backemf.c     ****  uint8_t  *buffer_ptr;
 205:backemf.c     ****  uint8_t   i;
 206:backemf.c     ****  
 207:backemf.c     **** // Should repeat until end of buffer
 208:backemf.c     ****  
 209:backemf.c     **** // Loop until end of text
 210:backemf.c     **** 
 211:backemf.c     ****    buffer_ptr   = g_rcv_buff;
 212:backemf.c     ****    cmd_argument = g_rcv_buff;
 213:backemf.c     ****      
 214:backemf.c     ****    while ( cmd_no !=  CMD_LINE_END)     // Until end of line which mean g_motor will change
 215:backemf.c     ****    {
 216:backemf.c     ****  		cmd_no =  text_decode (buffer_ptr,cmd_argument);
 544               	.LM56:
 545 0218 60E0      		ldi r22,lo8(g_rcv_buff)
 546 021a 70E0      		ldi r23,hi8(g_rcv_buff)
 547 021c CB01      		movw r24,r22
 548 021e 0E94 0000 		call text_decode
 549 0222 F82E      		mov r15,r24
 217:backemf.c     **** #ifdef DEBUG		
 218:backemf.c     **** 		uart_puts("Command :");
 551               	.LM57:
 552 0224 80E0      		ldi r24,lo8(.LC2)
 553 0226 90E0      		ldi r25,hi8(.LC2)
 554 0228 0E94 0000 		call uart_puts
 219:backemf.c     **** 		uart_putc(0x30+cmd_no);
 556               	.LM58:
 557 022c 8F2D      		mov r24,r15
 558 022e 805D      		subi r24,lo8(-(48))
 559 0230 0E94 0000 		call uart_putc
 220:backemf.c     **** 		uart_putc('*');
 561               	.LM59:
 562 0234 8AE2      		ldi r24,lo8(42)
 563 0236 0E94 0000 		call uart_putc
 221:backemf.c     **** 		uart_puts(cmd_argument);
 565               	.LM60:
 566 023a 80E0      		ldi r24,lo8(g_rcv_buff)
 567 023c 90E0      		ldi r25,hi8(g_rcv_buff)
 568 023e 0E94 0000 		call uart_puts
 222:backemf.c     **** #endif        
 223:backemf.c     ****  		switch (cmd_no)
 570               	.LM61:
 571 0242 8F2D      		mov r24,r15
 572 0244 9927      		clr r25
 573 0246 8230      		cpi r24,2
 574 0248 9105      		cpc r25,__zero_reg__
 575 024a C9F0      		breq .L54
 577               	.LM62:
 578 024c 8330      		cpi r24,3
 579 024e 9105      		cpc r25,__zero_reg__
 580 0250 1CF4      		brge .L67
 581 0252 0197      		sbiw r24,1
 582 0254 21F0      		breq .L51
 583 0256 93C0      		rjmp .L66
 584               	.L67:
 585 0258 0397      		sbiw r24,3
 586 025a 81F1      		breq .L58
 587 025c 90C0      		rjmp .L66
 588               	.L51:
 224:backemf.c     **** 		{
 225:backemf.c     **** 			case MOTOR_CMD: 
 226:backemf.c     **** 				g_motor = (uint8_t)atoi(cmd_argument);
 590               	.LM63:
 591 025e 80E0      		ldi r24,lo8(g_rcv_buff)
 592 0260 90E0      		ldi r25,hi8(g_rcv_buff)
 593 0262 0E94 0000 		call atoi
 594 0266 8093 0000 		sts g_motor,r24
 227:backemf.c     **** 				if (g_motor > 0)
 596               	.LM64:
 597 026a 282F      		mov r18,r24
 598 026c 8823      		tst r24
 599 026e 21F0      		breq .L52
 228:backemf.c     **** 				   g_motor--;                //  > 0 Start from 0 need -1
 601               	.LM65:
 602 0270 2150      		subi r18,lo8(-(-1))
 603 0272 2093 0000 		sts g_motor,r18
 604 0276 87C0      		rjmp .L48
 605               	.L52:
 229:backemf.c     **** 				else
 230:backemf.c     **** 				   g_motor = 0;
 607               	.LM66:
 608 0278 8093 0000 		sts g_motor,r24
 231:backemf.c     ****  				break;
 610               	.LM67:
 611 027c 84C0      		rjmp .L48
 612               	.L54:
 232:backemf.c     **** 			case  SPEED_CMD:	
 233:backemf.c     **** 				i = (uint8_t)atoi(cmd_argument);
 614               	.LM68:
 615 027e 80E0      		ldi r24,lo8(g_rcv_buff)
 616 0280 90E0      		ldi r25,hi8(g_rcv_buff)
 617 0282 0E94 0000 		call atoi
 618 0286 E82F      		mov r30,r24
 234:backemf.c     **** 				if ( i >=  MOTOR_MAX_SPEED)
 620               	.LM69:
 621 0288 8930      		cpi r24,lo8(9)
 622 028a 10F0      		brlo .L55
 235:backemf.c     **** 						i = MOTOR_MAX_SPEED;    // Start from 0
 624               	.LM70:
 625 028c E9E0      		ldi r30,lo8(9)
 626 028e 01C0      		rjmp .L71
 627               	.L55:
 236:backemf.c     **** 				if (i)   // i > 0; 		
 629               	.LM71:
 630 0290 8111      		cpse r24,__zero_reg__
 631               	.L71:
 237:backemf.c     **** 					i--;   //Start from 0;		
 633               	.LM72:
 634 0292 E150      		subi r30,lo8(-(-1))
 635               	.L56:
 238:backemf.c     **** 				g_speed[g_motor] =  g_speed_table[i];
 637               	.LM73:
 638 0294 8091 0000 		lds r24,g_motor
 639 0298 C82F      		mov r28,r24
 640 029a DD27      		clr r29
 641 029c DE01      		movw r26,r28
 642 029e AC0F      		add r26,r28
 643 02a0 BD1F      		adc r27,r29
 644 02a2 A050      		subi r26,lo8(-(g_speed))
 645 02a4 B040      		sbci r27,hi8(-(g_speed))
 646 02a6 FF27      		clr r31
 647 02a8 E050      		subi r30,lo8(-(g_speed_table))
 648 02aa F040      		sbci r31,hi8(-(g_speed_table))
 649 02ac 8081      		ld r24,Z
 650 02ae 9927      		clr r25
 651 02b0 8D93      		st X+,r24
 652 02b2 9C93      		st X,r25
 239:backemf.c     **** 				if (g_speed[g_motor] == 0)
 654               	.LM74:
 655 02b4 892B      		or r24,r25
 656 02b6 09F0      		breq .+2
 657 02b8 66C0      		rjmp .L48
 658 02ba 32C0      		rjmp .L73
 659               	.L58:
 240:backemf.c     **** 				        g_mode[g_motor] = MOTOR_STOP;
 241:backemf.c     ****   				break;
 242:backemf.c     **** 			case  ANGLE_CMD:   // Can be - 
 243:backemf.c     **** 				g_angle[g_motor] = atoi(cmd_argument);
 661               	.LM75:
 662 02bc 8091 0000 		lds r24,g_motor
 663 02c0 C82F      		mov r28,r24
 664 02c2 DD27      		clr r29
 665 02c4 8E01      		movw r16,r28
 666 02c6 000F      		lsl r16
 667 02c8 111F      		rol r17
 668 02ca 000F      		lsl r16
 669 02cc 111F      		rol r17
 670 02ce 0050      		subi r16,lo8(-(g_angle))
 671 02d0 1040      		sbci r17,hi8(-(g_angle))
 672 02d2 80E0      		ldi r24,lo8(g_rcv_buff)
 673 02d4 90E0      		ldi r25,hi8(g_rcv_buff)
 674 02d6 0E94 0000 		call atoi
 675 02da 9C01      		movw r18,r24
 676 02dc 4427      		clr r20
 677 02de 37FD      		sbrc r19,7
 678 02e0 4095      		com r20
 679 02e2 542F      		mov r21,r20
 680 02e4 F801      		movw r30,r16
 681 02e6 2083      		st Z,r18
 682 02e8 3183      		std Z+1,r19
 683 02ea 4283      		std Z+2,r20
 684 02ec 5383      		std Z+3,r21
 244:backemf.c     **** 				if (g_angle[g_motor] < 0)
 686               	.LM76:
 687 02ee 57FF      		sbrs r21,7
 688 02f0 12C0      		rjmp .L59
 245:backemf.c     **** 				{   
 246:backemf.c     **** 						g_mode[g_motor] = MOTOR_BACKWARD;
 690               	.LM77:
 691 02f2 FE01      		movw r30,r28
 692 02f4 E050      		subi r30,lo8(-(g_mode))
 693 02f6 F040      		sbci r31,hi8(-(g_mode))
 694 02f8 82E0      		ldi r24,lo8(2)
 695 02fa 8083      		st Z,r24
 247:backemf.c     **** // Set g_angle to positive value by invert all bit and +1                
 248:backemf.c     ****                         g_angle[g_motor] = (~(g_angle[g_motor])+1);
 697               	.LM78:
 698 02fc 6627      		clr r22
 699 02fe 7727      		clr r23
 700 0300 CB01      		movw r24,r22
 701 0302 621B      		sub r22,r18
 702 0304 730B      		sbc r23,r19
 703 0306 840B      		sbc r24,r20
 704 0308 950B      		sbc r25,r21
 705 030a F801      		movw r30,r16
 706 030c 6083      		st Z,r22
 707 030e 7183      		std Z+1,r23
 708 0310 8283      		std Z+2,r24
 709 0312 9383      		std Z+3,r25
 710 0314 18C0      		rjmp .L74
 711               	.L59:
 249:backemf.c     ****                         if  (g_angle[g_motor] > 1)
 250:backemf.c     **** 						{
 251:backemf.c     ****  						   g_angle[g_motor] *= MOTOR_ANGLE_COEF;
 252:backemf.c     **** 						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
 253:backemf.c     **** 						}		
 254:backemf.c     **** 				}	
 255:backemf.c     **** 				else  if (g_angle[g_motor] == 0)
 713               	.LM79:
 714 0316 2115      		cp r18,__zero_reg__
 715 0318 3105      		cpc r19,__zero_reg__
 716 031a 4105      		cpc r20,__zero_reg__
 717 031c 5105      		cpc r21,__zero_reg__
 718 031e 21F4      		brne .L62
 719               	.L73:
 256:backemf.c     **** 				        g_mode[g_motor] = MOTOR_STOP;
 721               	.LM80:
 722 0320 C050      		subi r28,lo8(-(g_mode))
 723 0322 D040      		sbci r29,hi8(-(g_mode))
 724 0324 1882      		st Y,__zero_reg__
 725 0326 2FC0      		rjmp .L48
 726               	.L62:
 257:backemf.c     **** 				else	  
 258:backemf.c     **** 				{
 259:backemf.c     **** 					if ((g_angle[g_motor] > 0))   //  +
 728               	.LM81:
 729 0328 1216      		cp __zero_reg__,r18
 730 032a 1306      		cpc __zero_reg__,r19
 731 032c 1406      		cpc __zero_reg__,r20
 732 032e 1506      		cpc __zero_reg__,r21
 733 0330 2CF4      		brge .L64
 260:backemf.c     **** 						g_mode[g_motor] = MOTOR_FORWARD;
 735               	.LM82:
 736 0332 FE01      		movw r30,r28
 737 0334 E050      		subi r30,lo8(-(g_mode))
 738 0336 F040      		sbci r31,hi8(-(g_mode))
 739 0338 81E0      		ldi r24,lo8(1)
 740 033a 8083      		st Z,r24
 741               	.L64:
 261:backemf.c     **** 					if  (g_angle[g_motor] > 1)
 743               	.LM83:
 744 033c F801      		movw r30,r16
 745 033e 6081      		ld r22,Z
 746 0340 7181      		ldd r23,Z+1
 747 0342 8281      		ldd r24,Z+2
 748 0344 9381      		ldd r25,Z+3
 749               	.L74:
 750 0346 6230      		cpi r22,lo8(2)
 751 0348 7105      		cpc r23,__zero_reg__
 752 034a 8105      		cpc r24,__zero_reg__
 753 034c 9105      		cpc r25,__zero_reg__
 754 034e DCF0      		brlt .L48
 262:backemf.c     **** 					{
 263:backemf.c     ****  						g_angle[g_motor] *=  MOTOR_ANGLE_COEF;	
 756               	.LM84:
 757 0350 24E6      		ldi r18,lo8(100)
 758 0352 30E0      		ldi r19,hi8(100)
 759 0354 40E0      		ldi r20,hlo8(100)
 760 0356 50E0      		ldi r21,hhi8(100)
 761 0358 0E94 0000 		call __mulsi3
 762 035c DC01      		movw r26,r24
 763 035e CB01      		movw r24,r22
 764 0360 F801      		movw r30,r16
 765 0362 8083      		st Z,r24
 766 0364 9183      		std Z+1,r25
 767 0366 A283      		std Z+2,r26
 768 0368 B383      		std Z+3,r27
 264:backemf.c     **** 						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
 770               	.LM85:
 771 036a CC0F      		add r28,r28
 772 036c DD1F      		adc r29,r29
 773 036e C050      		subi r28,lo8(-(g_speed))
 774 0370 D040      		sbci r29,hi8(-(g_speed))
 775 0372 8091 0000 		lds r24,g_speed_table+5
 776 0376 9927      		clr r25
 777 0378 8883      		st Y,r24
 778 037a 9983      		std Y+1,r25
 265:backemf.c     **** 					}
 266:backemf.c     ****  				}
 267:backemf.c     **** 				break;	
 780               	.LM86:
 781 037c 04C0      		rjmp .L48
 782               	.L66:
 268:backemf.c     ****  			default:
 269:backemf.c     **** 			    uart_puts("Command not found ");
 784               	.LM87:
 785 037e 80E0      		ldi r24,lo8(.LC3)
 786 0380 90E0      		ldi r25,hi8(.LC3)
 787 0382 0E94 0000 		call uart_puts
 788               	.L48:
 270:backemf.c     ****  		        break;	  
 790               	.LM88:
 791 0386 FFEF      		ldi r31,lo8(-1)
 792 0388 FF16      		cp r15,r31
 793 038a 09F0      		breq .+2
 794 038c 45CF      		rjmp .L68
 271:backemf.c     **** 		}		
 272:backemf.c     ****     }
 273:backemf.c     ****  return 0; 
 274:backemf.c     **** }
 796               	.LM89:
 797 038e 80E0      		ldi r24,lo8(0)
 798 0390 90E0      		ldi r25,hi8(0)
 799               	/* epilogue: frame size=0 */
 800 0392 DF91      		pop r29
 801 0394 CF91      		pop r28
 802 0396 1F91      		pop r17
 803 0398 0F91      		pop r16
 804 039a FF90      		pop r15
 805 039c 0895      		ret
 806               	/* epilogue end (size=6) */
 807               	/* function cmd_decode size 203 (192) */
 813               	.Lscope3:
 814               		.lcomm i.1,1
 815               		.data
 816               	.LC4:
 817 0044 566F 6C74 		.string	"Voltage SUM"
 817      6167 6520 
 817      5355 4D00 
 818               		.text
 821               	.global	calculate_backemf
 823               	calculate_backemf:
 275:backemf.c     **** 
 276:backemf.c     **** /* Calculate backemf and save in g_pos
 277:backemf.c     **** 
 278:backemf.c     **** */
 279:backemf.c     **** void calculate_backemf (uint8_t motor)
 280:backemf.c     **** {
 825               	.LM90:
 826               	/* prologue: frame size=0 */
 827 039e CF92      		push r12
 828 03a0 DF92      		push r13
 829 03a2 EF92      		push r14
 830 03a4 FF92      		push r15
 831 03a6 0F93      		push r16
 832 03a8 1F93      		push r17
 833 03aa CF93      		push r28
 834 03ac DF93      		push r29
 835               	/* prologue end (size=8) */
 836 03ae 182F      		mov r17,r24
 281:backemf.c     ****      int16_t backemf=0;
 282:backemf.c     ****   // Read backemf
 283:backemf.c     ****      static uint8_t  i = 0;
 284:backemf.c     **** 
 285:backemf.c     **** 	adc_init(3);
 838               	.LM91:
 839 03b0 83E0      		ldi r24,lo8(3)
 840 03b2 0E94 0000 		call adc_init
 286:backemf.c     **** 	backemf = read_adc(g_adc_channel[motor]);	
 842               	.LM92:
 843 03b6 012F      		mov r16,r17
 844 03b8 1127      		clr r17
 845 03ba F801      		movw r30,r16
 846 03bc E050      		subi r30,lo8(-(g_adc_channel))
 847 03be F040      		sbci r31,hi8(-(g_adc_channel))
 848 03c0 8081      		ld r24,Z
 849 03c2 0E94 0000 		call read_adc
 850 03c6 EC01      		movw r28,r24
 287:backemf.c     **** 
 288:backemf.c     **** 
 289:backemf.c     **** // Cut offset	
 290:backemf.c     **** 	if ((backemf > 0) && (backemf < MOTOR_OFFSET))
 852               	.LM93:
 853 03c8 0197      		sbiw r24,1
 854 03ca C197      		sbiw r24,49
 855 03cc 10F4      		brsh .L76
 291:backemf.c     **** 			backemf =0;
 857               	.LM94:
 858 03ce C0E0      		ldi r28,lo8(0)
 859 03d0 D0E0      		ldi r29,hi8(0)
 860               	.L76:
 292:backemf.c     **** 			
 293:backemf.c     **** // Negative convert to positive with 2 complement	
 294:backemf.c     **** 	if (g_mode[motor] == MOTOR_STOP)   
 862               	.LM95:
 863 03d2 F801      		movw r30,r16
 864 03d4 E050      		subi r30,lo8(-(g_mode))
 865 03d6 F040      		sbci r31,hi8(-(g_mode))
 866 03d8 8081      		ld r24,Z
 867 03da 8823      		tst r24
 868 03dc 51F4      		brne .L77
 295:backemf.c     ****     {	
 296:backemf.c     **** 		if (backemf & 0x200)
 870               	.LM96:
 871 03de CE01      		movw r24,r28
 872 03e0 892F      		mov r24,r25
 873 03e2 9927      		clr r25
 874 03e4 8695      		lsr r24
 875 03e6 80FF      		sbrs r24,0
 876 03e8 04C0      		rjmp .L77
 297:backemf.c     **** 		{
 298:backemf.c     **** 		    backemf = (~(backemf) & (0x03FF))+1;
 878               	.LM97:
 879 03ea C095      		com r28
 880 03ec D095      		com r29
 881 03ee D370      		andi r29,hi8(1023)
 882 03f0 2196      		adiw r28,1
 883               	.L77:
 299:backemf.c     ****  		}		
 300:backemf.c     **** 	}		
 301:backemf.c     **** 			
 302:backemf.c     **** 	if (g_mode[motor] == MOTOR_FORWARD)   // Motor stop backemf -  Forward backemf +
 885               	.LM98:
 886 03f2 F801      		movw r30,r16
 887 03f4 E050      		subi r30,lo8(-(g_mode))
 888 03f6 F040      		sbci r31,hi8(-(g_mode))
 889 03f8 8081      		ld r24,Z
 890 03fa 8130      		cpi r24,lo8(1)
 891 03fc 79F4      		brne .L79
 303:backemf.c     ****     {	
 304:backemf.c     **** 		if (backemf & 0x200)
 893               	.LM99:
 894 03fe CE01      		movw r24,r28
 895 0400 892F      		mov r24,r25
 896 0402 9927      		clr r25
 897 0404 8695      		lsr r24
 898 0406 9C01      		movw r18,r24
 899 0408 2170      		andi r18,lo8(1)
 900 040a 3070      		andi r19,hi8(1)
 901 040c 80FF      		sbrs r24,0
 902 040e 05C0      		rjmp .L80
 305:backemf.c     **** 		{
 306:backemf.c     **** 		    backemf = (~(backemf) & (0x03FF))+1;
 904               	.LM100:
 905 0410 C095      		com r28
 906 0412 D095      		com r29
 907 0414 D370      		andi r29,hi8(1023)
 908 0416 2196      		adiw r28,1
 909 0418 01C0      		rjmp .L79
 910               	.L80:
 307:backemf.c     ****  		}
 308:backemf.c     **** 		else
 309:backemf.c     **** 			backemf = 0;
 912               	.LM101:
 913 041a E901      		movw r28,r18
 914               	.L79:
 310:backemf.c     ****     }
 311:backemf.c     **** 	if (g_mode[motor] == MOTOR_BACKWARD)   // Motor stop backemf +  backward backemf -
 916               	.LM102:
 917 041c F801      		movw r30,r16
 918 041e E050      		subi r30,lo8(-(g_mode))
 919 0420 F040      		sbci r31,hi8(-(g_mode))
 920 0422 8081      		ld r24,Z
 921 0424 8230      		cpi r24,lo8(2)
 922 0426 41F4      		brne .L82
 312:backemf.c     ****     {	
 313:backemf.c     **** 		if (backemf & 0x200)
 924               	.LM103:
 925 0428 CE01      		movw r24,r28
 926 042a 892F      		mov r24,r25
 927 042c 9927      		clr r25
 928 042e 8695      		lsr r24
 929 0430 80FF      		sbrs r24,0
 930 0432 02C0      		rjmp .L82
 314:backemf.c     **** 		{
 315:backemf.c     **** 			backemf =0;
 932               	.LM104:
 933 0434 C0E0      		ldi r28,lo8(0)
 934 0436 D0E0      		ldi r29,hi8(0)
 935               	.L82:
 316:backemf.c     **** 		}
 317:backemf.c     ****     }
 318:backemf.c     **** 	
 319:backemf.c     **** 	g_pos[motor] += backemf;
 937               	.LM105:
 938 0438 6801      		movw r12,r16
 939 043a CC0C      		lsl r12
 940 043c DD1C      		rol r13
 941 043e CC0C      		lsl r12
 942 0440 DD1C      		rol r13
 943 0442 90E0      		ldi r25,lo8(g_pos)
 944 0444 E92E      		mov r14,r25
 945 0446 90E0      		ldi r25,hi8(g_pos)
 946 0448 F92E      		mov r15,r25
 947 044a EC0C      		add r14,r12
 948 044c FD1C      		adc r15,r13
 949 044e CE01      		movw r24,r28
 950 0450 AA27      		clr r26
 951 0452 97FD      		sbrc r25,7
 952 0454 A095      		com r26
 953 0456 BA2F      		mov r27,r26
 954 0458 F701      		movw r30,r14
 955 045a 2081      		ld r18,Z
 956 045c 3181      		ldd r19,Z+1
 957 045e 4281      		ldd r20,Z+2
 958 0460 5381      		ldd r21,Z+3
 959 0462 280F      		add r18,r24
 960 0464 391F      		adc r19,r25
 961 0466 4A1F      		adc r20,r26
 962 0468 5B1F      		adc r21,r27
 963 046a 2083      		st Z,r18
 964 046c 3183      		std Z+1,r19
 965 046e 4283      		std Z+2,r20
 966 0470 5383      		std Z+3,r21
 320:backemf.c     ****     if (g_mode[motor] != MOTOR_STOP)	
 968               	.LM106:
 969 0472 0050      		subi r16,lo8(-(g_mode))
 970 0474 1040      		sbci r17,hi8(-(g_mode))
 971 0476 F801      		movw r30,r16
 972 0478 8081      		ld r24,Z
 973 047a 8823      		tst r24
 974 047c 31F0      		breq .L84
 321:backemf.c     ****  	{   
 322:backemf.c     **** //	    i++;
 323:backemf.c     **** //		if ( i == 100 )
 324:backemf.c     **** 		{
 325:backemf.c     **** 			debug_value(backemf,10);
 976               	.LM107:
 977 047e 6AE0      		ldi r22,lo8(10)
 978 0480 CE01      		movw r24,r28
 979 0482 0E94 0000 		call debug_value
 326:backemf.c     **** 			i = 0;
 981               	.LM108:
 982 0486 1092 0000 		sts i.1,__zero_reg__
 983               	.L84:
 327:backemf.c     **** 		}
 328:backemf.c     **** 	}	
 329:backemf.c     **** //Compare voltage	
 330:backemf.c     **** 	if (((g_angle[motor] > 1)) && ( g_mode[motor] != MOTOR_STOP))
 985               	.LM109:
 986 048a F601      		movw r30,r12
 987 048c E050      		subi r30,lo8(-(g_angle))
 988 048e F040      		sbci r31,hi8(-(g_angle))
 989 0490 2081      		ld r18,Z
 990 0492 3181      		ldd r19,Z+1
 991 0494 4281      		ldd r20,Z+2
 992 0496 5381      		ldd r21,Z+3
 993 0498 2230      		cpi r18,lo8(2)
 994 049a 3105      		cpc r19,__zero_reg__
 995 049c 4105      		cpc r20,__zero_reg__
 996 049e 5105      		cpc r21,__zero_reg__
 997 04a0 0CF1      		brlt .L75
 998 04a2 F801      		movw r30,r16
 999 04a4 8081      		ld r24,Z
 1000 04a6 8823      		tst r24
 1001 04a8 E9F0      		breq .L75
 331:backemf.c     **** 	{   
 332:backemf.c     **** 			if ( g_pos[motor]  >= (g_angle[motor]))  //  Check for position
 1003               	.LM110:
 1004 04aa F701      		movw r30,r14
 1005 04ac 8081      		ld r24,Z
 1006 04ae 9181      		ldd r25,Z+1
 1007 04b0 A281      		ldd r26,Z+2
 1008 04b2 B381      		ldd r27,Z+3
 1009 04b4 8217      		cp r24,r18
 1010 04b6 9307      		cpc r25,r19
 1011 04b8 A407      		cpc r26,r20
 1012 04ba B507      		cpc r27,r21
 1013 04bc 9CF0      		brlt .L75
 333:backemf.c     **** 			{
 334:backemf.c     **** //				delay(3);
 335:backemf.c     **** 				g_mode[motor] = MOTOR_STOP;
 1015               	.LM111:
 1016 04be F801      		movw r30,r16
 1017 04c0 1082      		st Z,__zero_reg__
 336:backemf.c     **** 				uart_puts ("Voltage SUM");
 1019               	.LM112:
 1020 04c2 80E0      		ldi r24,lo8(.LC4)
 1021 04c4 90E0      		ldi r25,hi8(.LC4)
 1022 04c6 0E94 0000 		call uart_puts
 337:backemf.c     **** 				debug_lvalue(g_pos[motor],10);
 1024               	.LM113:
 1025 04ca 4AE0      		ldi r20,lo8(10)
 1026 04cc F701      		movw r30,r14
 1027 04ce 6081      		ld r22,Z
 1028 04d0 7181      		ldd r23,Z+1
 1029 04d2 8281      		ldd r24,Z+2
 1030 04d4 9381      		ldd r25,Z+3
 1031 04d6 0E94 0000 		call debug_lvalue
 338:backemf.c     **** 				g_pos[motor] =0;				
 1033               	.LM114:
 1034 04da F701      		movw r30,r14
 1035 04dc 1082      		st Z,__zero_reg__
 1036 04de 1182      		std Z+1,__zero_reg__
 1037 04e0 1282      		std Z+2,__zero_reg__
 1038 04e2 1382      		std Z+3,__zero_reg__
 1039               	.L75:
 1040               	/* epilogue: frame size=0 */
 1041 04e4 DF91      		pop r29
 1042 04e6 CF91      		pop r28
 1043 04e8 1F91      		pop r17
 1044 04ea 0F91      		pop r16
 1045 04ec FF90      		pop r15
 1046 04ee EF90      		pop r14
 1047 04f0 DF90      		pop r13
 1048 04f2 CF90      		pop r12
 1049 04f4 0895      		ret
 1050               	/* epilogue end (size=9) */
 1051               	/* function calculate_backemf size 175 (158) */
 1057               	.Lscope4:
 1059               	.global	__vector_11
 1061               	__vector_11:
 339:backemf.c     **** 			}
 340:backemf.c     **** 	}
 341:backemf.c     ****     		
 342:backemf.c     **** }
 343:backemf.c     **** 
 344:backemf.c     **** 
 345:backemf.c     **** 
 346:backemf.c     **** // Interrupt Vector table
 347:backemf.c     **** // Couter timer 0 reach top  
 348:backemf.c     **** //    ON Motor   0 - OCR0  ON   OCR0 - 0xFF OFF
 349:backemf.c     ****  SIGNAL (SIG_OVERFLOW0)   
 350:backemf.c     **** {
 1063               	.LM115:
 1064               	/* prologue: frame size=0 */
 1065 04f6 1F92      		push __zero_reg__
 1066 04f8 0F92      		push __tmp_reg__
 1067 04fa 0FB6      		in __tmp_reg__,__SREG__
 1068 04fc 0F92      		push __tmp_reg__
 1069 04fe 1124      		clr __zero_reg__
 1070 0500 2F93      		push r18
 1071 0502 3F93      		push r19
 1072 0504 4F93      		push r20
 1073 0506 5F93      		push r21
 1074 0508 6F93      		push r22
 1075 050a 7F93      		push r23
 1076 050c 8F93      		push r24
 1077 050e 9F93      		push r25
 1078 0510 AF93      		push r26
 1079 0512 BF93      		push r27
 1080 0514 EF93      		push r30
 1081 0516 FF93      		push r31
 1082               	/* prologue end (size=17) */
 351:backemf.c     ****  	calculate_backemf(0);
 1084               	.LM116:
 1085 0518 80E0      		ldi r24,lo8(0)
 1086 051a 0E94 0000 		call calculate_backemf
 352:backemf.c     ****     OCR0 =  g_speed[0];
 1088               	.LM117:
 1089 051e 8091 0000 		lds r24,g_speed
 1090 0522 8CBF      		out 92-0x20,r24
 353:backemf.c     ****     motor_control(1, g_mode[0]);
 1092               	.LM118:
 1093 0524 6091 0000 		lds r22,g_mode
 1094 0528 81E0      		ldi r24,lo8(1)
 1095 052a 0E94 0000 		call motor_control
 1096               	/* epilogue: frame size=0 */
 1097 052e FF91      		pop r31
 1098 0530 EF91      		pop r30
 1099 0532 BF91      		pop r27
 1100 0534 AF91      		pop r26
 1101 0536 9F91      		pop r25
 1102 0538 8F91      		pop r24
 1103 053a 7F91      		pop r23
 1104 053c 6F91      		pop r22
 1105 053e 5F91      		pop r21
 1106 0540 4F91      		pop r20
 1107 0542 3F91      		pop r19
 1108 0544 2F91      		pop r18
 1109 0546 0F90      		pop __tmp_reg__
 1110 0548 0FBE      		out __SREG__,__tmp_reg__
 1111 054a 0F90      		pop __tmp_reg__
 1112 054c 1F90      		pop __zero_reg__
 1113 054e 1895      		reti
 1114               	/* epilogue end (size=17) */
 1115               	/* function __vector_11 size 45 (11) */
 1117               	.Lscope5:
 1119               	.global	__vector_10
 1121               	__vector_10:
 354:backemf.c     **** 		
 355:backemf.c     **** }
 356:backemf.c     **** 
 357:backemf.c     **** // Counter timer 0 reach OCR0  OFF MOTOR
 358:backemf.c     ****  SIGNAL (SIG_OUTPUT_COMPARE0)
 359:backemf.c     **** {
 1123               	.LM119:
 1124               	/* prologue: frame size=0 */
 1125 0550 1F92      		push __zero_reg__
 1126 0552 0F92      		push __tmp_reg__
 1127 0554 0FB6      		in __tmp_reg__,__SREG__
 1128 0556 0F92      		push __tmp_reg__
 1129 0558 1124      		clr __zero_reg__
 1130 055a 2F93      		push r18
 1131 055c 3F93      		push r19
 1132 055e 4F93      		push r20
 1133 0560 5F93      		push r21
 1134 0562 6F93      		push r22
 1135 0564 7F93      		push r23
 1136 0566 8F93      		push r24
 1137 0568 9F93      		push r25
 1138 056a AF93      		push r26
 1139 056c BF93      		push r27
 1140 056e EF93      		push r30
 1141 0570 FF93      		push r31
 1142               	/* prologue end (size=17) */
 360:backemf.c     **** 		motor_control(1, MOTOR_STOP);
 1144               	.LM120:
 1145 0572 60E0      		ldi r22,lo8(0)
 1146 0574 81E0      		ldi r24,lo8(1)
 1147 0576 0E94 0000 		call motor_control
 1148               	/* epilogue: frame size=0 */
 1149 057a FF91      		pop r31
 1150 057c EF91      		pop r30
 1151 057e BF91      		pop r27
 1152 0580 AF91      		pop r26
 1153 0582 9F91      		pop r25
 1154 0584 8F91      		pop r24
 1155 0586 7F91      		pop r23
 1156 0588 6F91      		pop r22
 1157 058a 5F91      		pop r21
 1158 058c 4F91      		pop r20
 1159 058e 3F91      		pop r19
 1160 0590 2F91      		pop r18
 1161 0592 0F90      		pop __tmp_reg__
 1162 0594 0FBE      		out __SREG__,__tmp_reg__
 1163 0596 0F90      		pop __tmp_reg__
 1164 0598 1F90      		pop __zero_reg__
 1165 059a 1895      		reti
 1166               	/* epilogue end (size=17) */
 1167               	/* function __vector_10 size 38 (4) */
 1169               	.Lscope6:
 1171               	.global	__vector_5
 1173               	__vector_5:
 361:backemf.c     **** }
 362:backemf.c     ****  
 363:backemf.c     **** // TIMER2 will opposite with timer 0 to balance calculate backemf between timer0 and timer2
 364:backemf.c     **** // Couter timer 2 reach top  
 365:backemf.c     **** //    ON Motor   0 - OCR2  ON   OCR2 - 0xFF FF
 366:backemf.c     ****  SIGNAL (SIG_OVERFLOW2)   
 367:backemf.c     **** {
 1175               	.LM121:
 1176               	/* prologue: frame size=0 */
 1177 059c 1F92      		push __zero_reg__
 1178 059e 0F92      		push __tmp_reg__
 1179 05a0 0FB6      		in __tmp_reg__,__SREG__
 1180 05a2 0F92      		push __tmp_reg__
 1181 05a4 1124      		clr __zero_reg__
 1182 05a6 2F93      		push r18
 1183 05a8 3F93      		push r19
 1184 05aa 4F93      		push r20
 1185 05ac 5F93      		push r21
 1186 05ae 6F93      		push r22
 1187 05b0 7F93      		push r23
 1188 05b2 8F93      		push r24
 1189 05b4 9F93      		push r25
 1190 05b6 AF93      		push r26
 1191 05b8 BF93      		push r27
 1192 05ba EF93      		push r30
 1193 05bc FF93      		push r31
 1194               	/* prologue end (size=17) */
 368:backemf.c     ****    	motor_control(2, MOTOR_STOP);
 1196               	.LM122:
 1197 05be 60E0      		ldi r22,lo8(0)
 1198 05c0 82E0      		ldi r24,lo8(2)
 1199 05c2 0E94 0000 		call motor_control
 1200               	/* epilogue: frame size=0 */
 1201 05c6 FF91      		pop r31
 1202 05c8 EF91      		pop r30
 1203 05ca BF91      		pop r27
 1204 05cc AF91      		pop r26
 1205 05ce 9F91      		pop r25
 1206 05d0 8F91      		pop r24
 1207 05d2 7F91      		pop r23
 1208 05d4 6F91      		pop r22
 1209 05d6 5F91      		pop r21
 1210 05d8 4F91      		pop r20
 1211 05da 3F91      		pop r19
 1212 05dc 2F91      		pop r18
 1213 05de 0F90      		pop __tmp_reg__
 1214 05e0 0FBE      		out __SREG__,__tmp_reg__
 1215 05e2 0F90      		pop __tmp_reg__
 1216 05e4 1F90      		pop __zero_reg__
 1217 05e6 1895      		reti
 1218               	/* epilogue end (size=17) */
 1219               	/* function __vector_5 size 38 (4) */
 1221               	.Lscope7:
 1223               	.global	__vector_4
 1225               	__vector_4:
 369:backemf.c     ****    
 370:backemf.c     **** }
 371:backemf.c     **** 
 372:backemf.c     **** // Counter timer 2 reach OCR2  ON MOTOR
 373:backemf.c     ****  SIGNAL (SIG_OUTPUT_COMPARE2)
 374:backemf.c     **** {
 1227               	.LM123:
 1228               	/* prologue: frame size=0 */
 1229 05e8 1F92      		push __zero_reg__
 1230 05ea 0F92      		push __tmp_reg__
 1231 05ec 0FB6      		in __tmp_reg__,__SREG__
 1232 05ee 0F92      		push __tmp_reg__
 1233 05f0 1124      		clr __zero_reg__
 1234 05f2 2F93      		push r18
 1235 05f4 3F93      		push r19
 1236 05f6 4F93      		push r20
 1237 05f8 5F93      		push r21
 1238 05fa 6F93      		push r22
 1239 05fc 7F93      		push r23
 1240 05fe 8F93      		push r24
 1241 0600 9F93      		push r25
 1242 0602 AF93      		push r26
 1243 0604 BF93      		push r27
 1244 0606 EF93      		push r30
 1245 0608 FF93      		push r31
 1246               	/* prologue end (size=17) */
 375:backemf.c     **** 	calculate_backemf(1);
 1248               	.LM124:
 1249 060a 81E0      		ldi r24,lo8(1)
 1250 060c 0E94 0000 		call calculate_backemf
 376:backemf.c     ****   	OCR2 =  0xFF - g_speed[1];   // Because opposite with timer0
 1252               	.LM125:
 1253 0610 8091 0000 		lds r24,g_speed+2
 1254 0614 8095      		com r24
 1255 0616 83BD      		out 67-0x20,r24
 377:backemf.c     ****    motor_control(2, g_mode[1]);
 1257               	.LM126:
 1258 0618 6091 0000 		lds r22,g_mode+1
 1259 061c 82E0      		ldi r24,lo8(2)
 1260 061e 0E94 0000 		call motor_control
 1261               	/* epilogue: frame size=0 */
 1262 0622 FF91      		pop r31
 1263 0624 EF91      		pop r30
 1264 0626 BF91      		pop r27
 1265 0628 AF91      		pop r26
 1266 062a 9F91      		pop r25
 1267 062c 8F91      		pop r24
 1268 062e 7F91      		pop r23
 1269 0630 6F91      		pop r22
 1270 0632 5F91      		pop r21
 1271 0634 4F91      		pop r20
 1272 0636 3F91      		pop r19
 1273 0638 2F91      		pop r18
 1274 063a 0F90      		pop __tmp_reg__
 1275 063c 0FBE      		out __SREG__,__tmp_reg__
 1276 063e 0F90      		pop __tmp_reg__
 1277 0640 1F90      		pop __zero_reg__
 1278 0642 1895      		reti
 1279               	/* epilogue end (size=17) */
 1280               	/* function __vector_4 size 46 (12) */
 1282               	.Lscope8:
 1283               		.lcomm i.0,2
 1285               	.global	__vector_13
 1287               	__vector_13:
 378:backemf.c     ****  
 379:backemf.c     **** }
 380:backemf.c     ****  
 381:backemf.c     ****   
 382:backemf.c     ****  
 383:backemf.c     ****  
 384:backemf.c     **** /* UART receiver ready
 385:backemf.c     **** */
 386:backemf.c     **** 
 387:backemf.c     **** SIGNAL(SIG_UART_RECV)
 388:backemf.c     **** {
 1289               	.LM127:
 1290               	/* prologue: frame size=0 */
 1291 0644 1F92      		push __zero_reg__
 1292 0646 0F92      		push __tmp_reg__
 1293 0648 0FB6      		in __tmp_reg__,__SREG__
 1294 064a 0F92      		push __tmp_reg__
 1295 064c 1124      		clr __zero_reg__
 1296 064e 2F93      		push r18
 1297 0650 8F93      		push r24
 1298 0652 9F93      		push r25
 1299 0654 EF93      		push r30
 1300 0656 FF93      		push r31
 1301               	/* prologue end (size=10) */
 389:backemf.c     ****   static uint16_t i= 0;
 390:backemf.c     ****   uint8_t ch;
 391:backemf.c     ****   ch = UDR;
 1303               	.LM128:
 1304 0658 2CB1      		in r18,44-0x20
 392:backemf.c     **** 
 393:backemf.c     **** 	g_rcv_buff[i] = ch;    
 1306               	.LM129:
 1307 065a 8091 0000 		lds r24,i.0
 1308 065e 9091 0000 		lds r25,(i.0)+1
 1309 0662 FC01      		movw r30,r24
 1310 0664 E050      		subi r30,lo8(-(g_rcv_buff))
 1311 0666 F040      		sbci r31,hi8(-(g_rcv_buff))
 1312 0668 2083      		st Z,r18
 394:backemf.c     **** 	i++;
 1314               	.LM130:
 1315 066a FC01      		movw r30,r24
 1316 066c 3196      		adiw r30,1
 1317 066e F093 0000 		sts (i.0)+1,r31
 1318 0672 E093 0000 		sts i.0,r30
 395:backemf.c     ****  
 396:backemf.c     **** // Found 0xOD or 0x0A end with null
 397:backemf.c     ****    if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
 1320               	.LM131:
 1321 0676 2D30      		cpi r18,lo8(13)
 1322 0678 11F0      		breq .L93
 1324               	.LM132:
 1325 067a 2A30      		cpi r18,lo8(10)
 1326 067c 51F4      		brne .L91
 1327               	.L93:
 398:backemf.c     ****    {	
 399:backemf.c     ****     	g_rcv_buff[i]  = 0;   // End with null
 1329               	.LM133:
 1330 067e E050      		subi r30,lo8(-(g_rcv_buff))
 1331 0680 F040      		sbci r31,hi8(-(g_rcv_buff))
 1332 0682 1082      		st Z,__zero_reg__
 400:backemf.c     **** 		i = 0;
 1334               	.LM134:
 1335 0684 1092 0000 		sts (i.0)+1,__zero_reg__
 1336 0688 1092 0000 		sts i.0,__zero_reg__
 401:backemf.c     ****   		g_cmd_decode = 1;
 1338               	.LM135:
 1339 068c 81E0      		ldi r24,lo8(1)
 1340 068e 8093 0000 		sts g_cmd_decode,r24
 1341               	.L91:
 1342               	/* epilogue: frame size=0 */
 1343 0692 FF91      		pop r31
 1344 0694 EF91      		pop r30
 1345 0696 9F91      		pop r25
 1346 0698 8F91      		pop r24
 1347 069a 2F91      		pop r18
 1348 069c 0F90      		pop __tmp_reg__
 1349 069e 0FBE      		out __SREG__,__tmp_reg__
 1350 06a0 0F90      		pop __tmp_reg__
 1351 06a2 1F90      		pop __zero_reg__
 1352 06a4 1895      		reti
 1353               	/* epilogue end (size=10) */
 1354               	/* function __vector_13 size 49 (29) */
 1360               	.Lscope9:
 1362               	.global	__vector_14
 1364               	__vector_14:
 402:backemf.c     ****    }
 403:backemf.c     **** }
 404:backemf.c     **** 
 405:backemf.c     ****   
 406:backemf.c     **** 
 407:backemf.c     **** /*************************************************************************
 408:backemf.c     **** Function: UART Data Register Empty interrupt
 409:backemf.c     **** Purpose:  called when the UART is ready to transmit the next byte
 410:backemf.c     **** **************************************************************************/
 411:backemf.c     **** 
 412:backemf.c     **** SIGNAL(SIG_UART_DATA)
 413:backemf.c     **** { 
 1366               	.LM136:
 1367               	/* prologue: frame size=0 */
 1368 06a6 1F92      		push __zero_reg__
 1369 06a8 0F92      		push __tmp_reg__
 1370 06aa 0FB6      		in __tmp_reg__,__SREG__
 1371 06ac 0F92      		push __tmp_reg__
 1372 06ae 1124      		clr __zero_reg__
 1373 06b0 2F93      		push r18
 1374 06b2 3F93      		push r19
 1375 06b4 4F93      		push r20
 1376 06b6 5F93      		push r21
 1377 06b8 6F93      		push r22
 1378 06ba 7F93      		push r23
 1379 06bc 8F93      		push r24
 1380 06be 9F93      		push r25
 1381 06c0 AF93      		push r26
 1382 06c2 BF93      		push r27
 1383 06c4 EF93      		push r30
 1384 06c6 FF93      		push r31
 1385               	/* prologue end (size=17) */
 414:backemf.c     ****     uint8_t  ch;
 415:backemf.c     **** 	if ((ch = uart_get_TX()))
 1387               	.LM137:
 1388 06c8 0E94 0000 		call uart_get_TX
 1389 06cc 8823      		tst r24
 1390 06ce 11F0      		breq .L95
 416:backemf.c     **** 	{
 417:backemf.c     ****  		UDR = ch;
 1392               	.LM138:
 1393 06d0 8CB9      		out 44-0x20,r24
 1394 06d2 01C0      		rjmp .L94
 1395               	.L95:
 418:backemf.c     **** 	}	
 419:backemf.c     **** 	else 
 420:backemf.c     **** // No character disable  interrupt to avoid repetable call Enable again when
 421:backemf.c     **** //	send character in putc procedure
 422:backemf.c     **** 	{
 423:backemf.c     **** 	    UCSRB &=  ~(1<<UDRIE);
 1397               	.LM139:
 1398 06d4 5598      		cbi 42-0x20,5
 1399               	.L94:
 1400               	/* epilogue: frame size=0 */
 1401 06d6 FF91      		pop r31
 1402 06d8 EF91      		pop r30
 1403 06da BF91      		pop r27
 1404 06dc AF91      		pop r26
 1405 06de 9F91      		pop r25
 1406 06e0 8F91      		pop r24
 1407 06e2 7F91      		pop r23
 1408 06e4 6F91      		pop r22
 1409 06e6 5F91      		pop r21
 1410 06e8 4F91      		pop r20
 1411 06ea 3F91      		pop r19
 1412 06ec 2F91      		pop r18
 1413 06ee 0F90      		pop __tmp_reg__
 1414 06f0 0FBE      		out __SREG__,__tmp_reg__
 1415 06f2 0F90      		pop __tmp_reg__
 1416 06f4 1F90      		pop __zero_reg__
 1417 06f6 1895      		reti
 1418               	/* epilogue end (size=17) */
 1419               	/* function __vector_14 size 41 (7) */
 1424               	.Lscope10:
 1426               	.global	__vector_6
 1428               	__vector_6:
 424:backemf.c     **** 	}
 425:backemf.c     **** 	
 426:backemf.c     **** }
 427:backemf.c     **** 
 428:backemf.c     ****  
 429:backemf.c     ****  
 430:backemf.c     **** /* Interrupt handle for Input Capture
 431:backemf.c     **** This routine will detect/ process the Sony IR remote command. Protocol using Sony remote control
 432:backemf.c     **** INPUT   :  Infrared signal from  ICP pin
 433:backemf.c     **** 		   Command table 
 434:backemf.c     **** 		  
 435:backemf.c     **** 
 436:backemf.c     **** OUTPUT 	: g_num  Number of message to display
 437:backemf.c     **** 		: g_control.display_mode   Display mode of message
 438:backemf.c     **** 		: g_start_bit
 439:backemf.c     **** 		
 440:backemf.c     **** 
 441:backemf.c     **** */
 442:backemf.c     **** SIGNAL(SIG_INPUT_CAPTURE1)
 443:backemf.c     **** {
 1430               	.LM140:
 1431               	/* prologue: frame size=0 */
 1432 06f8 1F92      		push __zero_reg__
 1433 06fa 0F92      		push __tmp_reg__
 1434 06fc 0FB6      		in __tmp_reg__,__SREG__
 1435 06fe 0F92      		push __tmp_reg__
 1436 0700 1124      		clr __zero_reg__
 1437 0702 2F93      		push r18
 1438 0704 3F93      		push r19
 1439 0706 4F93      		push r20
 1440 0708 5F93      		push r21
 1441 070a 6F93      		push r22
 1442 070c 7F93      		push r23
 1443 070e 8F93      		push r24
 1444 0710 9F93      		push r25
 1445 0712 AF93      		push r26
 1446 0714 BF93      		push r27
 1447 0716 EF93      		push r30
 1448 0718 FF93      		push r31
 1449               	/* prologue end (size=17) */
 444:backemf.c     **** 	uint16_t  ir_code;
 445:backemf.c     ****     ir_code = ICR1;
 1451               	.LM141:
 1452 071a 26B5      		in r18,70-0x20
 1453 071c 37B5      		in r19,(70)+1-0x20
 446:backemf.c     **** 	cli(); 
 1455               	.LM142:
 1456               	/* #APP */
 1457 071e F894      		cli
 447:backemf.c     **** 
 448:backemf.c     ****     TCCR1B  |= _BV(ICES1);	     // Rising edge
 1459               	.LM143:
 1460               	/* #NOAPP */
 1461 0720 8EB5      		in r24,78-0x20
 1462 0722 8064      		ori r24,lo8(64)
 1463 0724 8EBD      		out 78-0x20,r24
 449:backemf.c     ****  	ir_code  = sony_ir_decode(ir_code);  
 1465               	.LM144:
 1466 0726 C901      		movw r24,r18
 1467 0728 0E94 0000 		call sony_ir_decode
 450:backemf.c     ****  	if (ir_code)
 1469               	.LM145:
 1470 072c 0097      		sbiw r24,0
 1471 072e 29F0      		breq .L98
 451:backemf.c     **** 	{       //End code dispatch command    
 452:backemf.c     ****  
 453:backemf.c     **** 		remote_decode (ir_code);
 1473               	.LM146:
 1474 0730 0E94 0000 		call remote_decode
 454:backemf.c     **** // Return to falling edge for Start		
 455:backemf.c     **** 		TCCR1B  &= ~(_BV(ICES1));
 1476               	.LM147:
 1477 0734 8EB5      		in r24,78-0x20
 1478 0736 8F7B      		andi r24,lo8(-65)
 1479 0738 8EBD      		out 78-0x20,r24
 1480               	.L98:
 456:backemf.c     **** 		
 457:backemf.c     **** 
 458:backemf.c     **** //Note if  SELFTEST is selected g_irint = 0;
 459:backemf.c     **** 	} 
 460:backemf.c     ****     sei();
 1482               	.LM148:
 1483               	/* #APP */
 1484 073a 7894      		sei
 1485               	/* #NOAPP */
 1486               	/* epilogue: frame size=0 */
 1487 073c FF91      		pop r31
 1488 073e EF91      		pop r30
 1489 0740 BF91      		pop r27
 1490 0742 AF91      		pop r26
 1491 0744 9F91      		pop r25
 1492 0746 8F91      		pop r24
 1493 0748 7F91      		pop r23
 1494 074a 6F91      		pop r22
 1495 074c 5F91      		pop r21
 1496 074e 4F91      		pop r20
 1497 0750 3F91      		pop r19
 1498 0752 2F91      		pop r18
 1499 0754 0F90      		pop __tmp_reg__
 1500 0756 0FBE      		out __SREG__,__tmp_reg__
 1501 0758 0F90      		pop __tmp_reg__
 1502 075a 1F90      		pop __zero_reg__
 1503 075c 1895      		reti
 1504               	/* epilogue end (size=17) */
 1505               	/* function __vector_6 size 53 (19) */
 1510               	.Lscope11:
 1512               	.global	init_board
 1514               	init_board:
 461:backemf.c     ****  
 462:backemf.c     **** }
 463:backemf.c     **** 
 464:backemf.c     **** 
 465:backemf.c     **** void init_board()
 466:backemf.c     **** {
 1516               	.LM149:
 1517               	/* prologue: frame size=0 */
 1518               	/* prologue end (size=0) */
 467:backemf.c     ****     uint8_t i;
 468:backemf.c     **** 	d7segment_init();
 1520               	.LM150:
 1521 075e 0E94 0000 		call d7segment_init
 469:backemf.c     **** 	init_ir();
 1523               	.LM151:
 1524 0762 0E94 0000 		call init_ir
 470:backemf.c     **** 	init_motor();
 1526               	.LM152:
 1527 0766 0E94 0000 		call init_motor
 471:backemf.c     **** 	uart_init(); 
 1529               	.LM153:
 1530 076a 0E94 0000 		call uart_init
 472:backemf.c     ****     adc_init(3);   // 2.56 BG as reference 
 1532               	.LM154:
 1533 076e 83E0      		ldi r24,lo8(3)
 1534 0770 0E94 0000 		call adc_init
 473:backemf.c     **** 	
 474:backemf.c     **** 	g_cmd_decode = 0; 
 1536               	.LM155:
 1537 0774 1092 0000 		sts g_cmd_decode,__zero_reg__
 475:backemf.c     **** 	g_motor= 0;
 1539               	.LM156:
 1540 0778 1092 0000 		sts g_motor,__zero_reg__
 1541 077c 61E0      		ldi r22,lo8(1)
 1542 077e 70E0      		ldi r23,hi8(1)
 1543 0780 21E0      		ldi r18,lo8(1)
 1544 0782 30E0      		ldi r19,hi8(1)
 1545 0784 40E0      		ldi r20,hlo8(1)
 1546 0786 50E0      		ldi r21,hhi8(1)
 1547 0788 A0E0      		ldi r26,lo8(g_angle)
 1548 078a B0E0      		ldi r27,hi8(g_angle)
 1549 078c 81E0      		ldi r24,lo8(1)
 1550 078e E0E0      		ldi r30,lo8(g_speed)
 1551 0790 F0E0      		ldi r31,hi8(g_speed)
 1552               	.L103:
 476:backemf.c     **** 	
 477:backemf.c     **** 	for ( i = 0 ; i< MOTOR_MAX ;i++)
 478:backemf.c     **** 	{
 479:backemf.c     **** 		g_speed[i] = 1;
 1554               	.LM157:
 1555 0792 6193      		st Z+,r22
 1556 0794 7193      		st Z+,r23
 480:backemf.c     **** 		g_angle[i] = 1;
 1558               	.LM158:
 1559 0796 2D93      		st X+,r18
 1560 0798 3D93      		st X+,r19
 1561 079a 4D93      		st X+,r20
 1562 079c 5D93      		st X+,r21
 1564               	.LM159:
 1565 079e 8150      		subi r24,lo8(-(-1))
 1566 07a0 87FF      		sbrs r24,7
 1567 07a2 F7CF      		rjmp .L103
 481:backemf.c     **** 	} 
 482:backemf.c     **** 	sei();
 1569               	.LM160:
 1570               	/* #APP */
 1571 07a4 7894      		sei
 1572               	/* #NOAPP */
 1573               	/* epilogue: frame size=0 */
 1574 07a6 0895      		ret
 1575               	/* epilogue end (size=1) */
 1576               	/* function init_board size 38 (37) */
 1581               	.Lscope12:
 1582               		.data
 1583               	.LC5:
 1584 0050 00        		.byte	0
 1585 0051 66        		.byte	102
 1586 0052 62        		.byte	98
 1587               		.text
 1589               	.global	main
 1591               	main:
 483:backemf.c     ****  
 484:backemf.c     **** }
 485:backemf.c     **** 
 486:backemf.c     **** void main()
 487:backemf.c     **** {
 1593               	.LM161:
 1594               	/* prologue: frame size=3 */
 1595 07a8 C0E0      		ldi r28,lo8(__stack - 3)
 1596 07aa D0E0      		ldi r29,hi8(__stack - 3)
 1597 07ac DEBF      		out __SP_H__,r29
 1598 07ae CDBF      		out __SP_L__,r28
 1599               	/* prologue end (size=4) */
 488:backemf.c     ****   uint8_t sw1,sw2,i;
 489:backemf.c     ****    uint16_t k;
 490:backemf.c     ****    int16_t backemf;
 491:backemf.c     ****   int8_t d1,d2;
 492:backemf.c     ****   uint8_t show[3] = {0,'f','b'};
 1601               	.LM162:
 1602 07b0 6E01      		movw r12,r28
 1603 07b2 0894      		sec
 1604 07b4 C11C      		adc r12,__zero_reg__
 1605 07b6 D11C      		adc r13,__zero_reg__
 1606 07b8 83E0      		ldi r24,lo8(3)
 1607 07ba E0E0      		ldi r30,lo8(.LC5)
 1608 07bc F0E0      		ldi r31,hi8(.LC5)
 1609 07be D601      		movw r26,r12
 1610 07c0 0190      		ld __tmp_reg__,Z+
 1611 07c2 0D92      		st X+,__tmp_reg__
 1612 07c4 8A95      		dec r24
 1613 07c6 E1F7      		brne .-8
 493:backemf.c     ****    init_board();
 1615               	.LM163:
 1616 07c8 0E94 0000 		call init_board
 494:backemf.c     ****   d1 = 0;
 1618               	.LM164:
 1619 07cc FF24      		clr r15
 495:backemf.c     ****   d2 = 0;
 1621               	.LM165:
 1622 07ce EF2C      		mov r14,r15
 1623               	.L107:
 496:backemf.c     ****   backemf =0;
 497:backemf.c     ****   while (1)
 498:backemf.c     ****   {
 499:backemf.c     ****    sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
 1625               	.LM166:
 1626 07d0 80B3      		in r24,48-0x20
 500:backemf.c     ****    
 501:backemf.c     ****    if (!sw1) // SW1  Press
 1628               	.LM167:
 1629 07d2 982F      		mov r25,r24
 1630 07d4 9870      		andi r25,lo8(8)
 1631 07d6 83FD      		sbrc r24,3
 1632 07d8 1DC0      		rjmp .L109
 502:backemf.c     ****     {   	
 503:backemf.c     **** 		d1++;
 1634               	.LM168:
 1635 07da E394      		inc r14
 504:backemf.c     **** 	     if (d1 > MOTOR_BACKWARD)
 1637               	.LM169:
 1638 07dc B2E0      		ldi r27,lo8(2)
 1639 07de BE15      		cp r27,r14
 1640 07e0 0CF4      		brge .L110
 505:backemf.c     **** 			d1 = MOTOR_STOP;
 1642               	.LM170:
 1643 07e2 E92E      		mov r14,r25
 1644               	.L110:
 1645 07e4 03EF      		ldi r16,lo8(499)
 1646 07e6 11E0      		ldi r17,hi8(499)
 1647               	.L114:
 506:backemf.c     **** 		for (k = 0; k < 500 ;k++)                         // Delay for key bounce
 507:backemf.c     **** 				delay(6000);						
 1649               	.LM171:
 1650 07e8 80E7      		ldi r24,lo8(6000)
 1651 07ea 97E1      		ldi r25,hi8(6000)
 1652 07ec 0E94 0000 		call delay
 1654               	.LM172:
 1655 07f0 0150      		subi r16,lo8(-(-1))
 1656 07f2 1040      		sbci r17,hi8(-(-1))
 1657 07f4 17FF      		sbrs r17,7
 1658 07f6 F8CF      		rjmp .L114
 508:backemf.c     **** 		g_mode[0] = d1;
 1660               	.LM173:
 1661 07f8 E092 0000 		sts g_mode,r14
 509:backemf.c     **** 		g_angle[0] = 1;    // Continuous move
 1663               	.LM174:
 1664 07fc 81E0      		ldi r24,lo8(1)
 1665 07fe 90E0      		ldi r25,hi8(1)
 1666 0800 A0E0      		ldi r26,hlo8(1)
 1667 0802 B0E0      		ldi r27,hhi8(1)
 1668 0804 8093 0000 		sts g_angle,r24
 1669 0808 9093 0000 		sts (g_angle)+1,r25
 1670 080c A093 0000 		sts (g_angle)+2,r26
 1671 0810 B093 0000 		sts (g_angle)+3,r27
 1672               	.L109:
 510:backemf.c     **** 
 511:backemf.c     **** 	}
 512:backemf.c     ****    
 513:backemf.c     ****    sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
 1674               	.LM175:
 1675 0814 83B3      		in r24,51-0x20
 514:backemf.c     ****    if (!sw2) // SW2 Press
 1677               	.LM176:
 1678 0816 982F      		mov r25,r24
 1679 0818 9470      		andi r25,lo8(4)
 1680 081a 82FD      		sbrc r24,2
 1681 081c 1DC0      		rjmp .L115
 515:backemf.c     ****    {
 516:backemf.c     ****         d2++;
 1683               	.LM177:
 1684 081e F394      		inc r15
 517:backemf.c     **** 		if (d2 > MOTOR_BACKWARD)
 1686               	.LM178:
 1687 0820 82E0      		ldi r24,lo8(2)
 1688 0822 8F15      		cp r24,r15
 1689 0824 0CF4      		brge .L116
 518:backemf.c     **** 			d2 = MOTOR_STOP;
 1691               	.LM179:
 1692 0826 F92E      		mov r15,r25
 1693               	.L116:
 1694 0828 03EF      		ldi r16,lo8(499)
 1695 082a 11E0      		ldi r17,hi8(499)
 1696               	.L120:
 519:backemf.c     ****  		for (k = 0; k < 500 ;k++)                         // Delay for key bounce		
 520:backemf.c     ****  				delay(6000);
 1698               	.LM180:
 1699 082c 80E7      		ldi r24,lo8(6000)
 1700 082e 97E1      		ldi r25,hi8(6000)
 1701 0830 0E94 0000 		call delay
 1703               	.LM181:
 1704 0834 0150      		subi r16,lo8(-(-1))
 1705 0836 1040      		sbci r17,hi8(-(-1))
 1706 0838 17FF      		sbrs r17,7
 1707 083a F8CF      		rjmp .L120
 521:backemf.c     **** 		g_mode[1] = d2;
 1709               	.LM182:
 1710 083c F092 0000 		sts g_mode+1,r15
 522:backemf.c     **** 		g_angle[1] = 1;    // Continuous move	
 1712               	.LM183:
 1713 0840 81E0      		ldi r24,lo8(1)
 1714 0842 90E0      		ldi r25,hi8(1)
 1715 0844 A0E0      		ldi r26,hlo8(1)
 1716 0846 B0E0      		ldi r27,hhi8(1)
 1717 0848 8093 0000 		sts g_angle+4,r24
 1718 084c 9093 0000 		sts (g_angle+4)+1,r25
 1719 0850 A093 0000 		sts (g_angle+4)+2,r26
 1720 0854 B093 0000 		sts (g_angle+4)+3,r27
 1721               	.L115:
 523:backemf.c     ****    }
 524:backemf.c     **** 
 525:backemf.c     **** // Command decode
 526:backemf.c     ****     if ( g_cmd_decode)
 1723               	.LM184:
 1724 0858 8091 0000 		lds r24,g_cmd_decode
 1725 085c 8823      		tst r24
 1726 085e 91F0      		breq .L121
 527:backemf.c     **** 	{
 528:backemf.c     **** // Decode command	
 529:backemf.c     ****    	    cmd_decode ();
 1728               	.LM185:
 1729 0860 0E94 0000 		call cmd_decode
 530:backemf.c     **** 		g_cmd_decode = 0; 
 1731               	.LM186:
 1732 0864 1092 0000 		sts g_cmd_decode,__zero_reg__
 531:backemf.c     **** 		g_pos[g_motor] = 0;
 1734               	.LM187:
 1735 0868 8091 0000 		lds r24,g_motor
 1736 086c E82F      		mov r30,r24
 1737 086e FF27      		clr r31
 1738 0870 EE0F      		lsl r30
 1739 0872 FF1F      		rol r31
 1740 0874 EE0F      		lsl r30
 1741 0876 FF1F      		rol r31
 1742 0878 E050      		subi r30,lo8(-(g_pos))
 1743 087a F040      		sbci r31,hi8(-(g_pos))
 1744 087c 1082      		st Z,__zero_reg__
 1745 087e 1182      		std Z+1,__zero_reg__
 1746 0880 1282      		std Z+2,__zero_reg__
 1747 0882 1382      		std Z+3,__zero_reg__
 1748               	.L121:
 532:backemf.c     **** 	}
 533:backemf.c     **** 	
 534:backemf.c     ****  	
 535:backemf.c     ****     for (i = 0 ; i < MOTOR_MAX ; i++)
 1750               	.LM188:
 1751 0884 E0E0      		ldi r30,lo8(0)
 1752               	.L125:
 536:backemf.c     **** 	{
 537:backemf.c     **** 
 538:backemf.c     **** // 7 Segments display	
 539:backemf.c     **** 
 540:backemf.c     **** 		d7segment_display(show[g_mode[i]],i+1);
 1754               	.LM189:
 1755 0886 1E2F      		mov r17,r30
 1756 0888 1F5F      		subi r17,lo8(-(1))
 1757 088a FF27      		clr r31
 1758 088c E050      		subi r30,lo8(-(g_mode))
 1759 088e F040      		sbci r31,hi8(-(g_mode))
 1760 0890 8081      		ld r24,Z
 1761 0892 F601      		movw r30,r12
 1762 0894 E80F      		add r30,r24
 1763 0896 F11D      		adc r31,__zero_reg__
 1764 0898 612F      		mov r22,r17
 1765 089a 8081      		ld r24,Z
 1766 089c 0E94 0000 		call d7segment_display
 541:backemf.c     ****         delay(500);
 1768               	.LM190:
 1769 08a0 84EF      		ldi r24,lo8(500)
 1770 08a2 91E0      		ldi r25,hi8(500)
 1771 08a4 0E94 0000 		call delay
 1773               	.LM191:
 1774 08a8 E12F      		mov r30,r17
 1775 08aa 1230      		cpi r17,lo8(2)
 1776 08ac 60F3      		brlo .L125
 1777 08ae 90CF      		rjmp .L107
 1778               	/* epilogue: frame size=3 */
 1779               	/* epilogue: noreturn */
 1780               	/* epilogue end (size=0) */
 1781               	/* function main size 132 (128) */
 1792               	.Lscope13:
 1793               		.comm g_motor,1,1
 1794               		.comm g_speed,4,1
 1795               		.comm g_angle,8,1
 1796               		.comm g_rcv_buff,250,1
 1806               		.text
 1808               	Letext:
 1809               	/* File "backemf.c": code 1129 = 0x0469 ( 868), prologues 130, epilogues 131 */
DEFINED SYMBOLS
                            *ABS*:00000000 backemf.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:84     .bss:00000000 g_cmd_decode
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:90     .bss:00000001 g_pos
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:96     .data:00000000 g_adc_channel
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:102    .data:00000002 g_speed_table
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:117    .bss:00000009 g_mode
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:124    .text:00000000 delay
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:153    .text:0000000a set_motor_parameter
                            *COM*:00000008 g_angle
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:269    .text:000000a6 remote_decode
                            *COM*:00000004 g_speed
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:532    .text:0000020e cmd_decode
                            *COM*:000000fa g_rcv_buff
                            *COM*:00000001 g_motor
                             .bss:0000000b i.1
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:823    .text:0000039e calculate_backemf
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1061   .text:000004f6 __vector_11
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1121   .text:00000550 __vector_10
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1173   .text:0000059c __vector_5
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1225   .text:000005e8 __vector_4
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:814    .bss:0000000c i.0
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1287   .text:00000644 __vector_13
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1364   .text:000006a6 __vector_14
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1428   .text:000006f8 __vector_6
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1514   .text:0000075e init_board
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1591   .text:000007a8 main
C:\DOCUME~1\tos\LOCALS~1\Temp/ccG8aaaa.s:1808   .text:000008b0 Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
uart_puts
debug_lvalue
text_decode
uart_putc
atoi
__mulsi3
adc_init
read_adc
debug_value
motor_control
uart_get_TX
sony_ir_decode
d7segment_init
init_ir
init_motor
uart_init
__stack
d7segment_display
