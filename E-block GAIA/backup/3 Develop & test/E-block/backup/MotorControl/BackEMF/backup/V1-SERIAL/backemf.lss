
backemf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b3c  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00000b3c  00000bd0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000192  00800090  00800090  00000c00  2**0
                  ALLOC
  3 .noinit       00000000  00800222  00800222  00000c00  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00000c00  2**0
                  CONTENTS
  5 .stab         00002238  00000000  00000000  00000c00  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000eb6  00000000  00000000  00002e38  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3f 00 	jmp	0x7e
   4:	0c 94 5a 00 	jmp	0xb4
   8:	0c 94 5a 00 	jmp	0xb4
   c:	0c 94 5a 00 	jmp	0xb4
  10:	0c 94 5a 00 	jmp	0xb4
  14:	0c 94 5a 00 	jmp	0xb4
  18:	0c 94 b3 01 	jmp	0x366
  1c:	0c 94 5a 00 	jmp	0xb4
  20:	0c 94 5a 00 	jmp	0xb4
  24:	0c 94 5a 00 	jmp	0xb4
  28:	0c 94 5a 00 	jmp	0xb4
  2c:	0c 94 5a 00 	jmp	0xb4
  30:	0c 94 5a 00 	jmp	0xb4
  34:	0c 94 59 01 	jmp	0x2b2
  38:	0c 94 8a 01 	jmp	0x314
  3c:	0c 94 5a 00 	jmp	0xb4
  40:	0c 94 5a 00 	jmp	0xb4
  44:	0c 94 5a 00 	jmp	0xb4
  48:	0c 94 5a 00 	jmp	0xb4
  4c:	0c 94 5a 00 	jmp	0xb4
  50:	0c 94 5a 00 	jmp	0xb4

00000054 <__ctors_end>:
  54:	20 09       	sbc	r18, r0
	...

00000057 <delimiter>:
  57:	3d 22 20 09 2c 0d 0a 00                             =" .,...

0000005f <text_cmd>:
  5f:	6d 6f 74 6f 72 00 00 00 00 00 73 70 65 65 64 00     motor.....speed.
  6f:	00 00 00 00 61 6e 67 6c 65 00 00 00 00 00 00        ....angle......

0000007e <__init>:
  7e:	11 24       	eor	r1, r1
  80:	1f be       	out	0x3f, r1	; 63
  82:	cf e5       	ldi	r28, 0x5F	; 95
  84:	d8 e0       	ldi	r29, 0x08	; 8
  86:	de bf       	out	0x3e, r29	; 62
  88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
  8a:	10 e0       	ldi	r17, 0x00	; 0
  8c:	a0 e6       	ldi	r26, 0x60	; 96
  8e:	b0 e0       	ldi	r27, 0x00	; 0
  90:	ec e3       	ldi	r30, 0x3C	; 60
  92:	fb e0       	ldi	r31, 0x0B	; 11
  94:	02 c0       	rjmp	.+4      	; 0x9a

00000096 <.do_copy_data_loop>:
  96:	05 90       	lpm	r0, Z+
  98:	0d 92       	st	X+, r0

0000009a <.do_copy_data_start>:
  9a:	a0 39       	cpi	r26, 0x90	; 144
  9c:	b1 07       	cpc	r27, r17
  9e:	d9 f7       	brne	.-10     	; 0x96

000000a0 <__do_clear_bss>:
  a0:	12 e0       	ldi	r17, 0x02	; 2
  a2:	a0 e9       	ldi	r26, 0x90	; 144
  a4:	b0 e0       	ldi	r27, 0x00	; 0
  a6:	01 c0       	rjmp	.+2      	; 0xaa

000000a8 <.do_clear_bss_loop>:
  a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
  aa:	a2 32       	cpi	r26, 0x22	; 34
  ac:	b1 07       	cpc	r27, r17
  ae:	e1 f7       	brne	.-8      	; 0xa8
  b0:	0c 94 f2 01 	jmp	0x3e4

000000b4 <__bad_interrupt>:
  b4:	0c 94 00 00 	jmp	0x0

000000b8 <delay>:

void delay ( uint16_t  time)
{
   uint16_t i;
   for (i = 0 ; i < time; i++);
  b8:	00 97       	sbiw	r24, 0x00	; 0
  ba:	11 f0       	breq	.+4      	; 0xc0
  bc:	01 97       	sbiw	r24, 0x01	; 1
  be:	fc cf       	rjmp	.-8      	; 0xb8
  c0:	08 95       	ret

000000c2 <remote_decode>:

}


/* This subroutine will handle IR remote decode by getting remote code from Interrupt handle for input capture
and will response  to each remote key. For other applications user can modified here for different remote active
However this routine support Sony remote control only
   global effect   g_irint;
*/

uint8_t remote_decode ( uint16_t ircode)
{ 
  uint16_t pwm;
  uint8_t speed, found = 1;
  c2:	31 e0       	ldi	r19, 0x01	; 1
  speed = 10;
  c4:	2a e0       	ldi	r18, 0x0A	; 10
  switch ( ircode)
  c6:	48 e0       	ldi	r20, 0x08	; 8
  c8:	80 31       	cpi	r24, 0x10	; 16
  ca:	94 07       	cpc	r25, r20
  cc:	09 f4       	brne	.+2      	; 0xd0
  ce:	63 c0       	rjmp	.+198    	; 0x196
  d0:	48 e0       	ldi	r20, 0x08	; 8
  d2:	81 31       	cpi	r24, 0x11	; 17
  d4:	94 07       	cpc	r25, r20
  d6:	80 f5       	brcc	.+96     	; 0x138
  d8:	42 e0       	ldi	r20, 0x02	; 2
  da:	80 31       	cpi	r24, 0x10	; 16
  dc:	94 07       	cpc	r25, r20
  de:	09 f4       	brne	.+2      	; 0xe2
  e0:	60 c0       	rjmp	.+192    	; 0x1a2
  e2:	42 e0       	ldi	r20, 0x02	; 2
  e4:	81 31       	cpi	r24, 0x11	; 17
  e6:	94 07       	cpc	r25, r20
  e8:	80 f4       	brcc	.+32     	; 0x10a
  ea:	80 39       	cpi	r24, 0x90	; 144
  ec:	91 05       	cpc	r25, r1
  ee:	09 f4       	brne	.+2      	; 0xf2
  f0:	65 c0       	rjmp	.+202    	; 0x1bc
  f2:	81 39       	cpi	r24, 0x91	; 145
  f4:	91 05       	cpc	r25, r1
  f6:	20 f4       	brcc	.+8      	; 0x100
  f8:	40 97       	sbiw	r24, 0x10	; 16
  fa:	09 f4       	brne	.+2      	; 0xfe
  fc:	4a c0       	rjmp	.+148    	; 0x192
  fe:	71 c0       	rjmp	.+226    	; 0x1e2
 100:	80 51       	subi	r24, 0x10	; 16
 102:	91 40       	sbci	r25, 0x01	; 1
 104:	09 f4       	brne	.+2      	; 0x108
 106:	73 c0       	rjmp	.+230    	; 0x1ee
 108:	6c c0       	rjmp	.+216    	; 0x1e2
 10a:	44 e0       	ldi	r20, 0x04	; 4
 10c:	80 31       	cpi	r24, 0x10	; 16
 10e:	94 07       	cpc	r25, r20
 110:	09 f4       	brne	.+2      	; 0x114
 112:	43 c0       	rjmp	.+134    	; 0x19a
 114:	44 e0       	ldi	r20, 0x04	; 4
 116:	81 31       	cpi	r24, 0x11	; 17
 118:	94 07       	cpc	r25, r20
 11a:	28 f4       	brcc	.+10     	; 0x126
 11c:	80 59       	subi	r24, 0x90	; 144
 11e:	92 40       	sbci	r25, 0x02	; 2
 120:	09 f4       	brne	.+2      	; 0x124
 122:	65 c0       	rjmp	.+202    	; 0x1ee
 124:	5e c0       	rjmp	.+188    	; 0x1e2
 126:	44 e0       	ldi	r20, 0x04	; 4
 128:	80 39       	cpi	r24, 0x90	; 144
 12a:	94 07       	cpc	r25, r20
 12c:	09 f4       	brne	.+2      	; 0x130
 12e:	4d c0       	rjmp	.+154    	; 0x1ca
 130:	80 51       	subi	r24, 0x10	; 16
 132:	96 40       	sbci	r25, 0x06	; 6
 134:	d1 f1       	breq	.+116    	; 0x1aa
 136:	55 c0       	rjmp	.+170    	; 0x1e2
 138:	4a e0       	ldi	r20, 0x0A	; 10
 13a:	80 35       	cpi	r24, 0x50	; 80
 13c:	94 07       	cpc	r25, r20
 13e:	09 f4       	brne	.+2      	; 0x142
 140:	56 c0       	rjmp	.+172    	; 0x1ee
 142:	4a e0       	ldi	r20, 0x0A	; 10
 144:	81 35       	cpi	r24, 0x51	; 81
 146:	94 07       	cpc	r25, r20
 148:	80 f4       	brcc	.+32     	; 0x16a
 14a:	49 e0       	ldi	r20, 0x09	; 9
 14c:	80 31       	cpi	r24, 0x10	; 16
 14e:	94 07       	cpc	r25, r20
 150:	81 f1       	breq	.+96     	; 0x1b2
 152:	49 e0       	ldi	r20, 0x09	; 9
 154:	81 31       	cpi	r24, 0x11	; 17
 156:	94 07       	cpc	r25, r20
 158:	20 f4       	brcc	.+8      	; 0x162
 15a:	80 59       	subi	r24, 0x90	; 144
 15c:	98 40       	sbci	r25, 0x08	; 8
 15e:	89 f1       	breq	.+98     	; 0x1c2
 160:	40 c0       	rjmp	.+128    	; 0x1e2
 162:	80 51       	subi	r24, 0x10	; 16
 164:	9a 40       	sbci	r25, 0x0A	; 10
 166:	f9 f0       	breq	.+62     	; 0x1a6
 168:	3c c0       	rjmp	.+120    	; 0x1e2
 16a:	4c e0       	ldi	r20, 0x0C	; 12
 16c:	80 31       	cpi	r24, 0x10	; 16
 16e:	94 07       	cpc	r25, r20
 170:	b1 f0       	breq	.+44     	; 0x19e
 172:	4c e0       	ldi	r20, 0x0C	; 12
 174:	81 31       	cpi	r24, 0x11	; 17
 176:	94 07       	cpc	r25, r20
 178:	20 f4       	brcc	.+8      	; 0x182
 17a:	80 59       	subi	r24, 0x90	; 144
 17c:	9a 40       	sbci	r25, 0x0A	; 10
 17e:	b9 f1       	breq	.+110    	; 0x1ee
 180:	30 c0       	rjmp	.+96     	; 0x1e2
 182:	4c e0       	ldi	r20, 0x0C	; 12
 184:	80 39       	cpi	r24, 0x90	; 144
 186:	94 07       	cpc	r25, r20
 188:	31 f1       	breq	.+76     	; 0x1d6
 18a:	80 51       	subi	r24, 0x10	; 16
 18c:	9e 40       	sbci	r25, 0x0E	; 14
 18e:	79 f0       	breq	.+30     	; 0x1ae
 190:	28 c0       	rjmp	.+80     	; 0x1e2
	   {
	    case IR_TV_1:	
			speed = 2;
 192:	22 e0       	ldi	r18, 0x02	; 2
			 break;
 194:	2c c0       	rjmp	.+88     	; 0x1ee
		case IR_TV_2:
			speed = 3;
 196:	23 e0       	ldi	r18, 0x03	; 3
			 break;
 198:	2a c0       	rjmp	.+84     	; 0x1ee
	    case IR_TV_3:
			speed = 4;
 19a:	24 e0       	ldi	r18, 0x04	; 4
			 break;
 19c:	28 c0       	rjmp	.+80     	; 0x1ee
		case IR_TV_4:
			speed = 5;
 19e:	25 e0       	ldi	r18, 0x05	; 5
			 break;
 1a0:	26 c0       	rjmp	.+76     	; 0x1ee
	    case IR_TV_5:
			speed = 6;
 1a2:	26 e0       	ldi	r18, 0x06	; 6
			 break;
 1a4:	24 c0       	rjmp	.+72     	; 0x1ee
		case IR_TV_6:
			speed = 7;
 1a6:	27 e0       	ldi	r18, 0x07	; 7
			 break;
 1a8:	22 c0       	rjmp	.+68     	; 0x1ee
	    case IR_TV_7:
			speed = 8;
 1aa:	28 e0       	ldi	r18, 0x08	; 8
			break;
 1ac:	20 c0       	rjmp	.+64     	; 0x1ee
		case IR_TV_8:
			speed = 9;
 1ae:	29 e0       	ldi	r18, 0x09	; 9
			break;
 1b0:	1e c0       	rjmp	.+60     	; 0x1ee
	    case IR_TV_9:
			speed = 10;
			break;
		case IR_TV_0:
			g_mode1  = MOTOR_STOP;
 1b2:	10 92 92 00 	sts	0x0092, r1
			g_mode2  = MOTOR_STOP;
 1b6:	10 92 91 00 	sts	0x0091, r1
			break;
 1ba:	19 c0       	rjmp	.+50     	; 0x1ee
		case IR_TV_CHUP:							
        	g_mode1 = MOTOR_FORWARD;		
 1bc:	30 93 92 00 	sts	0x0092, r19
 1c0:	0d c0       	rjmp	.+26     	; 0x1dc
			g_mode2 = MOTOR_FORWARD;
			break;
		case IR_TV_CHDOWN:							
			g_mode1 = MOTOR_BACKWARD;
 1c2:	82 e0       	ldi	r24, 0x02	; 2
 1c4:	80 93 92 00 	sts	0x0092, r24
 1c8:	03 c0       	rjmp	.+6      	; 0x1d0
			g_mode2 = MOTOR_BACKWARD;
			break;
		case IR_TV_TVMUTE:
			break;
		case  IR_TV_TVPOWER:
		  	break;
		case   IR_TV_TVAV:
		    break;
		case  IR_TV_VOLUP:
            g_mode1 = MOTOR_FORWARD;		
 1ca:	30 93 92 00 	sts	0x0092, r19
			g_mode2 = MOTOR_BACKWARD;
 1ce:	82 e0       	ldi	r24, 0x02	; 2
 1d0:	80 93 91 00 	sts	0x0091, r24
			break;
 1d4:	0c c0       	rjmp	.+24     	; 0x1ee
		case  IR_TV_VOLDOWN:                 			
			g_mode1 = MOTOR_BACKWARD;
 1d6:	82 e0       	ldi	r24, 0x02	; 2
 1d8:	80 93 92 00 	sts	0x0092, r24
			g_mode2 = MOTOR_FORWARD;
 1dc:	30 93 91 00 	sts	0x0091, r19
			break;
 1e0:	06 c0       	rjmp	.+12     	; 0x1ee
		default:
			found = 0;
 1e2:	30 e0       	ldi	r19, 0x00	; 0
			g_mode1  = MOTOR_STOP;
 1e4:	30 93 92 00 	sts	0x0092, r19
			g_mode2  = MOTOR_STOP;
 1e8:	30 93 91 00 	sts	0x0091, r19
 1ec:	08 c0       	rjmp	.+16     	; 0x1fe
			break;
 	   }
       if (found)
	   {	pwm = (speed * 100);             // Start from +  speed*2^4
 1ee:	84 e6       	ldi	r24, 0x64	; 100
 1f0:	28 9f       	mul	r18, r24
 1f2:	c0 01       	movw	r24, r0
 1f4:	11 24       	eor	r1, r1
			OCR1A = pwm;
 1f6:	9b bd       	out	0x2b, r25	; 43
 1f8:	8a bd       	out	0x2a, r24	; 42
			OCR1B = pwm;
 1fa:	99 bd       	out	0x29, r25	; 41
 1fc:	88 bd       	out	0x28, r24	; 40
		}	
	   return found;

}
 1fe:	83 2f       	mov	r24, r19
 200:	99 27       	eor	r25, r25
 202:	08 95       	ret

00000204 <cmd_decode>:





/* Command decode from g_rcv_buffer  will decode and action according to command in buffer
 
*/

int16_t cmd_decode (void)
{
 204:	cf 93       	push	r28

 uint8_t  cmd_no =0;
 uint8_t  *cmd_argument;
 uint8_t  *buffer_ptr;
 
 
// Should repeat until end of buffer
 
// Loop until end of text

   buffer_ptr   = g_rcv_buff;
   cmd_argument = g_rcv_buff;
     
   while ( cmd_no !=  CMD_LINE_END)
   {
 		cmd_no =  text_decode (buffer_ptr,cmd_argument);
 206:	61 ea       	ldi	r22, 0xA1	; 161
 208:	70 e0       	ldi	r23, 0x00	; 0
 20a:	cb 01       	movw	r24, r22
 20c:	0e 94 28 04 	call	0x850
 210:	c8 2f       	mov	r28, r24
//		debug_value (cmd_no,10);
		uart_puts("Command :");
 212:	80 e6       	ldi	r24, 0x60	; 96
 214:	90 e0       	ldi	r25, 0x00	; 0
 216:	0e 94 d6 03 	call	0x7ac
		uart_putc(0x30+cmd_no);
 21a:	8c 2f       	mov	r24, r28
 21c:	80 5d       	subi	r24, 0xD0	; 208
 21e:	0e 94 d0 03 	call	0x7a0
		uart_putc('*');
 222:	8a e2       	ldi	r24, 0x2A	; 42
 224:	0e 94 d0 03 	call	0x7a0
		uart_puts(cmd_argument);
 228:	81 ea       	ldi	r24, 0xA1	; 161
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	0e 94 d6 03 	call	0x7ac
  
 		switch (cmd_no)
 230:	8c 2f       	mov	r24, r28
 232:	99 27       	eor	r25, r25
 234:	82 30       	cpi	r24, 0x02	; 2
 236:	91 05       	cpc	r25, r1
 238:	81 f0       	breq	.+32     	; 0x25a
 23a:	83 30       	cpi	r24, 0x03	; 3
 23c:	91 05       	cpc	r25, r1
 23e:	1c f4       	brge	.+6      	; 0x246
 240:	01 97       	sbiw	r24, 0x01	; 1
 242:	21 f0       	breq	.+8      	; 0x24c
 244:	2b c0       	rjmp	.+86     	; 0x29c
 246:	03 97       	sbiw	r24, 0x03	; 3
 248:	79 f0       	breq	.+30     	; 0x268
 24a:	28 c0       	rjmp	.+80     	; 0x29c
		{
			case MOTOR_CMD: 
				g_motor = (uint8_t)atoi(cmd_argument);
 24c:	81 ea       	ldi	r24, 0xA1	; 161
 24e:	90 e0       	ldi	r25, 0x00	; 0
 250:	0e 94 0d 05 	call	0xa1a
 254:	80 93 a0 00 	sts	0x00A0, r24
 				break;
 258:	25 c0       	rjmp	.+74     	; 0x2a4
			case  SPEED_CMD:	
				g_speed = (uint8_t)atoi(cmd_argument);
 25a:	81 ea       	ldi	r24, 0xA1	; 161
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	0e 94 0d 05 	call	0xa1a
 262:	80 93 21 01 	sts	0x0121, r24
  				break;
 266:	1e c0       	rjmp	.+60     	; 0x2a4
			case  ANGLE_CMD:   // Can be - 
				g_angle = atoi(cmd_argument);
 268:	81 ea       	ldi	r24, 0xA1	; 161
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	0e 94 0d 05 	call	0xa1a
 270:	90 93 9f 00 	sts	0x009F, r25
 274:	80 93 9e 00 	sts	0x009E, r24
				if (g_angle > 0)
 278:	18 16       	cp	r1, r24
 27a:	19 06       	cpc	r1, r25
 27c:	64 f4       	brge	.+24     	; 0x296
				{
					if (g_motor == 1)
 27e:	80 91 a0 00 	lds	r24, 0x00A0
 282:	90 91 9e 00 	lds	r25, 0x009E
 286:	81 30       	cpi	r24, 0x01	; 1
 288:	19 f4       	brne	.+6      	; 0x290
						g_mode1 = g_angle;
 28a:	90 93 92 00 	sts	0x0092, r25
 28e:	0a c0       	rjmp	.+20     	; 0x2a4
					else
						g_mode2 = g_angle;
 290:	90 93 91 00 	sts	0x0091, r25
 294:	07 c0       	rjmp	.+14     	; 0x2a4
				}
				else
					uart_puts("Negative value");
 296:	8a e6       	ldi	r24, 0x6A	; 106
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	02 c0       	rjmp	.+4      	; 0x2a0
				break;	
//		    case  CMD_LINE_END:
//				break;
			default:
			    uart_puts("Command not found ");
 29c:	89 e7       	ldi	r24, 0x79	; 121
 29e:	90 e0       	ldi	r25, 0x00	; 0
 2a0:	0e 94 d6 03 	call	0x7ac
// 				uart_putc('-');
//				uart_puts(cmd_argument);
		        break;	  
 2a4:	cf 3f       	cpi	r28, 0xFF	; 255
 2a6:	09 f0       	breq	.+2      	; 0x2aa
 2a8:	ae cf       	rjmp	.-164    	; 0x206
		}		
    }
 return 0; 
}
 2aa:	80 e0       	ldi	r24, 0x00	; 0
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	cf 91       	pop	r28
 2b0:	08 95       	ret

000002b2 <__vector_13>:


 
 
/* UART receiver ready
*/

SIGNAL(SIG_UART_RECV)
{
 2b2:	1f 92       	push	r1
 2b4:	0f 92       	push	r0
 2b6:	0f b6       	in	r0, 0x3f	; 63
 2b8:	0f 92       	push	r0
 2ba:	11 24       	eor	r1, r1
 2bc:	2f 93       	push	r18
 2be:	8f 93       	push	r24
 2c0:	9f 93       	push	r25
 2c2:	ef 93       	push	r30
 2c4:	ff 93       	push	r31
  static uint16_t i= 0;
  uint8_t ch;
  ch = UDR;
 2c6:	2c b1       	in	r18, 0x0c	; 12

	g_rcv_buff[i] = ch;    
 2c8:	80 91 93 00 	lds	r24, 0x0093
 2cc:	90 91 94 00 	lds	r25, 0x0094
 2d0:	fc 01       	movw	r30, r24
 2d2:	ef 55       	subi	r30, 0x5F	; 95
 2d4:	ff 4f       	sbci	r31, 0xFF	; 255
 2d6:	20 83       	st	Z, r18
	i++;
 2d8:	fc 01       	movw	r30, r24
 2da:	31 96       	adiw	r30, 0x01	; 1
 2dc:	f0 93 94 00 	sts	0x0094, r31
 2e0:	e0 93 93 00 	sts	0x0093, r30
 
// Found 0xOD or 0x0A end with null
   if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
 2e4:	2d 30       	cpi	r18, 0x0D	; 13
 2e6:	11 f0       	breq	.+4      	; 0x2ec
 2e8:	2a 30       	cpi	r18, 0x0A	; 10
 2ea:	51 f4       	brne	.+20     	; 0x300
   {	
    	g_rcv_buff[i]  = 0;   // End with null
 2ec:	ef 55       	subi	r30, 0x5F	; 95
 2ee:	ff 4f       	sbci	r31, 0xFF	; 255
 2f0:	10 82       	st	Z, r1
		i = 0;
 2f2:	10 92 94 00 	sts	0x0094, r1
 2f6:	10 92 93 00 	sts	0x0093, r1
  		g_cmd_decode = 1;
 2fa:	81 e0       	ldi	r24, 0x01	; 1
 2fc:	80 93 90 00 	sts	0x0090, r24
 300:	ff 91       	pop	r31
 302:	ef 91       	pop	r30
 304:	9f 91       	pop	r25
 306:	8f 91       	pop	r24
 308:	2f 91       	pop	r18
 30a:	0f 90       	pop	r0
 30c:	0f be       	out	0x3f, r0	; 63
 30e:	0f 90       	pop	r0
 310:	1f 90       	pop	r1
 312:	18 95       	reti

00000314 <__vector_14>:
   }
}

  

/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/

SIGNAL(SIG_UART_DATA)
{ 
 314:	1f 92       	push	r1
 316:	0f 92       	push	r0
 318:	0f b6       	in	r0, 0x3f	; 63
 31a:	0f 92       	push	r0
 31c:	11 24       	eor	r1, r1
 31e:	2f 93       	push	r18
 320:	3f 93       	push	r19
 322:	4f 93       	push	r20
 324:	5f 93       	push	r21
 326:	6f 93       	push	r22
 328:	7f 93       	push	r23
 32a:	8f 93       	push	r24
 32c:	9f 93       	push	r25
 32e:	af 93       	push	r26
 330:	bf 93       	push	r27
 332:	ef 93       	push	r30
 334:	ff 93       	push	r31
    uint8_t  ch;
	if ((ch = uart_get_TX()))
 336:	0e 94 b0 03 	call	0x760
 33a:	88 23       	and	r24, r24
 33c:	11 f0       	breq	.+4      	; 0x342
	{
 		UDR = ch;
 33e:	8c b9       	out	0x0c, r24	; 12
 340:	01 c0       	rjmp	.+2      	; 0x344
	}	
	else 
// No character disable  interrupt to avoid repetable call Enable again when
//	send character in putc procedure
	{
	    UCSRB &=  ~(1<<UDRIE);
 342:	55 98       	cbi	0x0a, 5	; 10
 344:	ff 91       	pop	r31
 346:	ef 91       	pop	r30
 348:	bf 91       	pop	r27
 34a:	af 91       	pop	r26
 34c:	9f 91       	pop	r25
 34e:	8f 91       	pop	r24
 350:	7f 91       	pop	r23
 352:	6f 91       	pop	r22
 354:	5f 91       	pop	r21
 356:	4f 91       	pop	r20
 358:	3f 91       	pop	r19
 35a:	2f 91       	pop	r18
 35c:	0f 90       	pop	r0
 35e:	0f be       	out	0x3f, r0	; 63
 360:	0f 90       	pop	r0
 362:	1f 90       	pop	r1
 364:	18 95       	reti

00000366 <__vector_6>:
	}
	
}

 
 
/* Interrupt handle for Input Capture
This routine will detect/ process the Sony IR remote command. Protocol using Sony remote control
INPUT   :  Infrared signal from  ICP pin
		   Command table 
		  

OUTPUT 	: g_num  Number of message to display
		: g_control.display_mode   Display mode of message
		: g_start_bit
		

*/
SIGNAL(SIG_INPUT_CAPTURE1)
{
 366:	1f 92       	push	r1
 368:	0f 92       	push	r0
 36a:	0f b6       	in	r0, 0x3f	; 63
 36c:	0f 92       	push	r0
 36e:	11 24       	eor	r1, r1
 370:	2f 93       	push	r18
 372:	3f 93       	push	r19
 374:	4f 93       	push	r20
 376:	5f 93       	push	r21
 378:	6f 93       	push	r22
 37a:	7f 93       	push	r23
 37c:	8f 93       	push	r24
 37e:	9f 93       	push	r25
 380:	af 93       	push	r26
 382:	bf 93       	push	r27
 384:	ef 93       	push	r30
 386:	ff 93       	push	r31
	uint16_t  ir_code;
    ir_code = ICR1;
 388:	26 b5       	in	r18, 0x26	; 38
 38a:	37 b5       	in	r19, 0x27	; 39
	cli(); 
 38c:	f8 94       	cli

    TCCR1B  |= _BV(ICES1);	     // Rising edge
 38e:	8e b5       	in	r24, 0x2e	; 46
 390:	80 64       	ori	r24, 0x40	; 64
 392:	8e bd       	out	0x2e, r24	; 46
 	ir_code  = sony_ir_decode(ir_code);  
 394:	c9 01       	movw	r24, r18
 396:	0e 94 14 03 	call	0x628

	if (ir_code)
 39a:	00 97       	sbiw	r24, 0x00	; 0
 39c:	29 f0       	breq	.+10     	; 0x3a8
	{       //End code dispatch command    
 
		remote_decode (ir_code);
 39e:	0e 94 61 00 	call	0xc2
// Return to falling edge for Start		
		TCCR1B  &= ~(_BV(ICES1));
 3a2:	8e b5       	in	r24, 0x2e	; 46
 3a4:	8f 7b       	andi	r24, 0xBF	; 191
 3a6:	8e bd       	out	0x2e, r24	; 46

//Note if  SELFTEST is selected g_irint = 0;
	} 
    sei();
 3a8:	78 94       	sei
 3aa:	ff 91       	pop	r31
 3ac:	ef 91       	pop	r30
 3ae:	bf 91       	pop	r27
 3b0:	af 91       	pop	r26
 3b2:	9f 91       	pop	r25
 3b4:	8f 91       	pop	r24
 3b6:	7f 91       	pop	r23
 3b8:	6f 91       	pop	r22
 3ba:	5f 91       	pop	r21
 3bc:	4f 91       	pop	r20
 3be:	3f 91       	pop	r19
 3c0:	2f 91       	pop	r18
 3c2:	0f 90       	pop	r0
 3c4:	0f be       	out	0x3f, r0	; 63
 3c6:	0f 90       	pop	r0
 3c8:	1f 90       	pop	r1
 3ca:	18 95       	reti

000003cc <init_board>:
 
}


void init_board()
{
	d7segment_init();
 3cc:	0e 94 bd 02 	call	0x57a
	init_ir();
 3d0:	0e 94 0b 03 	call	0x616
	init_motor();
 3d4:	0e 94 c7 02 	call	0x58e
	uart_init(); 
 3d8:	0e 94 56 03 	call	0x6ac
  
	g_cmd_decode = 0; 
 3dc:	10 92 90 00 	sts	0x0090, r1
	sei();
 3e0:	78 94       	sei
 3e2:	08 95       	ret

000003e4 <main>:
}

void main()
{
 3e4:	cc e5       	ldi	r28, 0x5C	; 92
 3e6:	d8 e0       	ldi	r29, 0x08	; 8
 3e8:	de bf       	out	0x3e, r29	; 62
 3ea:	cd bf       	out	0x3d, r28	; 61
  uint8_t sw1,sw2;
  uint16_t k;
  int8_t d1,d2;
  uint8_t show[3] = {0,'f','b'};
 3ec:	7e 01       	movw	r14, r28
 3ee:	08 94       	sec
 3f0:	e1 1c       	adc	r14, r1
 3f2:	f1 1c       	adc	r15, r1
 3f4:	83 e0       	ldi	r24, 0x03	; 3
 3f6:	ec e8       	ldi	r30, 0x8C	; 140
 3f8:	f0 e0       	ldi	r31, 0x00	; 0
 3fa:	d7 01       	movw	r26, r14
 3fc:	01 90       	ld	r0, Z+
 3fe:	0d 92       	st	X+, r0
 400:	8a 95       	dec	r24
 402:	e1 f7       	brne	.-8      	; 0x3fc
  
  
//  enum {MOTOR_STOP,MOTOR_FORWARD,MOTOR_BACKWARD,MOTOR_BRAKE};
  d7segment_init();   // Init both SW and 7 Segments
 404:	0e 94 bd 02 	call	0x57a
  init_ir();
 408:	0e 94 0b 03 	call	0x616
  init_motor();
 40c:	0e 94 c7 02 	call	0x58e
  uart_init(); 
 410:	0e 94 56 03 	call	0x6ac
   
  sei();
 414:	78 94       	sei
  d1 = 0;
 416:	dd 24       	eor	r13, r13
  d2 = 0;
 418:	cd 2c       	mov	r12, r13

  
  while (1)
  {
   sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
 41a:	80 b3       	in	r24, 0x10	; 16
   
   if (!sw1) // SW1  Press
 41c:	98 2f       	mov	r25, r24
 41e:	98 70       	andi	r25, 0x08	; 8
 420:	83 fd       	sbrc	r24, 3
 422:	11 c0       	rjmp	.+34     	; 0x446
    {   	
		d1++;
 424:	c3 94       	inc	r12
	     if (d1 > MOTOR_BACKWARD)
 426:	b2 e0       	ldi	r27, 0x02	; 2
 428:	bc 15       	cp	r27, r12
 42a:	0c f4       	brge	.+2      	; 0x42e
			d1 = MOTOR_STOP;
 42c:	c9 2e       	mov	r12, r25
 42e:	03 ef       	ldi	r16, 0xF3	; 243
 430:	11 e0       	ldi	r17, 0x01	; 1
		for (k = 0; k < 500 ;k++)                         // Delay for key bounce
				delay(6000);						
 432:	80 e7       	ldi	r24, 0x70	; 112
 434:	97 e1       	ldi	r25, 0x17	; 23
 436:	0e 94 5c 00 	call	0xb8
 43a:	01 50       	subi	r16, 0x01	; 1
 43c:	10 40       	sbci	r17, 0x00	; 0
 43e:	17 ff       	sbrs	r17, 7
 440:	f8 cf       	rjmp	.-16     	; 0x432
		g_mode1 = d1;
 442:	c0 92 92 00 	sts	0x0092, r12

	}
   
   sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
 446:	83 b3       	in	r24, 0x13	; 19
   if (!sw2) // SW2 Press
 448:	98 2f       	mov	r25, r24
 44a:	94 70       	andi	r25, 0x04	; 4
 44c:	82 fd       	sbrc	r24, 2
 44e:	11 c0       	rjmp	.+34     	; 0x472
   {
        d2++;
 450:	d3 94       	inc	r13
		if (d2 > MOTOR_BACKWARD)
 452:	82 e0       	ldi	r24, 0x02	; 2
 454:	8d 15       	cp	r24, r13
 456:	0c f4       	brge	.+2      	; 0x45a
			d2 = MOTOR_STOP;
 458:	d9 2e       	mov	r13, r25
 45a:	03 ef       	ldi	r16, 0xF3	; 243
 45c:	11 e0       	ldi	r17, 0x01	; 1
 		for (k = 0; k < 500 ;k++)                         // Delay for key bounce		
 				delay(6000);
 45e:	80 e7       	ldi	r24, 0x70	; 112
 460:	97 e1       	ldi	r25, 0x17	; 23
 462:	0e 94 5c 00 	call	0xb8
 466:	01 50       	subi	r16, 0x01	; 1
 468:	10 40       	sbci	r17, 0x00	; 0
 46a:	17 ff       	sbrs	r17, 7
 46c:	f8 cf       	rjmp	.-16     	; 0x45e
		g_mode2 = d2;
 46e:	d0 92 91 00 	sts	0x0091, r13
	
   }

 
 
// Command decode
    if ( g_cmd_decode)
 472:	80 91 90 00 	lds	r24, 0x0090
 476:	88 23       	and	r24, r24
 478:	21 f0       	breq	.+8      	; 0x482
	{
// Decode command	
   	     cmd_decode ();
 47a:	0e 94 02 01 	call	0x204
		 g_cmd_decode = 0;
 47e:	10 92 90 00 	sts	0x0090, r1
	
	}


// Motor contol section

	motor_control(1, g_mode1);
 482:	60 91 92 00 	lds	r22, 0x0092
 486:	81 e0       	ldi	r24, 0x01	; 1
 488:	0e 94 d9 02 	call	0x5b2
	motor_control(2, g_mode2);
 48c:	60 91 91 00 	lds	r22, 0x0091
 490:	82 e0       	ldi	r24, 0x02	; 2
 492:	0e 94 d9 02 	call	0x5b2
	
//  		for (k = 0; k < 10 ;k++)                         // Delay for key bounce
//			delay (30000);
//		motor_control (1, MOTOR_STOP);

   	d7segment_display(show[g_mode1],1);
 496:	80 91 92 00 	lds	r24, 0x0092
 49a:	f7 01       	movw	r30, r14
 49c:	e8 0f       	add	r30, r24
 49e:	f1 1d       	adc	r31, r1
 4a0:	61 e0       	ldi	r22, 0x01	; 1
 4a2:	80 81       	ld	r24, Z
 4a4:	0e 94 66 02 	call	0x4cc
 			delay(12000);
 4a8:	80 ee       	ldi	r24, 0xE0	; 224
 4aa:	9e e2       	ldi	r25, 0x2E	; 46
 4ac:	0e 94 5c 00 	call	0xb8
	d7segment_display(show[g_mode2],2);
 4b0:	80 91 91 00 	lds	r24, 0x0091
 4b4:	f7 01       	movw	r30, r14
 4b6:	e8 0f       	add	r30, r24
 4b8:	f1 1d       	adc	r31, r1
 4ba:	62 e0       	ldi	r22, 0x02	; 2
 4bc:	80 81       	ld	r24, Z
 4be:	0e 94 66 02 	call	0x4cc
 			delay(12000);
 4c2:	80 ee       	ldi	r24, 0xE0	; 224
 4c4:	9e e2       	ldi	r25, 0x2E	; 46
 4c6:	0e 94 5c 00 	call	0xb8
 4ca:	a7 cf       	rjmp	.-178    	; 0x41a

000004cc <d7segment_display>:
#include "Dual_7Segment.h"

void d7segment_display( int8_t num, uint8_t digit)
{
 switch (num)
 4cc:	99 27       	eor	r25, r25
 4ce:	87 fd       	sbrc	r24, 7
 4d0:	90 95       	com	r25
 4d2:	86 30       	cpi	r24, 0x06	; 6
 4d4:	91 05       	cpc	r25, r1
 4d6:	09 f4       	brne	.+2      	; 0x4da
 4d8:	41 c0       	rjmp	.+130    	; 0x55c
 4da:	87 30       	cpi	r24, 0x07	; 7
 4dc:	91 05       	cpc	r25, r1
 4de:	8c f4       	brge	.+34     	; 0x502
 4e0:	82 30       	cpi	r24, 0x02	; 2
 4e2:	91 05       	cpc	r25, r1
 4e4:	59 f1       	breq	.+86     	; 0x53c
 4e6:	83 30       	cpi	r24, 0x03	; 3
 4e8:	91 05       	cpc	r25, r1
 4ea:	2c f4       	brge	.+10     	; 0x4f6
 4ec:	00 97       	sbiw	r24, 0x00	; 0
 4ee:	11 f1       	breq	.+68     	; 0x534
 4f0:	01 97       	sbiw	r24, 0x01	; 1
 4f2:	11 f1       	breq	.+68     	; 0x538
 4f4:	37 c0       	rjmp	.+110    	; 0x564
 4f6:	84 30       	cpi	r24, 0x04	; 4
 4f8:	91 05       	cpc	r25, r1
 4fa:	21 f1       	breq	.+72     	; 0x544
 4fc:	05 97       	sbiw	r24, 0x05	; 5
 4fe:	24 f5       	brge	.+72     	; 0x548
 500:	1f c0       	rjmp	.+62     	; 0x540
 502:	89 30       	cpi	r24, 0x09	; 9
 504:	91 05       	cpc	r25, r1
 506:	31 f1       	breq	.+76     	; 0x554
 508:	8a 30       	cpi	r24, 0x0A	; 10
 50a:	91 05       	cpc	r25, r1
 50c:	34 f4       	brge	.+12     	; 0x51a
 50e:	87 30       	cpi	r24, 0x07	; 7
 510:	91 05       	cpc	r25, r1
 512:	e1 f0       	breq	.+56     	; 0x54c
 514:	08 97       	sbiw	r24, 0x08	; 8
 516:	e1 f0       	breq	.+56     	; 0x550
 518:	25 c0       	rjmp	.+74     	; 0x564
 51a:	82 36       	cpi	r24, 0x62	; 98
 51c:	91 05       	cpc	r25, r1
 51e:	f1 f0       	breq	.+60     	; 0x55c
 520:	83 36       	cpi	r24, 0x63	; 99
 522:	91 05       	cpc	r25, r1
 524:	1c f4       	brge	.+6      	; 0x52c
 526:	0a 97       	sbiw	r24, 0x0a	; 10
 528:	d9 f0       	breq	.+54     	; 0x560
 52a:	1c c0       	rjmp	.+56     	; 0x564
 52c:	86 36       	cpi	r24, 0x66	; 102
 52e:	91 05       	cpc	r25, r1
 530:	99 f0       	breq	.+38     	; 0x558
 532:	18 c0       	rjmp	.+48     	; 0x564
 {
	case 0:
		_7SEGMENT_PORT = _7SEGMENT_0;
 534:	8f e3       	ldi	r24, 0x3F	; 63
 536:	15 c0       	rjmp	.+42     	; 0x562
		break;
	case 1:
		_7SEGMENT_PORT = _7SEGMENT_1;
 538:	86 e0       	ldi	r24, 0x06	; 6
 53a:	13 c0       	rjmp	.+38     	; 0x562
		break;
	case 2:
		_7SEGMENT_PORT = _7SEGMENT_2;
 53c:	8b e5       	ldi	r24, 0x5B	; 91
 53e:	11 c0       	rjmp	.+34     	; 0x562
		break;
	case 3:
		_7SEGMENT_PORT = _7SEGMENT_3;
 540:	8f e4       	ldi	r24, 0x4F	; 79
 542:	0f c0       	rjmp	.+30     	; 0x562
		break;
	case 4:
		_7SEGMENT_PORT = _7SEGMENT_4;
 544:	86 e6       	ldi	r24, 0x66	; 102
 546:	0d c0       	rjmp	.+26     	; 0x562
		break;
	case 5:
		_7SEGMENT_PORT = _7SEGMENT_5;
 548:	8d e6       	ldi	r24, 0x6D	; 109
 54a:	0b c0       	rjmp	.+22     	; 0x562
		break;
	case 6:
		_7SEGMENT_PORT = _7SEGMENT_6;
		break;
	case 7:
		_7SEGMENT_PORT = _7SEGMENT_7;
 54c:	87 e0       	ldi	r24, 0x07	; 7
 54e:	09 c0       	rjmp	.+18     	; 0x562
		break;
	case 8:
		_7SEGMENT_PORT = _7SEGMENT_8;
 550:	8f e7       	ldi	r24, 0x7F	; 127
 552:	07 c0       	rjmp	.+14     	; 0x562
		break;
	case 9:
		_7SEGMENT_PORT = _7SEGMENT_9;
 554:	87 e6       	ldi	r24, 0x67	; 103
 556:	05 c0       	rjmp	.+10     	; 0x562
	    break;
	case 'f':
	    _7SEGMENT_PORT = _7SEGMENT_C_F;
 558:	81 e7       	ldi	r24, 0x71	; 113
 55a:	03 c0       	rjmp	.+6      	; 0x562
		break;
	case 'b':
	    _7SEGMENT_PORT = _7SEGMENT_C_B;
 55c:	8c e7       	ldi	r24, 0x7C	; 124
 55e:	01 c0       	rjmp	.+2      	; 0x562
		break;
	case DOT:
		_7SEGMENT_PORT = _7SEGMENT_DOT;
 560:	80 e8       	ldi	r24, 0x80	; 128
 562:	88 bb       	out	0x18, r24	; 24
		break;
 
 }
// Out digit
	 
    if ( digit == 1 )
 564:	61 30       	cpi	r22, 0x01	; 1
 566:	19 f4       	brne	.+6      	; 0x56e
	{  // ON Digit 1 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT1);
 568:	ab 98       	cbi	0x15, 3	; 21
	   // OFF Digit 2 
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT2;
 56a:	ac 9a       	sbi	0x15, 4	; 21
 56c:	08 95       	ret
	}
	if ( digit == 2 )
 56e:	62 30       	cpi	r22, 0x02	; 2
 570:	11 f4       	brne	.+4      	; 0x576
	{  // ON Digit 2 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT2);
 572:	ac 98       	cbi	0x15, 4	; 21
	   // OFF Digit 1
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT1;
 574:	ab 9a       	sbi	0x15, 3	; 21
 576:	08 95       	ret
 578:	08 95       	ret

0000057a <d7segment_init>:
	}	

}	


/* Initial 7 Segments. Set port to output before use 
*/
void d7segment_init (void)
{
// Set direction for output for 7 Segment
	_7SEGMENT_DIGIT_DIR   = 0xFF;
 57a:	8f ef       	ldi	r24, 0xFF	; 255
 57c:	87 bb       	out	0x17, r24	; 23
	_7SEGMENT_PORT_DIR	  |= _7SEGMENT_DIGIT1 | _7SEGMENT_DIGIT2;
 57e:	84 b3       	in	r24, 0x14	; 20
 580:	88 61       	ori	r24, 0x18	; 24
 582:	84 bb       	out	0x14, r24	; 20
 
// Set direction for input for SW 
	_7SEGMENT_SW1_DIR	&=  ~(_7SEGMENT_SW1);
 584:	8b 98       	cbi	0x11, 3	; 17
	_7SEGMENT_SW2_DIR	&=  ~(_7SEGMENT_SW2);
 586:	a2 98       	cbi	0x14, 2	; 20

// Enable pull up
    _7SEGMENT_SW1_PORT   |= _7SEGMENT_SW1;
 588:	93 9a       	sbi	0x12, 3	; 18
    _7SEGMENT_SW2_PORT   |= _7SEGMENT_SW2;
 58a:	aa 9a       	sbi	0x15, 2	; 21
 58c:	08 95       	ret

0000058e <init_motor>:
{
 // Initial for PWM Motor control for 16 timer for OC1A and OC1B
// 8 bit fast PWM set OC1A OC1B on comapare match

    TCCR1A |= _BV(WGM10) |_BV(WGM11) | _BV(COM1B1)|_BV(COM1A1);
 58e:	8f b5       	in	r24, 0x2f	; 47
 590:	83 6a       	ori	r24, 0xA3	; 163
 592:	8f bd       	out	0x2f, r24	; 47
    TCCR1B |= _BV(WGM12) | _BV(CS12) | _BV(CS10);   // Clk /1024
 594:	8e b5       	in	r24, 0x2e	; 46
 596:	8d 60       	ori	r24, 0x0D	; 13
 598:	8e bd       	out	0x2e, r24	; 46
	OCR1A = 0x00FF;
 59a:	8f ef       	ldi	r24, 0xFF	; 255
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	9b bd       	out	0x2b, r25	; 43
 5a0:	8a bd       	out	0x2a, r24	; 42
	OCR1B = 0x00FF;
 5a2:	99 bd       	out	0x29, r25	; 41
 5a4:	88 bd       	out	0x28, r24	; 40

//    OCR1A = 0;
//	OCR1B = 0;
    MOTOR_DIRECTION_DIR  |= 	MOTORA_1 | MOTORA_2 | MOTORB_1 | MOTORB_2;
 5a6:	8a b3       	in	r24, 0x1a	; 26
 5a8:	80 6f       	ori	r24, 0xF0	; 240
 5aa:	8a bb       	out	0x1a, r24	; 26
	MOTOR_ENABLE12_DIR	 |= 	MOTOR_ENABLE12;
 5ac:	8d 9a       	sbi	0x11, 5	; 17
	MOTOR_ENABLE34_DIR	 |=  	MOTOR_ENABLE34;		
 5ae:	8c 9a       	sbi	0x11, 4	; 17
 5b0:	08 95       	ret

000005b2 <motor_control>:
  
}


// speed from 1 - 10

void  motor_control (uint8_t port, uint8_t direction) 
{
 5b2:	38 2f       	mov	r19, r24
 5b4:	86 2f       	mov	r24, r22
  
   uint8_t  controlA,controlB;
   
   switch (direction)
 5b6:	99 27       	eor	r25, r25
 5b8:	81 30       	cpi	r24, 0x01	; 1
 5ba:	91 05       	cpc	r25, r1
 5bc:	49 f0       	breq	.+18     	; 0x5d0
 5be:	82 30       	cpi	r24, 0x02	; 2
 5c0:	91 05       	cpc	r25, r1
 5c2:	74 f0       	brlt	.+28     	; 0x5e0
 5c4:	82 30       	cpi	r24, 0x02	; 2
 5c6:	91 05       	cpc	r25, r1
 5c8:	31 f0       	breq	.+12     	; 0x5d6
 5ca:	03 97       	sbiw	r24, 0x03	; 3
 5cc:	39 f0       	breq	.+14     	; 0x5dc
 5ce:	08 c0       	rjmp	.+16     	; 0x5e0
   {
     case MOTOR_FORWARD:
	    controlA = 0;
 5d0:	20 e0       	ldi	r18, 0x00	; 0
		controlB = 0xFF;
 5d2:	9f ef       	ldi	r25, 0xFF	; 255
		break;
 5d4:	07 c0       	rjmp	.+14     	; 0x5e4
	 case MOTOR_BACKWARD:
        controlA = 0xFF;
 5d6:	2f ef       	ldi	r18, 0xFF	; 255
		controlB = 0;
 5d8:	90 e0       	ldi	r25, 0x00	; 0
		break;
 5da:	04 c0       	rjmp	.+8      	; 0x5e4
	 case MOTOR_STOP:
	    controlA = 0;
		controlB = 0;
		break;
	case MOTOR_BRAKE:
	    controlA = 0xFF;
 5dc:	9f ef       	ldi	r25, 0xFF	; 255
 5de:	01 c0       	rjmp	.+2      	; 0x5e2
		controlB = 0xFF;
		break;
	default:
	    controlA = 0;
 5e0:	90 e0       	ldi	r25, 0x00	; 0
		controlB = 0;
 5e2:	29 2f       	mov	r18, r25
   }
 if (port == 1)
 5e4:	31 30       	cpi	r19, 0x01	; 1
 5e6:	51 f4       	brne	.+20     	; 0x5fc
   {
//      MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORA_1 | MOTORA_2); 
 5e8:	8b b3       	in	r24, 0x1b	; 27
 5ea:	8f 7c       	andi	r24, 0xCF	; 207
 5ec:	8b bb       	out	0x1b, r24	; 27
	  MOTOR_DIRECTION_CONTROL |= ((MOTORA_1 & controlA ) | (MOTORA_2 & controlB));
 5ee:	20 71       	andi	r18, 0x10	; 16
 5f0:	90 72       	andi	r25, 0x20	; 32
 5f2:	29 2b       	or	r18, r25
 5f4:	8b b3       	in	r24, 0x1b	; 27
 5f6:	82 2b       	or	r24, r18
 5f8:	8b bb       	out	0x1b, r24	; 27
 5fa:	08 95       	ret
  }
  if (port == 2)
 5fc:	32 30       	cpi	r19, 0x02	; 2
 5fe:	49 f4       	brne	.+18     	; 0x612
   {
// 	  MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORB_1 | MOTORB_2); 
 600:	8b b3       	in	r24, 0x1b	; 27
 602:	8f 73       	andi	r24, 0x3F	; 63
 604:	8b bb       	out	0x1b, r24	; 27
  	  MOTOR_DIRECTION_CONTROL |= ((MOTORB_1 & controlA ) | (MOTORB_2 & controlB));
 606:	20 74       	andi	r18, 0x40	; 64
 608:	90 78       	andi	r25, 0x80	; 128
 60a:	29 2b       	or	r18, r25
 60c:	8b b3       	in	r24, 0x1b	; 27
 60e:	82 2b       	or	r24, r18
 610:	8b bb       	out	0x1b, r24	; 27
 612:	08 95       	ret
 614:	08 95       	ret

00000616 <init_ir>:

void init_ir()
{
 //Set Direction
    IR_DDR_PORT &= ~IR_ICP; 
 616:	8e 98       	cbi	0x11, 6	; 17
	
	TCCR1B  |= ( _BV(ICNC1) | _BV(CS12) | _BV(CS10));			// Time 1 input to clock/1024 input capture on falling edge  noise cancel
 618:	8e b5       	in	r24, 0x2e	; 46
 61a:	85 68       	ori	r24, 0x85	; 133
 61c:	8e bd       	out	0x2e, r24	; 46
	TIMSK   |= _BV(TICIE1);   								// Enable input capture enable 
 61e:	89 b7       	in	r24, 0x39	; 57
 620:	80 62       	ori	r24, 0x20	; 32
 622:	89 bf       	out	0x39, r24	; 57
	sei();
 624:	78 94       	sei
 626:	08 95       	ret

00000628 <sony_ir_decode>:
}
/*  Decode for Sony remote TV IR 
			Input  Input capturn counter 16 bit register
		   Output  0  = no code detect
				   ir_decode  = detect IR code 
				   
	Algorithm
		Calculate pulse width by substract ICP counter. from pulse width 
		can determine whether it is  START BIT 		 =  XX
									  BIT1 			 =  XX
		until 12 bits then return ir code							  
									 
*/

uint16_t sony_ir_decode ( uint16_t capture_counter)
{
 628:	bc 01       	movw	r22, r24
  static 	uint16_t  	prev_capture_counter = 0;
  static 	uint8_t   	stop_bit = 0;
  static	uint16_t	ir_code = 0;
 			uint16_t	width  = 0;	  

      if ( capture_counter > prev_capture_counter)
 62a:	80 91 95 00 	lds	r24, 0x0095
 62e:	90 91 96 00 	lds	r25, 0x0096
 632:	9b 01       	movw	r18, r22
 634:	28 1b       	sub	r18, r24
 636:	39 0b       	sbc	r19, r25
			width = capture_counter - prev_capture_counter;
	  else
			width = capture_counter+(MAX_INT16 - prev_capture_counter);
//Check for start bit
     if ( width > IR_TV_PULSE_WIDTH)
 638:	2a 30       	cpi	r18, 0x0A	; 10
 63a:	31 05       	cpc	r19, r1
 63c:	20 f1       	brcs	.+72     	; 0x686
	 {
		  if (width > IR_TV_START_BIT)  			//  Found Start bit 
 63e:	26 32       	cpi	r18, 0x26	; 38
 640:	31 05       	cpc	r19, r1
 642:	58 f0       	brcs	.+22     	; 0x65a
			    {
				  stop_bit = 0;
 644:	10 92 97 00 	sts	0x0097, r1
				  prev_capture_counter = 0;
 648:	10 92 96 00 	sts	0x0096, r1
 64c:	10 92 95 00 	sts	0x0095, r1
				  ir_code = 0;     			// New code
 650:	10 92 99 00 	sts	0x0099, r1
 654:	10 92 98 00 	sts	0x0098, r1
 658:	16 c0       	rjmp	.+44     	; 0x686
 65a:	80 91 98 00 	lds	r24, 0x0098
 65e:	90 91 99 00 	lds	r25, 0x0099
 662:	40 91 97 00 	lds	r20, 0x0097
				}
		  else if (width > IR_TV_BIT1)	  		// bit 1 (3T)
 666:	2a 31       	cpi	r18, 0x1A	; 26
 668:	31 05       	cpc	r19, r1
 66a:	20 f0       	brcs	.+8      	; 0x674
				{
				   ir_code <<= 1;    			//Shift right
 66c:	88 0f       	add	r24, r24
 66e:	99 1f       	adc	r25, r25
				   ir_code  |= 1;    			// Or 1
 670:	81 60       	ori	r24, 0x01	; 1
 672:	02 c0       	rjmp	.+4      	; 0x678
				    stop_bit++;
				}
		        else 	  // bit 0
				{
					ir_code  <<=  1;  //Shift right
 674:	88 0f       	add	r24, r24
 676:	99 1f       	adc	r25, r25
 678:	90 93 99 00 	sts	0x0099, r25
 67c:	80 93 98 00 	sts	0x0098, r24
					stop_bit++;
 680:	4f 5f       	subi	r20, 0xFF	; 255
 682:	40 93 97 00 	sts	0x0097, r20
				}
	}
	prev_capture_counter = capture_counter;
 686:	70 93 96 00 	sts	0x0096, r23
 68a:	60 93 95 00 	sts	0x0095, r22
	if (stop_bit == IR_TV_STOP_BIT)
 68e:	80 91 97 00 	lds	r24, 0x0097
 692:	8c 30       	cpi	r24, 0x0C	; 12
 694:	39 f4       	brne	.+14     	; 0x6a4
	{       //End code dispatch command
  	    stop_bit = 0;
 696:	10 92 97 00 	sts	0x0097, r1

		return ir_code;
 69a:	80 91 98 00 	lds	r24, 0x0098
 69e:	90 91 99 00 	lds	r25, 0x0099
 6a2:	08 95       	ret
			
//Note if  SELFTEST is selected g_irint = 0;
	}   
	else
		return 0;		// No code detect yet
 6a4:	80 e0       	ldi	r24, 0x00	; 0
 6a6:	90 e0       	ldi	r25, 0x00	; 0
}
 6a8:	08 95       	ret
 6aa:	08 95       	ret

000006ac <uart_init>:
{
 
// Initialize UART  
    
    UCSRC  = 0x86;    // 8 bit non parity  1 stop bit
 6ac:	86 e8       	ldi	r24, 0x86	; 134
 6ae:	80 bd       	out	0x20, r24	; 32
     UCSRB  = 0x98;    // Enable RX Interrupt and Enable TX, RX pin
 6b0:	88 e9       	ldi	r24, 0x98	; 152
 6b2:	8a b9       	out	0x0a, r24	; 10
//    UCSRB  = 0B8;    // Enable RX Interrupt, Data registerempty interrupt enable and Enable TX, RX pin 1011-1000
	UBRRL  = 0x67;    // Speed 9600 UBRR = 103 at 16 MHZ
 6b4:	87 e6       	ldi	r24, 0x67	; 103
 6b6:	89 b9       	out	0x09, r24	; 9
	UBRRH  = 0;
 6b8:	10 bc       	out	0x20, r1	; 32
//    DDRD = 0x00;	 
 
	g_rx_ptr = 0;
 6ba:	10 92 9b 00 	sts	0x009B, r1
	g_tx_ptr = 0;
 6be:	10 92 9a 00 	sts	0x009A, r1
 6c2:	08 95       	ret

000006c4 <uart_put_RX>:
 /* Set baud rate */
 
}

/*
Put character into Rx buffer

Return  = Success 0
        = Fail   Buffer Full
		
*/
uint8_t uart_put_RX ( uint8_t ch)
{
 6c4:	98 2f       	mov	r25, r24
   if ((g_rx_ptr < MAX_BUFF)) 
 6c6:	80 91 9b 00 	lds	r24, 0x009B
 6ca:	87 fd       	sbrc	r24, 7
 6cc:	10 c0       	rjmp	.+32     	; 0x6ee
   {
//  End with Null
		g_rx_buff[g_rx_ptr] = ch;
 6ce:	e8 2f       	mov	r30, r24
 6d0:	ff 27       	eor	r31, r31
 6d2:	ee 5d       	subi	r30, 0xDE	; 222
 6d4:	fe 4f       	sbci	r31, 0xFE	; 254
 6d6:	90 83       	st	Z, r25
		g_rx_ptr++;
 6d8:	8f 5f       	subi	r24, 0xFF	; 255
 6da:	80 93 9b 00 	sts	0x009B, r24
		g_rx_buff[g_rx_ptr] = 0;   // End with null characters
 6de:	e8 2f       	mov	r30, r24
 6e0:	ff 27       	eor	r31, r31
 6e2:	ee 5d       	subi	r30, 0xDE	; 222
 6e4:	fe 4f       	sbci	r31, 0xFE	; 254
 6e6:	10 82       	st	Z, r1
		return 0;
 6e8:	80 e0       	ldi	r24, 0x00	; 0
 6ea:	90 e0       	ldi	r25, 0x00	; 0
 6ec:	08 95       	ret
    }
   else  // Buffer full do nothing  return error
   {
        return UART_BUFFER_FULL;
 6ee:	82 e0       	ldi	r24, 0x02	; 2
 6f0:	90 e0       	ldi	r25, 0x00	; 0
   }
}
 6f2:	08 95       	ret
 6f4:	08 95       	ret

000006f6 <uart_get_RX>:

// Get character from RX buffer

uint8_t uart_get_RX (void)
{
   uint8_t  i,j,ch;
   if (g_rx_ptr)
 6f6:	80 91 9b 00 	lds	r24, 0x009B
 6fa:	88 23       	and	r24, r24
 6fc:	a1 f0       	breq	.+40     	; 0x726
   {
		ch = g_rx_buff[0];
 6fe:	90 91 22 01 	lds	r25, 0x0122
        i =  g_rx_ptr;
 702:	28 2f       	mov	r18, r24
        g_rx_ptr--;
 704:	21 50       	subi	r18, 0x01	; 1
 706:	20 93 9b 00 	sts	0x009B, r18
 70a:	2f 5f       	subi	r18, 0xFF	; 255
		j = 0;
 70c:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_rx_buff[j] =  g_rx_buff[j+1];
 70e:	e3 2f       	mov	r30, r19
 710:	ff 27       	eor	r31, r31
 712:	ee 5d       	subi	r30, 0xDE	; 222
 714:	fe 4f       	sbci	r31, 0xFE	; 254
 716:	81 81       	ldd	r24, Z+1	; 0x01
 718:	80 83       	st	Z, r24
	      j++;
 71a:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
 71c:	21 50       	subi	r18, 0x01	; 1
 71e:	b9 f7       	brne	.-18     	; 0x70e
		}
		return ch;
 720:	89 2f       	mov	r24, r25
 722:	99 27       	eor	r25, r25
 724:	08 95       	ret
   }
   return 0;
 726:	80 e0       	ldi	r24, 0x00	; 0
 728:	90 e0       	ldi	r25, 0x00	; 0
}
 72a:	08 95       	ret
 72c:	08 95       	ret

0000072e <uart_put_TX>:

/* Put character into g_tx_buff
    INPUT  : Character to put in buffer
	Output : 0  OK
		   : UART_BUFFER_FULL  Buffer full
*/

uint8_t uart_put_TX ( uint8_t ch)
{
 72e:	98 2f       	mov	r25, r24
// If exceed buffer do nothing until buffer is flushed
    if ((g_tx_ptr > MAX_BUFF)) 
 730:	80 91 9a 00 	lds	r24, 0x009A
 734:	81 38       	cpi	r24, 0x81	; 129
 736:	18 f0       	brcs	.+6      	; 0x73e
    {
		return UART_BUFFER_FULL;   // No increase pointer
 738:	82 e0       	ldi	r24, 0x02	; 2
 73a:	90 e0       	ldi	r25, 0x00	; 0
 73c:	08 95       	ret
    }
	g_tx_buff[g_tx_ptr]= ch;
 73e:	e8 2f       	mov	r30, r24
 740:	ff 27       	eor	r31, r31
 742:	ee 55       	subi	r30, 0x5E	; 94
 744:	fe 4f       	sbci	r31, 0xFE	; 254
 746:	90 83       	st	Z, r25
	g_tx_ptr++;
 748:	8f 5f       	subi	r24, 0xFF	; 255
 74a:	80 93 9a 00 	sts	0x009A, r24
	g_tx_buff[g_tx_ptr] = 0;    // Put null character at the end
 74e:	e8 2f       	mov	r30, r24
 750:	ff 27       	eor	r31, r31
 752:	ee 55       	subi	r30, 0x5E	; 94
 754:	fe 4f       	sbci	r31, 0xFE	; 254
 756:	10 82       	st	Z, r1
	return 0;
 758:	80 e0       	ldi	r24, 0x00	; 0
 75a:	90 e0       	ldi	r25, 0x00	; 0
}
 75c:	08 95       	ret
 75e:	08 95       	ret

00000760 <uart_get_TX>:


// Get character from TX buffer
uint8_t uart_get_TX (void)
{
   uint8_t i,j,ch =0;
   
   if ( g_tx_ptr)
 760:	80 91 9a 00 	lds	r24, 0x009A
 764:	88 23       	and	r24, r24
 766:	a1 f0       	breq	.+40     	; 0x790
   {
		i  =  g_tx_ptr;
 768:	28 2f       	mov	r18, r24
		g_tx_ptr--;
 76a:	21 50       	subi	r18, 0x01	; 1
 76c:	20 93 9a 00 	sts	0x009A, r18
 770:	2f 5f       	subi	r18, 0xFF	; 255
		ch =  g_tx_buff[0];   // Start from 0 FIFO
 772:	90 91 a2 01 	lds	r25, 0x01A2
		j = 0;
 776:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_tx_buff[j] =  g_tx_buff[j+1];
 778:	e3 2f       	mov	r30, r19
 77a:	ff 27       	eor	r31, r31
 77c:	ee 55       	subi	r30, 0x5E	; 94
 77e:	fe 4f       	sbci	r31, 0xFE	; 254
 780:	81 81       	ldd	r24, Z+1	; 0x01
 782:	80 83       	st	Z, r24
	      j++;
 784:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
 786:	21 50       	subi	r18, 0x01	; 1
 788:	b9 f7       	brne	.-18     	; 0x778
		}
		return ch;
 78a:	89 2f       	mov	r24, r25
 78c:	99 27       	eor	r25, r25
 78e:	08 95       	ret
   }
   return 0;
 790:	80 e0       	ldi	r24, 0x00	; 0
 792:	90 e0       	ldi	r25, 0x00	; 0
}
 794:	08 95       	ret
 796:	08 95       	ret

00000798 <uart_getc>:


uint8_t uart_getc(void)
{
    uint8_t ch;
	ch = uart_get_RX();
 798:	0e 94 7b 03 	call	0x6f6
    return ch ;
}
 79c:	99 27       	eor	r25, r25
 79e:	08 95       	ret

000007a0 <uart_putc>:

uint8_t uart_putc(uint8_t c)
{
    uart_put_TX(c);
 7a0:	0e 94 97 03 	call	0x72e
// Enable interrupt UART Data Register empty
   UCSRB  |=  (1<<UDRIE);	
 7a4:	55 9a       	sbi	0x0a, 5	; 10
    return 0;

}
 7a6:	80 e0       	ldi	r24, 0x00	; 0
 7a8:	90 e0       	ldi	r25, 0x00	; 0
 7aa:	08 95       	ret

000007ac <uart_puts>:


/*************************************************************************
Function: uart_puts()
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const uint8_t *s )
{
 7ac:	cf 93       	push	r28
 7ae:	df 93       	push	r29
 7b0:	ec 01       	movw	r28, r24
    while (*s) 
      uart_putc(*s++);
 7b2:	88 81       	ld	r24, Y
 7b4:	88 23       	and	r24, r24
 7b6:	21 f0       	breq	.+8      	; 0x7c0
 7b8:	89 91       	ld	r24, Y+
 7ba:	0e 94 d0 03 	call	0x7a0
 7be:	f9 cf       	rjmp	.-14     	; 0x7b2
    uart_putc(0x0D);
 7c0:	8d e0       	ldi	r24, 0x0D	; 13
 7c2:	0e 94 d0 03 	call	0x7a0
	uart_putc(0x0A);
 7c6:	8a e0       	ldi	r24, 0x0A	; 10
 7c8:	0e 94 d0 03 	call	0x7a0
 7cc:	df 91       	pop	r29
 7ce:	cf 91       	pop	r28
 7d0:	08 95       	ret

000007d2 <debug_value>:
}

/*
Show debug value
*/

void  debug_value ( uint16_t value, uint8_t radix)
{
 7d2:	cf 93       	push	r28
 7d4:	df 93       	push	r29
 7d6:	cd b7       	in	r28, 0x3d	; 61
 7d8:	de b7       	in	r29, 0x3e	; 62
 7da:	64 97       	sbiw	r28, 0x14	; 20
 7dc:	0f b6       	in	r0, 0x3f	; 63
 7de:	f8 94       	cli
 7e0:	de bf       	out	0x3e, r29	; 62
 7e2:	0f be       	out	0x3f, r0	; 63
 7e4:	cd bf       	out	0x3d, r28	; 61
 7e6:	26 2f       	mov	r18, r22
   uint8_t  buff[20];
   
   itoa (value,buff, radix);
 7e8:	33 27       	eor	r19, r19
 7ea:	a9 01       	movw	r20, r18
 7ec:	be 01       	movw	r22, r28
 7ee:	6f 5f       	subi	r22, 0xFF	; 255
 7f0:	7f 4f       	sbci	r23, 0xFF	; 255
 7f2:	0e 94 3a 05 	call	0xa74
    uart_puts ( buff);
 7f6:	ce 01       	movw	r24, r28
 7f8:	01 96       	adiw	r24, 0x01	; 1
 7fa:	0e 94 d6 03 	call	0x7ac
 7fe:	64 96       	adiw	r28, 0x14	; 20
 800:	0f b6       	in	r0, 0x3f	; 63
 802:	f8 94       	cli
 804:	de bf       	out	0x3e, r29	; 62
 806:	0f be       	out	0x3f, r0	; 63
 808:	cd bf       	out	0x3d, r28	; 61
 80a:	df 91       	pop	r29
 80c:	cf 91       	pop	r28
 80e:	08 95       	ret

00000810 <adc_init>:
      Bit 5   left or right adjust bit in ADLAR
*/
void adc_init(uint8_t voltage)
{
    ADCSRA = 0xC7;
 810:	97 ec       	ldi	r25, 0xC7	; 199
 812:	96 b9       	out	0x06, r25	; 6
	
// Set voltage reference 	
	ADMUX  =  voltage << 6;
 814:	82 95       	swap	r24
 816:	88 0f       	add	r24, r24
 818:	88 0f       	add	r24, r24
 81a:	80 7c       	andi	r24, 0xC0	; 192
 81c:	87 b9       	out	0x07, r24	; 7
 81e:	08 95       	ret

00000820 <adc_enable_int>:

}

/*
  Input mode = 0  Disable
        mode > 0  Enable


*/
void  adc_enable_int (uint8_t mode)
{
    if (mode)
 820:	88 23       	and	r24, r24
 822:	19 f0       	breq	.+6      	; 0x82a
	{
		ADCSRA  |= ( (1 << ADEN) | (1 << ADIE) | (1<< ADSC));
 824:	86 b1       	in	r24, 0x06	; 6
 826:	88 6c       	ori	r24, 0xC8	; 200
 828:	02 c0       	rjmp	.+4      	; 0x82e
    }
	else
	{
		ADCSRA  &= ~((1 << ADIE) | (1<< ADSC));
 82a:	86 b1       	in	r24, 0x06	; 6
 82c:	87 7b       	andi	r24, 0xB7	; 183
 82e:	86 b9       	out	0x06, r24	; 6
 830:	08 95       	ret
 832:	08 95       	ret

00000834 <read_adc>:
	}
}


/*
Read adc value		
	
	INPUT :  channel  to read adc  ( See table for Differential INput and Gain)
    Polling mode 
*/

int16_t read_adc(uint8_t channel)
{
  int16_t  value;
// Before that need to clear ADATE and ADEN
    ADCSRA &= ~((1 << ADEN) | (1<< ADATE));
 834:	96 b1       	in	r25, 0x06	; 6
 836:	9f 75       	andi	r25, 0x5F	; 95
 838:	96 b9       	out	0x06, r25	; 6

// Set channel
    ADMUX |= channel;
 83a:	97 b1       	in	r25, 0x07	; 7
 83c:	98 2b       	or	r25, r24
 83e:	97 b9       	out	0x07, r25	; 7
	
// Enable conversion
	ADCSRA |= (1<<ADEN);
 840:	37 9a       	sbi	0x06, 7	; 6
// Start conversion
//    ADCSRA |= ADSC;	
    
// Check whether conversion is conversion
//   	while( bit_is_set(ADCSRA, ADIF) );

       ADCSRA |= (1<<ADSC);        // do single conversion
 842:	36 9a       	sbi	0x06, 6	; 6
        while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
 844:	34 9b       	sbis	0x06, 4	; 6
 846:	fe cf       	rjmp	.-4      	; 0x844
        
 
//Read value
//      value = ADCL;            // read out ADCL register
//      value += (ADCH << 8);    // read out ADCH register        

  
	value = ADCW;
 848:	84 b1       	in	r24, 0x04	; 4
 84a:	95 b1       	in	r25, 0x05	; 5

// Stop conversion
    ADCSRA &= ~(1 << ADEN);
 84c:	37 98       	cbi	0x06, 7	; 6
 84e:	08 95       	ret

00000850 <text_decode>:

*/ 

uint8_t text_decode (uint8_t *buffer, uint8_t *cmd_argument)
{
 850:	cf 92       	push	r12
 852:	df 92       	push	r13
 854:	ef 92       	push	r14
 856:	ff 92       	push	r15
 858:	0f 93       	push	r16
 85a:	1f 93       	push	r17
 85c:	cf 93       	push	r28
 85e:	7c 01       	movw	r14, r24

 uint8_t  found,ch,ch2,cmd_no,j,k,index,cmd_complete;
 uint8_t  state = WAIT_CMD_STATE, quote  = 0;
 860:	51 e0       	ldi	r21, 0x01	; 1
 static uint16_t i=0; // Keep pointer for next command decode
 cmd_complete = 0;
 862:	cc 24       	eor	r12, r12
 cmd_no 	= 0;
 864:	dc 2c       	mov	r13, r12
 index 		= 0;
 866:	4c 2d       	mov	r20, r12
 
 cmd_argument  = buffer;
 
 while (*(buffer+i))	  		//End with NULL
 {
// Check with delimiter

 	 j = 0;
	 found = 0;
	
	switch (state)
	{
	  case WAIT_CMD_STATE:   // If found first character in command table  then go to get_cmd state
 		j = 0;
		while ((ch = pgm_read_byte(&text_cmd[j][0])))     //Check first charaters in cmd table
		{ 
		  if (*(buffer+i) == ch)
		  {
			state = GET_CMD_STATE;   // Found delimiter
			*(cmd_argument) = ch;
			index = 1;
			break; 
		  }
		 j++;
		}  
	    break;
	  case GET_CMD_STATE:
	    ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
		if (found)
		{
        	*(cmd_argument+index) = 0x00;
		     if (ch == '=')
			 {
// Check command number 
  				for (k = 0; k < CMD_NUM ; k++)
				{
					if (!(strcasecmp_P(cmd_argument,&text_cmd[k][0])))  // Found then keep command
					{
						cmd_no  = k+1;   // Start from 0 
						break;
					}
				}
// clear index
  				index = 0;
			    state = WAIT_ARG_STATE;	
			 }	
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}
		break;
		
	  case WAIT_ARG_STATE:
		ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
				
		if ( ch == '"')   // Start quote
		{
			quote ^= 1;   // Toggle quote	
			state = GET_ARG_STATE;   
 			index = 0;
		}
		
		if (!found)    // Not delimiter start get Argument
		{
			state = GET_ARG_STATE;   
			*(cmd_argument) = ch;
			index = 1;
		}
		break;	
	  case	GET_ARG_STATE:
	  	ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
 		if ( ch == '"')     // End quote
		{
			quote ^= 1;   // Toggle quote	
   		}
		if ( quote)
		{
         	found = 0; //  ignore all characters after the quote until found quote again
// Cancel quote
            
		}	
		if (found)
		{	
            cmd_complete = 1;
			*(cmd_argument+index) = 0;
		    state = WAIT_CMD_STATE;
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}  
		break;
	}
	
	if(cmd_complete)   // COmmand both cmd number and argument
	{
		return cmd_no;	 	 
	}
	i++;
 868:	e0 91 9c 00 	lds	r30, 0x009C
 86c:	f0 91 9d 00 	lds	r31, 0x009D
 870:	ee 0d       	add	r30, r14
 872:	ff 1d       	adc	r31, r15
 874:	80 81       	ld	r24, Z
 876:	88 23       	and	r24, r24
 878:	09 f4       	brne	.+2      	; 0x87c
 87a:	c1 c0       	rjmp	.+386    	; 0x9fe
 87c:	30 e0       	ldi	r19, 0x00	; 0
 87e:	85 2f       	mov	r24, r21
 880:	99 27       	eor	r25, r25
 882:	82 30       	cpi	r24, 0x02	; 2
 884:	91 05       	cpc	r25, r1
 886:	79 f1       	breq	.+94     	; 0x8e6
 888:	83 30       	cpi	r24, 0x03	; 3
 88a:	91 05       	cpc	r25, r1
 88c:	1c f4       	brge	.+6      	; 0x894
 88e:	01 97       	sbiw	r24, 0x01	; 1
 890:	59 f0       	breq	.+22     	; 0x8a8
 892:	ab c0       	rjmp	.+342    	; 0x9ea
 894:	83 30       	cpi	r24, 0x03	; 3
 896:	91 05       	cpc	r25, r1
 898:	09 f4       	brne	.+2      	; 0x89c
 89a:	5a c0       	rjmp	.+180    	; 0x950
 89c:	04 97       	sbiw	r24, 0x04	; 4
 89e:	09 f4       	brne	.+2      	; 0x8a2
 8a0:	7b c0       	rjmp	.+246    	; 0x998
 8a2:	a3 c0       	rjmp	.+326    	; 0x9ea
 8a4:	52 e0       	ldi	r21, 0x02	; 2
 8a6:	72 c0       	rjmp	.+228    	; 0x98c
 8a8:	23 2f       	mov	r18, r19
 8aa:	ef e5       	ldi	r30, 0x5F	; 95
 8ac:	f0 e0       	ldi	r31, 0x00	; 0
 8ae:	94 91       	lpm	r25, Z
 8b0:	99 23       	and	r25, r25
 8b2:	09 f4       	brne	.+2      	; 0x8b6
 8b4:	9a c0       	rjmp	.+308    	; 0x9ea
 8b6:	e0 91 9c 00 	lds	r30, 0x009C
 8ba:	f0 91 9d 00 	lds	r31, 0x009D
 8be:	ee 0d       	add	r30, r14
 8c0:	ff 1d       	adc	r31, r15
 8c2:	80 81       	ld	r24, Z
 8c4:	3a e0       	ldi	r19, 0x0A	; 10
 8c6:	89 17       	cp	r24, r25
 8c8:	69 f3       	breq	.-38     	; 0x8a4
 8ca:	2f 5f       	subi	r18, 0xFF	; 255
 8cc:	23 9f       	mul	r18, r19
 8ce:	f0 01       	movw	r30, r0
 8d0:	11 24       	eor	r1, r1
 8d2:	e1 5a       	subi	r30, 0xA1	; 161
 8d4:	ff 4f       	sbci	r31, 0xFF	; 255
 8d6:	94 91       	lpm	r25, Z
 8d8:	99 23       	and	r25, r25
 8da:	a9 f7       	brne	.-22     	; 0x8c6
 8dc:	86 c0       	rjmp	.+268    	; 0x9ea
 8de:	31 e0       	ldi	r19, 0x01	; 1
 8e0:	17 c0       	rjmp	.+46     	; 0x910
 8e2:	c2 2e       	mov	r12, r18
 8e4:	30 c0       	rjmp	.+96     	; 0x946
 8e6:	e0 91 9c 00 	lds	r30, 0x009C
 8ea:	f0 91 9d 00 	lds	r31, 0x009D
 8ee:	ee 0d       	add	r30, r14
 8f0:	ff 1d       	adc	r31, r15
 8f2:	90 81       	ld	r25, Z
 8f4:	23 2f       	mov	r18, r19
 8f6:	e7 e5       	ldi	r30, 0x57	; 87
 8f8:	f0 e0       	ldi	r31, 0x00	; 0
 8fa:	84 91       	lpm	r24, Z
 8fc:	88 23       	and	r24, r24
 8fe:	41 f0       	breq	.+16     	; 0x910
 900:	98 17       	cp	r25, r24
 902:	69 f3       	breq	.-38     	; 0x8de
 904:	2f 5f       	subi	r18, 0xFF	; 255
 906:	e2 2f       	mov	r30, r18
 908:	ff 27       	eor	r31, r31
 90a:	e9 5a       	subi	r30, 0xA9	; 169
 90c:	ff 4f       	sbci	r31, 0xFF	; 255
 90e:	f5 cf       	rjmp	.-22     	; 0x8fa
 910:	e4 2f       	mov	r30, r20
 912:	ff 27       	eor	r31, r31
 914:	33 23       	and	r19, r19
 916:	09 f4       	brne	.+2      	; 0x91a
 918:	64 c0       	rjmp	.+200    	; 0x9e2
 91a:	ee 0d       	add	r30, r14
 91c:	ff 1d       	adc	r31, r15
 91e:	10 82       	st	Z, r1
 920:	9d 33       	cpi	r25, 0x3D	; 61
 922:	09 f0       	breq	.+2      	; 0x926
 924:	62 c0       	rjmp	.+196    	; 0x9ea
 926:	c0 81       	ld	r28, Z
 928:	0f e5       	ldi	r16, 0x5F	; 95
 92a:	10 e0       	ldi	r17, 0x00	; 0
 92c:	b8 01       	movw	r22, r16
 92e:	c7 01       	movw	r24, r14
 930:	0e 94 67 05 	call	0xace
 934:	2c 2f       	mov	r18, r28
 936:	2f 5f       	subi	r18, 0xFF	; 255
 938:	89 2b       	or	r24, r25
 93a:	99 f2       	breq	.-90     	; 0x8e2
 93c:	c2 2f       	mov	r28, r18
 93e:	06 5f       	subi	r16, 0xF6	; 246
 940:	1f 4f       	sbci	r17, 0xFF	; 255
 942:	23 30       	cpi	r18, 0x03	; 3
 944:	98 f3       	brcs	.-26     	; 0x92c
 946:	40 e0       	ldi	r20, 0x00	; 0
 948:	53 e0       	ldi	r21, 0x03	; 3
 94a:	4f c0       	rjmp	.+158    	; 0x9ea
 94c:	31 e0       	ldi	r19, 0x01	; 1
 94e:	15 c0       	rjmp	.+42     	; 0x97a
 950:	e0 91 9c 00 	lds	r30, 0x009C
 954:	f0 91 9d 00 	lds	r31, 0x009D
 958:	ee 0d       	add	r30, r14
 95a:	ff 1d       	adc	r31, r15
 95c:	90 81       	ld	r25, Z
 95e:	23 2f       	mov	r18, r19
 960:	e7 e5       	ldi	r30, 0x57	; 87
 962:	f0 e0       	ldi	r31, 0x00	; 0
 964:	84 91       	lpm	r24, Z
 966:	88 23       	and	r24, r24
 968:	41 f0       	breq	.+16     	; 0x97a
 96a:	98 17       	cp	r25, r24
 96c:	79 f3       	breq	.-34     	; 0x94c
 96e:	2f 5f       	subi	r18, 0xFF	; 255
 970:	e2 2f       	mov	r30, r18
 972:	ff 27       	eor	r31, r31
 974:	e9 5a       	subi	r30, 0xA9	; 169
 976:	ff 4f       	sbci	r31, 0xFF	; 255
 978:	f5 cf       	rjmp	.-22     	; 0x964
 97a:	92 32       	cpi	r25, 0x22	; 34
 97c:	21 f4       	brne	.+8      	; 0x986
 97e:	81 e0       	ldi	r24, 0x01	; 1
 980:	d8 26       	eor	r13, r24
 982:	54 e0       	ldi	r21, 0x04	; 4
 984:	40 e0       	ldi	r20, 0x00	; 0
 986:	33 23       	and	r19, r19
 988:	81 f5       	brne	.+96     	; 0x9ea
 98a:	54 e0       	ldi	r21, 0x04	; 4
 98c:	f7 01       	movw	r30, r14
 98e:	90 83       	st	Z, r25
 990:	41 e0       	ldi	r20, 0x01	; 1
 992:	2b c0       	rjmp	.+86     	; 0x9ea
 994:	31 e0       	ldi	r19, 0x01	; 1
 996:	15 c0       	rjmp	.+42     	; 0x9c2
 998:	e0 91 9c 00 	lds	r30, 0x009C
 99c:	f0 91 9d 00 	lds	r31, 0x009D
 9a0:	ee 0d       	add	r30, r14
 9a2:	ff 1d       	adc	r31, r15
 9a4:	90 81       	ld	r25, Z
 9a6:	23 2f       	mov	r18, r19
 9a8:	e7 e5       	ldi	r30, 0x57	; 87
 9aa:	f0 e0       	ldi	r31, 0x00	; 0
 9ac:	84 91       	lpm	r24, Z
 9ae:	88 23       	and	r24, r24
 9b0:	41 f0       	breq	.+16     	; 0x9c2
 9b2:	98 17       	cp	r25, r24
 9b4:	79 f3       	breq	.-34     	; 0x994
 9b6:	2f 5f       	subi	r18, 0xFF	; 255
 9b8:	e2 2f       	mov	r30, r18
 9ba:	ff 27       	eor	r31, r31
 9bc:	e9 5a       	subi	r30, 0xA9	; 169
 9be:	ff 4f       	sbci	r31, 0xFF	; 255
 9c0:	f5 cf       	rjmp	.-22     	; 0x9ac
 9c2:	92 32       	cpi	r25, 0x22	; 34
 9c4:	11 f4       	brne	.+4      	; 0x9ca
 9c6:	81 e0       	ldi	r24, 0x01	; 1
 9c8:	d8 26       	eor	r13, r24
 9ca:	d1 10       	cpse	r13, r1
 9cc:	30 e0       	ldi	r19, 0x00	; 0
 9ce:	e4 2f       	mov	r30, r20
 9d0:	ff 27       	eor	r31, r31
 9d2:	33 23       	and	r19, r19
 9d4:	31 f0       	breq	.+12     	; 0x9e2
 9d6:	ee 0d       	add	r30, r14
 9d8:	ff 1d       	adc	r31, r15
 9da:	10 82       	st	Z, r1
 9dc:	8c 2d       	mov	r24, r12
 9de:	99 27       	eor	r25, r25
 9e0:	14 c0       	rjmp	.+40     	; 0xa0a
 9e2:	ee 0d       	add	r30, r14
 9e4:	ff 1d       	adc	r31, r15
 9e6:	90 83       	st	Z, r25
 9e8:	4f 5f       	subi	r20, 0xFF	; 255
 9ea:	e0 91 9c 00 	lds	r30, 0x009C
 9ee:	f0 91 9d 00 	lds	r31, 0x009D
 9f2:	31 96       	adiw	r30, 0x01	; 1
 9f4:	f0 93 9d 00 	sts	0x009D, r31
 9f8:	e0 93 9c 00 	sts	0x009C, r30
 9fc:	39 cf       	rjmp	.-398    	; 0x870
 }
  i = 0;
 9fe:	10 92 9d 00 	sts	0x009D, r1
 a02:	10 92 9c 00 	sts	0x009C, r1
  return 0xFF;  // End of Buffer
 a06:	8f ef       	ldi	r24, 0xFF	; 255
 a08:	90 e0       	ldi	r25, 0x00	; 0
 a0a:	cf 91       	pop	r28
 a0c:	1f 91       	pop	r17
 a0e:	0f 91       	pop	r16
 a10:	ff 90       	pop	r15
 a12:	ef 90       	pop	r14
 a14:	df 90       	pop	r13
 a16:	cf 90       	pop	r12
 a18:	08 95       	ret

00000a1a <atoi>:
 a1a:	fc 01       	movw	r30, r24
 a1c:	88 27       	eor	r24, r24
 a1e:	99 27       	eor	r25, r25
 a20:	e8 94       	clt

00000a22 <.atoi_loop>:
 a22:	21 91       	ld	r18, Z+
 a24:	22 23       	and	r18, r18
 a26:	f1 f0       	breq	.+60     	; 0xa64
 a28:	20 32       	cpi	r18, 0x20	; 32
 a2a:	d9 f3       	breq	.-10     	; 0xa22
 a2c:	29 30       	cpi	r18, 0x09	; 9
 a2e:	c9 f3       	breq	.-14     	; 0xa22
 a30:	2a 30       	cpi	r18, 0x0A	; 10
 a32:	b9 f3       	breq	.-18     	; 0xa22
 a34:	2c 30       	cpi	r18, 0x0C	; 12
 a36:	a9 f3       	breq	.-22     	; 0xa22
 a38:	2d 30       	cpi	r18, 0x0D	; 13
 a3a:	99 f3       	breq	.-26     	; 0xa22
 a3c:	26 37       	cpi	r18, 0x76	; 118
 a3e:	89 f3       	breq	.-30     	; 0xa22
 a40:	2b 32       	cpi	r18, 0x2B	; 43
 a42:	19 f0       	breq	.+6      	; 0xa4a
 a44:	2d 32       	cpi	r18, 0x2D	; 45
 a46:	21 f4       	brne	.+8      	; 0xa50

00000a48 <.atoi_neg>:
 a48:	68 94       	set

00000a4a <.atoi_loop2>:
 a4a:	21 91       	ld	r18, Z+
 a4c:	22 23       	and	r18, r18
 a4e:	51 f0       	breq	.+20     	; 0xa64

00000a50 <.atoi_digit>:
 a50:	20 33       	cpi	r18, 0x30	; 48
 a52:	44 f0       	brlt	.+16     	; 0xa64
 a54:	2a 33       	cpi	r18, 0x3A	; 58
 a56:	34 f4       	brge	.+12     	; 0xa64
 a58:	20 53       	subi	r18, 0x30	; 48
 a5a:	0e 94 5f 05 	call	0xabe
 a5e:	82 0f       	add	r24, r18
 a60:	91 1d       	adc	r25, r1
 a62:	f3 cf       	rjmp	.-26     	; 0xa4a

00000a64 <.atoi_sig>:
 a64:	81 15       	cp	r24, r1
 a66:	91 05       	cpc	r25, r1
 a68:	21 f0       	breq	.+8      	; 0xa72
 a6a:	1e f4       	brtc	.+6      	; 0xa72
 a6c:	80 95       	com	r24
 a6e:	90 95       	com	r25
 a70:	01 96       	adiw	r24, 0x01	; 1

00000a72 <.atoi_done>:
 a72:	08 95       	ret

00000a74 <itoa>:
 a74:	e6 2f       	mov	r30, r22
 a76:	f7 2f       	mov	r31, r23
 a78:	2e 2f       	mov	r18, r30
 a7a:	3f 2f       	mov	r19, r31
 a7c:	e8 94       	clt
 a7e:	42 30       	cpi	r20, 0x02	; 2
 a80:	cc f0       	brlt	.+50     	; 0xab4
 a82:	45 32       	cpi	r20, 0x25	; 37
 a84:	bc f4       	brge	.+46     	; 0xab4
 a86:	4a 30       	cpi	r20, 0x0A	; 10
 a88:	29 f4       	brne	.+10     	; 0xa94
 a8a:	97 fb       	bst	r25, 7
 a8c:	1e f4       	brtc	.+6      	; 0xa94
 a8e:	90 95       	com	r25
 a90:	81 95       	neg	r24
 a92:	9f 4f       	sbci	r25, 0xFF	; 255

00000a94 <divide_loop>:
 a94:	64 2f       	mov	r22, r20
 a96:	77 27       	eor	r23, r23
 a98:	0e 94 8a 05 	call	0xb14
 a9c:	80 5d       	subi	r24, 0xD0	; 208
 a9e:	8a 33       	cpi	r24, 0x3A	; 58
 aa0:	0c f0       	brlt	.+2      	; 0xaa4
 aa2:	89 5d       	subi	r24, 0xD9	; 217

00000aa4 <L_10>:
 aa4:	81 93       	st	Z+, r24
 aa6:	86 2f       	mov	r24, r22
 aa8:	97 2f       	mov	r25, r23
 aaa:	00 97       	sbiw	r24, 0x00	; 0
 aac:	99 f7       	brne	.-26     	; 0xa94
 aae:	16 f4       	brtc	.+4      	; 0xab4
 ab0:	5d e2       	ldi	r21, 0x2D	; 45
 ab2:	51 93       	st	Z+, r21

00000ab4 <terminate>:
 ab4:	93 2f       	mov	r25, r19
 ab6:	82 2f       	mov	r24, r18
 ab8:	10 82       	st	Z, r1
 aba:	0c 94 7a 05 	jmp	0xaf4

00000abe <__mulhi_const_10>:
 abe:	7a e0       	ldi	r23, 0x0A	; 10
 ac0:	97 9f       	mul	r25, r23
 ac2:	90 2d       	mov	r25, r0
 ac4:	87 9f       	mul	r24, r23
 ac6:	80 2d       	mov	r24, r0
 ac8:	91 0d       	add	r25, r1
 aca:	11 24       	eor	r1, r1
 acc:	08 95       	ret

00000ace <strcasecmp_P>:
 ace:	fb 01       	movw	r30, r22
 ad0:	dc 01       	movw	r26, r24

00000ad2 <.strcasecmp_P_loop>:
 ad2:	8d 91       	ld	r24, X+
 ad4:	05 90       	lpm	r0, Z+
 ad6:	60 2d       	mov	r22, r0
 ad8:	50 2d       	mov	r21, r0
 ada:	50 62       	ori	r21, 0x20	; 32
 adc:	51 36       	cpi	r21, 0x61	; 97
 ade:	24 f0       	brlt	.+8      	; 0xae8
 ae0:	5b 37       	cpi	r21, 0x7B	; 123
 ae2:	14 f4       	brge	.+4      	; 0xae8
 ae4:	60 62       	ori	r22, 0x20	; 32
 ae6:	80 62       	ori	r24, 0x20	; 32

00000ae8 <.strcasecmp_P_tst>:
 ae8:	86 1b       	sub	r24, r22
 aea:	11 f4       	brne	.+4      	; 0xaf0
 aec:	00 20       	and	r0, r0
 aee:	89 f7       	brne	.-30     	; 0xad2

00000af0 <.strcasecmp_P_done>:
 af0:	99 0b       	sbc	r25, r25
 af2:	08 95       	ret

00000af4 <strrev>:
 af4:	dc 01       	movw	r26, r24
 af6:	fc 01       	movw	r30, r24

00000af8 <.strrev_eos>:
 af8:	01 90       	ld	r0, Z+
 afa:	00 20       	and	r0, r0
 afc:	e9 f7       	brne	.-6      	; 0xaf8
 afe:	32 97       	sbiw	r30, 0x02	; 2

00000b00 <.strrev_loop>:
 b00:	ae 17       	cp	r26, r30
 b02:	bf 07       	cpc	r27, r31
 b04:	30 f4       	brcc	.+12     	; 0xb12
 b06:	7c 91       	ld	r23, X
 b08:	60 81       	ld	r22, Z
 b0a:	70 83       	st	Z, r23
 b0c:	31 97       	sbiw	r30, 0x01	; 1
 b0e:	6d 93       	st	X+, r22
 b10:	f7 cf       	rjmp	.-18     	; 0xb00

00000b12 <.strrev_done>:
 b12:	08 95       	ret

00000b14 <__udivmodhi4>:
 b14:	aa 1b       	sub	r26, r26
 b16:	bb 1b       	sub	r27, r27
 b18:	51 e1       	ldi	r21, 0x11	; 17
 b1a:	07 c0       	rjmp	.+14     	; 0xb2a

00000b1c <__udivmodhi4_loop>:
 b1c:	aa 1f       	adc	r26, r26
 b1e:	bb 1f       	adc	r27, r27
 b20:	a6 17       	cp	r26, r22
 b22:	b7 07       	cpc	r27, r23
 b24:	10 f0       	brcs	.+4      	; 0xb2a
 b26:	a6 1b       	sub	r26, r22
 b28:	b7 0b       	sbc	r27, r23

00000b2a <__udivmodhi4_ep>:
 b2a:	88 1f       	adc	r24, r24
 b2c:	99 1f       	adc	r25, r25
 b2e:	5a 95       	dec	r21
 b30:	a9 f7       	brne	.-22     	; 0xb1c
 b32:	80 95       	com	r24
 b34:	90 95       	com	r25
 b36:	bc 01       	movw	r22, r24
 b38:	cd 01       	movw	r24, r26
 b3a:	08 95       	ret
