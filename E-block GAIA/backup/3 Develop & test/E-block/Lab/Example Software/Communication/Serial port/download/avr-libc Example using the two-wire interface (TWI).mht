From: <Saved by Microsoft Internet Explorer 5>
Subject: avr-libc: Example using the two-wire interface (TWI)
Date: Tue, 21 Feb 2006 10:07:05 +0700
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01C636CE.916F9650"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.2180

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01C636CE.916F9650
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-1.2.5/group__twi__demo.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>avr-libc: Example using the two-wire interface =
(TWI)</TITLE>
<META http-equiv=3DContent-Type =
content=3Dtext/html;charset=3Diso-8859-1><LINK=20
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/dox.css"=20
type=3Dtext/css rel=3Dstylesheet>
<META content=3D"MSHTML 6.00.2900.2180" name=3DGENERATOR></HEAD>
<BODY><!-- Generated by Doxygen 1.4.1 -->
<H1>Example using the two-wire interface (TWI)<BR><SMALL>[<A class=3Del=20
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__demos.html">Demo=20
projects</A>]</SMALL> </H1>Some newer devices of the ATmega series =
contain=20
builtin support for interfacing the microcontroller to a two-wire bus, =
called=20
TWI. This is essentially the same called I2C by Philips, but that term =
is=20
avoided in Atmel's documentation due to patenting issues.
<P>For the original Philips documentation, see
<P><A=20
href=3D"http://www.semiconductors.philips.com/buses/i2c/index.html">http:=
//www.semiconductors.philips.com/buses/i2c/index.html</A>
<H2><A class=3Danchor name=3Dtwi_demo_intro>Introduction into =
TWI</A></H2>The=20
two-wire interface consists of two signal lines named <EM>SDA</EM> =
(serial data)=20
and <EM>SCL</EM> (serial clock) (plus a ground line, of course). All =
devices=20
participating in the bus are connected together, using open-drain driver =

circuitry, so the wires must be terminated using appropriate pullup =
resistors.=20
The pullups must be small enough to recharge the line capacity in short =
enough=20
time compared to the desired maximal clock frequency, yet large enough =
so all=20
drivers will not be overloaded. There are formulas in the datasheet that =
help=20
selecting the pullups.
<P>Devices can either act as a master to the bus (i. e., they initiate a =

transfer), or as a slave (they only act when being called by a master). =
The bus=20
is multi-master capable, and a particular device implementation can act =
as=20
either master or slave at different times. Devices are addressed using a =
7-bit=20
address (coordinated by Philips) transfered as the first byte after the=20
so-called start condition. The LSB of that byte is R/~W, i. e. it =
determines=20
whether the request to the slave is to read or write data during the =
next=20
cycles. (There is also an option to have devices using 10-bit addresses =
but that=20
is not covered by this example.)
<H2><A class=3Danchor name=3Dtwi_demo_project>The TWI example =
project</A></H2>The=20
ATmega TWI hardware supports both, master and slave operation. This =
example will=20
only demonstrate how to use an AVR microcontroller as TWI master. The=20
implementation is kept simple in order to concentrate on the steps that =
are=20
required to talk to a TWI slave, so all processing is done in =
polled-mode,=20
waiting for the TWI interface to indicate that the next processing step =
is due=20
(by setting the TWINT interrupt bit). If it is desired to have the =
entire TWI=20
communication happen in "background", all this can be implemented in an=20
interrupt-controlled way, where only the start condition needs to be =
triggered=20
from outside the interrupt routine.
<P>There is a variety of slave devices available that can be connected =
to a TWI=20
bus. For the purpose of this example, an EEPROM device out of the=20
industry-standard <B>24C<EM>xx</EM></B> series has been chosen (where=20
<EM>xx</EM> can be one of <B>01</B>, <B>02</B>, <B>04</B>, <B>08</B>, or =

<B>16</B>) which are available from various vendors. The choice was =
almost=20
arbitrary, mainly triggered by the fact that an EEPROM device is being =
talked to=20
in both directions, reading and writing the slave device, so the example =
will=20
demonstrate the details of both.
<P>Usually, there is probably not much need to add more EEPROM to an =
ATmega=20
system that way: the smallest possible AVR device that offers hardware =
TWI=20
support is the ATmega8 which comes with 512 bytes of EEPROM, which is =
equivalent=20
to an 24C04 device. The ATmega128 already comes with twice as much =
EEPROM as the=20
24C16 would offer. One exception might be to use an externally connected =
EEPROM=20
device that is removable; e. g. SDRAM PC memory comes with an integrated =
TWI=20
EEPROM that carries the RAM configuration information.
<H2><A class=3Danchor name=3Dtwi_demo_src>The Source Code</A></H2>
<DIV class=3Dfragment><PRE class=3Dfragment><SPAN =
class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * =
-------------------------------------------------------------------------=
---</SPAN>
<SPAN class=3Dcomment> * "THE BEER-WARE LICENSE" (Revision 42):</SPAN>
<SPAN class=3Dcomment> * &lt;joerg@FreeBSD.ORG&gt; wrote this file.  As =
long as you retain this notice you</SPAN>
<SPAN class=3Dcomment> * can do whatever you want with this stuff. If we =
meet some day, and you think</SPAN>
<SPAN class=3Dcomment> * this stuff is worth it, you can buy me a beer =
in return.        Joerg Wunsch</SPAN>
<SPAN class=3Dcomment> * =
-------------------------------------------------------------------------=
---</SPAN>
<SPAN class=3Dcomment> */</SPAN>

<SPAN class=3Dcomment>/* $Id: twitest.c,v 1.2.2.2 2005/02/07 22:47:46 =
arcanum Exp $ */</SPAN>

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Simple demo program that talks to a 24Cxx I=B2C =
EEPROM using the</SPAN>
<SPAN class=3Dcomment> * builtin TWI interface of an ATmega =
device.</SPAN>
<SPAN class=3Dcomment> */</SPAN>

<SPAN class=3Dpreprocessor>#include &lt;inttypes.h&gt;</SPAN>
<SPAN class=3Dpreprocessor>#include &lt;stdio.h&gt;</SPAN>
<SPAN class=3Dpreprocessor>#include &lt;stdlib.h&gt;</SPAN>

<SPAN class=3Dpreprocessor>#include &lt;avr/io.h&gt;</SPAN>
<SPAN class=3Dpreprocessor>#include &lt;compat/twi.h&gt;</SPAN>         =
<SPAN class=3Dcomment>/* Note [1] */</SPAN>

<SPAN class=3Dpreprocessor>#define DEBUG 1</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * System clock in Hz.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dpreprocessor>#define F_CPU 14745600UL        </SPAN><SPAN =
class=3Dcomment>/* Note [2] */</SPAN>

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Compatibility defines.  This should work on =
ATmega8, ATmega16,</SPAN>
<SPAN class=3Dcomment> * ATmega163, ATmega323 and ATmega128 (IOW: on all =
devices that</SPAN>
<SPAN class=3Dcomment> * provide a builtin TWI interface).</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * On the 128, it defaults to USART 1.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dpreprocessor>#ifndef UCSRB</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor># ifdef =
UCSR1A          </SPAN><SPAN class=3Dcomment>/* ATmega128 */</SPAN>
<SPAN class=3Dpreprocessor>#  define UCSRA UCSR1A</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
UCSRB UCSR1B</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
UBRR UBRR1L</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
UDR UDR1</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor># else =
</SPAN><SPAN class=3Dcomment>/* ATmega8 */</SPAN>
<SPAN class=3Dpreprocessor>#  define UCSRA USR</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
UCSRB UCR</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor># =
endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN =
class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#ifndef =
UBRR</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
UBRR UBRRL</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN =
class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Note [3]</SPAN>
<SPAN class=3Dcomment> * TWI address for 24Cxx EEPROM:</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * 1 0 1 0 E2 E1 E0 R/~W        24C01/24C02</SPAN>
<SPAN class=3Dcomment> * 1 0 1 0 E2 E1 A8 R/~W        24C04</SPAN>
<SPAN class=3Dcomment> * 1 0 1 0 E2 A9 A8 R/~W        24C08</SPAN>
<SPAN class=3Dcomment> * 1 0 1 0 A10 A9 A8 R/~W       24C16</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dpreprocessor>#define TWI_SLA_24CXX   0xa0    </SPAN><SPAN =
class=3Dcomment>/* E2 E1 E0 =3D 0 0 0 */</SPAN>

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Maximal number of iterations to wait for a =
device to respond for a</SPAN>
<SPAN class=3Dcomment> * selection.  Should be large enough to allow for =
a pending write to</SPAN>
<SPAN class=3Dcomment> * complete, but low enough to properly abort an =
infinite loop in case</SPAN>
<SPAN class=3Dcomment> * a slave is broken or not present at all.  With =
100 kHz TWI clock,</SPAN>
<SPAN class=3Dcomment> * transfering the start condition and SLA+R/W =
packet takes about 10</SPAN>
<SPAN class=3Dcomment> * =B5s.  The longest write period is supposed to =
not exceed ~ 10 ms.</SPAN>
<SPAN class=3Dcomment> * Thus, normal operation should not require more =
than 100 iterations</SPAN>
<SPAN class=3Dcomment> * to get the device to respond to a =
selection.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dpreprocessor>#define MAX_ITER        200</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Number of bytes that can be written in a row, =
see comments for</SPAN>
<SPAN class=3Dcomment> * ee24xx_write_page() below.  Some vendor's =
devices would accept 16,</SPAN>
<SPAN class=3Dcomment> * but 8 seems to be the lowest common =
denominator.</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * Note that the page size must be a power of two, =
this simplifies the</SPAN>
<SPAN class=3Dcomment> * page boundary calculations below.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dpreprocessor>#define PAGE_SIZE 8</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Saved TWI status register, for error messages =
only.  We need to</SPAN>
<SPAN class=3Dcomment> * save it in a variable, since the datasheet only =
guarantees the TWSR</SPAN>
<SPAN class=3Dcomment> * register to have valid contents while the TWINT =
bit in TWCR is set.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga1">uint8_t</A> twst;

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Do all the startup-time peripheral =
initializations: UART (for our</SPAN>
<SPAN class=3Dcomment> * debug/test output), and TWI clock.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dkeywordtype>void</SPAN>
ioinit(<SPAN class=3Dkeywordtype>void</SPAN>)
{

<SPAN class=3Dpreprocessor>#if F_CPU &lt;=3D 1000000UL</SPAN>
<SPAN class=3Dpreprocessor></SPAN>  <SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment>   * Note [4]</SPAN>
<SPAN class=3Dcomment>   * Slow system clock, double Baud rate to =
improve rate error.</SPAN>
<SPAN class=3Dcomment>   */</SPAN>
  UCSRA =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(U2X);
  UBRR =3D (F_CPU / (8 * 9600UL)) - 1; <SPAN class=3Dcomment>/* 9600 Bd =
*/</SPAN>
<SPAN class=3Dpreprocessor>#else</SPAN>
<SPAN class=3Dpreprocessor></SPAN>  UBRR =3D (F_CPU / (16 * 9600UL)) - =
1; <SPAN class=3Dcomment>/* 9600 Bd */</SPAN>
<SPAN class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>  UCSRB =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TXEN);            <SPAN =
class=3Dcomment>/* tx enable */</SPAN>

  <SPAN class=3Dcomment>/* initialize TWI clock: 100 kHz clock, TWPS =3D =
0 =3D&gt; prescaler =3D 1 */</SPAN>
<SPAN class=3Dpreprocessor>#if defined(TWPS0)</SPAN>
<SPAN class=3Dpreprocessor></SPAN>  <SPAN class=3Dcomment>/* has =
prescaler (mega128 &amp; newer) */</SPAN>
  TWSR =3D 0;
<SPAN class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
<SPAN class=3Dpreprocessor>#if F_CPU &lt; 3600000UL</SPAN>
<SPAN class=3Dpreprocessor></SPAN>  TWBR =3D 10;                    =
<SPAN class=3Dcomment>/* smallest TWBR value, see note [5] */</SPAN>
<SPAN class=3Dpreprocessor>#else</SPAN>
<SPAN class=3Dpreprocessor></SPAN>  TWBR =3D (F_CPU / 100000UL - 16) / =
2;
<SPAN class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>}

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Note [6]</SPAN>
<SPAN class=3Dcomment> * Send character c down the UART Tx, wait until =
tx holding register</SPAN>
<SPAN class=3Dcomment> * is empty.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dkeywordtype>int</SPAN>
uart_putchar(<SPAN class=3Dkeywordtype>char</SPAN> c)
{

  <SPAN class=3Dkeywordflow>if</SPAN> (c =3D=3D <SPAN =
class=3Dcharliteral>'\n'</SPAN>)
    uart_putchar('\r');
  loop_until_bit_is_set(UCSRA, UDRE);
  UDR =3D c;
  return 0;
}

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Note [7]</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * Read "len" bytes from EEPROM starting at =
"eeaddr" into "buf".</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * This requires two bus cycles: during the first =
cycle, the device</SPAN>
<SPAN class=3Dcomment> * will be selected (master transmitter mode), and =
the address</SPAN>
<SPAN class=3Dcomment> * transfered.  Address bits exceeding 256 are =
transfered in the</SPAN>
<SPAN class=3Dcomment> * E2/E1/E0 bits (subaddress bits) of the device =
selector.</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * The second bus cycle will reselect the device =
(repeated start</SPAN>
<SPAN class=3Dcomment> * condition, going into master receiver mode), =
and transfer the data</SPAN>
<SPAN class=3Dcomment> * from the device to the TWI master.  Multiple =
bytes can be</SPAN>
<SPAN class=3Dcomment> * transfered by ACKing the client's transfer.  =
The last transfer will</SPAN>
<SPAN class=3Dcomment> * be NACKed, which the client will take as an =
indication to not</SPAN>
<SPAN class=3Dcomment> * initiate further transfers.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dkeywordtype>int</SPAN>
ee24xx_read_bytes(uint16_t eeaddr, <SPAN class=3Dkeywordtype>int</SPAN> =
len, uint8_t *buf)
{
  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga1">uint8_t</A> sla, twcr, n =3D 0;
  <SPAN class=3Dkeywordtype>int</SPAN> rv =3D 0;

  <SPAN class=3Dcomment>/* patch high bits of EEPROM address into SLA =
*/</SPAN>
  sla =3D TWI_SLA_24CXX | (((eeaddr &gt;&gt; 8) &amp; 0x07) &lt;&lt; 1);

  <SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment>   * Note [8]</SPAN>
<SPAN class=3Dcomment>   * First cycle: master transmitter mode</SPAN>
<SPAN class=3Dcomment>   */</SPAN>
  restart:
  <SPAN class=3Dkeywordflow>if</SPAN> (n++ &gt;=3D MAX_ITER)
    return -1;
  begin:

  TWCR =3D _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); <SPAN class=3Dcomment>/* =
send start condition */</SPAN>
  while ((TWCR &amp; _BV(TWINT)) =3D=3D 0) ; <SPAN class=3Dcomment>/* =
wait for transmission */</SPAN>
  switch ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_REP_START:          <SPAN =
class=3Dcomment>/* OK, but should not happen */</SPAN>
    <SPAN class=3Dkeywordflow>case</SPAN> TW_START:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_ARB_LOST:        <SPAN =
class=3Dcomment>/* Note [9] */</SPAN>
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>return</SPAN> -1;                <SPAN =
class=3Dcomment>/* error: not in start condition */</SPAN>
                                <SPAN class=3Dcomment>/* NB: do /not/ =
send stop condition */</SPAN>
    }

  <SPAN class=3Dcomment>/* Note [10] */</SPAN>
  <SPAN class=3Dcomment>/* send SLA+W */</SPAN>
  TWDR =3D sla | TW_WRITE;
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
clear interrupt to start transmission */</SPAN>
  <SPAN class=3Dkeywordflow>while</SPAN> ((TWCR &amp; <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
  <SPAN class=3Dkeywordflow>switch</SPAN> ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_SLA_ACK:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_SLA_NACK:        <SPAN =
class=3Dcomment>/* nack during select: device busy writing */</SPAN>
                                <SPAN class=3Dcomment>/* Note [11] =
*/</SPAN>
      <SPAN class=3Dkeywordflow>goto</SPAN> restart;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_ARB_LOST:        <SPAN =
class=3Dcomment>/* re-arbitrate */</SPAN>
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>goto</SPAN> error;               <SPAN =
class=3Dcomment>/* must send stop condition */</SPAN>
    }

  TWDR =3D eeaddr;                <SPAN class=3Dcomment>/* low 8 bits of =
addr */</SPAN>
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
clear interrupt to start transmission */</SPAN>
  <SPAN class=3Dkeywordflow>while</SPAN> ((TWCR &amp; <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
  <SPAN class=3Dkeywordflow>switch</SPAN> ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_DATA_ACK:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_DATA_NACK:
      <SPAN class=3Dkeywordflow>goto</SPAN> quit;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_ARB_LOST:
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>goto</SPAN> error;               <SPAN =
class=3Dcomment>/* must send stop condition */</SPAN>
    }

  <SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment>   * Note [12]</SPAN>
<SPAN class=3Dcomment>   * Next cycle(s): master receiver mode</SPAN>
<SPAN class=3Dcomment>   */</SPAN>
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWSTA) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
send (rep.) start condition */</SPAN>
  <SPAN class=3Dkeywordflow>while</SPAN> ((TWCR &amp; <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
  <SPAN class=3Dkeywordflow>switch</SPAN> ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_START:              <SPAN =
class=3Dcomment>/* OK, but should not happen */</SPAN>
    <SPAN class=3Dkeywordflow>case</SPAN> TW_REP_START:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_ARB_LOST:
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>goto</SPAN> error;
    }

  <SPAN class=3Dcomment>/* send SLA+R */</SPAN>
  TWDR =3D sla | TW_READ;
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
clear interrupt to start transmission */</SPAN>
  <SPAN class=3Dkeywordflow>while</SPAN> ((TWCR &amp; <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
  <SPAN class=3Dkeywordflow>switch</SPAN> ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_MR_SLA_ACK:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MR_SLA_NACK:
      <SPAN class=3Dkeywordflow>goto</SPAN> quit;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MR_ARB_LOST:
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>goto</SPAN> error;
    }

  <SPAN class=3Dkeywordflow>for</SPAN> (twcr =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEA) <SPAN class=3Dcomment>/* =
Note [13] */</SPAN>;
       len &gt; 0;
       len--)
    {
      <SPAN class=3Dkeywordflow>if</SPAN> (len =3D=3D 1)
        twcr =3D _BV(TWINT) | _BV(TWEN); <SPAN class=3Dcomment>/* send =
NAK this time */</SPAN>
      TWCR =3D twcr;              <SPAN class=3Dcomment>/* clear int to =
start transmission */</SPAN>
      while ((TWCR &amp; _BV(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
      switch ((twst =3D TW_STATUS))
        {
        <SPAN class=3Dkeywordflow>case</SPAN> TW_MR_DATA_NACK:
          len =3D 0;              <SPAN class=3Dcomment>/* force end of =
loop */</SPAN>
          <SPAN class=3Dcomment>/* FALLTHROUGH */</SPAN>
        <SPAN class=3Dkeywordflow>case</SPAN> TW_MR_DATA_ACK:
          *buf++ =3D TWDR;
          rv++;
          <SPAN class=3Dkeywordflow>break</SPAN>;

        <SPAN class=3Dkeywordflow>default</SPAN>:
          <SPAN class=3Dkeywordflow>goto</SPAN> error;
        }
    }
  quit:
  <SPAN class=3Dcomment>/* Note [14] */</SPAN>
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWSTO) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
send stop condition */</SPAN>

  <SPAN class=3Dkeywordflow>return</SPAN> rv;

  error:
  rv =3D -1;
  <SPAN class=3Dkeywordflow>goto</SPAN> quit;
}

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Write "len" bytes into EEPROM starting at =
"eeaddr" from "buf".</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * This is a bit simpler than the previous =
function since both, the</SPAN>
<SPAN class=3Dcomment> * address and the data bytes will be transfered =
in master transmitter</SPAN>
<SPAN class=3Dcomment> * mode, thus no reselection of the device is =
necessary.  However, the</SPAN>
<SPAN class=3Dcomment> * EEPROMs are only capable of writing one "page" =
simultaneously, so</SPAN>
<SPAN class=3Dcomment> * care must be taken to not cross a page boundary =
within one write</SPAN>
<SPAN class=3Dcomment> * cycle.  The amount of data one page consists of =
varies from</SPAN>
<SPAN class=3Dcomment> * manufacturer to manufacturer: some vendors only =
use 8-byte pages</SPAN>
<SPAN class=3Dcomment> * for the smaller devices, and 16-byte pages for =
the larger devices,</SPAN>
<SPAN class=3Dcomment> * while other vendors generally use 16-byte =
pages.  We thus use the</SPAN>
<SPAN class=3Dcomment> * smallest common denominator of 8 bytes per =
page, declared by the</SPAN>
<SPAN class=3Dcomment> * macro PAGE_SIZE above.</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * The function simply returns after writing one =
page, returning the</SPAN>
<SPAN class=3Dcomment> * actual number of data byte written.  It is up =
to the caller to</SPAN>
<SPAN class=3Dcomment> * re-invoke it in order to write further =
data.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dkeywordtype>int</SPAN>
ee24xx_write_page(uint16_t eeaddr, <SPAN class=3Dkeywordtype>int</SPAN> =
len, uint8_t *buf)
{
  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga1">uint8_t</A> sla, n =3D 0;
  <SPAN class=3Dkeywordtype>int</SPAN> rv =3D 0;
  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga3">uint16_t</A> endaddr;

  <SPAN class=3Dkeywordflow>if</SPAN> (eeaddr + len &lt; (eeaddr | =
(PAGE_SIZE - 1)))
    endaddr =3D eeaddr + len;
  else
    endaddr =3D (eeaddr | (PAGE_SIZE - 1)) + 1;
  len =3D endaddr - eeaddr;

  <SPAN class=3Dcomment>/* patch high bits of EEPROM address into SLA =
*/</SPAN>
  sla =3D TWI_SLA_24CXX | (((eeaddr &gt;&gt; 8) &amp; 0x07) &lt;&lt; 1);

  restart:
  if (n++ &gt;=3D MAX_ITER)
    return -1;
  begin:

  <SPAN class=3Dcomment>/* Note [15] */</SPAN>
  TWCR =3D _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); <SPAN class=3Dcomment>/* =
send start condition */</SPAN>
  while ((TWCR &amp; _BV(TWINT)) =3D=3D 0) ; <SPAN class=3Dcomment>/* =
wait for transmission */</SPAN>
  switch ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_REP_START:          <SPAN =
class=3Dcomment>/* OK, but should not happen */</SPAN>
    <SPAN class=3Dkeywordflow>case</SPAN> TW_START:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_ARB_LOST:
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>return</SPAN> -1;                <SPAN =
class=3Dcomment>/* error: not in start condition */</SPAN>
                                <SPAN class=3Dcomment>/* NB: do /not/ =
send stop condition */</SPAN>
    }

  <SPAN class=3Dcomment>/* send SLA+W */</SPAN>
  TWDR =3D sla | TW_WRITE;
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
clear interrupt to start transmission */</SPAN>
  <SPAN class=3Dkeywordflow>while</SPAN> ((TWCR &amp; <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
  <SPAN class=3Dkeywordflow>switch</SPAN> ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_SLA_ACK:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_SLA_NACK:        <SPAN =
class=3Dcomment>/* nack during select: device busy writing */</SPAN>
      <SPAN class=3Dkeywordflow>goto</SPAN> restart;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_ARB_LOST:        <SPAN =
class=3Dcomment>/* re-arbitrate */</SPAN>
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>goto</SPAN> error;               <SPAN =
class=3Dcomment>/* must send stop condition */</SPAN>
    }

  TWDR =3D eeaddr;                <SPAN class=3Dcomment>/* low 8 bits of =
addr */</SPAN>
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
clear interrupt to start transmission */</SPAN>
  <SPAN class=3Dkeywordflow>while</SPAN> ((TWCR &amp; <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
  <SPAN class=3Dkeywordflow>switch</SPAN> ((twst =3D TW_STATUS))
    {
    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_DATA_ACK:
      <SPAN class=3Dkeywordflow>break</SPAN>;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_DATA_NACK:
      <SPAN class=3Dkeywordflow>goto</SPAN> quit;

    <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_ARB_LOST:
      <SPAN class=3Dkeywordflow>goto</SPAN> begin;

    <SPAN class=3Dkeywordflow>default</SPAN>:
      <SPAN class=3Dkeywordflow>goto</SPAN> error;               <SPAN =
class=3Dcomment>/* must send stop condition */</SPAN>
    }

  <SPAN class=3Dkeywordflow>for</SPAN> (; len &gt; 0; len--)
    {
      TWDR =3D *buf++;
      TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
start transmission */</SPAN>
      <SPAN class=3Dkeywordflow>while</SPAN> ((TWCR &amp; <A =
class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT)) =3D=3D 0) ; <SPAN =
class=3Dcomment>/* wait for transmission */</SPAN>
      <SPAN class=3Dkeywordflow>switch</SPAN> ((twst =3D TW_STATUS))
        {
        <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_DATA_NACK:
          <SPAN class=3Dkeywordflow>goto</SPAN> error;           <SPAN =
class=3Dcomment>/* device write protected -- Note [16] */</SPAN>

        <SPAN class=3Dkeywordflow>case</SPAN> TW_MT_DATA_ACK:
          rv++;
          <SPAN class=3Dkeywordflow>break</SPAN>;

        <SPAN class=3Dkeywordflow>default</SPAN>:
          <SPAN class=3Dkeywordflow>goto</SPAN> error;
        }
    }
  quit:
  TWCR =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWINT) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWSTO) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A>(TWEN); <SPAN class=3Dcomment>/* =
send stop condition */</SPAN>

  <SPAN class=3Dkeywordflow>return</SPAN> rv;

  error:
  rv =3D -1;
  <SPAN class=3Dkeywordflow>goto</SPAN> quit;
}

<SPAN class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * Wrapper around ee24xx_write_page() that repeats =
calling this</SPAN>
<SPAN class=3Dcomment> * function until either an error has been =
returned, or all bytes</SPAN>
<SPAN class=3Dcomment> * have been written.</SPAN>
<SPAN class=3Dcomment> */</SPAN>
<SPAN class=3Dkeywordtype>int</SPAN>
ee24xx_write_bytes(uint16_t eeaddr, <SPAN class=3Dkeywordtype>int</SPAN> =
len, uint8_t *buf)
{
  <SPAN class=3Dkeywordtype>int</SPAN> rv, total;

  total =3D 0;
  <SPAN class=3Dkeywordflow>do</SPAN>
    {
<SPAN class=3Dpreprocessor>#if DEBUG</SPAN>
<SPAN class=3Dpreprocessor></SPAN>      <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdio.html#ga4">printf</A>(<SPAN =
class=3Dstringliteral>"Calling ee24xx_write_page(%d, %d, %p)"</SPAN>,
             eeaddr, len, buf);
<SPAN class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>      rv =3D ee24xx_write_page(eeaddr, =
len, buf);
<SPAN class=3Dpreprocessor>#if DEBUG</SPAN>
<SPAN class=3Dpreprocessor></SPAN>      <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdio.html#ga4">printf</A>(<SPAN =
class=3Dstringliteral>" =3D&gt; %d\n"</SPAN>, rv);
<SPAN class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>      <SPAN =
class=3Dkeywordflow>if</SPAN> (rv =3D=3D -1)
        return -1;
      eeaddr +=3D rv;
      len -=3D rv;
      buf +=3D rv;
      total +=3D rv;
    }
  while (len &gt; 0);

  return total;
}

<SPAN class=3Dkeywordtype>void</SPAN>
error(<SPAN class=3Dkeywordtype>void</SPAN>)
{

  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdio.html#ga4">printf</A>(<SPAN =
class=3Dstringliteral>"error: TWI status %#x\n"</SPAN>, twst);
  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdlib.html#ga15">exit</A>(0);
}

<SPAN class=3Dkeywordtype>void</SPAN>
main(<SPAN class=3Dkeywordtype>void</SPAN>)
{
  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga3">uint16_t</A> a;
  <SPAN class=3Dkeywordtype>int</SPAN> rv;
  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga1">uint8_t</A> b[16];
  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga1">uint8_t</A> x;

  ioinit();

  <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdio.html#ga37">fdevopen</A>(uart_putchar, NULL, 0);

  <SPAN class=3Dkeywordflow>for</SPAN> (a =3D 0; a &lt; 256;)
    {
      <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdio.html#ga4">printf</A>(<SPAN =
class=3Dstringliteral>"%#04x: "</SPAN>, a);
      rv =3D ee24xx_read_bytes(a, 16, b);
      <SPAN class=3Dkeywordflow>if</SPAN> (rv &lt;=3D 0)
        error();
      if (rv &lt; 16)
        printf("warning: <SPAN class=3Dkeywordtype>short</SPAN> read =
%d\n", rv);
      a +=3D rv;
      for (x =3D 0; x &lt; rv; x++)
        printf("%02x ", b[x]);
      putchar('\n');
    }
#define EE_WRITE(addr, str) ee24xx_write_bytes(addr, sizeof(str)-1, str)
  rv =3D EE_WRITE(55, "The quick brown fox jumps over the lazy dog.");
  if (rv &lt; 0)
    error();
  printf("Wrote %d bytes.\n", rv);
  for (a =3D 0; a &lt; 256;)
    {
      <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdio.html#ga4">printf</A>(<SPAN =
class=3Dstringliteral>"%#04x: "</SPAN>, a);
      rv =3D ee24xx_read_bytes(a, 16, b);
      <SPAN class=3Dkeywordflow>if</SPAN> (rv &lt;=3D 0)
        error();
      if (rv &lt; 16)
        printf("warning: <SPAN class=3Dkeywordtype>short</SPAN> read =
%d\n", rv);
      a +=3D rv;
      for (x =3D 0; x &lt; rv; x++)
        printf("%02x ", b[x]);
      putchar('\n');
    }

  printf("done.\n");

}
</PRE></DIV>
<P>
<DL compact>
  <DT><B>Note [1]</B>
  <DD></DD></DL>The header file <CODE>&lt;compat/twi.h&gt;</CODE> =
contains some=20
macro definitions for symbolic constants used in the TWI status =
register. These=20
definitions match the names used in the Atmel datasheet except that all =
names=20
have been prefixed with <CODE>TW_</CODE>.
<P>
<DL compact>
  <DT><B>Note [2]</B>
  <DD></DD></DL>The clock is used in timer calculations done by the =
compiler, for=20
the UART baud rate and the TWI clock rate.
<P>
<DL compact>
  <DT><B>Note [3]</B>
  <DD></DD></DL>The address assigned for the 24Cxx EEPROM consists of =
1010 in the=20
upper four bits. The following three bits are normally available as =
slave=20
sub-addresses, allowing to operate more than one device of the same type =
on a=20
single bus, where the actual subaddress used for each device is =
configured by=20
hardware strapping. However, since the next data packet following the =
device=20
selection only allows for 8 bits that are used as an EEPROM address, =
devices=20
that require more than 8 address bits (24C04 and above) "steal" =
subaddress bits=20
and use them for the EEPROM cell address bits 9 to 11 as required. This =
example=20
simply assumes all subaddress bits are 0 for the smaller devices, so the =
E0, E1,=20
and E2 inputs of the 24Cxx must be grounded.
<P>
<DL compact>
  <DT><B>Note [4]</B>
  <DD></DD></DL>For slow clocks, enable the 2 x U[S]ART clock =
multiplier, to=20
improve the baud rate error. This will allow a 9600 Bd communication =
using the=20
standard 1 MHz calibrated RC oscillator. See also the Baud rate tables =
in the=20
datasheets.
<P>
<DL compact>
  <DT><B>Note [5]</B>
  <DD></DD></DL>The datasheet explains why a minimum TWBR value of 10 =
should be=20
maintained when running in master mode. Thus, for system clocks below =
3.6 MHz,=20
we cannot run the bus at the intented clock rate of 100 kHz but have to =
slow=20
down accordingly.
<P>
<DL compact>
  <DT><B>Note [6]</B>
  <DD></DD></DL>This function is used by the standard output facilities =
that are=20
utilized in this example for debugging and demonstration purposes.
<P>
<DL compact>
  <DT><B>Note [7]</B>
  <DD></DD></DL>In order to shorten the data to be sent over the TWI =
bus, the=20
24Cxx EEPROMs support multiple data bytes transfered within a single =
request,=20
maintaining an internal address counter that is updated after each data =
byte=20
transfered successfully. When reading data, one request can read the =
entire=20
device memory if desired (the counter would wrap around and start back =
from 0=20
when reaching the end of the device).
<P>
<DL compact>
  <DT><B>Note [8]</B>
  <DD></DD></DL>When reading the EEPROM, a first device selection must =
be made=20
with write intent (R/~W bit set to 0 indicating a write operation) in =
order to=20
transfer the EEPROM address to start reading from. This is called =
<EM>master=20
transmitter mode</EM>. Each completion of a particular step in TWI =
communication=20
is indicated by an asserted TWINT bit in TWCR. (An interrupt would be =
generated=20
if allowed.) After performing any actions that are needed for the next=20
communication step, the interrupt condition must be manually cleared by=20
<EM>setting</EM> the TWINT bit. Unlike with many other interrupt =
sources, this=20
would even be required when using a true interrupt routine, since as =
soon as=20
TWINT is re-asserted, the next bus transaction will start.
<P>
<DL compact>
  <DT><B>Note [9]</B>
  <DD></DD></DL>Since the TWI bus is multi-master capable, there is =
potential for=20
a bus contention when one master starts to access the bus. Normally, the =
TWI bus=20
interface unit will detect this situation, and will not initiate a start =

condition while the bus is busy. However, in case two masters were =
starting at=20
exactly the same time, the way bus arbitration works, there is always a =
chance=20
that one master could lose arbitration of the bus during any transmit =
operation.=20
A master that has lost arbitration is required by the protocol to =
immediately=20
cease talking on the bus; in particular it must not initiate a stop =
condition in=20
order to not corrupt the ongoing transfer from the active master. In =
this=20
example, upon detecting a lost arbitration condition, the entire =
transfer is=20
going to be restarted. This will cause a new start condition to be =
initiated,=20
which will normally be delayed until the currently active master has =
released=20
the bus.
<P>
<DL compact>
  <DT><B>Note [10]</B>
  <DD></DD></DL>Next, the device slave is going to be reselected (using =
a=20
so-called repeated start condition which is meant to guarantee that the =
bus=20
arbitration will remain at the current master) using the same slave =
address=20
(SLA), but this time with read intent (R/~W bit set to 1) in order to =
request=20
the device slave to start transfering data from the slave to the master =
in the=20
next packet.
<P>
<DL compact>
  <DT><B>Note [11]</B>
  <DD></DD></DL>If the EEPROM device is still busy writing one or more =
cells after=20
a previous write request, it will simply leave its bus interface drivers =
at high=20
impedance, and does not respond to a selection in any way at all. The =
master=20
selecting the device will see the high level at SDA after transfering =
the=20
SLA+R/W packet as a NACK to its selection request. Thus, the select =
process is=20
simply started over (effectively causing a <EM>repeated start =
condition</EM>),=20
until the device will eventually respond. This polling procedure is =
recommended=20
in the 24Cxx datasheet in order to minimize the busy wait time when =
writing.=20
Note that in case a device is broken and never responds to a selection =
(e. g.=20
since it is no longer present at all), this will cause an infinite loop. =
Thus=20
the maximal number of iterations made until the device is declared to be =
not=20
responding at all, and an error is returned, will be limited to =
MAX_ITER.
<P>
<DL compact>
  <DT><B>Note [12]</B>
  <DD></DD></DL>This is called <EM>master receiver mode</EM>: the bus =
master still=20
supplies the SCL clock, but the device slave drives the SDA line with =
the=20
appropriate data. After 8 data bits, the master responds with an ACK bit =
(SDA=20
driven low) in order to request another data transfer from the slave, or =
it can=20
leave the SDA line high (NACK), indicating to the slave that it is going =
to stop=20
the transfer now. Assertion of ACK is handled by setting the TWEA bit in =
TWCR=20
when starting the current transfer.
<P>
<DL compact>
  <DT><B>Note [13]</B>
  <DD></DD></DL>The control word sent out in order to initiate the =
transfer of the=20
next data packet is initially set up to assert the TWEA bit. During the =
last=20
loop iteration, TWEA is de-asserted so the client will get informed that =
no=20
further transfer is desired.
<P>
<DL compact>
  <DT><B>Note [14]</B>
  <DD></DD></DL>Except in the case of lost arbitration, all bus =
transactions must=20
properly be terminated by the master initiating a stop condition.
<P>
<DL compact>
  <DT><B>Note [15]</B>
  <DD></DD></DL>Writing to the EEPROM device is simpler than reading, =
since only a=20
master transmitter mode transfer is needed. Note that the first packet =
after the=20
SLA+W selection is always considered to be the EEPROM address for the =
next=20
operation. (This packet is exactly the same as the one above sent before =

starting to read the device.) In case a master transmitter mode transfer =
is=20
going to send more than one data packet, all following packets will be=20
considered data bytes to write at the indicated address. The internal =
address=20
pointer will be incremented after each write operation.
<P>
<DL compact>
  <DT><B>Note [16]</B>
  <DD></DD></DL>24Cxx devices can become write-protected by strapping =
their ~WC=20
pin to logic high. (Leaving it unconnected is explicitly allowed, and=20
constitutes logic low level, i. e. no write protection.) In case of a =
write=20
protected device, all data transfer attempts will be NACKed by the =
device. Note=20
that some devices might not implement this.=20
<P>
<TABLE cellSpacing=3D0 cellPadding=3D0 border=3D0>
  <TBODY>
  <TR>
    <TD></TD></TR></TBODY></TABLE>
<HR width=3D"80%">

<P>
<CENTER>Automatically generated by Doxygen 1.4.1 on 1 Aug 2005.</CENTER>
<P></P></BODY></HTML>

------=_NextPart_000_0000_01C636CE.916F9650
Content-Type: text/css;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-1.2.5/dox.css

BODY {
	BACKGROUND-COLOR: #dddddd
}
H1 {
	TEXT-ALIGN: center
}
A.qindex {
=09
}
A.qindexRef {
=09
}
A.el {
	FONT-WEIGHT: bold; TEXT-DECORATION: none
}
A.elRef {
	FONT-WEIGHT: bold
}
A.code {
	FONT-WEIGHT: normal; COLOR: #4444ee; TEXT-DECORATION: none
}
A.codeRef {
	FONT-WEIGHT: normal; COLOR: #4444ee
}
A:hover {
	BACKGROUND-COLOR: #bbbbbb; TEXT-DECORATION: none
}
DL.el {
	MARGIN-LEFT: -1cm
}
DIV.fragment {
	BORDER-RIGHT: black thin solid; BORDER-TOP: black thin solid; =
PADDING-LEFT: 5px; BORDER-LEFT: black thin solid; MARGIN-RIGHT: 5px; =
BORDER-BOTTOM: black thin solid; BACKGROUND-COLOR: #d0d0d0
}
DIV.ah {
	MARGIN-TOP: 3px; FONT-WEIGHT: bold; MARGIN-BOTTOM: 3px; COLOR: #ffffff; =
BACKGROUND-COLOR: black
}
TD.mdRow {
	FONT-WEIGHT: bold; BACKGROUND-COLOR: #ccccbb
}
TD.md {
	FONT-WEIGHT: bold; BACKGROUND-COLOR: #ccccbb
}
TD.mdname1 {
	FONT-WEIGHT: bold; COLOR: #702020; BACKGROUND-COLOR: #ccccbb
}
TD.mdname {
	FONT-WEIGHT: bold; WIDTH: 600px; COLOR: #702020; BACKGROUND-COLOR: =
#ccccbb
}
DIV.groupHeader {
	MARGIN-TOP: 12px; FONT-WEIGHT: bold; MARGIN-BOTTOM: 6px; MARGIN-LEFT: =
16px
}
DIV.groupText {
	FONT-SIZE: smaller; MARGIN-LEFT: 16px; FONT-STYLE: italic
}
FONT.keyword {
	COLOR: #008000
}
FONT.keywordtype {
	COLOR: #604020
}
FONT.keywordflow {
	COLOR: #e08000
}
FONT.comment {
	COLOR: #800000
}
FONT.preprocessor {
	COLOR: #806020
}
FONT.stringliteral {
	COLOR: #002080
}
FONT.charliteral {
	COLOR: #008080
}

------=_NextPart_000_0000_01C636CE.916F9650--
