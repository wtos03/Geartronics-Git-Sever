
backemf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f36  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00000f36  00000fca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000019c  00800090  00800090  00000ffa  2**0
                  ALLOC
  3 .noinit       00000000  0080022c  0080022c  00000ffa  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00000ffa  2**0
                  CONTENTS
  5 .stab         00002550  00000000  00000000  00000ffc  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000f4a  00000000  00000000  0000354c  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 42 00 	jmp	0x84
   4:	0c 94 5d 00 	jmp	0xba
   8:	0c 94 5d 00 	jmp	0xba
   c:	0c 94 5d 00 	jmp	0xba
  10:	0c 94 5d 00 	jmp	0xba
  14:	0c 94 5d 00 	jmp	0xba
  18:	0c 94 66 03 	jmp	0x6cc
  1c:	0c 94 80 02 	jmp	0x500
  20:	0c 94 ce 02 	jmp	0x59c
  24:	0c 94 5d 00 	jmp	0xba
  28:	0c 94 5d 00 	jmp	0xba
  2c:	0c 94 5d 00 	jmp	0xba
  30:	0c 94 5d 00 	jmp	0xba
  34:	0c 94 0c 03 	jmp	0x618
  38:	0c 94 3d 03 	jmp	0x67a
  3c:	0c 94 5d 00 	jmp	0xba
  40:	0c 94 5d 00 	jmp	0xba
  44:	0c 94 5d 00 	jmp	0xba
  48:	0c 94 5d 00 	jmp	0xba
  4c:	0c 94 5d 00 	jmp	0xba
  50:	0c 94 5d 00 	jmp	0xba

00000054 <__ctors_end>:
  54:	3d 22       	and	r3, r29
  56:	20 09       	sbc	r18, r0
  58:	2c 0d       	add	r18, r12
  5a:	0a 00       	.word	0x000a	; ????

0000005c <text_cmd>:
  5c:	6d 6f 74 6f 72 00 00 00 00 00 73 70 65 65 64 00     motor.....speed.
  6c:	00 00 00 00 61 6e 67 6c 65 00 00 00 00 00 00 00     ....angle.......
	...

00000084 <__init>:
  84:	11 24       	eor	r1, r1
  86:	1f be       	out	0x3f, r1	; 63
  88:	cf e5       	ldi	r28, 0x5F	; 95
  8a:	d8 e0       	ldi	r29, 0x08	; 8
  8c:	de bf       	out	0x3e, r29	; 62
  8e:	cd bf       	out	0x3d, r28	; 61

00000090 <__do_copy_data>:
  90:	10 e0       	ldi	r17, 0x00	; 0
  92:	a0 e6       	ldi	r26, 0x60	; 96
  94:	b0 e0       	ldi	r27, 0x00	; 0
  96:	e6 e3       	ldi	r30, 0x36	; 54
  98:	ff e0       	ldi	r31, 0x0F	; 15
  9a:	02 c0       	rjmp	.+4      	; 0xa0

0000009c <.do_copy_data_loop>:
  9c:	05 90       	lpm	r0, Z+
  9e:	0d 92       	st	X+, r0

000000a0 <.do_copy_data_start>:
  a0:	a0 39       	cpi	r26, 0x90	; 144
  a2:	b1 07       	cpc	r27, r17
  a4:	d9 f7       	brne	.-10     	; 0x9c

000000a6 <__do_clear_bss>:
  a6:	12 e0       	ldi	r17, 0x02	; 2
  a8:	a0 e9       	ldi	r26, 0x90	; 144
  aa:	b0 e0       	ldi	r27, 0x00	; 0
  ac:	01 c0       	rjmp	.+2      	; 0xb0

000000ae <.do_clear_bss_loop>:
  ae:	1d 92       	st	X+, r1

000000b0 <.do_clear_bss_start>:
  b0:	ac 32       	cpi	r26, 0x2C	; 44
  b2:	b1 07       	cpc	r27, r17
  b4:	e1 f7       	brne	.-8      	; 0xae
  b6:	0c 94 ba 03 	jmp	0x774

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0x0

000000be <delay>:

void delay ( uint16_t  time)
{
   uint16_t i;
   for (i = 0 ; i < time; i++);
  be:	00 97       	sbiw	r24, 0x00	; 0
  c0:	11 f0       	breq	.+4      	; 0xc6
  c2:	01 97       	sbiw	r24, 0x01	; 1
  c4:	fc cf       	rjmp	.-8      	; 0xbe
  c6:	08 95       	ret

000000c8 <set_motor_parameter>:

}

void  set_motor_parameter ( uint8_t mode)
{
   switch (mode)
  c8:	28 2f       	mov	r18, r24
  ca:	33 27       	eor	r19, r19
  cc:	22 30       	cpi	r18, 0x02	; 2
  ce:	31 05       	cpc	r19, r1
  d0:	b9 f0       	breq	.+46     	; 0x100
  d2:	23 30       	cpi	r18, 0x03	; 3
  d4:	31 05       	cpc	r19, r1
  d6:	3c f4       	brge	.+14     	; 0xe6
  d8:	21 15       	cp	r18, r1
  da:	31 05       	cpc	r19, r1
  dc:	a9 f0       	breq	.+42     	; 0x108
  de:	21 30       	cpi	r18, 0x01	; 1
  e0:	31 05       	cpc	r19, r1
  e2:	41 f0       	breq	.+16     	; 0xf4
  e4:	34 c0       	rjmp	.+104    	; 0x14e
  e6:	24 30       	cpi	r18, 0x04	; 4
  e8:	31 05       	cpc	r19, r1
  ea:	d9 f0       	breq	.+54     	; 0x122
  ec:	25 30       	cpi	r18, 0x05	; 5
  ee:	31 05       	cpc	r19, r1
  f0:	49 f1       	breq	.+82     	; 0x144
  f2:	2d c0       	rjmp	.+90     	; 0x14e
   {
    case  MOTOR_FORWARD:
        g_mode[0] = MOTOR_FORWARD;		
  f4:	81 e0       	ldi	r24, 0x01	; 1
  f6:	80 93 95 00 	sts	0x0095, r24
		g_mode[1] = MOTOR_FORWARD;
  fa:	80 93 96 00 	sts	0x0096, r24
  fe:	08 c0       	rjmp	.+16     	; 0x110
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case  MOTOR_BACKWARD:
		g_mode[0] = MOTOR_BACKWARD;
 100:	82 e0       	ldi	r24, 0x02	; 2
 102:	80 93 95 00 	sts	0x0095, r24
 106:	11 c0       	rjmp	.+34     	; 0x12a
		g_mode[1] = MOTOR_BACKWARD;
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
    case MOTOR_STOP:
		g_mode[0]  = MOTOR_STOP;
 108:	10 92 95 00 	sts	0x0095, r1
		g_mode[1]  = MOTOR_STOP;
 10c:	10 92 96 00 	sts	0x0096, r1
		g_angle[0] = 0;
 110:	30 93 a4 00 	sts	0x00A4, r19
 114:	20 93 a3 00 	sts	0x00A3, r18
		g_angle[1] = 0;
 118:	30 93 a6 00 	sts	0x00A6, r19
 11c:	20 93 a5 00 	sts	0x00A5, r18
		break;
 120:	08 95       	ret
	case MOTOR_TURN_LEFT:
		g_mode[0] = MOTOR_FORWARD;		
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	80 93 95 00 	sts	0x0095, r24
		g_mode[1] = MOTOR_BACKWARD;
 128:	82 e0       	ldi	r24, 0x02	; 2
 12a:	80 93 96 00 	sts	0x0096, r24
		g_angle[0] = 1;
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	90 93 a4 00 	sts	0x00A4, r25
 136:	80 93 a3 00 	sts	0x00A3, r24
		g_angle[1] = 1;
 13a:	90 93 a6 00 	sts	0x00A6, r25
 13e:	80 93 a5 00 	sts	0x00A5, r24
		break;
 142:	08 95       	ret
	case MOTOR_TURN_RIGHT:
		g_mode[0] = MOTOR_BACKWARD;
 144:	82 e0       	ldi	r24, 0x02	; 2
 146:	80 93 95 00 	sts	0x0095, r24
		g_mode[1] = MOTOR_FORWARD;
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	ee cf       	rjmp	.-36     	; 0x12a
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	 default:
	 	g_mode[0]  = MOTOR_STOP;
 14e:	10 92 95 00 	sts	0x0095, r1
		g_mode[1]  = MOTOR_STOP;
 152:	10 92 96 00 	sts	0x0096, r1
		g_angle[0] = 0;
 156:	10 92 a4 00 	sts	0x00A4, r1
 15a:	10 92 a3 00 	sts	0x00A3, r1
		g_angle[1] = 0;
 15e:	10 92 a6 00 	sts	0x00A6, r1
 162:	10 92 a5 00 	sts	0x00A5, r1
 166:	08 95       	ret
 168:	08 95       	ret

0000016a <remote_decode>:
		break;
   }
  
}

/* This subroutine will handle IR remote decode by getting remote code from Interrupt handle for input capture
and will response  to each remote key. For other applications user can modified here for different remote active
However this routine support Sony remote control only
   global effect   g_irint;
*/

void remote_decode ( uint16_t ircode)
{ 

  uint8_t set_speed = 0;
  switch ( ircode)
 16a:	26 e0       	ldi	r18, 0x06	; 6
 16c:	80 31       	cpi	r24, 0x10	; 16
 16e:	92 07       	cpc	r25, r18
 170:	09 f4       	brne	.+2      	; 0x174
 172:	ac c0       	rjmp	.+344    	; 0x2cc
 174:	26 e0       	ldi	r18, 0x06	; 6
 176:	81 31       	cpi	r24, 0x11	; 17
 178:	92 07       	cpc	r25, r18
 17a:	28 f5       	brcc	.+74     	; 0x1c6
 17c:	21 e0       	ldi	r18, 0x01	; 1
 17e:	80 31       	cpi	r24, 0x10	; 16
 180:	92 07       	cpc	r25, r18
 182:	09 f4       	brne	.+2      	; 0x186
 184:	b9 c0       	rjmp	.+370    	; 0x2f8
 186:	21 e0       	ldi	r18, 0x01	; 1
 188:	81 31       	cpi	r24, 0x11	; 17
 18a:	92 07       	cpc	r25, r18
 18c:	48 f4       	brcc	.+18     	; 0x1a0
 18e:	80 31       	cpi	r24, 0x10	; 16
 190:	91 05       	cpc	r25, r1
 192:	09 f4       	brne	.+2      	; 0x196
 194:	45 c0       	rjmp	.+138    	; 0x220
 196:	80 39       	cpi	r24, 0x90	; 144
 198:	91 05       	cpc	r25, r1
 19a:	09 f4       	brne	.+2      	; 0x19e
 19c:	ba c0       	rjmp	.+372    	; 0x312
 19e:	08 95       	ret
 1a0:	24 e0       	ldi	r18, 0x04	; 4
 1a2:	80 31       	cpi	r24, 0x10	; 16
 1a4:	92 07       	cpc	r25, r18
 1a6:	09 f4       	brne	.+2      	; 0x1aa
 1a8:	65 c0       	rjmp	.+202    	; 0x274
 1aa:	24 e0       	ldi	r18, 0x04	; 4
 1ac:	81 31       	cpi	r24, 0x11	; 17
 1ae:	92 07       	cpc	r25, r18
 1b0:	28 f4       	brcc	.+10     	; 0x1bc
 1b2:	80 51       	subi	r24, 0x10	; 16
 1b4:	92 40       	sbci	r25, 0x02	; 2
 1b6:	09 f4       	brne	.+2      	; 0x1ba
 1b8:	73 c0       	rjmp	.+230    	; 0x2a0
 1ba:	08 95       	ret
 1bc:	80 59       	subi	r24, 0x90	; 144
 1be:	94 40       	sbci	r25, 0x04	; 4
 1c0:	09 f4       	brne	.+2      	; 0x1c4
 1c2:	ab c0       	rjmp	.+342    	; 0x31a
 1c4:	08 95       	ret
 1c6:	2a e0       	ldi	r18, 0x0A	; 10
 1c8:	80 31       	cpi	r24, 0x10	; 16
 1ca:	92 07       	cpc	r25, r18
 1cc:	09 f4       	brne	.+2      	; 0x1d0
 1ce:	73 c0       	rjmp	.+230    	; 0x2b6
 1d0:	2a e0       	ldi	r18, 0x0A	; 10
 1d2:	81 31       	cpi	r24, 0x11	; 17
 1d4:	92 07       	cpc	r25, r18
 1d6:	90 f4       	brcc	.+36     	; 0x1fc
 1d8:	28 e0       	ldi	r18, 0x08	; 8
 1da:	80 39       	cpi	r24, 0x90	; 144
 1dc:	92 07       	cpc	r25, r18
 1de:	09 f4       	brne	.+2      	; 0x1e2
 1e0:	9a c0       	rjmp	.+308    	; 0x316
 1e2:	28 e0       	ldi	r18, 0x08	; 8
 1e4:	81 39       	cpi	r24, 0x91	; 145
 1e6:	92 07       	cpc	r25, r18
 1e8:	20 f4       	brcc	.+8      	; 0x1f2
 1ea:	80 51       	subi	r24, 0x10	; 16
 1ec:	98 40       	sbci	r25, 0x08	; 8
 1ee:	19 f1       	breq	.+70     	; 0x236
 1f0:	08 95       	ret
 1f2:	80 51       	subi	r24, 0x10	; 16
 1f4:	99 40       	sbci	r25, 0x09	; 9
 1f6:	09 f4       	brne	.+2      	; 0x1fa
 1f8:	8a c0       	rjmp	.+276    	; 0x30e
 1fa:	08 95       	ret
 1fc:	2c e0       	ldi	r18, 0x0C	; 12
 1fe:	80 39       	cpi	r24, 0x90	; 144
 200:	92 07       	cpc	r25, r18
 202:	09 f4       	brne	.+2      	; 0x206
 204:	8c c0       	rjmp	.+280    	; 0x31e
 206:	2c e0       	ldi	r18, 0x0C	; 12
 208:	81 39       	cpi	r24, 0x91	; 145
 20a:	92 07       	cpc	r25, r18
 20c:	20 f4       	brcc	.+8      	; 0x216
 20e:	80 51       	subi	r24, 0x10	; 16
 210:	9c 40       	sbci	r25, 0x0C	; 12
 212:	d9 f1       	breq	.+118    	; 0x28a
 214:	08 95       	ret
 216:	80 51       	subi	r24, 0x10	; 16
 218:	9e 40       	sbci	r25, 0x0E	; 14
 21a:	09 f4       	brne	.+2      	; 0x21e
 21c:	62 c0       	rjmp	.+196    	; 0x2e2
 21e:	08 95       	ret
	   {
	    case IR_TV_1:	
			g_speed[g_motor] = 800;
 220:	80 91 a7 00 	lds	r24, 0x00A7
 224:	e8 2f       	mov	r30, r24
 226:	ff 27       	eor	r31, r31
 228:	ee 0f       	add	r30, r30
 22a:	ff 1f       	adc	r31, r31
 22c:	e8 5d       	subi	r30, 0xD8	; 216
 22e:	fe 4f       	sbci	r31, 0xFE	; 254
 230:	80 e2       	ldi	r24, 0x20	; 32
 232:	93 e0       	ldi	r25, 0x03	; 3
 234:	0a c0       	rjmp	.+20     	; 0x24a
			set_speed =1;
			 break;
		case IR_TV_2:
			g_speed[g_motor] = 700;
 236:	80 91 a7 00 	lds	r24, 0x00A7
 23a:	e8 2f       	mov	r30, r24
 23c:	ff 27       	eor	r31, r31
 23e:	ee 0f       	add	r30, r30
 240:	ff 1f       	adc	r31, r31
 242:	e8 5d       	subi	r30, 0xD8	; 216
 244:	fe 4f       	sbci	r31, 0xFE	; 254
 246:	8c eb       	ldi	r24, 0xBC	; 188
 248:	92 e0       	ldi	r25, 0x02	; 2
 24a:	80 83       	st	Z, r24
 24c:	91 83       	std	Z+1, r25	; 0x01
			set_speed =1;
			break;
	    case IR_TV_3:
			g_speed[g_motor] = 600;
			set_speed =1;			
			break;
		case IR_TV_4:
			g_speed[g_motor] = 500;
			set_speed =1;			
			 break;
	    case IR_TV_5:
			g_speed[g_motor] = 400;
			set_speed =1;			
			 break;
		case IR_TV_6:
			g_speed[g_motor] = 300;
			set_speed =1;			
			 break;
	    case IR_TV_7:
			g_speed[g_motor] = 200;
			set_speed =1;			
			break;
		case IR_TV_8:
			g_speed[g_motor] = 100;
			set_speed =1;			
			break;
	    case IR_TV_9:
			g_speed[g_motor] = 10;
			set_speed =1;			
			break;
		case IR_TV_0:
			set_motor_parameter (MOTOR_STOP);
			break;
		case IR_TV_CHUP:
			set_motor_parameter(MOTOR_FORWARD);
			break;
		case IR_TV_CHDOWN:							
			set_motor_parameter(MOTOR_BACKWARD);
			break;
		case IR_TV_TVMUTE:
			break;
		case  IR_TV_TVPOWER:
		  	break;
		case   IR_TV_TVAV:
		    break;
		case  IR_TV_VOLUP:
            set_motor_parameter(MOTOR_TURN_LEFT);
			break;
		case  IR_TV_VOLDOWN:                 			
		    set_motor_parameter(MOTOR_TURN_RIGHT);
			break;
		default:
 //			set_motor_parameter (MOTOR_STOP);
			break;
 	   }
       if (set_speed)
	   {	         // Start from +  speed*2^4
            g_speed[1] = g_speed[g_motor]*MOTOR_SPEED_MULTIPLY; 
 24e:	80 91 a7 00 	lds	r24, 0x00A7
 252:	e8 2f       	mov	r30, r24
 254:	ff 27       	eor	r31, r31
 256:	ee 0f       	add	r30, r30
 258:	ff 1f       	adc	r31, r31
 25a:	e8 5d       	subi	r30, 0xD8	; 216
 25c:	fe 4f       	sbci	r31, 0xFE	; 254
 25e:	80 81       	ld	r24, Z
 260:	91 81       	ldd	r25, Z+1	; 0x01
 262:	90 93 2b 01 	sts	0x012B, r25
 266:	80 93 2a 01 	sts	0x012A, r24
			g_speed[0] = g_speed[1];
 26a:	90 93 29 01 	sts	0x0129, r25
 26e:	80 93 28 01 	sts	0x0128, r24
 272:	08 95       	ret
 274:	80 91 a7 00 	lds	r24, 0x00A7
 278:	e8 2f       	mov	r30, r24
 27a:	ff 27       	eor	r31, r31
 27c:	ee 0f       	add	r30, r30
 27e:	ff 1f       	adc	r31, r31
 280:	e8 5d       	subi	r30, 0xD8	; 216
 282:	fe 4f       	sbci	r31, 0xFE	; 254
 284:	88 e5       	ldi	r24, 0x58	; 88
 286:	92 e0       	ldi	r25, 0x02	; 2
 288:	e0 cf       	rjmp	.-64     	; 0x24a
 28a:	80 91 a7 00 	lds	r24, 0x00A7
 28e:	e8 2f       	mov	r30, r24
 290:	ff 27       	eor	r31, r31
 292:	ee 0f       	add	r30, r30
 294:	ff 1f       	adc	r31, r31
 296:	e8 5d       	subi	r30, 0xD8	; 216
 298:	fe 4f       	sbci	r31, 0xFE	; 254
 29a:	84 ef       	ldi	r24, 0xF4	; 244
 29c:	91 e0       	ldi	r25, 0x01	; 1
 29e:	d5 cf       	rjmp	.-86     	; 0x24a
 2a0:	80 91 a7 00 	lds	r24, 0x00A7
 2a4:	e8 2f       	mov	r30, r24
 2a6:	ff 27       	eor	r31, r31
 2a8:	ee 0f       	add	r30, r30
 2aa:	ff 1f       	adc	r31, r31
 2ac:	e8 5d       	subi	r30, 0xD8	; 216
 2ae:	fe 4f       	sbci	r31, 0xFE	; 254
 2b0:	80 e9       	ldi	r24, 0x90	; 144
 2b2:	91 e0       	ldi	r25, 0x01	; 1
 2b4:	ca cf       	rjmp	.-108    	; 0x24a
 2b6:	80 91 a7 00 	lds	r24, 0x00A7
 2ba:	e8 2f       	mov	r30, r24
 2bc:	ff 27       	eor	r31, r31
 2be:	ee 0f       	add	r30, r30
 2c0:	ff 1f       	adc	r31, r31
 2c2:	e8 5d       	subi	r30, 0xD8	; 216
 2c4:	fe 4f       	sbci	r31, 0xFE	; 254
 2c6:	8c e2       	ldi	r24, 0x2C	; 44
 2c8:	91 e0       	ldi	r25, 0x01	; 1
 2ca:	bf cf       	rjmp	.-130    	; 0x24a
 2cc:	80 91 a7 00 	lds	r24, 0x00A7
 2d0:	e8 2f       	mov	r30, r24
 2d2:	ff 27       	eor	r31, r31
 2d4:	ee 0f       	add	r30, r30
 2d6:	ff 1f       	adc	r31, r31
 2d8:	e8 5d       	subi	r30, 0xD8	; 216
 2da:	fe 4f       	sbci	r31, 0xFE	; 254
 2dc:	88 ec       	ldi	r24, 0xC8	; 200
 2de:	90 e0       	ldi	r25, 0x00	; 0
 2e0:	b4 cf       	rjmp	.-152    	; 0x24a
 2e2:	80 91 a7 00 	lds	r24, 0x00A7
 2e6:	e8 2f       	mov	r30, r24
 2e8:	ff 27       	eor	r31, r31
 2ea:	ee 0f       	add	r30, r30
 2ec:	ff 1f       	adc	r31, r31
 2ee:	e8 5d       	subi	r30, 0xD8	; 216
 2f0:	fe 4f       	sbci	r31, 0xFE	; 254
 2f2:	84 e6       	ldi	r24, 0x64	; 100
 2f4:	90 e0       	ldi	r25, 0x00	; 0
 2f6:	a9 cf       	rjmp	.-174    	; 0x24a
 2f8:	80 91 a7 00 	lds	r24, 0x00A7
 2fc:	e8 2f       	mov	r30, r24
 2fe:	ff 27       	eor	r31, r31
 300:	ee 0f       	add	r30, r30
 302:	ff 1f       	adc	r31, r31
 304:	e8 5d       	subi	r30, 0xD8	; 216
 306:	fe 4f       	sbci	r31, 0xFE	; 254
 308:	8a e0       	ldi	r24, 0x0A	; 10
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	9e cf       	rjmp	.-196    	; 0x24a
 30e:	80 e0       	ldi	r24, 0x00	; 0
 310:	07 c0       	rjmp	.+14     	; 0x320
 312:	81 e0       	ldi	r24, 0x01	; 1
 314:	05 c0       	rjmp	.+10     	; 0x320
 316:	82 e0       	ldi	r24, 0x02	; 2
 318:	03 c0       	rjmp	.+6      	; 0x320
 31a:	84 e0       	ldi	r24, 0x04	; 4
 31c:	01 c0       	rjmp	.+2      	; 0x320
 31e:	85 e0       	ldi	r24, 0x05	; 5
 320:	0e 94 64 00 	call	0xc8
 324:	08 95       	ret

00000326 <cmd_decode>:
 	   }
}



/* Command decode from g_rcv_buffer  will decode and action according to command in buffer
 
*/

int16_t cmd_decode (void)
{
 326:	df 92       	push	r13
 328:	ef 92       	push	r14
 32a:	ff 92       	push	r15
 32c:	0f 93       	push	r16
 32e:	1f 93       	push	r17
 330:	cf 93       	push	r28
 332:	df 93       	push	r29

 uint8_t  cmd_no =0;
 uint8_t  *cmd_argument;
 uint8_t  *buffer_ptr;
 
 
// Should repeat until end of buffer
 
// Loop until end of text

   buffer_ptr   = g_rcv_buff;
   cmd_argument = g_rcv_buff;
     
   while ( cmd_no !=  CMD_LINE_END)     // Until end of line which mean g_motor will change
   {
 		cmd_no =  text_decode (buffer_ptr,cmd_argument);
 334:	68 ea       	ldi	r22, 0xA8	; 168
 336:	70 e0       	ldi	r23, 0x00	; 0
 338:	cb 01       	movw	r24, r22
 33a:	0e 94 25 06 	call	0xc4a
 33e:	d8 2e       	mov	r13, r24
#ifdef DEBUG		
		uart_puts("Command :");
 340:	82 e6       	ldi	r24, 0x62	; 98
 342:	90 e0       	ldi	r25, 0x00	; 0
 344:	0e 94 d1 05 	call	0xba2
		uart_putc(0x30+cmd_no);
 348:	8d 2d       	mov	r24, r13
 34a:	80 5d       	subi	r24, 0xD0	; 208
 34c:	0e 94 cb 05 	call	0xb96
		uart_putc('*');
 350:	8a e2       	ldi	r24, 0x2A	; 42
 352:	0e 94 cb 05 	call	0xb96
		uart_puts(cmd_argument);
 356:	88 ea       	ldi	r24, 0xA8	; 168
 358:	90 e0       	ldi	r25, 0x00	; 0
 35a:	0e 94 d1 05 	call	0xba2
#endif        
 		switch (cmd_no)
 35e:	8d 2d       	mov	r24, r13
 360:	99 27       	eor	r25, r25
 362:	82 30       	cpi	r24, 0x02	; 2
 364:	91 05       	cpc	r25, r1
 366:	c9 f0       	breq	.+50     	; 0x39a
 368:	83 30       	cpi	r24, 0x03	; 3
 36a:	91 05       	cpc	r25, r1
 36c:	1c f4       	brge	.+6      	; 0x374
 36e:	01 97       	sbiw	r24, 0x01	; 1
 370:	21 f0       	breq	.+8      	; 0x37a
 372:	66 c0       	rjmp	.+204    	; 0x440
 374:	03 97       	sbiw	r24, 0x03	; 3
 376:	f9 f0       	breq	.+62     	; 0x3b6
 378:	63 c0       	rjmp	.+198    	; 0x440
		{
			case MOTOR_CMD: 
				g_motor = (uint8_t)atoi(cmd_argument);
 37a:	88 ea       	ldi	r24, 0xA8	; 168
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	0e 94 0a 07 	call	0xe14
 382:	80 93 a7 00 	sts	0x00A7, r24
				if (g_motor > 0)
 386:	28 2f       	mov	r18, r24
 388:	88 23       	and	r24, r24
 38a:	21 f0       	breq	.+8      	; 0x394
				   g_motor--;                //  > 0 Start from 0 need -1
 38c:	21 50       	subi	r18, 0x01	; 1
 38e:	20 93 a7 00 	sts	0x00A7, r18
 392:	5a c0       	rjmp	.+180    	; 0x448
				else
				   g_motor = 0;
 394:	80 93 a7 00 	sts	0x00A7, r24
 
 				break;
 398:	57 c0       	rjmp	.+174    	; 0x448
			case  SPEED_CMD:	
				g_speed[g_motor] = (uint8_t)atoi(cmd_argument);
 39a:	80 91 a7 00 	lds	r24, 0x00A7
 39e:	08 2f       	mov	r16, r24
 3a0:	11 27       	eor	r17, r17
 3a2:	00 0f       	add	r16, r16
 3a4:	11 1f       	adc	r17, r17
 3a6:	08 5d       	subi	r16, 0xD8	; 216
 3a8:	1e 4f       	sbci	r17, 0xFE	; 254
 3aa:	88 ea       	ldi	r24, 0xA8	; 168
 3ac:	90 e0       	ldi	r25, 0x00	; 0
 3ae:	0e 94 0a 07 	call	0xe14
 3b2:	99 27       	eor	r25, r25
 3b4:	41 c0       	rjmp	.+130    	; 0x438
				g_speed[g_motor] *=  MOTOR_SPEED_MULTIPLY;
  				break;
			case  ANGLE_CMD:   // Can be - 
				g_angle[g_motor] = atoi(cmd_argument);
 3b6:	80 91 a7 00 	lds	r24, 0x00A7
 3ba:	c8 2f       	mov	r28, r24
 3bc:	dd 27       	eor	r29, r29
 3be:	8e 01       	movw	r16, r28
 3c0:	0c 0f       	add	r16, r28
 3c2:	1d 1f       	adc	r17, r29
 3c4:	53 ea       	ldi	r21, 0xA3	; 163
 3c6:	e5 2e       	mov	r14, r21
 3c8:	50 e0       	ldi	r21, 0x00	; 0
 3ca:	f5 2e       	mov	r15, r21
 3cc:	e0 0e       	add	r14, r16
 3ce:	f1 1e       	adc	r15, r17
 3d0:	88 ea       	ldi	r24, 0xA8	; 168
 3d2:	90 e0       	ldi	r25, 0x00	; 0
 3d4:	0e 94 0a 07 	call	0xe14
 3d8:	9c 01       	movw	r18, r24
 3da:	f7 01       	movw	r30, r14
 3dc:	80 83       	st	Z, r24
 3de:	91 83       	std	Z+1, r25	; 0x01
				if (g_angle[g_motor] < 0)
 3e0:	97 ff       	sbrs	r25, 7
 3e2:	0a c0       	rjmp	.+20     	; 0x3f8
				{   
						g_mode[g_motor] = MOTOR_BACKWARD;
 3e4:	cb 56       	subi	r28, 0x6B	; 107
 3e6:	df 4f       	sbci	r29, 0xFF	; 255
 3e8:	82 e0       	ldi	r24, 0x02	; 2
 3ea:	88 83       	st	Y, r24
// Set g_angle to positive value by invert all bit and +1                
                        g_angle[g_motor] = (~(g_angle[g_motor])+1);
 3ec:	30 95       	com	r19
 3ee:	21 95       	neg	r18
 3f0:	3f 4f       	sbci	r19, 0xFF	; 255
 3f2:	20 83       	st	Z, r18
 3f4:	31 83       	std	Z+1, r19	; 0x01
 3f6:	10 c0       	rjmp	.+32     	; 0x418
                        if  (g_angle[g_motor] > 1)
						{
 						   g_angle[g_motor] *= MOTOR_ANGLE_COEF;
						   g_speed[g_motor] =  1000*MOTOR_SPEED_MULTIPLY;
						}		
				}	
				else  if (g_angle[g_motor] == 0)
 3f8:	00 97       	sbiw	r24, 0x00	; 0
 3fa:	21 f4       	brne	.+8      	; 0x404
				        g_mode[g_motor] = MOTOR_STOP;
 3fc:	cb 56       	subi	r28, 0x6B	; 107
 3fe:	df 4f       	sbci	r29, 0xFF	; 255
 400:	18 82       	st	Y, r1
 402:	22 c0       	rjmp	.+68     	; 0x448
				else	  
				{
					if ((g_angle[g_motor] > 0))   //  +
 404:	18 16       	cp	r1, r24
 406:	19 06       	cpc	r1, r25
 408:	24 f4       	brge	.+8      	; 0x412
						g_mode[g_motor] = MOTOR_FORWARD;
 40a:	cb 56       	subi	r28, 0x6B	; 107
 40c:	df 4f       	sbci	r29, 0xFF	; 255
 40e:	81 e0       	ldi	r24, 0x01	; 1
 410:	88 83       	st	Y, r24
					 if  (g_angle[g_motor] > 1)
 412:	f7 01       	movw	r30, r14
 414:	20 81       	ld	r18, Z
 416:	31 81       	ldd	r19, Z+1	; 0x01
 418:	22 30       	cpi	r18, 0x02	; 2
 41a:	31 05       	cpc	r19, r1
 41c:	ac f0       	brlt	.+42     	; 0x448
					 {
 						g_angle[g_motor] *=  MOTOR_ANGLE_COEF;	
 41e:	c9 01       	movw	r24, r18
 420:	88 0f       	add	r24, r24
 422:	99 1f       	adc	r25, r25
 424:	88 0f       	add	r24, r24
 426:	99 1f       	adc	r25, r25
 428:	82 0f       	add	r24, r18
 42a:	93 1f       	adc	r25, r19
 42c:	80 83       	st	Z, r24
 42e:	91 83       	std	Z+1, r25	; 0x01
						g_speed[g_motor] =  1000*MOTOR_SPEED_MULTIPLY;
 430:	08 5d       	subi	r16, 0xD8	; 216
 432:	1e 4f       	sbci	r17, 0xFE	; 254
 434:	88 ee       	ldi	r24, 0xE8	; 232
 436:	93 e0       	ldi	r25, 0x03	; 3
 438:	f8 01       	movw	r30, r16
 43a:	80 83       	st	Z, r24
 43c:	91 83       	std	Z+1, r25	; 0x01
					 }
 				}
				break;	
 43e:	04 c0       	rjmp	.+8      	; 0x448
 			default:
			    uart_puts("Command not found ");
 440:	8c e6       	ldi	r24, 0x6C	; 108
 442:	90 e0       	ldi	r25, 0x00	; 0
 444:	0e 94 d1 05 	call	0xba2
 		        break;	  
 448:	ff ef       	ldi	r31, 0xFF	; 255
 44a:	df 16       	cp	r13, r31
 44c:	09 f0       	breq	.+2      	; 0x450
 44e:	72 cf       	rjmp	.-284    	; 0x334
		}		
    }
 return 0; 
}
 450:	80 e0       	ldi	r24, 0x00	; 0
 452:	90 e0       	ldi	r25, 0x00	; 0
 454:	df 91       	pop	r29
 456:	cf 91       	pop	r28
 458:	1f 91       	pop	r17
 45a:	0f 91       	pop	r16
 45c:	ff 90       	pop	r15
 45e:	ef 90       	pop	r14
 460:	df 90       	pop	r13
 462:	08 95       	ret

00000464 <calculate_backemf>:

/* Calculate backemf and save in g_pos

*/
void calculate_backemf (uint8_t motor)
{
 464:	ef 92       	push	r14
 466:	ff 92       	push	r15
 468:	0f 93       	push	r16
 46a:	1f 93       	push	r17
 46c:	cf 93       	push	r28
 46e:	df 93       	push	r29
     uint16_t backemf=0;
 470:	c0 e0       	ldi	r28, 0x00	; 0
 472:	d0 e0       	ldi	r29, 0x00	; 0
  // Read backemf
	
	if (g_mode[motor] == MOTOR_FORWARD)
 474:	e8 2e       	mov	r14, r24
 476:	ff 24       	eor	r15, r15
 478:	f7 01       	movw	r30, r14
 47a:	eb 56       	subi	r30, 0x6B	; 107
 47c:	ff 4f       	sbci	r31, 0xFF	; 255
 47e:	80 81       	ld	r24, Z
 480:	81 30       	cpi	r24, 0x01	; 1
 482:	79 f4       	brne	.+30     	; 0x4a2
	{     	
		adc_init(3);
 484:	83 e0       	ldi	r24, 0x03	; 3
 486:	0e 94 03 06 	call	0xc06
		backemf = read_adc(g_adc_channel[motor]);
 48a:	87 01       	movw	r16, r14
 48c:	00 5a       	subi	r16, 0xA0	; 160
 48e:	1f 4f       	sbci	r17, 0xFF	; 255
 490:	f8 01       	movw	r30, r16
 492:	80 81       	ld	r24, Z
 494:	0e 94 18 06 	call	0xc30
		backemf = read_adc(g_adc_channel[motor]);
 498:	f8 01       	movw	r30, r16
 49a:	80 81       	ld	r24, Z
 49c:	0e 94 18 06 	call	0xc30
 4a0:	ec 01       	movw	r28, r24
 	}
	if (g_mode[0] == MOTOR_BACKWARD)	
 4a2:	80 91 95 00 	lds	r24, 0x0095
 4a6:	82 30       	cpi	r24, 0x02	; 2
 4a8:	81 f4       	brne	.+32     	; 0x4ca
	{   
		adc_init(3);
 4aa:	83 e0       	ldi	r24, 0x03	; 3
 4ac:	0e 94 03 06 	call	0xc06
		backemf = read_adc((g_adc_channel[motor]+1));		
 4b0:	87 01       	movw	r16, r14
 4b2:	00 5a       	subi	r16, 0xA0	; 160
 4b4:	1f 4f       	sbci	r17, 0xFF	; 255
 4b6:	f8 01       	movw	r30, r16
 4b8:	80 81       	ld	r24, Z
 4ba:	8f 5f       	subi	r24, 0xFF	; 255
 4bc:	0e 94 18 06 	call	0xc30
		backemf = read_adc(g_adc_channel[motor]);
 4c0:	f8 01       	movw	r30, r16
 4c2:	80 81       	ld	r24, Z
 4c4:	0e 94 18 06 	call	0xc30
 4c8:	ec 01       	movw	r28, r24
 	}
	if (backemf > 211)
 4ca:	c4 3d       	cpi	r28, 0xD4	; 212
 4cc:	d1 05       	cpc	r29, r1
 4ce:	88 f0       	brcs	.+34     	; 0x4f2
    {
		backemf  -= 211;
 4d0:	c3 5d       	subi	r28, 0xD3	; 211
 4d2:	d0 40       	sbci	r29, 0x00	; 0
		debug_value(backemf,10);
 4d4:	6a e0       	ldi	r22, 0x0A	; 10
 4d6:	ce 01       	movw	r24, r28
 4d8:	0e 94 e4 05 	call	0xbc8
		g_pos[motor] += backemf;
 4dc:	f7 01       	movw	r30, r14
 4de:	ee 0d       	add	r30, r14
 4e0:	ff 1d       	adc	r31, r15
 4e2:	ef 56       	subi	r30, 0x6F	; 111
 4e4:	ff 4f       	sbci	r31, 0xFF	; 255
 4e6:	80 81       	ld	r24, Z
 4e8:	91 81       	ldd	r25, Z+1	; 0x01
 4ea:	8c 0f       	add	r24, r28
 4ec:	9d 1f       	adc	r25, r29
 4ee:	80 83       	st	Z, r24
 4f0:	91 83       	std	Z+1, r25	; 0x01
 4f2:	df 91       	pop	r29
 4f4:	cf 91       	pop	r28
 4f6:	1f 91       	pop	r17
 4f8:	0f 91       	pop	r16
 4fa:	ff 90       	pop	r15
 4fc:	ef 90       	pop	r14
 4fe:	08 95       	ret

00000500 <__vector_7>:
    }
}



// Interrupt Vector table

 
/*
 OC1A Compare match  Toggle between on and off
*/ 
SIGNAL (SIG_OUTPUT_COMPARE1A)
{
 500:	1f 92       	push	r1
 502:	0f 92       	push	r0
 504:	0f b6       	in	r0, 0x3f	; 63
 506:	0f 92       	push	r0
 508:	11 24       	eor	r1, r1
 50a:	2f 93       	push	r18
 50c:	3f 93       	push	r19
 50e:	4f 93       	push	r20
 510:	5f 93       	push	r21
 512:	6f 93       	push	r22
 514:	7f 93       	push	r23
 516:	8f 93       	push	r24
 518:	9f 93       	push	r25
 51a:	af 93       	push	r26
 51c:	bf 93       	push	r27
 51e:	cf 93       	push	r28
 520:	ef 93       	push	r30
 522:	ff 93       	push	r31
  static uint8_t toggle=0;
 
  if (toggle)   // ON period
 524:	c0 91 97 00 	lds	r28, 0x0097
 528:	20 91 28 01 	lds	r18, 0x0128
 52c:	30 91 29 01 	lds	r19, 0x0129
 530:	cc 23       	and	r28, r28
 532:	99 f0       	breq	.+38     	; 0x55a
  {  
    OCR1A = 0x0FFF - g_speed[0];
 534:	8f ef       	ldi	r24, 0xFF	; 255
 536:	9f e0       	ldi	r25, 0x0F	; 15
 538:	82 1b       	sub	r24, r18
 53a:	93 0b       	sbc	r25, r19
 53c:	9b bd       	out	0x2b, r25	; 43
 53e:	8a bd       	out	0x2a, r24	; 42
    motor_control(1, g_mode[0]);
 540:	60 91 95 00 	lds	r22, 0x0095
 544:	81 e0       	ldi	r24, 0x01	; 1
 546:	0e 94 d2 04 	call	0x9a4
    if ( g_mode[0] != MOTOR_STOP)
 54a:	80 91 95 00 	lds	r24, 0x0095
 54e:	88 23       	and	r24, r24
 550:	69 f0       	breq	.+26     	; 0x56c
			uart_putc ('x');	
 552:	88 e7       	ldi	r24, 0x78	; 120
 554:	0e 94 cb 05 	call	0xb96
 558:	09 c0       	rjmp	.+18     	; 0x56c
 
  }
  else //  OFF period
  {
    OCR1A =  g_speed[0];
 55a:	3b bd       	out	0x2b, r19	; 43
 55c:	2a bd       	out	0x2a, r18	; 42
	motor_control(1, MOTOR_STOP);
 55e:	6c 2f       	mov	r22, r28
 560:	81 e0       	ldi	r24, 0x01	; 1
 562:	0e 94 d2 04 	call	0x9a4
	calculate_backemf(0);
 566:	8c 2f       	mov	r24, r28
 568:	0e 94 32 02 	call	0x464
  }
  
  toggle ^= 1;
 56c:	80 91 97 00 	lds	r24, 0x0097
 570:	91 e0       	ldi	r25, 0x01	; 1
 572:	89 27       	eor	r24, r25
 574:	80 93 97 00 	sts	0x0097, r24
 578:	ff 91       	pop	r31
 57a:	ef 91       	pop	r30
 57c:	cf 91       	pop	r28
 57e:	bf 91       	pop	r27
 580:	af 91       	pop	r26
 582:	9f 91       	pop	r25
 584:	8f 91       	pop	r24
 586:	7f 91       	pop	r23
 588:	6f 91       	pop	r22
 58a:	5f 91       	pop	r21
 58c:	4f 91       	pop	r20
 58e:	3f 91       	pop	r19
 590:	2f 91       	pop	r18
 592:	0f 90       	pop	r0
 594:	0f be       	out	0x3f, r0	; 63
 596:	0f 90       	pop	r0
 598:	1f 90       	pop	r1
 59a:	18 95       	reti

0000059c <__vector_8>:

}


/*
 OC1B Compare match 
*/ 
SIGNAL (SIG_OUTPUT_COMPARE1B)
{
 59c:	1f 92       	push	r1
 59e:	0f 92       	push	r0
 5a0:	0f b6       	in	r0, 0x3f	; 63
 5a2:	0f 92       	push	r0
 5a4:	11 24       	eor	r1, r1
 5a6:	2f 93       	push	r18
 5a8:	3f 93       	push	r19
 5aa:	4f 93       	push	r20
 5ac:	5f 93       	push	r21
 5ae:	6f 93       	push	r22
 5b0:	7f 93       	push	r23
 5b2:	8f 93       	push	r24
 5b4:	9f 93       	push	r25
 5b6:	af 93       	push	r26
 5b8:	bf 93       	push	r27
 5ba:	ef 93       	push	r30
 5bc:	ff 93       	push	r31
 static uint8_t toggle=1;     // Opposite with OCR1A for optimize
 
  if (toggle)   // ON period
 5be:	60 91 7f 00 	lds	r22, 0x007F
 5c2:	20 91 2a 01 	lds	r18, 0x012A
 5c6:	30 91 2b 01 	lds	r19, 0x012B
 5ca:	66 23       	and	r22, r22
 5cc:	29 f0       	breq	.+10     	; 0x5d8
  {  
    OCR1B =  g_speed[1];
 5ce:	39 bd       	out	0x29, r19	; 41
 5d0:	28 bd       	out	0x28, r18	; 40
	motor_control(2, g_mode[1]);
 5d2:	60 91 96 00 	lds	r22, 0x0096
 5d6:	06 c0       	rjmp	.+12     	; 0x5e4
 	
  }
  else //  OFF period
  {
    OCR1B = 0x00FF - g_speed[1];
 5d8:	8f ef       	ldi	r24, 0xFF	; 255
 5da:	90 e0       	ldi	r25, 0x00	; 0
 5dc:	82 1b       	sub	r24, r18
 5de:	93 0b       	sbc	r25, r19
 5e0:	99 bd       	out	0x29, r25	; 41
 5e2:	88 bd       	out	0x28, r24	; 40
	motor_control(2, MOTOR_STOP);	 
 5e4:	82 e0       	ldi	r24, 0x02	; 2
 5e6:	0e 94 d2 04 	call	0x9a4
//	calculate_backemf(1);
  }
  
  toggle ^= 1;
 5ea:	80 91 7f 00 	lds	r24, 0x007F
 5ee:	91 e0       	ldi	r25, 0x01	; 1
 5f0:	89 27       	eor	r24, r25
 5f2:	80 93 7f 00 	sts	0x007F, r24
 5f6:	ff 91       	pop	r31
 5f8:	ef 91       	pop	r30
 5fa:	bf 91       	pop	r27
 5fc:	af 91       	pop	r26
 5fe:	9f 91       	pop	r25
 600:	8f 91       	pop	r24
 602:	7f 91       	pop	r23
 604:	6f 91       	pop	r22
 606:	5f 91       	pop	r21
 608:	4f 91       	pop	r20
 60a:	3f 91       	pop	r19
 60c:	2f 91       	pop	r18
 60e:	0f 90       	pop	r0
 610:	0f be       	out	0x3f, r0	; 63
 612:	0f 90       	pop	r0
 614:	1f 90       	pop	r1
 616:	18 95       	reti

00000618 <__vector_13>:
}
 

 
/* UART receiver ready
*/

SIGNAL(SIG_UART_RECV)
{
 618:	1f 92       	push	r1
 61a:	0f 92       	push	r0
 61c:	0f b6       	in	r0, 0x3f	; 63
 61e:	0f 92       	push	r0
 620:	11 24       	eor	r1, r1
 622:	2f 93       	push	r18
 624:	8f 93       	push	r24
 626:	9f 93       	push	r25
 628:	ef 93       	push	r30
 62a:	ff 93       	push	r31
  static uint16_t i= 0;
  uint8_t ch;
  ch = UDR;
 62c:	2c b1       	in	r18, 0x0c	; 12

	g_rcv_buff[i] = ch;    
 62e:	80 91 98 00 	lds	r24, 0x0098
 632:	90 91 99 00 	lds	r25, 0x0099
 636:	fc 01       	movw	r30, r24
 638:	e8 55       	subi	r30, 0x58	; 88
 63a:	ff 4f       	sbci	r31, 0xFF	; 255
 63c:	20 83       	st	Z, r18
	i++;
 63e:	fc 01       	movw	r30, r24
 640:	31 96       	adiw	r30, 0x01	; 1
 642:	f0 93 99 00 	sts	0x0099, r31
 646:	e0 93 98 00 	sts	0x0098, r30
 
// Found 0xOD or 0x0A end with null
   if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
 64a:	2d 30       	cpi	r18, 0x0D	; 13
 64c:	11 f0       	breq	.+4      	; 0x652
 64e:	2a 30       	cpi	r18, 0x0A	; 10
 650:	51 f4       	brne	.+20     	; 0x666
   {	
    	g_rcv_buff[i]  = 0;   // End with null
 652:	e8 55       	subi	r30, 0x58	; 88
 654:	ff 4f       	sbci	r31, 0xFF	; 255
 656:	10 82       	st	Z, r1
		i = 0;
 658:	10 92 99 00 	sts	0x0099, r1
 65c:	10 92 98 00 	sts	0x0098, r1
  		g_cmd_decode = 1;
 660:	81 e0       	ldi	r24, 0x01	; 1
 662:	80 93 90 00 	sts	0x0090, r24
 666:	ff 91       	pop	r31
 668:	ef 91       	pop	r30
 66a:	9f 91       	pop	r25
 66c:	8f 91       	pop	r24
 66e:	2f 91       	pop	r18
 670:	0f 90       	pop	r0
 672:	0f be       	out	0x3f, r0	; 63
 674:	0f 90       	pop	r0
 676:	1f 90       	pop	r1
 678:	18 95       	reti

0000067a <__vector_14>:
   }
}

  

/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/

SIGNAL(SIG_UART_DATA)
{ 
 67a:	1f 92       	push	r1
 67c:	0f 92       	push	r0
 67e:	0f b6       	in	r0, 0x3f	; 63
 680:	0f 92       	push	r0
 682:	11 24       	eor	r1, r1
 684:	2f 93       	push	r18
 686:	3f 93       	push	r19
 688:	4f 93       	push	r20
 68a:	5f 93       	push	r21
 68c:	6f 93       	push	r22
 68e:	7f 93       	push	r23
 690:	8f 93       	push	r24
 692:	9f 93       	push	r25
 694:	af 93       	push	r26
 696:	bf 93       	push	r27
 698:	ef 93       	push	r30
 69a:	ff 93       	push	r31
    uint8_t  ch;
	if ((ch = uart_get_TX()))
 69c:	0e 94 ab 05 	call	0xb56
 6a0:	88 23       	and	r24, r24
 6a2:	11 f0       	breq	.+4      	; 0x6a8
	{
 		UDR = ch;
 6a4:	8c b9       	out	0x0c, r24	; 12
 6a6:	01 c0       	rjmp	.+2      	; 0x6aa
	}	
	else 
// No character disable  interrupt to avoid repetable call Enable again when
//	send character in putc procedure
	{
	    UCSRB &=  ~(1<<UDRIE);
 6a8:	55 98       	cbi	0x0a, 5	; 10
 6aa:	ff 91       	pop	r31
 6ac:	ef 91       	pop	r30
 6ae:	bf 91       	pop	r27
 6b0:	af 91       	pop	r26
 6b2:	9f 91       	pop	r25
 6b4:	8f 91       	pop	r24
 6b6:	7f 91       	pop	r23
 6b8:	6f 91       	pop	r22
 6ba:	5f 91       	pop	r21
 6bc:	4f 91       	pop	r20
 6be:	3f 91       	pop	r19
 6c0:	2f 91       	pop	r18
 6c2:	0f 90       	pop	r0
 6c4:	0f be       	out	0x3f, r0	; 63
 6c6:	0f 90       	pop	r0
 6c8:	1f 90       	pop	r1
 6ca:	18 95       	reti

000006cc <__vector_6>:
	}
	
}

 
 
/* Interrupt handle for Input Capture
This routine will detect/ process the Sony IR remote command. Protocol using Sony remote control
INPUT   :  Infrared signal from  ICP pin
		   Command table 
		  

OUTPUT 	: g_num  Number of message to display
		: g_control.display_mode   Display mode of message
		: g_start_bit
		

*/
SIGNAL(SIG_INPUT_CAPTURE1)
{
 6cc:	1f 92       	push	r1
 6ce:	0f 92       	push	r0
 6d0:	0f b6       	in	r0, 0x3f	; 63
 6d2:	0f 92       	push	r0
 6d4:	11 24       	eor	r1, r1
 6d6:	2f 93       	push	r18
 6d8:	3f 93       	push	r19
 6da:	4f 93       	push	r20
 6dc:	5f 93       	push	r21
 6de:	6f 93       	push	r22
 6e0:	7f 93       	push	r23
 6e2:	8f 93       	push	r24
 6e4:	9f 93       	push	r25
 6e6:	af 93       	push	r26
 6e8:	bf 93       	push	r27
 6ea:	ef 93       	push	r30
 6ec:	ff 93       	push	r31
	uint16_t  ir_code;
    ir_code = ICR1;
 6ee:	26 b5       	in	r18, 0x26	; 38
 6f0:	37 b5       	in	r19, 0x27	; 39
	cli(); 
 6f2:	f8 94       	cli

    TCCR1B  |= _BV(ICES1);	     // Rising edge
 6f4:	8e b5       	in	r24, 0x2e	; 46
 6f6:	80 64       	ori	r24, 0x40	; 64
 6f8:	8e bd       	out	0x2e, r24	; 46
 	ir_code  = sony_ir_decode(ir_code);  
 6fa:	c9 01       	movw	r24, r18
 6fc:	0e 94 0f 05 	call	0xa1e

	if (ir_code)
 700:	00 97       	sbiw	r24, 0x00	; 0
 702:	29 f0       	breq	.+10     	; 0x70e
	{       //End code dispatch command    
 
		remote_decode (ir_code);
 704:	0e 94 b5 00 	call	0x16a
// Return to falling edge for Start		
		TCCR1B  &= ~(_BV(ICES1));
 708:	8e b5       	in	r24, 0x2e	; 46
 70a:	8f 7b       	andi	r24, 0xBF	; 191
 70c:	8e bd       	out	0x2e, r24	; 46

//Note if  SELFTEST is selected g_irint = 0;
	} 
    sei();
 70e:	78 94       	sei
 710:	ff 91       	pop	r31
 712:	ef 91       	pop	r30
 714:	bf 91       	pop	r27
 716:	af 91       	pop	r26
 718:	9f 91       	pop	r25
 71a:	8f 91       	pop	r24
 71c:	7f 91       	pop	r23
 71e:	6f 91       	pop	r22
 720:	5f 91       	pop	r21
 722:	4f 91       	pop	r20
 724:	3f 91       	pop	r19
 726:	2f 91       	pop	r18
 728:	0f 90       	pop	r0
 72a:	0f be       	out	0x3f, r0	; 63
 72c:	0f 90       	pop	r0
 72e:	1f 90       	pop	r1
 730:	18 95       	reti

00000732 <init_board>:
 
}


void init_board()
{
    uint8_t i;
	d7segment_init();
 732:	0e 94 b3 04 	call	0x966
	init_ir();
 736:	0e 94 06 05 	call	0xa0c
	init_motor();
 73a:	0e 94 bd 04 	call	0x97a
	uart_init(); 
 73e:	0e 94 51 05 	call	0xaa2
    adc_init(1);   // AVCC as reference 
 742:	81 e0       	ldi	r24, 0x01	; 1
 744:	0e 94 03 06 	call	0xc06
	
	g_cmd_decode = 0; 
 748:	10 92 90 00 	sts	0x0090, r1
	g_motor= 0;
 74c:	10 92 a7 00 	sts	0x00A7, r1
 750:	4a e0       	ldi	r20, 0x0A	; 10
 752:	50 e0       	ldi	r21, 0x00	; 0
 754:	21 e0       	ldi	r18, 0x01	; 1
 756:	30 e0       	ldi	r19, 0x00	; 0
 758:	81 e0       	ldi	r24, 0x01	; 1
 75a:	a3 ea       	ldi	r26, 0xA3	; 163
 75c:	b0 e0       	ldi	r27, 0x00	; 0
 75e:	e8 e2       	ldi	r30, 0x28	; 40
 760:	f1 e0       	ldi	r31, 0x01	; 1
	
	for ( i = 0 ; i< MOTOR_MAX ;i++)
	{
		g_speed[i] = 10;
 762:	41 93       	st	Z+, r20
 764:	51 93       	st	Z+, r21
		g_angle[i] = 1;
 766:	2d 93       	st	X+, r18
 768:	3d 93       	st	X+, r19
 76a:	81 50       	subi	r24, 0x01	; 1
 76c:	87 ff       	sbrs	r24, 7
 76e:	f9 cf       	rjmp	.-14     	; 0x762
	} 
	sei();
 770:	78 94       	sei
 772:	08 95       	ret

00000774 <main>:
 
}

void main()
{
 774:	cc e5       	ldi	r28, 0x5C	; 92
 776:	d8 e0       	ldi	r29, 0x08	; 8
 778:	de bf       	out	0x3e, r29	; 62
 77a:	cd bf       	out	0x3d, r28	; 61
  uint8_t sw1,sw2,i;
   uint16_t k,backemf;
  int8_t d1,d2;
  uint8_t show[3] = {0,'f','b'};
 77c:	4e 01       	movw	r8, r28
 77e:	08 94       	sec
 780:	81 1c       	adc	r8, r1
 782:	91 1c       	adc	r9, r1
 784:	83 e0       	ldi	r24, 0x03	; 3
 786:	e0 e8       	ldi	r30, 0x80	; 128
 788:	f0 e0       	ldi	r31, 0x00	; 0
 78a:	d4 01       	movw	r26, r8
 78c:	01 90       	ld	r0, Z+
 78e:	0d 92       	st	X+, r0
 790:	8a 95       	dec	r24
 792:	e1 f7       	brne	.-8      	; 0x78c
   init_board();
 794:	0e 94 99 03 	call	0x732
  d1 = 0;
 798:	cc 24       	eor	r12, r12
  d2 = 0;
 79a:	bc 2c       	mov	r11, r12
  backemf =0;
  while (1)
  {
   sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
 79c:	80 b3       	in	r24, 0x10	; 16
   
   if (!sw1) // SW1  Press
 79e:	98 2f       	mov	r25, r24
 7a0:	98 70       	andi	r25, 0x08	; 8
 7a2:	83 fd       	sbrc	r24, 3
 7a4:	17 c0       	rjmp	.+46     	; 0x7d4
    {   	
		d1++;
 7a6:	b3 94       	inc	r11
	     if (d1 > MOTOR_BACKWARD)
 7a8:	b2 e0       	ldi	r27, 0x02	; 2
 7aa:	bb 15       	cp	r27, r11
 7ac:	0c f4       	brge	.+2      	; 0x7b0
			d1 = MOTOR_STOP;
 7ae:	b9 2e       	mov	r11, r25
 7b0:	03 ef       	ldi	r16, 0xF3	; 243
 7b2:	11 e0       	ldi	r17, 0x01	; 1
		for (k = 0; k < 500 ;k++)                         // Delay for key bounce
				delay(6000);						
 7b4:	80 e7       	ldi	r24, 0x70	; 112
 7b6:	97 e1       	ldi	r25, 0x17	; 23
 7b8:	0e 94 5f 00 	call	0xbe
 7bc:	01 50       	subi	r16, 0x01	; 1
 7be:	10 40       	sbci	r17, 0x00	; 0
 7c0:	17 ff       	sbrs	r17, 7
 7c2:	f8 cf       	rjmp	.-16     	; 0x7b4
		g_mode[0] = d1;
 7c4:	b0 92 95 00 	sts	0x0095, r11
		g_angle[0] = 1;    // Continuous move
 7c8:	81 e0       	ldi	r24, 0x01	; 1
 7ca:	90 e0       	ldi	r25, 0x00	; 0
 7cc:	90 93 a4 00 	sts	0x00A4, r25
 7d0:	80 93 a3 00 	sts	0x00A3, r24

	}
   
   sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
 7d4:	83 b3       	in	r24, 0x13	; 19
   if (!sw2) // SW2 Press
 7d6:	98 2f       	mov	r25, r24
 7d8:	94 70       	andi	r25, 0x04	; 4
 7da:	82 fd       	sbrc	r24, 2
 7dc:	17 c0       	rjmp	.+46     	; 0x80c
   {
        d2++;
 7de:	c3 94       	inc	r12
		if (d2 > MOTOR_BACKWARD)
 7e0:	e2 e0       	ldi	r30, 0x02	; 2
 7e2:	ec 15       	cp	r30, r12
 7e4:	0c f4       	brge	.+2      	; 0x7e8
			d2 = MOTOR_STOP;
 7e6:	c9 2e       	mov	r12, r25
 7e8:	03 ef       	ldi	r16, 0xF3	; 243
 7ea:	11 e0       	ldi	r17, 0x01	; 1
 		for (k = 0; k < 500 ;k++)                         // Delay for key bounce		
 				delay(6000);
 7ec:	80 e7       	ldi	r24, 0x70	; 112
 7ee:	97 e1       	ldi	r25, 0x17	; 23
 7f0:	0e 94 5f 00 	call	0xbe
 7f4:	01 50       	subi	r16, 0x01	; 1
 7f6:	10 40       	sbci	r17, 0x00	; 0
 7f8:	17 ff       	sbrs	r17, 7
 7fa:	f8 cf       	rjmp	.-16     	; 0x7ec
		g_mode[1] = d2;
 7fc:	c0 92 96 00 	sts	0x0096, r12
		g_angle[1] = 1;    // Continuous move	
 800:	81 e0       	ldi	r24, 0x01	; 1
 802:	90 e0       	ldi	r25, 0x00	; 0
 804:	90 93 a6 00 	sts	0x00A6, r25
 808:	80 93 a5 00 	sts	0x00A5, r24
   }

// Command decode
    if ( g_cmd_decode)
 80c:	80 91 90 00 	lds	r24, 0x0090
 810:	88 23       	and	r24, r24
 812:	71 f0       	breq	.+28     	; 0x830
	{
// Decode command	
   	    cmd_decode ();
 814:	0e 94 93 01 	call	0x326
		g_cmd_decode = 0; 
 818:	10 92 90 00 	sts	0x0090, r1
		g_pos[g_motor] = 0;
 81c:	80 91 a7 00 	lds	r24, 0x00A7
 820:	e8 2f       	mov	r30, r24
 822:	ff 27       	eor	r31, r31
 824:	ee 0f       	add	r30, r30
 826:	ff 1f       	adc	r31, r31
 828:	ef 56       	subi	r30, 0x6F	; 111
 82a:	ff 4f       	sbci	r31, 0xFF	; 255
 82c:	10 82       	st	Z, r1
 82e:	11 82       	std	Z+1, r1	; 0x01
	}
	
 	
    for (i = 0 ; i < MOTOR_MAX ; i++)
 830:	dd 24       	eor	r13, r13
	{
// If angle > 1 Backemf calculate
		if (((g_angle[i] > 1)) && ( g_mode[i] != MOTOR_STOP))
 832:	ed 2c       	mov	r14, r13
 834:	ff 24       	eor	r15, r15
 836:	97 01       	movw	r18, r14
 838:	2e 0d       	add	r18, r14
 83a:	3f 1d       	adc	r19, r15
 83c:	f9 01       	movw	r30, r18
 83e:	ed 55       	subi	r30, 0x5D	; 93
 840:	ff 4f       	sbci	r31, 0xFF	; 255
 842:	40 81       	ld	r20, Z
 844:	51 81       	ldd	r21, Z+1	; 0x01
 846:	42 30       	cpi	r20, 0x02	; 2
 848:	51 05       	cpc	r21, r1
 84a:	ec f0       	brlt	.+58     	; 0x886
 84c:	d7 01       	movw	r26, r14
 84e:	ab 56       	subi	r26, 0x6B	; 107
 850:	bf 4f       	sbci	r27, 0xFF	; 255
 852:	8c 91       	ld	r24, X
 854:	88 23       	and	r24, r24
 856:	b9 f0       	breq	.+46     	; 0x886
		{   
  
			if ( g_pos[i]  >= (g_angle[i]))  //  Check for position
 858:	89 01       	movw	r16, r18
 85a:	0f 56       	subi	r16, 0x6F	; 111
 85c:	1f 4f       	sbci	r17, 0xFF	; 255
 85e:	f8 01       	movw	r30, r16
 860:	80 81       	ld	r24, Z
 862:	91 81       	ldd	r25, Z+1	; 0x01
 864:	84 17       	cp	r24, r20
 866:	95 07       	cpc	r25, r21
 868:	70 f0       	brcs	.+28     	; 0x886
			{
 				g_mode[i] = MOTOR_STOP;
 86a:	1c 92       	st	X, r1
				uart_puts ("Voltage SUM");
 86c:	83 e8       	ldi	r24, 0x83	; 131
 86e:	90 e0       	ldi	r25, 0x00	; 0
 870:	0e 94 d1 05 	call	0xba2
				debug_value(g_pos[i],10);
 874:	6a e0       	ldi	r22, 0x0A	; 10
 876:	d8 01       	movw	r26, r16
 878:	8d 91       	ld	r24, X+
 87a:	9c 91       	ld	r25, X
 87c:	0e 94 e4 05 	call	0xbc8
				g_pos[i] =0;
 880:	f8 01       	movw	r30, r16
 882:	10 82       	st	Z, r1
 884:	11 82       	std	Z+1, r1	; 0x01
				
			}
		}	
		
// 7 Segments display	
		d7segment_display(show[g_mode[i]],i+1);
 886:	1d 2d       	mov	r17, r13
 888:	1f 5f       	subi	r17, 0xFF	; 255
 88a:	85 e9       	ldi	r24, 0x95	; 149
 88c:	90 e0       	ldi	r25, 0x00	; 0
 88e:	e8 0e       	add	r14, r24
 890:	f9 1e       	adc	r15, r25
 892:	d7 01       	movw	r26, r14
 894:	8c 91       	ld	r24, X
 896:	f4 01       	movw	r30, r8
 898:	e8 0f       	add	r30, r24
 89a:	f1 1d       	adc	r31, r1
 89c:	61 2f       	mov	r22, r17
 89e:	80 81       	ld	r24, Z
 8a0:	0e 94 5c 04 	call	0x8b8
 			delay(10000);	
 8a4:	80 e1       	ldi	r24, 0x10	; 16
 8a6:	97 e2       	ldi	r25, 0x27	; 39
 8a8:	0e 94 5f 00 	call	0xbe
 8ac:	d1 2e       	mov	r13, r17
 8ae:	b1 e0       	ldi	r27, 0x01	; 1
 8b0:	b1 17       	cp	r27, r17
 8b2:	08 f0       	brcs	.+2      	; 0x8b6
 8b4:	be cf       	rjmp	.-132    	; 0x832
 8b6:	72 cf       	rjmp	.-284    	; 0x79c

000008b8 <d7segment_display>:
#include "Dual_7Segment.h"

void d7segment_display( int8_t num, uint8_t digit)
{
 switch (num)
 8b8:	99 27       	eor	r25, r25
 8ba:	87 fd       	sbrc	r24, 7
 8bc:	90 95       	com	r25
 8be:	86 30       	cpi	r24, 0x06	; 6
 8c0:	91 05       	cpc	r25, r1
 8c2:	09 f4       	brne	.+2      	; 0x8c6
 8c4:	41 c0       	rjmp	.+130    	; 0x948
 8c6:	87 30       	cpi	r24, 0x07	; 7
 8c8:	91 05       	cpc	r25, r1
 8ca:	8c f4       	brge	.+34     	; 0x8ee
 8cc:	82 30       	cpi	r24, 0x02	; 2
 8ce:	91 05       	cpc	r25, r1
 8d0:	59 f1       	breq	.+86     	; 0x928
 8d2:	83 30       	cpi	r24, 0x03	; 3
 8d4:	91 05       	cpc	r25, r1
 8d6:	2c f4       	brge	.+10     	; 0x8e2
 8d8:	00 97       	sbiw	r24, 0x00	; 0
 8da:	11 f1       	breq	.+68     	; 0x920
 8dc:	01 97       	sbiw	r24, 0x01	; 1
 8de:	11 f1       	breq	.+68     	; 0x924
 8e0:	37 c0       	rjmp	.+110    	; 0x950
 8e2:	84 30       	cpi	r24, 0x04	; 4
 8e4:	91 05       	cpc	r25, r1
 8e6:	21 f1       	breq	.+72     	; 0x930
 8e8:	05 97       	sbiw	r24, 0x05	; 5
 8ea:	24 f5       	brge	.+72     	; 0x934
 8ec:	1f c0       	rjmp	.+62     	; 0x92c
 8ee:	89 30       	cpi	r24, 0x09	; 9
 8f0:	91 05       	cpc	r25, r1
 8f2:	31 f1       	breq	.+76     	; 0x940
 8f4:	8a 30       	cpi	r24, 0x0A	; 10
 8f6:	91 05       	cpc	r25, r1
 8f8:	34 f4       	brge	.+12     	; 0x906
 8fa:	87 30       	cpi	r24, 0x07	; 7
 8fc:	91 05       	cpc	r25, r1
 8fe:	e1 f0       	breq	.+56     	; 0x938
 900:	08 97       	sbiw	r24, 0x08	; 8
 902:	e1 f0       	breq	.+56     	; 0x93c
 904:	25 c0       	rjmp	.+74     	; 0x950
 906:	82 36       	cpi	r24, 0x62	; 98
 908:	91 05       	cpc	r25, r1
 90a:	f1 f0       	breq	.+60     	; 0x948
 90c:	83 36       	cpi	r24, 0x63	; 99
 90e:	91 05       	cpc	r25, r1
 910:	1c f4       	brge	.+6      	; 0x918
 912:	0a 97       	sbiw	r24, 0x0a	; 10
 914:	d9 f0       	breq	.+54     	; 0x94c
 916:	1c c0       	rjmp	.+56     	; 0x950
 918:	86 36       	cpi	r24, 0x66	; 102
 91a:	91 05       	cpc	r25, r1
 91c:	99 f0       	breq	.+38     	; 0x944
 91e:	18 c0       	rjmp	.+48     	; 0x950
 {
	case 0:
		_7SEGMENT_PORT = _7SEGMENT_0;
 920:	8f e3       	ldi	r24, 0x3F	; 63
 922:	15 c0       	rjmp	.+42     	; 0x94e
		break;
	case 1:
		_7SEGMENT_PORT = _7SEGMENT_1;
 924:	86 e0       	ldi	r24, 0x06	; 6
 926:	13 c0       	rjmp	.+38     	; 0x94e
		break;
	case 2:
		_7SEGMENT_PORT = _7SEGMENT_2;
 928:	8b e5       	ldi	r24, 0x5B	; 91
 92a:	11 c0       	rjmp	.+34     	; 0x94e
		break;
	case 3:
		_7SEGMENT_PORT = _7SEGMENT_3;
 92c:	8f e4       	ldi	r24, 0x4F	; 79
 92e:	0f c0       	rjmp	.+30     	; 0x94e
		break;
	case 4:
		_7SEGMENT_PORT = _7SEGMENT_4;
 930:	86 e6       	ldi	r24, 0x66	; 102
 932:	0d c0       	rjmp	.+26     	; 0x94e
		break;
	case 5:
		_7SEGMENT_PORT = _7SEGMENT_5;
 934:	8d e6       	ldi	r24, 0x6D	; 109
 936:	0b c0       	rjmp	.+22     	; 0x94e
		break;
	case 6:
		_7SEGMENT_PORT = _7SEGMENT_6;
		break;
	case 7:
		_7SEGMENT_PORT = _7SEGMENT_7;
 938:	87 e0       	ldi	r24, 0x07	; 7
 93a:	09 c0       	rjmp	.+18     	; 0x94e
		break;
	case 8:
		_7SEGMENT_PORT = _7SEGMENT_8;
 93c:	8f e7       	ldi	r24, 0x7F	; 127
 93e:	07 c0       	rjmp	.+14     	; 0x94e
		break;
	case 9:
		_7SEGMENT_PORT = _7SEGMENT_9;
 940:	87 e6       	ldi	r24, 0x67	; 103
 942:	05 c0       	rjmp	.+10     	; 0x94e
	    break;
	case 'f':
	    _7SEGMENT_PORT = _7SEGMENT_C_F;
 944:	81 e7       	ldi	r24, 0x71	; 113
 946:	03 c0       	rjmp	.+6      	; 0x94e
		break;
	case 'b':
	    _7SEGMENT_PORT = _7SEGMENT_C_B;
 948:	8c e7       	ldi	r24, 0x7C	; 124
 94a:	01 c0       	rjmp	.+2      	; 0x94e
		break;
	case DOT:
		_7SEGMENT_PORT = _7SEGMENT_DOT;
 94c:	80 e8       	ldi	r24, 0x80	; 128
 94e:	88 bb       	out	0x18, r24	; 24
		break;
 
 }
// Out digit
	 
    if ( digit == 1 )
 950:	61 30       	cpi	r22, 0x01	; 1
 952:	19 f4       	brne	.+6      	; 0x95a
	{  // ON Digit 1 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT1);
 954:	ab 98       	cbi	0x15, 3	; 21
	   // OFF Digit 2 
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT2;
 956:	ac 9a       	sbi	0x15, 4	; 21
 958:	08 95       	ret
	}
	if ( digit == 2 )
 95a:	62 30       	cpi	r22, 0x02	; 2
 95c:	11 f4       	brne	.+4      	; 0x962
	{  // ON Digit 2 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT2);
 95e:	ac 98       	cbi	0x15, 4	; 21
	   // OFF Digit 1
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT1;
 960:	ab 9a       	sbi	0x15, 3	; 21
 962:	08 95       	ret
 964:	08 95       	ret

00000966 <d7segment_init>:
	}	

}	


/* Initial 7 Segments. Set port to output before use 
*/
void d7segment_init (void)
{
// Set direction for output for 7 Segment
	_7SEGMENT_DIGIT_DIR   = 0xFF;
 966:	8f ef       	ldi	r24, 0xFF	; 255
 968:	87 bb       	out	0x17, r24	; 23
	_7SEGMENT_PORT_DIR	  |= _7SEGMENT_DIGIT1 | _7SEGMENT_DIGIT2;
 96a:	84 b3       	in	r24, 0x14	; 20
 96c:	88 61       	ori	r24, 0x18	; 24
 96e:	84 bb       	out	0x14, r24	; 20
 
// Set direction for input for SW 
	_7SEGMENT_SW1_DIR	&=  ~(_7SEGMENT_SW1);
 970:	8b 98       	cbi	0x11, 3	; 17
	_7SEGMENT_SW2_DIR	&=  ~(_7SEGMENT_SW2);
 972:	a2 98       	cbi	0x14, 2	; 20

// Enable pull up
    _7SEGMENT_SW1_PORT   |= _7SEGMENT_SW1;
 974:	93 9a       	sbi	0x12, 3	; 18
    _7SEGMENT_SW2_PORT   |= _7SEGMENT_SW2;
 976:	aa 9a       	sbi	0x15, 2	; 21
 978:	08 95       	ret

0000097a <init_motor>:
{
 // Initial for PWM Motor control for 16 timer for OC1A and OC1B
// 8 bit fast PWM set OC1A OC1B on comapare match

	TCCR1A |= _BV(WGM10) |_BV(WGM11) ;  //| _BV(COM1B1)|_BV(COM1A1);
 97a:	8f b5       	in	r24, 0x2f	; 47
 97c:	83 60       	ori	r24, 0x03	; 3
 97e:	8f bd       	out	0x2f, r24	; 47
	TCCR1B |= _BV(WGM12) | _BV(CS12);   // Clk /256
 980:	8e b5       	in	r24, 0x2e	; 46
 982:	8c 60       	ori	r24, 0x0C	; 12
 984:	8e bd       	out	0x2e, r24	; 46
//	TCCR1B |= _BV(WGM12) | _BV(CS12) | _BV(CS10);   // Clk /1024
// Enable Interrupt for comapre match
    TIMSK  |=  _BV(OCIE1A) | _BV(OCIE1B);	
 986:	89 b7       	in	r24, 0x39	; 57
 988:	88 61       	ori	r24, 0x18	; 24
 98a:	89 bf       	out	0x39, r24	; 57
	OCR1A = 0x007F;
 98c:	8f e7       	ldi	r24, 0x7F	; 127
 98e:	90 e0       	ldi	r25, 0x00	; 0
 990:	9b bd       	out	0x2b, r25	; 43
 992:	8a bd       	out	0x2a, r24	; 42
	OCR1B = 0x007F;
 994:	99 bd       	out	0x29, r25	; 41
 996:	88 bd       	out	0x28, r24	; 40


    MOTOR_DIRECTION_DIR  |= 	MOTORA_1 | MOTORA_2 | MOTORB_1 | MOTORB_2;
 998:	8a b3       	in	r24, 0x1a	; 26
 99a:	80 6f       	ori	r24, 0xF0	; 240
 99c:	8a bb       	out	0x1a, r24	; 26
	MOTOR_ENABLE12_DIR	 |= 	MOTOR_ENABLE12;
 99e:	8d 9a       	sbi	0x11, 5	; 17
	MOTOR_ENABLE34_DIR	 |=  	MOTOR_ENABLE34;		
 9a0:	8c 9a       	sbi	0x11, 4	; 17
 9a2:	08 95       	ret

000009a4 <motor_control>:
  
}


// speed from 1 - 10

void  motor_control (uint8_t port, uint8_t direction) 
{
 9a4:	38 2f       	mov	r19, r24
 9a6:	86 2f       	mov	r24, r22
  
   uint8_t  controlA,controlB;
   
   switch (direction)
 9a8:	99 27       	eor	r25, r25
 9aa:	81 30       	cpi	r24, 0x01	; 1
 9ac:	91 05       	cpc	r25, r1
 9ae:	49 f0       	breq	.+18     	; 0x9c2
 9b0:	82 30       	cpi	r24, 0x02	; 2
 9b2:	91 05       	cpc	r25, r1
 9b4:	74 f0       	brlt	.+28     	; 0x9d2
 9b6:	82 30       	cpi	r24, 0x02	; 2
 9b8:	91 05       	cpc	r25, r1
 9ba:	31 f0       	breq	.+12     	; 0x9c8
 9bc:	03 97       	sbiw	r24, 0x03	; 3
 9be:	39 f0       	breq	.+14     	; 0x9ce
 9c0:	08 c0       	rjmp	.+16     	; 0x9d2
   {
     case MOTOR_FORWARD:
	    controlA = 0;
 9c2:	20 e0       	ldi	r18, 0x00	; 0
		controlB = 0xFF;
 9c4:	9f ef       	ldi	r25, 0xFF	; 255
		break;
 9c6:	07 c0       	rjmp	.+14     	; 0x9d6
	 case MOTOR_BACKWARD:
        controlA = 0xFF;
 9c8:	2f ef       	ldi	r18, 0xFF	; 255
		controlB = 0;
 9ca:	90 e0       	ldi	r25, 0x00	; 0
		break;
 9cc:	04 c0       	rjmp	.+8      	; 0x9d6
	 case MOTOR_STOP:
	    controlA = 0;
		controlB = 0;
		break;
	case MOTOR_BRAKE:
	    controlA = 0xFF;
 9ce:	9f ef       	ldi	r25, 0xFF	; 255
 9d0:	01 c0       	rjmp	.+2      	; 0x9d4
		controlB = 0xFF;
		break;
	default:
	    controlA = 0;
 9d2:	90 e0       	ldi	r25, 0x00	; 0
		controlB = 0;
 9d4:	29 2f       	mov	r18, r25
   }
 if (port == 1)
 9d6:	31 30       	cpi	r19, 0x01	; 1
 9d8:	59 f4       	brne	.+22     	; 0x9f0
   {
       MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;
 9da:	95 9a       	sbi	0x12, 5	; 18
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORA_1 | MOTORA_2); 
 9dc:	8b b3       	in	r24, 0x1b	; 27
 9de:	8f 7c       	andi	r24, 0xCF	; 207
 9e0:	8b bb       	out	0x1b, r24	; 27
	  MOTOR_DIRECTION_CONTROL |= ((MOTORA_1 & controlA ) | (MOTORA_2 & controlB));
 9e2:	20 71       	andi	r18, 0x10	; 16
 9e4:	90 72       	andi	r25, 0x20	; 32
 9e6:	29 2b       	or	r18, r25
 9e8:	8b b3       	in	r24, 0x1b	; 27
 9ea:	82 2b       	or	r24, r18
 9ec:	8b bb       	out	0x1b, r24	; 27
 9ee:	08 95       	ret
  }
  if (port == 2)
 9f0:	32 30       	cpi	r19, 0x02	; 2
 9f2:	51 f4       	brne	.+20     	; 0xa08
   {
  	  MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
 9f4:	94 9a       	sbi	0x12, 4	; 18
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORB_1 | MOTORB_2); 
 9f6:	8b b3       	in	r24, 0x1b	; 27
 9f8:	8f 73       	andi	r24, 0x3F	; 63
 9fa:	8b bb       	out	0x1b, r24	; 27
  	  MOTOR_DIRECTION_CONTROL |= ((MOTORB_1 & controlA ) | (MOTORB_2 & controlB));
 9fc:	20 74       	andi	r18, 0x40	; 64
 9fe:	90 78       	andi	r25, 0x80	; 128
 a00:	29 2b       	or	r18, r25
 a02:	8b b3       	in	r24, 0x1b	; 27
 a04:	82 2b       	or	r24, r18
 a06:	8b bb       	out	0x1b, r24	; 27
 a08:	08 95       	ret
 a0a:	08 95       	ret

00000a0c <init_ir>:

void init_ir()
{
 //Set Direction
    IR_DDR_PORT &= ~IR_ICP; 
 a0c:	8e 98       	cbi	0x11, 6	; 17
	
	TCCR1B  |= ( _BV(ICNC1) | _BV(CS12) | _BV(CS10));			// Time 1 input to clock/1024 input capture on falling edge  noise cancel
 a0e:	8e b5       	in	r24, 0x2e	; 46
 a10:	85 68       	ori	r24, 0x85	; 133
 a12:	8e bd       	out	0x2e, r24	; 46
	TIMSK   |= _BV(TICIE1);   								// Enable input capture enable 
 a14:	89 b7       	in	r24, 0x39	; 57
 a16:	80 62       	ori	r24, 0x20	; 32
 a18:	89 bf       	out	0x39, r24	; 57
	sei();
 a1a:	78 94       	sei
 a1c:	08 95       	ret

00000a1e <sony_ir_decode>:
}
/*  Decode for Sony remote TV IR 
			Input  Input capturn counter 16 bit register
		   Output  0  = no code detect
				   ir_decode  = detect IR code 
				   
	Algorithm
		Calculate pulse width by substract ICP counter. from pulse width 
		can determine whether it is  START BIT 		 =  XX
									  BIT1 			 =  XX
		until 12 bits then return ir code							  
									 
*/

uint16_t sony_ir_decode ( uint16_t capture_counter)
{
 a1e:	bc 01       	movw	r22, r24
  static 	uint16_t  	prev_capture_counter = 0;
  static 	uint8_t   	stop_bit = 0;
  static	uint16_t	ir_code = 0;
 			uint16_t	width  = 0;	  

      if ( capture_counter > prev_capture_counter)
 a20:	80 91 9a 00 	lds	r24, 0x009A
 a24:	90 91 9b 00 	lds	r25, 0x009B
 a28:	9b 01       	movw	r18, r22
 a2a:	28 1b       	sub	r18, r24
 a2c:	39 0b       	sbc	r19, r25
			width = capture_counter - prev_capture_counter;
	  else
			width = capture_counter+(MAX_INT16 - prev_capture_counter);
//Check for start bit
     if ( width > IR_TV_PULSE_WIDTH)
 a2e:	2a 30       	cpi	r18, 0x0A	; 10
 a30:	31 05       	cpc	r19, r1
 a32:	20 f1       	brcs	.+72     	; 0xa7c
	 {
		  if (width > IR_TV_START_BIT)  			//  Found Start bit 
 a34:	26 32       	cpi	r18, 0x26	; 38
 a36:	31 05       	cpc	r19, r1
 a38:	58 f0       	brcs	.+22     	; 0xa50
			    {
				  stop_bit = 0;
 a3a:	10 92 9c 00 	sts	0x009C, r1
				  prev_capture_counter = 0;
 a3e:	10 92 9b 00 	sts	0x009B, r1
 a42:	10 92 9a 00 	sts	0x009A, r1
				  ir_code = 0;     			// New code
 a46:	10 92 9e 00 	sts	0x009E, r1
 a4a:	10 92 9d 00 	sts	0x009D, r1
 a4e:	16 c0       	rjmp	.+44     	; 0xa7c
 a50:	80 91 9d 00 	lds	r24, 0x009D
 a54:	90 91 9e 00 	lds	r25, 0x009E
 a58:	40 91 9c 00 	lds	r20, 0x009C
				}
		  else if (width > IR_TV_BIT1)	  		// bit 1 (3T)
 a5c:	2a 31       	cpi	r18, 0x1A	; 26
 a5e:	31 05       	cpc	r19, r1
 a60:	20 f0       	brcs	.+8      	; 0xa6a
				{
				   ir_code <<= 1;    			//Shift right
 a62:	88 0f       	add	r24, r24
 a64:	99 1f       	adc	r25, r25
				   ir_code  |= 1;    			// Or 1
 a66:	81 60       	ori	r24, 0x01	; 1
 a68:	02 c0       	rjmp	.+4      	; 0xa6e
				    stop_bit++;
				}
		        else 	  // bit 0
				{
					ir_code  <<=  1;  //Shift right
 a6a:	88 0f       	add	r24, r24
 a6c:	99 1f       	adc	r25, r25
 a6e:	90 93 9e 00 	sts	0x009E, r25
 a72:	80 93 9d 00 	sts	0x009D, r24
					stop_bit++;
 a76:	4f 5f       	subi	r20, 0xFF	; 255
 a78:	40 93 9c 00 	sts	0x009C, r20
				}
	}
	prev_capture_counter = capture_counter;
 a7c:	70 93 9b 00 	sts	0x009B, r23
 a80:	60 93 9a 00 	sts	0x009A, r22
	if (stop_bit == IR_TV_STOP_BIT)
 a84:	80 91 9c 00 	lds	r24, 0x009C
 a88:	8c 30       	cpi	r24, 0x0C	; 12
 a8a:	39 f4       	brne	.+14     	; 0xa9a
	{       //End code dispatch command
  	    stop_bit = 0;
 a8c:	10 92 9c 00 	sts	0x009C, r1

		return ir_code;
 a90:	80 91 9d 00 	lds	r24, 0x009D
 a94:	90 91 9e 00 	lds	r25, 0x009E
 a98:	08 95       	ret
			
//Note if  SELFTEST is selected g_irint = 0;
	}   
	else
		return 0;		// No code detect yet
 a9a:	80 e0       	ldi	r24, 0x00	; 0
 a9c:	90 e0       	ldi	r25, 0x00	; 0
}
 a9e:	08 95       	ret
 aa0:	08 95       	ret

00000aa2 <uart_init>:
{
 
// Initialize UART  
    
    UCSRC  = 0x86;    // 8 bit non parity  1 stop bit
 aa2:	86 e8       	ldi	r24, 0x86	; 134
 aa4:	80 bd       	out	0x20, r24	; 32
     UCSRB  = 0x98;    // Enable RX Interrupt and Enable TX, RX pin
 aa6:	88 e9       	ldi	r24, 0x98	; 152
 aa8:	8a b9       	out	0x0a, r24	; 10
//    UCSRB  = 0B8;    // Enable RX Interrupt, Data registerempty interrupt enable and Enable TX, RX pin 1011-1000
	UBRRL  = 0x67;    // Speed 9600 UBRR = 103 at 16 MHZ
 aaa:	87 e6       	ldi	r24, 0x67	; 103
 aac:	89 b9       	out	0x09, r24	; 9
	UBRRH  = 0;
 aae:	10 bc       	out	0x20, r1	; 32
//    DDRD = 0x00;	 
 
	g_rx_ptr = 0;
 ab0:	10 92 a0 00 	sts	0x00A0, r1
	g_tx_ptr = 0;
 ab4:	10 92 9f 00 	sts	0x009F, r1
 ab8:	08 95       	ret

00000aba <uart_put_RX>:
 /* Set baud rate */
 
}

/*
Put character into Rx buffer

Return  = Success 0
        = Fail   Buffer Full
		
*/
uint8_t uart_put_RX ( uint8_t ch)
{
 aba:	98 2f       	mov	r25, r24
   if ((g_rx_ptr < MAX_BUFF)) 
 abc:	80 91 a0 00 	lds	r24, 0x00A0
 ac0:	87 fd       	sbrc	r24, 7
 ac2:	10 c0       	rjmp	.+32     	; 0xae4
   {
//  End with Null
		g_rx_buff[g_rx_ptr] = ch;
 ac4:	e8 2f       	mov	r30, r24
 ac6:	ff 27       	eor	r31, r31
 ac8:	e4 5d       	subi	r30, 0xD4	; 212
 aca:	fe 4f       	sbci	r31, 0xFE	; 254
 acc:	90 83       	st	Z, r25
		g_rx_ptr++;
 ace:	8f 5f       	subi	r24, 0xFF	; 255
 ad0:	80 93 a0 00 	sts	0x00A0, r24
		g_rx_buff[g_rx_ptr] = 0;   // End with null characters
 ad4:	e8 2f       	mov	r30, r24
 ad6:	ff 27       	eor	r31, r31
 ad8:	e4 5d       	subi	r30, 0xD4	; 212
 ada:	fe 4f       	sbci	r31, 0xFE	; 254
 adc:	10 82       	st	Z, r1
		return 0;
 ade:	80 e0       	ldi	r24, 0x00	; 0
 ae0:	90 e0       	ldi	r25, 0x00	; 0
 ae2:	08 95       	ret
    }
   else  // Buffer full do nothing  return error
   {
        return UART_BUFFER_FULL;
 ae4:	82 e0       	ldi	r24, 0x02	; 2
 ae6:	90 e0       	ldi	r25, 0x00	; 0
   }
}
 ae8:	08 95       	ret
 aea:	08 95       	ret

00000aec <uart_get_RX>:

// Get character from RX buffer

uint8_t uart_get_RX (void)
{
   uint8_t  i,j,ch;
   if (g_rx_ptr)
 aec:	80 91 a0 00 	lds	r24, 0x00A0
 af0:	88 23       	and	r24, r24
 af2:	a1 f0       	breq	.+40     	; 0xb1c
   {
		ch = g_rx_buff[0];
 af4:	90 91 2c 01 	lds	r25, 0x012C
        i =  g_rx_ptr;
 af8:	28 2f       	mov	r18, r24
        g_rx_ptr--;
 afa:	21 50       	subi	r18, 0x01	; 1
 afc:	20 93 a0 00 	sts	0x00A0, r18
 b00:	2f 5f       	subi	r18, 0xFF	; 255
		j = 0;
 b02:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_rx_buff[j] =  g_rx_buff[j+1];
 b04:	e3 2f       	mov	r30, r19
 b06:	ff 27       	eor	r31, r31
 b08:	e4 5d       	subi	r30, 0xD4	; 212
 b0a:	fe 4f       	sbci	r31, 0xFE	; 254
 b0c:	81 81       	ldd	r24, Z+1	; 0x01
 b0e:	80 83       	st	Z, r24
	      j++;
 b10:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
 b12:	21 50       	subi	r18, 0x01	; 1
 b14:	b9 f7       	brne	.-18     	; 0xb04
		}
		return ch;
 b16:	89 2f       	mov	r24, r25
 b18:	99 27       	eor	r25, r25
 b1a:	08 95       	ret
   }
   return 0;
 b1c:	80 e0       	ldi	r24, 0x00	; 0
 b1e:	90 e0       	ldi	r25, 0x00	; 0
}
 b20:	08 95       	ret
 b22:	08 95       	ret

00000b24 <uart_put_TX>:

/* Put character into g_tx_buff
    INPUT  : Character to put in buffer
	Output : 0  OK
		   : UART_BUFFER_FULL  Buffer full
*/

uint8_t uart_put_TX ( uint8_t ch)
{
 b24:	98 2f       	mov	r25, r24
// If exceed buffer do nothing until buffer is flushed
    if ((g_tx_ptr > MAX_BUFF)) 
 b26:	80 91 9f 00 	lds	r24, 0x009F
 b2a:	81 38       	cpi	r24, 0x81	; 129
 b2c:	18 f0       	brcs	.+6      	; 0xb34
    {
		return UART_BUFFER_FULL;   // No increase pointer
 b2e:	82 e0       	ldi	r24, 0x02	; 2
 b30:	90 e0       	ldi	r25, 0x00	; 0
 b32:	08 95       	ret
    }
	g_tx_buff[g_tx_ptr]= ch;
 b34:	e8 2f       	mov	r30, r24
 b36:	ff 27       	eor	r31, r31
 b38:	e4 55       	subi	r30, 0x54	; 84
 b3a:	fe 4f       	sbci	r31, 0xFE	; 254
 b3c:	90 83       	st	Z, r25
	g_tx_ptr++;
 b3e:	8f 5f       	subi	r24, 0xFF	; 255
 b40:	80 93 9f 00 	sts	0x009F, r24
	g_tx_buff[g_tx_ptr] = 0;    // Put null character at the end
 b44:	e8 2f       	mov	r30, r24
 b46:	ff 27       	eor	r31, r31
 b48:	e4 55       	subi	r30, 0x54	; 84
 b4a:	fe 4f       	sbci	r31, 0xFE	; 254
 b4c:	10 82       	st	Z, r1
	return 0;
 b4e:	80 e0       	ldi	r24, 0x00	; 0
 b50:	90 e0       	ldi	r25, 0x00	; 0
}
 b52:	08 95       	ret
 b54:	08 95       	ret

00000b56 <uart_get_TX>:


// Get character from TX buffer
uint8_t uart_get_TX (void)
{
   uint8_t i,j,ch =0;
   
   if ( g_tx_ptr)
 b56:	80 91 9f 00 	lds	r24, 0x009F
 b5a:	88 23       	and	r24, r24
 b5c:	a1 f0       	breq	.+40     	; 0xb86
   {
		i  =  g_tx_ptr;
 b5e:	28 2f       	mov	r18, r24
		g_tx_ptr--;
 b60:	21 50       	subi	r18, 0x01	; 1
 b62:	20 93 9f 00 	sts	0x009F, r18
 b66:	2f 5f       	subi	r18, 0xFF	; 255
		ch =  g_tx_buff[0];   // Start from 0 FIFO
 b68:	90 91 ac 01 	lds	r25, 0x01AC
		j = 0;
 b6c:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_tx_buff[j] =  g_tx_buff[j+1];
 b6e:	e3 2f       	mov	r30, r19
 b70:	ff 27       	eor	r31, r31
 b72:	e4 55       	subi	r30, 0x54	; 84
 b74:	fe 4f       	sbci	r31, 0xFE	; 254
 b76:	81 81       	ldd	r24, Z+1	; 0x01
 b78:	80 83       	st	Z, r24
	      j++;
 b7a:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
 b7c:	21 50       	subi	r18, 0x01	; 1
 b7e:	b9 f7       	brne	.-18     	; 0xb6e
		}
		return ch;
 b80:	89 2f       	mov	r24, r25
 b82:	99 27       	eor	r25, r25
 b84:	08 95       	ret
   }
   return 0;
 b86:	80 e0       	ldi	r24, 0x00	; 0
 b88:	90 e0       	ldi	r25, 0x00	; 0
}
 b8a:	08 95       	ret
 b8c:	08 95       	ret

00000b8e <uart_getc>:


uint8_t uart_getc(void)
{
    uint8_t ch;
	ch = uart_get_RX();
 b8e:	0e 94 76 05 	call	0xaec
    return ch ;
}
 b92:	99 27       	eor	r25, r25
 b94:	08 95       	ret

00000b96 <uart_putc>:

uint8_t uart_putc(uint8_t c)
{
    uart_put_TX(c);
 b96:	0e 94 92 05 	call	0xb24
// Enable interrupt UART Data Register empty
   UCSRB  |=  (1<<UDRIE);	
 b9a:	55 9a       	sbi	0x0a, 5	; 10
    return 0;

}
 b9c:	80 e0       	ldi	r24, 0x00	; 0
 b9e:	90 e0       	ldi	r25, 0x00	; 0
 ba0:	08 95       	ret

00000ba2 <uart_puts>:


/*************************************************************************
Function: uart_puts()
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const uint8_t *s )
{
 ba2:	cf 93       	push	r28
 ba4:	df 93       	push	r29
 ba6:	ec 01       	movw	r28, r24
    while (*s) 
      uart_putc(*s++);
 ba8:	88 81       	ld	r24, Y
 baa:	88 23       	and	r24, r24
 bac:	21 f0       	breq	.+8      	; 0xbb6
 bae:	89 91       	ld	r24, Y+
 bb0:	0e 94 cb 05 	call	0xb96
 bb4:	f9 cf       	rjmp	.-14     	; 0xba8
   uart_putc(0x0D); // CR
 bb6:	8d e0       	ldi	r24, 0x0D	; 13
 bb8:	0e 94 cb 05 	call	0xb96
	uart_putc(0x0A); // LF
 bbc:	8a e0       	ldi	r24, 0x0A	; 10
 bbe:	0e 94 cb 05 	call	0xb96
 bc2:	df 91       	pop	r29
 bc4:	cf 91       	pop	r28
 bc6:	08 95       	ret

00000bc8 <debug_value>:
}

/*
Show debug value
*/

void  debug_value ( int16_t value, uint8_t radix)
{
 bc8:	cf 93       	push	r28
 bca:	df 93       	push	r29
 bcc:	cd b7       	in	r28, 0x3d	; 61
 bce:	de b7       	in	r29, 0x3e	; 62
 bd0:	64 97       	sbiw	r28, 0x14	; 20
 bd2:	0f b6       	in	r0, 0x3f	; 63
 bd4:	f8 94       	cli
 bd6:	de bf       	out	0x3e, r29	; 62
 bd8:	0f be       	out	0x3f, r0	; 63
 bda:	cd bf       	out	0x3d, r28	; 61
 bdc:	26 2f       	mov	r18, r22
   uint8_t  buff[20];
   
   itoa (value,buff, radix);
 bde:	33 27       	eor	r19, r19
 be0:	a9 01       	movw	r20, r18
 be2:	be 01       	movw	r22, r28
 be4:	6f 5f       	subi	r22, 0xFF	; 255
 be6:	7f 4f       	sbci	r23, 0xFF	; 255
 be8:	0e 94 37 07 	call	0xe6e
    uart_puts ( buff);
 bec:	ce 01       	movw	r24, r28
 bee:	01 96       	adiw	r24, 0x01	; 1
 bf0:	0e 94 d1 05 	call	0xba2
 bf4:	64 96       	adiw	r28, 0x14	; 20
 bf6:	0f b6       	in	r0, 0x3f	; 63
 bf8:	f8 94       	cli
 bfa:	de bf       	out	0x3e, r29	; 62
 bfc:	0f be       	out	0x3f, r0	; 63
 bfe:	cd bf       	out	0x3d, r28	; 61
 c00:	df 91       	pop	r29
 c02:	cf 91       	pop	r28
 c04:	08 95       	ret

00000c06 <adc_init>:
      Bit 5   left or right adjust bit in ADLAR
*/
void adc_init(uint8_t voltage)
{
    ADCSRA = 0xC7 | (1<< ADEN);
 c06:	97 ec       	ldi	r25, 0xC7	; 199
 c08:	96 b9       	out	0x06, r25	; 6
	
// Set voltage reference 	
	ADMUX  =  voltage << 6;
 c0a:	82 95       	swap	r24
 c0c:	88 0f       	add	r24, r24
 c0e:	88 0f       	add	r24, r24
 c10:	80 7c       	andi	r24, 0xC0	; 192
 c12:	87 b9       	out	0x07, r24	; 7

// Set input for ADC pin
    DDRA    &= 0xF0;	
 c14:	8a b3       	in	r24, 0x1a	; 26
 c16:	80 7f       	andi	r24, 0xF0	; 240
 c18:	8a bb       	out	0x1a, r24	; 26
 c1a:	08 95       	ret

00000c1c <adc_enable_int>:

}

/*
  Input mode = 0  Disable
        mode > 0  Enable


*/
void  adc_enable_int (uint8_t mode)
{
    if (mode)
 c1c:	88 23       	and	r24, r24
 c1e:	19 f0       	breq	.+6      	; 0xc26
	{
		ADCSRA  |= ( (1 << ADEN) | (1 << ADIE) | (1<< ADSC));
 c20:	86 b1       	in	r24, 0x06	; 6
 c22:	88 6c       	ori	r24, 0xC8	; 200
 c24:	02 c0       	rjmp	.+4      	; 0xc2a
    }
	else
	{
		ADCSRA  &= ~((1 << ADIE) | (1<< ADSC));
 c26:	86 b1       	in	r24, 0x06	; 6
 c28:	87 7b       	andi	r24, 0xB7	; 183
 c2a:	86 b9       	out	0x06, r24	; 6
 c2c:	08 95       	ret
 c2e:	08 95       	ret

00000c30 <read_adc>:
	}
}


/*
Read adc value		
	
	INPUT :  channel  to read adc  ( See table for Differential INput and Gain)
    Polling mode 
*/

int16_t read_adc(uint8_t channel)
{
  int16_t  value;
  
 
// Before that need to clear ADATE and ADEN
    ADCSRA &= ~((1 << ADEN) | (1<< ADATE));
 c30:	96 b1       	in	r25, 0x06	; 6
 c32:	9f 75       	andi	r25, 0x5F	; 95
 c34:	96 b9       	out	0x06, r25	; 6

// Set channel
    ADMUX |= channel;
 c36:	97 b1       	in	r25, 0x07	; 7
 c38:	98 2b       	or	r25, r24
 c3a:	97 b9       	out	0x07, r25	; 7
	
// Enable conversion
	ADCSRA |= (1<<ADEN);
 c3c:	37 9a       	sbi	0x06, 7	; 6
// Start conversion
 
    
// Check whether conversion is complete
 
    ADCSRA |= (1<<ADSC);         // do single conversion
 c3e:	36 9a       	sbi	0x06, 6	; 6
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
 c40:	34 9b       	sbis	0x06, 4	; 6
 c42:	fe cf       	rjmp	.-4      	; 0xc40

//Read value
//      value = ADCL;            // read out ADCL register
//      value += (ADCH << 8);    // read out ADCH register        
	value = ADCW;
 c44:	84 b1       	in	r24, 0x04	; 4
 c46:	95 b1       	in	r25, 0x05	; 5
 c48:	08 95       	ret

00000c4a <text_decode>:

*/ 

uint8_t text_decode (uint8_t *buffer, uint8_t *cmd_argument)
{
 c4a:	cf 92       	push	r12
 c4c:	df 92       	push	r13
 c4e:	ef 92       	push	r14
 c50:	ff 92       	push	r15
 c52:	0f 93       	push	r16
 c54:	1f 93       	push	r17
 c56:	cf 93       	push	r28
 c58:	7c 01       	movw	r14, r24

 uint8_t  found,ch,ch2,cmd_no,j,k,index,cmd_complete;
 uint8_t  state = WAIT_CMD_STATE, quote  = 0;
 c5a:	51 e0       	ldi	r21, 0x01	; 1
 static uint16_t i=0; // Keep pointer for next command decode
 cmd_complete = 0;
 c5c:	cc 24       	eor	r12, r12
 cmd_no 	= 0;
 c5e:	dc 2c       	mov	r13, r12
 index 		= 0;
 c60:	4c 2d       	mov	r20, r12
 
 cmd_argument  = buffer;
 
 while (*(buffer+i))	  		//End with NULL
 {
// Check with delimiter

 	 j = 0;
	 found = 0;
	
	switch (state)
	{
	  case WAIT_CMD_STATE:   // If found first character in command table  then go to get_cmd state
 		j = 0;
		while ((ch = pgm_read_byte(&text_cmd[j][0])))     //Check first charaters in cmd table
		{ 
		  if (*(buffer+i) == ch)
		  {
			state = GET_CMD_STATE;   // Found delimiter
			*(cmd_argument) = ch;
			index = 1;
			break; 
		  }
		 j++;
		}  
	    break;
	  case GET_CMD_STATE:
	    ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
		if (found)
		{
        	*(cmd_argument+index) = 0x00;
		     if (ch == '=')
			 {
// Check command number 
  				for (k = 0; k < CMD_NUM ; k++)
				{
					if (!(strcasecmp_P(cmd_argument,&text_cmd[k][0])))  // Found then keep command
					{
						cmd_no  = k+1;   // Start from 0 
						break;
					}
				}
// clear index
  				index = 0;
			    state = WAIT_ARG_STATE;	
			 }	
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}
		break;
		
	  case WAIT_ARG_STATE:
		ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
				
		if ( ch == '"')   // Start quote
		{
			quote ^= 1;   // Toggle quote	
			state = GET_ARG_STATE;   
 			index = 0;
		}
		
		if (!found)    // Not delimiter start get Argument
		{
			state = GET_ARG_STATE;   
			*(cmd_argument) = ch;
			index = 1;
		}
		break;	
	  case	GET_ARG_STATE:
	  	ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
 		if ( ch == '"')     // End quote
		{
			quote ^= 1;   // Toggle quote	
   		}
		if ( quote)
		{
         	found = 0; //  ignore all characters after the quote until found quote again
// Cancel quote
            
		}	
		if (found)
		{	
            cmd_complete = 1;
			*(cmd_argument+index) = 0;
		    state = WAIT_CMD_STATE;
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}  
		break;
	}
	
	if(cmd_complete)   // COmmand both cmd number and argument
	{
		return cmd_no;	 	 
	}
	i++;
 c62:	e0 91 a1 00 	lds	r30, 0x00A1
 c66:	f0 91 a2 00 	lds	r31, 0x00A2
 c6a:	ee 0d       	add	r30, r14
 c6c:	ff 1d       	adc	r31, r15
 c6e:	80 81       	ld	r24, Z
 c70:	88 23       	and	r24, r24
 c72:	09 f4       	brne	.+2      	; 0xc76
 c74:	c1 c0       	rjmp	.+386    	; 0xdf8
 c76:	30 e0       	ldi	r19, 0x00	; 0
 c78:	85 2f       	mov	r24, r21
 c7a:	99 27       	eor	r25, r25
 c7c:	82 30       	cpi	r24, 0x02	; 2
 c7e:	91 05       	cpc	r25, r1
 c80:	79 f1       	breq	.+94     	; 0xce0
 c82:	83 30       	cpi	r24, 0x03	; 3
 c84:	91 05       	cpc	r25, r1
 c86:	1c f4       	brge	.+6      	; 0xc8e
 c88:	01 97       	sbiw	r24, 0x01	; 1
 c8a:	59 f0       	breq	.+22     	; 0xca2
 c8c:	ab c0       	rjmp	.+342    	; 0xde4
 c8e:	83 30       	cpi	r24, 0x03	; 3
 c90:	91 05       	cpc	r25, r1
 c92:	09 f4       	brne	.+2      	; 0xc96
 c94:	5a c0       	rjmp	.+180    	; 0xd4a
 c96:	04 97       	sbiw	r24, 0x04	; 4
 c98:	09 f4       	brne	.+2      	; 0xc9c
 c9a:	7b c0       	rjmp	.+246    	; 0xd92
 c9c:	a3 c0       	rjmp	.+326    	; 0xde4
 c9e:	52 e0       	ldi	r21, 0x02	; 2
 ca0:	72 c0       	rjmp	.+228    	; 0xd86
 ca2:	23 2f       	mov	r18, r19
 ca4:	ec e5       	ldi	r30, 0x5C	; 92
 ca6:	f0 e0       	ldi	r31, 0x00	; 0
 ca8:	94 91       	lpm	r25, Z
 caa:	99 23       	and	r25, r25
 cac:	09 f4       	brne	.+2      	; 0xcb0
 cae:	9a c0       	rjmp	.+308    	; 0xde4
 cb0:	e0 91 a1 00 	lds	r30, 0x00A1
 cb4:	f0 91 a2 00 	lds	r31, 0x00A2
 cb8:	ee 0d       	add	r30, r14
 cba:	ff 1d       	adc	r31, r15
 cbc:	80 81       	ld	r24, Z
 cbe:	3a e0       	ldi	r19, 0x0A	; 10
 cc0:	89 17       	cp	r24, r25
 cc2:	69 f3       	breq	.-38     	; 0xc9e
 cc4:	2f 5f       	subi	r18, 0xFF	; 255
 cc6:	23 9f       	mul	r18, r19
 cc8:	f0 01       	movw	r30, r0
 cca:	11 24       	eor	r1, r1
 ccc:	e4 5a       	subi	r30, 0xA4	; 164
 cce:	ff 4f       	sbci	r31, 0xFF	; 255
 cd0:	94 91       	lpm	r25, Z
 cd2:	99 23       	and	r25, r25
 cd4:	a9 f7       	brne	.-22     	; 0xcc0
 cd6:	86 c0       	rjmp	.+268    	; 0xde4
 cd8:	31 e0       	ldi	r19, 0x01	; 1
 cda:	17 c0       	rjmp	.+46     	; 0xd0a
 cdc:	c2 2e       	mov	r12, r18
 cde:	30 c0       	rjmp	.+96     	; 0xd40
 ce0:	e0 91 a1 00 	lds	r30, 0x00A1
 ce4:	f0 91 a2 00 	lds	r31, 0x00A2
 ce8:	ee 0d       	add	r30, r14
 cea:	ff 1d       	adc	r31, r15
 cec:	90 81       	ld	r25, Z
 cee:	23 2f       	mov	r18, r19
 cf0:	e4 e5       	ldi	r30, 0x54	; 84
 cf2:	f0 e0       	ldi	r31, 0x00	; 0
 cf4:	84 91       	lpm	r24, Z
 cf6:	88 23       	and	r24, r24
 cf8:	41 f0       	breq	.+16     	; 0xd0a
 cfa:	98 17       	cp	r25, r24
 cfc:	69 f3       	breq	.-38     	; 0xcd8
 cfe:	2f 5f       	subi	r18, 0xFF	; 255
 d00:	e2 2f       	mov	r30, r18
 d02:	ff 27       	eor	r31, r31
 d04:	ec 5a       	subi	r30, 0xAC	; 172
 d06:	ff 4f       	sbci	r31, 0xFF	; 255
 d08:	f5 cf       	rjmp	.-22     	; 0xcf4
 d0a:	e4 2f       	mov	r30, r20
 d0c:	ff 27       	eor	r31, r31
 d0e:	33 23       	and	r19, r19
 d10:	09 f4       	brne	.+2      	; 0xd14
 d12:	64 c0       	rjmp	.+200    	; 0xddc
 d14:	ee 0d       	add	r30, r14
 d16:	ff 1d       	adc	r31, r15
 d18:	10 82       	st	Z, r1
 d1a:	9d 33       	cpi	r25, 0x3D	; 61
 d1c:	09 f0       	breq	.+2      	; 0xd20
 d1e:	62 c0       	rjmp	.+196    	; 0xde4
 d20:	c0 81       	ld	r28, Z
 d22:	0c e5       	ldi	r16, 0x5C	; 92
 d24:	10 e0       	ldi	r17, 0x00	; 0
 d26:	b8 01       	movw	r22, r16
 d28:	c7 01       	movw	r24, r14
 d2a:	0e 94 64 07 	call	0xec8
 d2e:	2c 2f       	mov	r18, r28
 d30:	2f 5f       	subi	r18, 0xFF	; 255
 d32:	89 2b       	or	r24, r25
 d34:	99 f2       	breq	.-90     	; 0xcdc
 d36:	c2 2f       	mov	r28, r18
 d38:	06 5f       	subi	r16, 0xF6	; 246
 d3a:	1f 4f       	sbci	r17, 0xFF	; 255
 d3c:	24 30       	cpi	r18, 0x04	; 4
 d3e:	98 f3       	brcs	.-26     	; 0xd26
 d40:	40 e0       	ldi	r20, 0x00	; 0
 d42:	53 e0       	ldi	r21, 0x03	; 3
 d44:	4f c0       	rjmp	.+158    	; 0xde4
 d46:	31 e0       	ldi	r19, 0x01	; 1
 d48:	15 c0       	rjmp	.+42     	; 0xd74
 d4a:	e0 91 a1 00 	lds	r30, 0x00A1
 d4e:	f0 91 a2 00 	lds	r31, 0x00A2
 d52:	ee 0d       	add	r30, r14
 d54:	ff 1d       	adc	r31, r15
 d56:	90 81       	ld	r25, Z
 d58:	23 2f       	mov	r18, r19
 d5a:	e4 e5       	ldi	r30, 0x54	; 84
 d5c:	f0 e0       	ldi	r31, 0x00	; 0
 d5e:	84 91       	lpm	r24, Z
 d60:	88 23       	and	r24, r24
 d62:	41 f0       	breq	.+16     	; 0xd74
 d64:	98 17       	cp	r25, r24
 d66:	79 f3       	breq	.-34     	; 0xd46
 d68:	2f 5f       	subi	r18, 0xFF	; 255
 d6a:	e2 2f       	mov	r30, r18
 d6c:	ff 27       	eor	r31, r31
 d6e:	ec 5a       	subi	r30, 0xAC	; 172
 d70:	ff 4f       	sbci	r31, 0xFF	; 255
 d72:	f5 cf       	rjmp	.-22     	; 0xd5e
 d74:	92 32       	cpi	r25, 0x22	; 34
 d76:	21 f4       	brne	.+8      	; 0xd80
 d78:	81 e0       	ldi	r24, 0x01	; 1
 d7a:	d8 26       	eor	r13, r24
 d7c:	54 e0       	ldi	r21, 0x04	; 4
 d7e:	40 e0       	ldi	r20, 0x00	; 0
 d80:	33 23       	and	r19, r19
 d82:	81 f5       	brne	.+96     	; 0xde4
 d84:	54 e0       	ldi	r21, 0x04	; 4
 d86:	f7 01       	movw	r30, r14
 d88:	90 83       	st	Z, r25
 d8a:	41 e0       	ldi	r20, 0x01	; 1
 d8c:	2b c0       	rjmp	.+86     	; 0xde4
 d8e:	31 e0       	ldi	r19, 0x01	; 1
 d90:	15 c0       	rjmp	.+42     	; 0xdbc
 d92:	e0 91 a1 00 	lds	r30, 0x00A1
 d96:	f0 91 a2 00 	lds	r31, 0x00A2
 d9a:	ee 0d       	add	r30, r14
 d9c:	ff 1d       	adc	r31, r15
 d9e:	90 81       	ld	r25, Z
 da0:	23 2f       	mov	r18, r19
 da2:	e4 e5       	ldi	r30, 0x54	; 84
 da4:	f0 e0       	ldi	r31, 0x00	; 0
 da6:	84 91       	lpm	r24, Z
 da8:	88 23       	and	r24, r24
 daa:	41 f0       	breq	.+16     	; 0xdbc
 dac:	98 17       	cp	r25, r24
 dae:	79 f3       	breq	.-34     	; 0xd8e
 db0:	2f 5f       	subi	r18, 0xFF	; 255
 db2:	e2 2f       	mov	r30, r18
 db4:	ff 27       	eor	r31, r31
 db6:	ec 5a       	subi	r30, 0xAC	; 172
 db8:	ff 4f       	sbci	r31, 0xFF	; 255
 dba:	f5 cf       	rjmp	.-22     	; 0xda6
 dbc:	92 32       	cpi	r25, 0x22	; 34
 dbe:	11 f4       	brne	.+4      	; 0xdc4
 dc0:	81 e0       	ldi	r24, 0x01	; 1
 dc2:	d8 26       	eor	r13, r24
 dc4:	d1 10       	cpse	r13, r1
 dc6:	30 e0       	ldi	r19, 0x00	; 0
 dc8:	e4 2f       	mov	r30, r20
 dca:	ff 27       	eor	r31, r31
 dcc:	33 23       	and	r19, r19
 dce:	31 f0       	breq	.+12     	; 0xddc
 dd0:	ee 0d       	add	r30, r14
 dd2:	ff 1d       	adc	r31, r15
 dd4:	10 82       	st	Z, r1
 dd6:	8c 2d       	mov	r24, r12
 dd8:	99 27       	eor	r25, r25
 dda:	14 c0       	rjmp	.+40     	; 0xe04
 ddc:	ee 0d       	add	r30, r14
 dde:	ff 1d       	adc	r31, r15
 de0:	90 83       	st	Z, r25
 de2:	4f 5f       	subi	r20, 0xFF	; 255
 de4:	e0 91 a1 00 	lds	r30, 0x00A1
 de8:	f0 91 a2 00 	lds	r31, 0x00A2
 dec:	31 96       	adiw	r30, 0x01	; 1
 dee:	f0 93 a2 00 	sts	0x00A2, r31
 df2:	e0 93 a1 00 	sts	0x00A1, r30
 df6:	39 cf       	rjmp	.-398    	; 0xc6a
 }
  i = 0;
 df8:	10 92 a2 00 	sts	0x00A2, r1
 dfc:	10 92 a1 00 	sts	0x00A1, r1
  return 0xFF;  // End of Buffer
 e00:	8f ef       	ldi	r24, 0xFF	; 255
 e02:	90 e0       	ldi	r25, 0x00	; 0
 e04:	cf 91       	pop	r28
 e06:	1f 91       	pop	r17
 e08:	0f 91       	pop	r16
 e0a:	ff 90       	pop	r15
 e0c:	ef 90       	pop	r14
 e0e:	df 90       	pop	r13
 e10:	cf 90       	pop	r12
 e12:	08 95       	ret

00000e14 <atoi>:
 e14:	fc 01       	movw	r30, r24
 e16:	88 27       	eor	r24, r24
 e18:	99 27       	eor	r25, r25
 e1a:	e8 94       	clt

00000e1c <.atoi_loop>:
 e1c:	21 91       	ld	r18, Z+
 e1e:	22 23       	and	r18, r18
 e20:	f1 f0       	breq	.+60     	; 0xe5e
 e22:	20 32       	cpi	r18, 0x20	; 32
 e24:	d9 f3       	breq	.-10     	; 0xe1c
 e26:	29 30       	cpi	r18, 0x09	; 9
 e28:	c9 f3       	breq	.-14     	; 0xe1c
 e2a:	2a 30       	cpi	r18, 0x0A	; 10
 e2c:	b9 f3       	breq	.-18     	; 0xe1c
 e2e:	2c 30       	cpi	r18, 0x0C	; 12
 e30:	a9 f3       	breq	.-22     	; 0xe1c
 e32:	2d 30       	cpi	r18, 0x0D	; 13
 e34:	99 f3       	breq	.-26     	; 0xe1c
 e36:	26 37       	cpi	r18, 0x76	; 118
 e38:	89 f3       	breq	.-30     	; 0xe1c
 e3a:	2b 32       	cpi	r18, 0x2B	; 43
 e3c:	19 f0       	breq	.+6      	; 0xe44
 e3e:	2d 32       	cpi	r18, 0x2D	; 45
 e40:	21 f4       	brne	.+8      	; 0xe4a

00000e42 <.atoi_neg>:
 e42:	68 94       	set

00000e44 <.atoi_loop2>:
 e44:	21 91       	ld	r18, Z+
 e46:	22 23       	and	r18, r18
 e48:	51 f0       	breq	.+20     	; 0xe5e

00000e4a <.atoi_digit>:
 e4a:	20 33       	cpi	r18, 0x30	; 48
 e4c:	44 f0       	brlt	.+16     	; 0xe5e
 e4e:	2a 33       	cpi	r18, 0x3A	; 58
 e50:	34 f4       	brge	.+12     	; 0xe5e
 e52:	20 53       	subi	r18, 0x30	; 48
 e54:	0e 94 5c 07 	call	0xeb8
 e58:	82 0f       	add	r24, r18
 e5a:	91 1d       	adc	r25, r1
 e5c:	f3 cf       	rjmp	.-26     	; 0xe44

00000e5e <.atoi_sig>:
 e5e:	81 15       	cp	r24, r1
 e60:	91 05       	cpc	r25, r1
 e62:	21 f0       	breq	.+8      	; 0xe6c
 e64:	1e f4       	brtc	.+6      	; 0xe6c
 e66:	80 95       	com	r24
 e68:	90 95       	com	r25
 e6a:	01 96       	adiw	r24, 0x01	; 1

00000e6c <.atoi_done>:
 e6c:	08 95       	ret

00000e6e <itoa>:
 e6e:	e6 2f       	mov	r30, r22
 e70:	f7 2f       	mov	r31, r23
 e72:	2e 2f       	mov	r18, r30
 e74:	3f 2f       	mov	r19, r31
 e76:	e8 94       	clt
 e78:	42 30       	cpi	r20, 0x02	; 2
 e7a:	cc f0       	brlt	.+50     	; 0xeae
 e7c:	45 32       	cpi	r20, 0x25	; 37
 e7e:	bc f4       	brge	.+46     	; 0xeae
 e80:	4a 30       	cpi	r20, 0x0A	; 10
 e82:	29 f4       	brne	.+10     	; 0xe8e
 e84:	97 fb       	bst	r25, 7
 e86:	1e f4       	brtc	.+6      	; 0xe8e
 e88:	90 95       	com	r25
 e8a:	81 95       	neg	r24
 e8c:	9f 4f       	sbci	r25, 0xFF	; 255

00000e8e <divide_loop>:
 e8e:	64 2f       	mov	r22, r20
 e90:	77 27       	eor	r23, r23
 e92:	0e 94 87 07 	call	0xf0e
 e96:	80 5d       	subi	r24, 0xD0	; 208
 e98:	8a 33       	cpi	r24, 0x3A	; 58
 e9a:	0c f0       	brlt	.+2      	; 0xe9e
 e9c:	89 5d       	subi	r24, 0xD9	; 217

00000e9e <L_10>:
 e9e:	81 93       	st	Z+, r24
 ea0:	86 2f       	mov	r24, r22
 ea2:	97 2f       	mov	r25, r23
 ea4:	00 97       	sbiw	r24, 0x00	; 0
 ea6:	99 f7       	brne	.-26     	; 0xe8e
 ea8:	16 f4       	brtc	.+4      	; 0xeae
 eaa:	5d e2       	ldi	r21, 0x2D	; 45
 eac:	51 93       	st	Z+, r21

00000eae <terminate>:
 eae:	93 2f       	mov	r25, r19
 eb0:	82 2f       	mov	r24, r18
 eb2:	10 82       	st	Z, r1
 eb4:	0c 94 77 07 	jmp	0xeee

00000eb8 <__mulhi_const_10>:
 eb8:	7a e0       	ldi	r23, 0x0A	; 10
 eba:	97 9f       	mul	r25, r23
 ebc:	90 2d       	mov	r25, r0
 ebe:	87 9f       	mul	r24, r23
 ec0:	80 2d       	mov	r24, r0
 ec2:	91 0d       	add	r25, r1
 ec4:	11 24       	eor	r1, r1
 ec6:	08 95       	ret

00000ec8 <strcasecmp_P>:
 ec8:	fb 01       	movw	r30, r22
 eca:	dc 01       	movw	r26, r24

00000ecc <.strcasecmp_P_loop>:
 ecc:	8d 91       	ld	r24, X+
 ece:	05 90       	lpm	r0, Z+
 ed0:	60 2d       	mov	r22, r0
 ed2:	50 2d       	mov	r21, r0
 ed4:	50 62       	ori	r21, 0x20	; 32
 ed6:	51 36       	cpi	r21, 0x61	; 97
 ed8:	24 f0       	brlt	.+8      	; 0xee2
 eda:	5b 37       	cpi	r21, 0x7B	; 123
 edc:	14 f4       	brge	.+4      	; 0xee2
 ede:	60 62       	ori	r22, 0x20	; 32
 ee0:	80 62       	ori	r24, 0x20	; 32

00000ee2 <.strcasecmp_P_tst>:
 ee2:	86 1b       	sub	r24, r22
 ee4:	11 f4       	brne	.+4      	; 0xeea
 ee6:	00 20       	and	r0, r0
 ee8:	89 f7       	brne	.-30     	; 0xecc

00000eea <.strcasecmp_P_done>:
 eea:	99 0b       	sbc	r25, r25
 eec:	08 95       	ret

00000eee <strrev>:
 eee:	dc 01       	movw	r26, r24
 ef0:	fc 01       	movw	r30, r24

00000ef2 <.strrev_eos>:
 ef2:	01 90       	ld	r0, Z+
 ef4:	00 20       	and	r0, r0
 ef6:	e9 f7       	brne	.-6      	; 0xef2
 ef8:	32 97       	sbiw	r30, 0x02	; 2

00000efa <.strrev_loop>:
 efa:	ae 17       	cp	r26, r30
 efc:	bf 07       	cpc	r27, r31
 efe:	30 f4       	brcc	.+12     	; 0xf0c
 f00:	7c 91       	ld	r23, X
 f02:	60 81       	ld	r22, Z
 f04:	70 83       	st	Z, r23
 f06:	31 97       	sbiw	r30, 0x01	; 1
 f08:	6d 93       	st	X+, r22
 f0a:	f7 cf       	rjmp	.-18     	; 0xefa

00000f0c <.strrev_done>:
 f0c:	08 95       	ret

00000f0e <__udivmodhi4>:
 f0e:	aa 1b       	sub	r26, r26
 f10:	bb 1b       	sub	r27, r27
 f12:	51 e1       	ldi	r21, 0x11	; 17
 f14:	07 c0       	rjmp	.+14     	; 0xf24

00000f16 <__udivmodhi4_loop>:
 f16:	aa 1f       	adc	r26, r26
 f18:	bb 1f       	adc	r27, r27
 f1a:	a6 17       	cp	r26, r22
 f1c:	b7 07       	cpc	r27, r23
 f1e:	10 f0       	brcs	.+4      	; 0xf24
 f20:	a6 1b       	sub	r26, r22
 f22:	b7 0b       	sbc	r27, r23

00000f24 <__udivmodhi4_ep>:
 f24:	88 1f       	adc	r24, r24
 f26:	99 1f       	adc	r25, r25
 f28:	5a 95       	dec	r21
 f2a:	a9 f7       	brne	.-22     	; 0xf16
 f2c:	80 95       	com	r24
 f2e:	90 95       	com	r25
 f30:	bc 01       	movw	r22, r24
 f32:	cd 01       	movw	r24, r26
 f34:	08 95       	ret
