
backemf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000de0  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000038  00800060  00000de0  00000e74  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000019b  00800098  00800098  00000eac  2**0
                  ALLOC
  3 .noinit       00000000  00800233  00800233  00000eac  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00000eac  2**0
                  CONTENTS
  5 .stab         00002520  00000000  00000000  00000eac  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000f78  00000000  00000000  000033cc  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 42 00 	jmp	0x84
   4:	0c 94 5d 00 	jmp	0xba
   8:	0c 94 5d 00 	jmp	0xba
   c:	0c 94 5d 00 	jmp	0xba
  10:	0c 94 5d 00 	jmp	0xba
  14:	0c 94 5d 00 	jmp	0xba
  18:	0c 94 f2 02 	jmp	0x5e4
  1c:	0c 94 5d 00 	jmp	0xba
  20:	0c 94 5d 00 	jmp	0xba
  24:	0c 94 5d 00 	jmp	0xba
  28:	0c 94 6b 02 	jmp	0x4d6
  2c:	0c 94 41 02 	jmp	0x482
  30:	0c 94 5d 00 	jmp	0xba
  34:	0c 94 98 02 	jmp	0x530
  38:	0c 94 c9 02 	jmp	0x592
  3c:	0c 94 5d 00 	jmp	0xba
  40:	0c 94 5d 00 	jmp	0xba
  44:	0c 94 5d 00 	jmp	0xba
  48:	0c 94 5d 00 	jmp	0xba
  4c:	0c 94 5d 00 	jmp	0xba
  50:	0c 94 5d 00 	jmp	0xba

00000054 <__ctors_end>:
  54:	3d 22       	and	r3, r29
  56:	20 09       	sbc	r18, r0
  58:	2c 0d       	add	r18, r12
  5a:	0a 00       	.word	0x000a	; ????

0000005c <text_cmd>:
  5c:	6d 6f 74 6f 72 00 00 00 00 00 73 70 65 65 64 00     motor.....speed.
  6c:	00 00 00 00 61 6e 67 6c 65 00 00 00 00 00 00 00     ....angle.......
	...

00000084 <__init>:
  84:	11 24       	eor	r1, r1
  86:	1f be       	out	0x3f, r1	; 63
  88:	cf e5       	ldi	r28, 0x5F	; 95
  8a:	d8 e0       	ldi	r29, 0x08	; 8
  8c:	de bf       	out	0x3e, r29	; 62
  8e:	cd bf       	out	0x3d, r28	; 61

00000090 <__do_copy_data>:
  90:	10 e0       	ldi	r17, 0x00	; 0
  92:	a0 e6       	ldi	r26, 0x60	; 96
  94:	b0 e0       	ldi	r27, 0x00	; 0
  96:	e0 ee       	ldi	r30, 0xE0	; 224
  98:	fd e0       	ldi	r31, 0x0D	; 13
  9a:	02 c0       	rjmp	.+4      	; 0xa0

0000009c <.do_copy_data_loop>:
  9c:	05 90       	lpm	r0, Z+
  9e:	0d 92       	st	X+, r0

000000a0 <.do_copy_data_start>:
  a0:	a8 39       	cpi	r26, 0x98	; 152
  a2:	b1 07       	cpc	r27, r17
  a4:	d9 f7       	brne	.-10     	; 0x9c

000000a6 <__do_clear_bss>:
  a6:	12 e0       	ldi	r17, 0x02	; 2
  a8:	a8 e9       	ldi	r26, 0x98	; 152
  aa:	b0 e0       	ldi	r27, 0x00	; 0
  ac:	01 c0       	rjmp	.+2      	; 0xb0

000000ae <.do_clear_bss_loop>:
  ae:	1d 92       	st	X+, r1

000000b0 <.do_clear_bss_start>:
  b0:	a3 33       	cpi	r26, 0x33	; 51
  b2:	b1 07       	cpc	r27, r17
  b4:	e1 f7       	brne	.-8      	; 0xae
  b6:	0c 94 44 03 	jmp	0x688

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0x0

000000be <delay>:

void delay ( uint16_t  time)
{
   uint16_t i;
   for (i = 0 ; i < time; i++);
  be:	00 97       	sbiw	r24, 0x00	; 0
  c0:	11 f0       	breq	.+4      	; 0xc6
  c2:	01 97       	sbiw	r24, 0x01	; 1
  c4:	fc cf       	rjmp	.-8      	; 0xbe
  c6:	08 95       	ret

000000c8 <set_motor_parameter>:

}

void  set_motor_parameter ( uint8_t mode)
{
   switch (mode)
  c8:	28 2f       	mov	r18, r24
  ca:	33 27       	eor	r19, r19
  cc:	22 30       	cpi	r18, 0x02	; 2
  ce:	31 05       	cpc	r19, r1
  d0:	b9 f0       	breq	.+46     	; 0x100
  d2:	23 30       	cpi	r18, 0x03	; 3
  d4:	31 05       	cpc	r19, r1
  d6:	3c f4       	brge	.+14     	; 0xe6
  d8:	21 15       	cp	r18, r1
  da:	31 05       	cpc	r19, r1
  dc:	a9 f0       	breq	.+42     	; 0x108
  de:	21 30       	cpi	r18, 0x01	; 1
  e0:	31 05       	cpc	r19, r1
  e2:	41 f0       	breq	.+16     	; 0xf4
  e4:	34 c0       	rjmp	.+104    	; 0x14e
  e6:	24 30       	cpi	r18, 0x04	; 4
  e8:	31 05       	cpc	r19, r1
  ea:	d9 f0       	breq	.+54     	; 0x122
  ec:	25 30       	cpi	r18, 0x05	; 5
  ee:	31 05       	cpc	r19, r1
  f0:	49 f1       	breq	.+82     	; 0x144
  f2:	2d c0       	rjmp	.+90     	; 0x14e
   {
    case  MOTOR_FORWARD:
        g_mode[0] = MOTOR_FORWARD;		
  f4:	81 e0       	ldi	r24, 0x01	; 1
  f6:	80 93 9d 00 	sts	0x009D, r24
		g_mode[1] = MOTOR_FORWARD;
  fa:	80 93 9e 00 	sts	0x009E, r24
  fe:	08 c0       	rjmp	.+16     	; 0x110
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case  MOTOR_BACKWARD:
		g_mode[0] = MOTOR_BACKWARD;
 100:	82 e0       	ldi	r24, 0x02	; 2
 102:	80 93 9d 00 	sts	0x009D, r24
 106:	11 c0       	rjmp	.+34     	; 0x12a
		g_mode[1] = MOTOR_BACKWARD;
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
    case MOTOR_STOP:
		g_mode[0]  = MOTOR_STOP;
 108:	10 92 9d 00 	sts	0x009D, r1
		g_mode[1]  = MOTOR_STOP;
 10c:	10 92 9e 00 	sts	0x009E, r1
		g_angle[0] = 0;
 110:	30 93 ab 00 	sts	0x00AB, r19
 114:	20 93 aa 00 	sts	0x00AA, r18
		g_angle[1] = 0;
 118:	30 93 ad 00 	sts	0x00AD, r19
 11c:	20 93 ac 00 	sts	0x00AC, r18
		break;
 120:	08 95       	ret
	case MOTOR_TURN_LEFT:
		g_mode[0] = MOTOR_FORWARD;		
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	80 93 9d 00 	sts	0x009D, r24
		g_mode[1] = MOTOR_BACKWARD;
 128:	82 e0       	ldi	r24, 0x02	; 2
 12a:	80 93 9e 00 	sts	0x009E, r24
		g_angle[0] = 1;
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	90 93 ab 00 	sts	0x00AB, r25
 136:	80 93 aa 00 	sts	0x00AA, r24
		g_angle[1] = 1;
 13a:	90 93 ad 00 	sts	0x00AD, r25
 13e:	80 93 ac 00 	sts	0x00AC, r24
		break;
 142:	08 95       	ret
	case MOTOR_TURN_RIGHT:
		g_mode[0] = MOTOR_BACKWARD;
 144:	82 e0       	ldi	r24, 0x02	; 2
 146:	80 93 9d 00 	sts	0x009D, r24
		g_mode[1] = MOTOR_FORWARD;
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	ee cf       	rjmp	.-36     	; 0x12a
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	 default:
	 	g_mode[0]  = MOTOR_STOP;
 14e:	10 92 9d 00 	sts	0x009D, r1
		g_mode[1]  = MOTOR_STOP;
 152:	10 92 9e 00 	sts	0x009E, r1
		g_angle[0] = 0;
 156:	10 92 ab 00 	sts	0x00AB, r1
 15a:	10 92 aa 00 	sts	0x00AA, r1
		g_angle[1] = 0;
 15e:	10 92 ad 00 	sts	0x00AD, r1
 162:	10 92 ac 00 	sts	0x00AC, r1
 166:	08 95       	ret
 168:	08 95       	ret

0000016a <remote_decode>:
		break;
   }
  
}

/* This subroutine will handle IR remote decode by getting remote code from Interrupt handle for input capture
and will response  to each remote key. For other applications user can modified here for different remote active
However this routine support Sony remote control only
   global effect   g_irint;
*/

void remote_decode ( uint16_t ircode)
{ 
 16a:	cf 93       	push	r28

  uint8_t set_speed = 8 ;
 16c:	c8 e0       	ldi	r28, 0x08	; 8
  switch ( ircode)
 16e:	26 e0       	ldi	r18, 0x06	; 6
 170:	80 31       	cpi	r24, 0x10	; 16
 172:	92 07       	cpc	r25, r18
 174:	09 f4       	brne	.+2      	; 0x178
 176:	5c c0       	rjmp	.+184    	; 0x230
 178:	26 e0       	ldi	r18, 0x06	; 6
 17a:	81 31       	cpi	r24, 0x11	; 17
 17c:	92 07       	cpc	r25, r18
 17e:	20 f5       	brcc	.+72     	; 0x1c8
 180:	21 e0       	ldi	r18, 0x01	; 1
 182:	80 31       	cpi	r24, 0x10	; 16
 184:	92 07       	cpc	r25, r18
 186:	09 f4       	brne	.+2      	; 0x18a
 188:	62 c0       	rjmp	.+196    	; 0x24e
 18a:	21 e0       	ldi	r18, 0x01	; 1
 18c:	81 31       	cpi	r24, 0x11	; 17
 18e:	92 07       	cpc	r25, r18
 190:	48 f4       	brcc	.+18     	; 0x1a4
 192:	80 31       	cpi	r24, 0x10	; 16
 194:	91 05       	cpc	r25, r1
 196:	09 f4       	brne	.+2      	; 0x19a
 198:	3f c0       	rjmp	.+126    	; 0x218
 19a:	80 39       	cpi	r24, 0x90	; 144
 19c:	91 05       	cpc	r25, r1
 19e:	09 f4       	brne	.+2      	; 0x1a2
 1a0:	4d c0       	rjmp	.+154    	; 0x23c
 1a2:	55 c0       	rjmp	.+170    	; 0x24e
 1a4:	24 e0       	ldi	r18, 0x04	; 4
 1a6:	80 31       	cpi	r24, 0x10	; 16
 1a8:	92 07       	cpc	r25, r18
 1aa:	09 f4       	brne	.+2      	; 0x1ae
 1ac:	39 c0       	rjmp	.+114    	; 0x220
 1ae:	24 e0       	ldi	r18, 0x04	; 4
 1b0:	81 31       	cpi	r24, 0x11	; 17
 1b2:	92 07       	cpc	r25, r18
 1b4:	20 f4       	brcc	.+8      	; 0x1be
 1b6:	80 51       	subi	r24, 0x10	; 16
 1b8:	92 40       	sbci	r25, 0x02	; 2
 1ba:	b1 f1       	breq	.+108    	; 0x228
 1bc:	48 c0       	rjmp	.+144    	; 0x24e
 1be:	80 59       	subi	r24, 0x90	; 144
 1c0:	94 40       	sbci	r25, 0x04	; 4
 1c2:	09 f4       	brne	.+2      	; 0x1c6
 1c4:	3f c0       	rjmp	.+126    	; 0x244
 1c6:	43 c0       	rjmp	.+134    	; 0x24e
 1c8:	2a e0       	ldi	r18, 0x0A	; 10
 1ca:	80 31       	cpi	r24, 0x10	; 16
 1cc:	92 07       	cpc	r25, r18
 1ce:	71 f1       	breq	.+92     	; 0x22c
 1d0:	2a e0       	ldi	r18, 0x0A	; 10
 1d2:	81 31       	cpi	r24, 0x11	; 17
 1d4:	92 07       	cpc	r25, r18
 1d6:	80 f4       	brcc	.+32     	; 0x1f8
 1d8:	28 e0       	ldi	r18, 0x08	; 8
 1da:	80 39       	cpi	r24, 0x90	; 144
 1dc:	92 07       	cpc	r25, r18
 1de:	81 f1       	breq	.+96     	; 0x240
 1e0:	28 e0       	ldi	r18, 0x08	; 8
 1e2:	81 39       	cpi	r24, 0x91	; 145
 1e4:	92 07       	cpc	r25, r18
 1e6:	20 f4       	brcc	.+8      	; 0x1f0
 1e8:	80 51       	subi	r24, 0x10	; 16
 1ea:	98 40       	sbci	r25, 0x08	; 8
 1ec:	b9 f0       	breq	.+46     	; 0x21c
 1ee:	2f c0       	rjmp	.+94     	; 0x24e
 1f0:	80 51       	subi	r24, 0x10	; 16
 1f2:	99 40       	sbci	r25, 0x09	; 9
 1f4:	09 f1       	breq	.+66     	; 0x238
 1f6:	2b c0       	rjmp	.+86     	; 0x24e
 1f8:	2c e0       	ldi	r18, 0x0C	; 12
 1fa:	80 39       	cpi	r24, 0x90	; 144
 1fc:	92 07       	cpc	r25, r18
 1fe:	21 f1       	breq	.+72     	; 0x248
 200:	2c e0       	ldi	r18, 0x0C	; 12
 202:	81 39       	cpi	r24, 0x91	; 145
 204:	92 07       	cpc	r25, r18
 206:	20 f4       	brcc	.+8      	; 0x210
 208:	80 51       	subi	r24, 0x10	; 16
 20a:	9c 40       	sbci	r25, 0x0C	; 12
 20c:	59 f0       	breq	.+22     	; 0x224
 20e:	1f c0       	rjmp	.+62     	; 0x24e
 210:	80 51       	subi	r24, 0x10	; 16
 212:	9e 40       	sbci	r25, 0x0E	; 14
 214:	79 f0       	breq	.+30     	; 0x234
 216:	1b c0       	rjmp	.+54     	; 0x24e
	   {
	    case IR_TV_1:	
 			set_speed = 0;
 218:	c0 e0       	ldi	r28, 0x00	; 0
			 break;
 21a:	19 c0       	rjmp	.+50     	; 0x24e
		case IR_TV_2:
			set_speed =1;
 21c:	c1 e0       	ldi	r28, 0x01	; 1
			break;
 21e:	17 c0       	rjmp	.+46     	; 0x24e
	    case IR_TV_3:
 			set_speed =2;			
 220:	c2 e0       	ldi	r28, 0x02	; 2
			break;
 222:	15 c0       	rjmp	.+42     	; 0x24e
		case IR_TV_4:
 			set_speed =3;			
 224:	c3 e0       	ldi	r28, 0x03	; 3
			 break;
 226:	13 c0       	rjmp	.+38     	; 0x24e
	    case IR_TV_5:
 			set_speed =4;			
 228:	c4 e0       	ldi	r28, 0x04	; 4
			 break;
 22a:	11 c0       	rjmp	.+34     	; 0x24e
		case IR_TV_6:
 			set_speed = 5;			
 22c:	c5 e0       	ldi	r28, 0x05	; 5
			 break;
 22e:	0f c0       	rjmp	.+30     	; 0x24e
	    case IR_TV_7:
 			set_speed = 6;			
 230:	c6 e0       	ldi	r28, 0x06	; 6
			break;
 232:	0d c0       	rjmp	.+26     	; 0x24e
		case IR_TV_8:
 			set_speed = 7;			
 234:	c7 e0       	ldi	r28, 0x07	; 7
			break;
 236:	0b c0       	rjmp	.+22     	; 0x24e
	    case IR_TV_9:
 			set_speed =8;			
			break;
		case IR_TV_0:
			set_motor_parameter (MOTOR_STOP);
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	07 c0       	rjmp	.+14     	; 0x24a
			break;
		case IR_TV_CHUP:
			set_motor_parameter(MOTOR_FORWARD);
 23c:	81 e0       	ldi	r24, 0x01	; 1
 23e:	05 c0       	rjmp	.+10     	; 0x24a
			break;
		case IR_TV_CHDOWN:							
			set_motor_parameter(MOTOR_BACKWARD);
 240:	82 e0       	ldi	r24, 0x02	; 2
 242:	03 c0       	rjmp	.+6      	; 0x24a
			break;
		case IR_TV_TVMUTE:
			break;
		case  IR_TV_TVPOWER:
		  	break;
		case   IR_TV_TVAV:
		    break;
		case  IR_TV_VOLUP:
            set_motor_parameter(MOTOR_TURN_LEFT);
 244:	84 e0       	ldi	r24, 0x04	; 4
 246:	01 c0       	rjmp	.+2      	; 0x24a
			break;
		case  IR_TV_VOLDOWN:                 			
		    set_motor_parameter(MOTOR_TURN_RIGHT);
 248:	85 e0       	ldi	r24, 0x05	; 5
 24a:	0e 94 64 00 	call	0xc8
			break;
		default:
 //			set_motor_parameter (MOTOR_STOP);
			break;
 	   }
	   g_speed[1] = g_speed_table[set_speed]; 
 24e:	ec 2f       	mov	r30, r28
 250:	ff 27       	eor	r31, r31
 252:	e0 5a       	subi	r30, 0xA0	; 160
 254:	ff 4f       	sbci	r31, 0xFF	; 255
 256:	80 81       	ld	r24, Z
 258:	99 27       	eor	r25, r25
 25a:	90 93 32 01 	sts	0x0132, r25
 25e:	80 93 31 01 	sts	0x0131, r24
	   g_speed[0] = g_speed[1];
 262:	90 93 30 01 	sts	0x0130, r25
 266:	80 93 2f 01 	sts	0x012F, r24
 26a:	cf 91       	pop	r28
 26c:	08 95       	ret

0000026e <cmd_decode>:
 	   
}



/* Command decode from g_rcv_buffer  will decode and action according to command in buffer
 
*/

int16_t cmd_decode (void)
{
 26e:	df 92       	push	r13
 270:	ef 92       	push	r14
 272:	ff 92       	push	r15
 274:	0f 93       	push	r16
 276:	1f 93       	push	r17
 278:	cf 93       	push	r28
 27a:	df 93       	push	r29

 uint8_t  cmd_no =0;
 uint8_t  *cmd_argument;
 uint8_t  *buffer_ptr;
 uint8_t   i;
 
// Should repeat until end of buffer
 
// Loop until end of text

   buffer_ptr   = g_rcv_buff;
   cmd_argument = g_rcv_buff;
     
   while ( cmd_no !=  CMD_LINE_END)     // Until end of line which mean g_motor will change
   {
 		cmd_no =  text_decode (buffer_ptr,cmd_argument);
 27c:	6f ea       	ldi	r22, 0xAF	; 175
 27e:	70 e0       	ldi	r23, 0x00	; 0
 280:	cb 01       	movw	r24, r22
 282:	0e 94 7a 05 	call	0xaf4
 286:	d8 2e       	mov	r13, r24
#ifdef DEBUG		
		uart_puts("Command :");
 288:	8b e6       	ldi	r24, 0x6B	; 107
 28a:	90 e0       	ldi	r25, 0x00	; 0
 28c:	0e 94 26 05 	call	0xa4c
		uart_putc(0x30+cmd_no);
 290:	8d 2d       	mov	r24, r13
 292:	80 5d       	subi	r24, 0xD0	; 208
 294:	0e 94 20 05 	call	0xa40
		uart_putc('*');
 298:	8a e2       	ldi	r24, 0x2A	; 42
 29a:	0e 94 20 05 	call	0xa40
		uart_puts(cmd_argument);
 29e:	8f ea       	ldi	r24, 0xAF	; 175
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	0e 94 26 05 	call	0xa4c
#endif        
 		switch (cmd_no)
 2a6:	8d 2d       	mov	r24, r13
 2a8:	99 27       	eor	r25, r25
 2aa:	82 30       	cpi	r24, 0x02	; 2
 2ac:	91 05       	cpc	r25, r1
 2ae:	c9 f0       	breq	.+50     	; 0x2e2
 2b0:	83 30       	cpi	r24, 0x03	; 3
 2b2:	91 05       	cpc	r25, r1
 2b4:	1c f4       	brge	.+6      	; 0x2bc
 2b6:	01 97       	sbiw	r24, 0x01	; 1
 2b8:	21 f0       	breq	.+8      	; 0x2c2
 2ba:	68 c0       	rjmp	.+208    	; 0x38c
 2bc:	03 97       	sbiw	r24, 0x03	; 3
 2be:	49 f1       	breq	.+82     	; 0x312
 2c0:	65 c0       	rjmp	.+202    	; 0x38c
		{
			case MOTOR_CMD: 
				g_motor = (uint8_t)atoi(cmd_argument);
 2c2:	8f ea       	ldi	r24, 0xAF	; 175
 2c4:	90 e0       	ldi	r25, 0x00	; 0
 2c6:	0e 94 5f 06 	call	0xcbe
 2ca:	80 93 ae 00 	sts	0x00AE, r24
				if (g_motor > 0)
 2ce:	28 2f       	mov	r18, r24
 2d0:	88 23       	and	r24, r24
 2d2:	21 f0       	breq	.+8      	; 0x2dc
				   g_motor--;                //  > 0 Start from 0 need -1
 2d4:	21 50       	subi	r18, 0x01	; 1
 2d6:	20 93 ae 00 	sts	0x00AE, r18
 2da:	5c c0       	rjmp	.+184    	; 0x394
				else
				   g_motor = 0;
 2dc:	80 93 ae 00 	sts	0x00AE, r24
 
 				break;
 2e0:	59 c0       	rjmp	.+178    	; 0x394
			case  SPEED_CMD:	
				i = (uint8_t)atoi(cmd_argument);
 2e2:	8f ea       	ldi	r24, 0xAF	; 175
 2e4:	90 e0       	ldi	r25, 0x00	; 0
 2e6:	0e 94 5f 06 	call	0xcbe
 2ea:	e8 2f       	mov	r30, r24
				if ( i >=  MOTOR_MAX)
 2ec:	82 30       	cpi	r24, 0x02	; 2
 2ee:	08 f0       	brcs	.+2      	; 0x2f2
						i = MOTOR_MAX-1;    // Start from 0
 2f0:	e1 e0       	ldi	r30, 0x01	; 1
				g_speed[g_motor] =  g_speed_table[i];
 2f2:	80 91 ae 00 	lds	r24, 0x00AE
 2f6:	a8 2f       	mov	r26, r24
 2f8:	bb 27       	eor	r27, r27
 2fa:	aa 0f       	add	r26, r26
 2fc:	bb 1f       	adc	r27, r27
 2fe:	a1 5d       	subi	r26, 0xD1	; 209
 300:	be 4f       	sbci	r27, 0xFE	; 254
 302:	ff 27       	eor	r31, r31
 304:	e0 5a       	subi	r30, 0xA0	; 160
 306:	ff 4f       	sbci	r31, 0xFF	; 255
 308:	80 81       	ld	r24, Z
 30a:	99 27       	eor	r25, r25
 30c:	8d 93       	st	X+, r24
 30e:	9c 93       	st	X, r25
  				break;
 310:	41 c0       	rjmp	.+130    	; 0x394
			case  ANGLE_CMD:   // Can be - 
				g_angle[g_motor] = atoi(cmd_argument);
 312:	80 91 ae 00 	lds	r24, 0x00AE
 316:	c8 2f       	mov	r28, r24
 318:	dd 27       	eor	r29, r29
 31a:	8e 01       	movw	r16, r28
 31c:	0c 0f       	add	r16, r28
 31e:	1d 1f       	adc	r17, r29
 320:	8a ea       	ldi	r24, 0xAA	; 170
 322:	e8 2e       	mov	r14, r24
 324:	80 e0       	ldi	r24, 0x00	; 0
 326:	f8 2e       	mov	r15, r24
 328:	e0 0e       	add	r14, r16
 32a:	f1 1e       	adc	r15, r17
 32c:	8f ea       	ldi	r24, 0xAF	; 175
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	0e 94 5f 06 	call	0xcbe
 334:	9c 01       	movw	r18, r24
 336:	f7 01       	movw	r30, r14
 338:	80 83       	st	Z, r24
 33a:	91 83       	std	Z+1, r25	; 0x01
				if (g_angle[g_motor] < 0)
 33c:	97 ff       	sbrs	r25, 7
 33e:	0b c0       	rjmp	.+22     	; 0x356
				{   
						g_mode[g_motor] = MOTOR_BACKWARD;
 340:	c3 56       	subi	r28, 0x63	; 99
 342:	df 4f       	sbci	r29, 0xFF	; 255
 344:	82 e0       	ldi	r24, 0x02	; 2
 346:	88 83       	st	Y, r24
// Set g_angle to positive value by invert all bit and +1                
                        g_angle[g_motor] = (~(g_angle[g_motor])+1);
 348:	88 27       	eor	r24, r24
 34a:	99 27       	eor	r25, r25
 34c:	82 1b       	sub	r24, r18
 34e:	93 0b       	sbc	r25, r19
 350:	80 83       	st	Z, r24
 352:	91 83       	std	Z+1, r25	; 0x01
 354:	10 c0       	rjmp	.+32     	; 0x376
                        if  (g_angle[g_motor] > 1)
						{
 						   g_angle[g_motor] *= MOTOR_ANGLE_COEF;
						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
						}		
				}	
				else  if (g_angle[g_motor] == 0)
 356:	00 97       	sbiw	r24, 0x00	; 0
 358:	21 f4       	brne	.+8      	; 0x362
				        g_mode[g_motor] = MOTOR_STOP;
 35a:	c3 56       	subi	r28, 0x63	; 99
 35c:	df 4f       	sbci	r29, 0xFF	; 255
 35e:	18 82       	st	Y, r1
 360:	19 c0       	rjmp	.+50     	; 0x394
				else	  
				{
					if ((g_angle[g_motor] > 0))   //  +
 362:	18 16       	cp	r1, r24
 364:	19 06       	cpc	r1, r25
 366:	24 f4       	brge	.+8      	; 0x370
						g_mode[g_motor] = MOTOR_FORWARD;
 368:	c3 56       	subi	r28, 0x63	; 99
 36a:	df 4f       	sbci	r29, 0xFF	; 255
 36c:	81 e0       	ldi	r24, 0x01	; 1
 36e:	88 83       	st	Y, r24
					if  (g_angle[g_motor] > 1)
 370:	f7 01       	movw	r30, r14
 372:	80 81       	ld	r24, Z
 374:	91 81       	ldd	r25, Z+1	; 0x01
 376:	02 97       	sbiw	r24, 0x02	; 2
 378:	6c f0       	brlt	.+26     	; 0x394
					{
 						g_angle[g_motor] *=  MOTOR_ANGLE_COEF;	
						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
 37a:	01 5d       	subi	r16, 0xD1	; 209
 37c:	1e 4f       	sbci	r17, 0xFE	; 254
 37e:	80 91 65 00 	lds	r24, 0x0065
 382:	99 27       	eor	r25, r25
 384:	f8 01       	movw	r30, r16
 386:	80 83       	st	Z, r24
 388:	91 83       	std	Z+1, r25	; 0x01
					}
 				}
				break;	
 38a:	04 c0       	rjmp	.+8      	; 0x394
 			default:
			    uart_puts("Command not found ");
 38c:	85 e7       	ldi	r24, 0x75	; 117
 38e:	90 e0       	ldi	r25, 0x00	; 0
 390:	0e 94 26 05 	call	0xa4c
 		        break;	  
 394:	ff ef       	ldi	r31, 0xFF	; 255
 396:	df 16       	cp	r13, r31
 398:	09 f0       	breq	.+2      	; 0x39c
 39a:	70 cf       	rjmp	.-288    	; 0x27c
		}		
    }
 return 0; 
}
 39c:	80 e0       	ldi	r24, 0x00	; 0
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	df 91       	pop	r29
 3a2:	cf 91       	pop	r28
 3a4:	1f 91       	pop	r17
 3a6:	0f 91       	pop	r16
 3a8:	ff 90       	pop	r15
 3aa:	ef 90       	pop	r14
 3ac:	df 90       	pop	r13
 3ae:	08 95       	ret

000003b0 <calculate_backemf>:

/* Calculate backemf and save in g_pos

*/
void calculate_backemf (uint8_t motor)
{
 3b0:	ef 92       	push	r14
 3b2:	ff 92       	push	r15
 3b4:	0f 93       	push	r16
 3b6:	1f 93       	push	r17
 3b8:	cf 93       	push	r28
 3ba:	df 93       	push	r29
 3bc:	c8 2f       	mov	r28, r24
     int16_t backemf=0;
  // Read backemf
		adc_init(3);
 3be:	83 e0       	ldi	r24, 0x03	; 3
 3c0:	0e 94 58 05 	call	0xab0
		backemf = read_adc(0x10);		
 3c4:	80 e1       	ldi	r24, 0x10	; 16
 3c6:	0e 94 6d 05 	call	0xada
 3ca:	ac 01       	movw	r20, r24
		if (backemf & 0x200)
 3cc:	89 2f       	mov	r24, r25
 3ce:	99 27       	eor	r25, r25
 3d0:	86 95       	lsr	r24
 3d2:	80 ff       	sbrs	r24, 0
 3d4:	05 c0       	rjmp	.+10     	; 0x3e0
		{
		    backemf = (~(backemf) & (0x03FF))+1;
 3d6:	40 95       	com	r20
 3d8:	50 95       	com	r21
 3da:	53 70       	andi	r21, 0x03	; 3
 3dc:	4f 5f       	subi	r20, 0xFF	; 255
 3de:	5f 4f       	sbci	r21, 0xFF	; 255
//			backemf -= 512; 
		}
		if (backemf  < MOTOR_OFFSET)
 3e0:	46 30       	cpi	r20, 0x06	; 6
 3e2:	51 05       	cpc	r21, r1
 3e4:	14 f4       	brge	.+4      	; 0x3ea
			backemf = 0;
 3e6:	40 e0       	ldi	r20, 0x00	; 0
 3e8:	50 e0       	ldi	r21, 0x00	; 0
 
		g_pos[motor] += backemf;
 3ea:	8c 2f       	mov	r24, r28
 3ec:	99 27       	eor	r25, r25
 3ee:	ec 01       	movw	r28, r24
 3f0:	c8 0f       	add	r28, r24
 3f2:	d9 1f       	adc	r29, r25
 3f4:	8e 01       	movw	r16, r28
 3f6:	07 56       	subi	r16, 0x67	; 103
 3f8:	1f 4f       	sbci	r17, 0xFF	; 255
 3fa:	f8 01       	movw	r30, r16
 3fc:	20 81       	ld	r18, Z
 3fe:	31 81       	ldd	r19, Z+1	; 0x01
 400:	24 0f       	add	r18, r20
 402:	35 1f       	adc	r19, r21
 404:	20 83       	st	Z, r18
 406:	31 83       	std	Z+1, r19	; 0x01
	if (g_mode[motor] != MOTOR_STOP)	
 408:	2d e9       	ldi	r18, 0x9D	; 157
 40a:	e2 2e       	mov	r14, r18
 40c:	20 e0       	ldi	r18, 0x00	; 0
 40e:	f2 2e       	mov	r15, r18
 410:	e8 0e       	add	r14, r24
 412:	f9 1e       	adc	r15, r25
 414:	f7 01       	movw	r30, r14
 416:	80 81       	ld	r24, Z
 418:	88 23       	and	r24, r24
 41a:	21 f0       	breq	.+8      	; 0x424
 		debug_value(backemf,10);
 41c:	6a e0       	ldi	r22, 0x0A	; 10
 41e:	ca 01       	movw	r24, r20
 420:	0e 94 39 05 	call	0xa72
 
//Compare voltage	
	if (((g_angle[motor] > 1)) && ( g_mode[motor] != MOTOR_STOP))
 424:	c6 55       	subi	r28, 0x56	; 86
 426:	df 4f       	sbci	r29, 0xFF	; 255
 428:	28 81       	ld	r18, Y
 42a:	39 81       	ldd	r19, Y+1	; 0x01
 42c:	22 30       	cpi	r18, 0x02	; 2
 42e:	31 05       	cpc	r19, r1
 430:	0c f1       	brlt	.+66     	; 0x474
 432:	f7 01       	movw	r30, r14
 434:	80 81       	ld	r24, Z
 436:	88 23       	and	r24, r24
 438:	e9 f0       	breq	.+58     	; 0x474
	{   
			if ( g_pos[motor]  >= (g_angle[motor]))  //  Check for position
 43a:	f8 01       	movw	r30, r16
 43c:	80 81       	ld	r24, Z
 43e:	91 81       	ldd	r25, Z+1	; 0x01
 440:	82 17       	cp	r24, r18
 442:	93 07       	cpc	r25, r19
 444:	bc f0       	brlt	.+46     	; 0x474
			{
 				motor_control(1, MOTOR_BRAKE);
 446:	63 e0       	ldi	r22, 0x03	; 3
 448:	81 e0       	ldi	r24, 0x01	; 1
 44a:	0e 94 27 04 	call	0x84e
				delay(3);
 44e:	83 e0       	ldi	r24, 0x03	; 3
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	0e 94 5f 00 	call	0xbe
				g_mode[motor] = MOTOR_STOP;
 456:	f7 01       	movw	r30, r14
 458:	10 82       	st	Z, r1
				uart_puts ("Voltage SUM");
 45a:	88 e8       	ldi	r24, 0x88	; 136
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	0e 94 26 05 	call	0xa4c
				debug_value(g_pos[motor],10);
 462:	6a e0       	ldi	r22, 0x0A	; 10
 464:	f8 01       	movw	r30, r16
 466:	80 81       	ld	r24, Z
 468:	91 81       	ldd	r25, Z+1	; 0x01
 46a:	0e 94 39 05 	call	0xa72
				g_pos[motor] =0;				
 46e:	f8 01       	movw	r30, r16
 470:	10 82       	st	Z, r1
 472:	11 82       	std	Z+1, r1	; 0x01
 474:	df 91       	pop	r29
 476:	cf 91       	pop	r28
 478:	1f 91       	pop	r17
 47a:	0f 91       	pop	r16
 47c:	ff 90       	pop	r15
 47e:	ef 90       	pop	r14
 480:	08 95       	ret

00000482 <__vector_11>:
			}
	}		
}



// Interrupt Vector table
// Couter timer 0 reach top  
//    ON Motor   0 - OCR0  ON   OCR0 - 0xFF OFF
 SIGNAL (SIG_OVERFLOW0)   
{
 482:	1f 92       	push	r1
 484:	0f 92       	push	r0
 486:	0f b6       	in	r0, 0x3f	; 63
 488:	0f 92       	push	r0
 48a:	11 24       	eor	r1, r1
 48c:	2f 93       	push	r18
 48e:	3f 93       	push	r19
 490:	4f 93       	push	r20
 492:	5f 93       	push	r21
 494:	6f 93       	push	r22
 496:	7f 93       	push	r23
 498:	8f 93       	push	r24
 49a:	9f 93       	push	r25
 49c:	af 93       	push	r26
 49e:	bf 93       	push	r27
 4a0:	ef 93       	push	r30
 4a2:	ff 93       	push	r31
    OCR0 =  g_speed[0];
 4a4:	80 91 2f 01 	lds	r24, 0x012F
 4a8:	8c bf       	out	0x3c, r24	; 60
    motor_control(1, g_mode[0]);
 4aa:	60 91 9d 00 	lds	r22, 0x009D
 4ae:	81 e0       	ldi	r24, 0x01	; 1
 4b0:	0e 94 27 04 	call	0x84e
 4b4:	ff 91       	pop	r31
 4b6:	ef 91       	pop	r30
 4b8:	bf 91       	pop	r27
 4ba:	af 91       	pop	r26
 4bc:	9f 91       	pop	r25
 4be:	8f 91       	pop	r24
 4c0:	7f 91       	pop	r23
 4c2:	6f 91       	pop	r22
 4c4:	5f 91       	pop	r21
 4c6:	4f 91       	pop	r20
 4c8:	3f 91       	pop	r19
 4ca:	2f 91       	pop	r18
 4cc:	0f 90       	pop	r0
 4ce:	0f be       	out	0x3f, r0	; 63
 4d0:	0f 90       	pop	r0
 4d2:	1f 90       	pop	r1
 4d4:	18 95       	reti

000004d6 <__vector_10>:
//    if ( g_mode[0] != MOTOR_STOP)
//			uart_putc ('x');	
//	calculate_backemf(0);
		
}

// Counter timer 0 reach OCR0  OFF MOTOR
 SIGNAL (SIG_OUTPUT_COMPARE0)
{
 4d6:	1f 92       	push	r1
 4d8:	0f 92       	push	r0
 4da:	0f b6       	in	r0, 0x3f	; 63
 4dc:	0f 92       	push	r0
 4de:	11 24       	eor	r1, r1
 4e0:	2f 93       	push	r18
 4e2:	3f 93       	push	r19
 4e4:	4f 93       	push	r20
 4e6:	5f 93       	push	r21
 4e8:	6f 93       	push	r22
 4ea:	7f 93       	push	r23
 4ec:	8f 93       	push	r24
 4ee:	9f 93       	push	r25
 4f0:	af 93       	push	r26
 4f2:	bf 93       	push	r27
 4f4:	ef 93       	push	r30
 4f6:	ff 93       	push	r31
  
//	   if ( g_mode[0] != MOTOR_STOP)
//			uart_putc ('-');	
		motor_control(1, MOTOR_STOP);
 4f8:	60 e0       	ldi	r22, 0x00	; 0
 4fa:	81 e0       	ldi	r24, 0x01	; 1
 4fc:	0e 94 27 04 	call	0x84e
 	  	delay(100);   // Delay for stable voltage
 500:	84 e6       	ldi	r24, 0x64	; 100
 502:	90 e0       	ldi	r25, 0x00	; 0
 504:	0e 94 5f 00 	call	0xbe
 		calculate_backemf(0);
 508:	80 e0       	ldi	r24, 0x00	; 0
 50a:	0e 94 d8 01 	call	0x3b0
 50e:	ff 91       	pop	r31
 510:	ef 91       	pop	r30
 512:	bf 91       	pop	r27
 514:	af 91       	pop	r26
 516:	9f 91       	pop	r25
 518:	8f 91       	pop	r24
 51a:	7f 91       	pop	r23
 51c:	6f 91       	pop	r22
 51e:	5f 91       	pop	r21
 520:	4f 91       	pop	r20
 522:	3f 91       	pop	r19
 524:	2f 91       	pop	r18
 526:	0f 90       	pop	r0
 528:	0f be       	out	0x3f, r0	; 63
 52a:	0f 90       	pop	r0
 52c:	1f 90       	pop	r1
 52e:	18 95       	reti

00000530 <__vector_13>:
  
}
 
 
 
/* UART receiver ready
*/

SIGNAL(SIG_UART_RECV)
{
 530:	1f 92       	push	r1
 532:	0f 92       	push	r0
 534:	0f b6       	in	r0, 0x3f	; 63
 536:	0f 92       	push	r0
 538:	11 24       	eor	r1, r1
 53a:	2f 93       	push	r18
 53c:	8f 93       	push	r24
 53e:	9f 93       	push	r25
 540:	ef 93       	push	r30
 542:	ff 93       	push	r31
  static uint16_t i= 0;
  uint8_t ch;
  ch = UDR;
 544:	2c b1       	in	r18, 0x0c	; 12

	g_rcv_buff[i] = ch;    
 546:	80 91 9f 00 	lds	r24, 0x009F
 54a:	90 91 a0 00 	lds	r25, 0x00A0
 54e:	fc 01       	movw	r30, r24
 550:	e1 55       	subi	r30, 0x51	; 81
 552:	ff 4f       	sbci	r31, 0xFF	; 255
 554:	20 83       	st	Z, r18
	i++;
 556:	fc 01       	movw	r30, r24
 558:	31 96       	adiw	r30, 0x01	; 1
 55a:	f0 93 a0 00 	sts	0x00A0, r31
 55e:	e0 93 9f 00 	sts	0x009F, r30
 
// Found 0xOD or 0x0A end with null
   if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
 562:	2d 30       	cpi	r18, 0x0D	; 13
 564:	11 f0       	breq	.+4      	; 0x56a
 566:	2a 30       	cpi	r18, 0x0A	; 10
 568:	51 f4       	brne	.+20     	; 0x57e
   {	
    	g_rcv_buff[i]  = 0;   // End with null
 56a:	e1 55       	subi	r30, 0x51	; 81
 56c:	ff 4f       	sbci	r31, 0xFF	; 255
 56e:	10 82       	st	Z, r1
		i = 0;
 570:	10 92 a0 00 	sts	0x00A0, r1
 574:	10 92 9f 00 	sts	0x009F, r1
  		g_cmd_decode = 1;
 578:	81 e0       	ldi	r24, 0x01	; 1
 57a:	80 93 98 00 	sts	0x0098, r24
 57e:	ff 91       	pop	r31
 580:	ef 91       	pop	r30
 582:	9f 91       	pop	r25
 584:	8f 91       	pop	r24
 586:	2f 91       	pop	r18
 588:	0f 90       	pop	r0
 58a:	0f be       	out	0x3f, r0	; 63
 58c:	0f 90       	pop	r0
 58e:	1f 90       	pop	r1
 590:	18 95       	reti

00000592 <__vector_14>:
   }
}

  

/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/

SIGNAL(SIG_UART_DATA)
{ 
 592:	1f 92       	push	r1
 594:	0f 92       	push	r0
 596:	0f b6       	in	r0, 0x3f	; 63
 598:	0f 92       	push	r0
 59a:	11 24       	eor	r1, r1
 59c:	2f 93       	push	r18
 59e:	3f 93       	push	r19
 5a0:	4f 93       	push	r20
 5a2:	5f 93       	push	r21
 5a4:	6f 93       	push	r22
 5a6:	7f 93       	push	r23
 5a8:	8f 93       	push	r24
 5aa:	9f 93       	push	r25
 5ac:	af 93       	push	r26
 5ae:	bf 93       	push	r27
 5b0:	ef 93       	push	r30
 5b2:	ff 93       	push	r31
    uint8_t  ch;
	if ((ch = uart_get_TX()))
 5b4:	0e 94 00 05 	call	0xa00
 5b8:	88 23       	and	r24, r24
 5ba:	11 f0       	breq	.+4      	; 0x5c0
	{
 		UDR = ch;
 5bc:	8c b9       	out	0x0c, r24	; 12
 5be:	01 c0       	rjmp	.+2      	; 0x5c2
	}	
	else 
// No character disable  interrupt to avoid repetable call Enable again when
//	send character in putc procedure
	{
	    UCSRB &=  ~(1<<UDRIE);
 5c0:	55 98       	cbi	0x0a, 5	; 10
 5c2:	ff 91       	pop	r31
 5c4:	ef 91       	pop	r30
 5c6:	bf 91       	pop	r27
 5c8:	af 91       	pop	r26
 5ca:	9f 91       	pop	r25
 5cc:	8f 91       	pop	r24
 5ce:	7f 91       	pop	r23
 5d0:	6f 91       	pop	r22
 5d2:	5f 91       	pop	r21
 5d4:	4f 91       	pop	r20
 5d6:	3f 91       	pop	r19
 5d8:	2f 91       	pop	r18
 5da:	0f 90       	pop	r0
 5dc:	0f be       	out	0x3f, r0	; 63
 5de:	0f 90       	pop	r0
 5e0:	1f 90       	pop	r1
 5e2:	18 95       	reti

000005e4 <__vector_6>:
	}
	
}

 
 
/* Interrupt handle for Input Capture
This routine will detect/ process the Sony IR remote command. Protocol using Sony remote control
INPUT   :  Infrared signal from  ICP pin
		   Command table 
		  

OUTPUT 	: g_num  Number of message to display
		: g_control.display_mode   Display mode of message
		: g_start_bit
		

*/
SIGNAL(SIG_INPUT_CAPTURE1)
{
 5e4:	1f 92       	push	r1
 5e6:	0f 92       	push	r0
 5e8:	0f b6       	in	r0, 0x3f	; 63
 5ea:	0f 92       	push	r0
 5ec:	11 24       	eor	r1, r1
 5ee:	2f 93       	push	r18
 5f0:	3f 93       	push	r19
 5f2:	4f 93       	push	r20
 5f4:	5f 93       	push	r21
 5f6:	6f 93       	push	r22
 5f8:	7f 93       	push	r23
 5fa:	8f 93       	push	r24
 5fc:	9f 93       	push	r25
 5fe:	af 93       	push	r26
 600:	bf 93       	push	r27
 602:	ef 93       	push	r30
 604:	ff 93       	push	r31
	uint16_t  ir_code;
    ir_code = ICR1;
 606:	26 b5       	in	r18, 0x26	; 38
 608:	37 b5       	in	r19, 0x27	; 39
	cli(); 
 60a:	f8 94       	cli

    TCCR1B  |= _BV(ICES1);	     // Rising edge
 60c:	8e b5       	in	r24, 0x2e	; 46
 60e:	80 64       	ori	r24, 0x40	; 64
 610:	8e bd       	out	0x2e, r24	; 46
 	ir_code  = sony_ir_decode(ir_code);  
 612:	c9 01       	movw	r24, r18
 614:	0e 94 64 04 	call	0x8c8

	if (ir_code)
 618:	00 97       	sbiw	r24, 0x00	; 0
 61a:	29 f0       	breq	.+10     	; 0x626
	{       //End code dispatch command    
 
		remote_decode (ir_code);
 61c:	0e 94 b5 00 	call	0x16a
// Return to falling edge for Start		
		TCCR1B  &= ~(_BV(ICES1));
 620:	8e b5       	in	r24, 0x2e	; 46
 622:	8f 7b       	andi	r24, 0xBF	; 191
 624:	8e bd       	out	0x2e, r24	; 46

//Note if  SELFTEST is selected g_irint = 0;
	} 
    sei();
 626:	78 94       	sei
 628:	ff 91       	pop	r31
 62a:	ef 91       	pop	r30
 62c:	bf 91       	pop	r27
 62e:	af 91       	pop	r26
 630:	9f 91       	pop	r25
 632:	8f 91       	pop	r24
 634:	7f 91       	pop	r23
 636:	6f 91       	pop	r22
 638:	5f 91       	pop	r21
 63a:	4f 91       	pop	r20
 63c:	3f 91       	pop	r19
 63e:	2f 91       	pop	r18
 640:	0f 90       	pop	r0
 642:	0f be       	out	0x3f, r0	; 63
 644:	0f 90       	pop	r0
 646:	1f 90       	pop	r1
 648:	18 95       	reti

0000064a <init_board>:
 
}


void init_board()
{
    uint8_t i;
	d7segment_init();
 64a:	0e 94 0f 04 	call	0x81e
	init_ir();
 64e:	0e 94 5b 04 	call	0x8b6
	init_motor();
 652:	0e 94 19 04 	call	0x832
	uart_init(); 
 656:	0e 94 a6 04 	call	0x94c
    adc_init(1);   // AVCC as reference 
 65a:	81 e0       	ldi	r24, 0x01	; 1
 65c:	0e 94 58 05 	call	0xab0
	
	g_cmd_decode = 0; 
 660:	10 92 98 00 	sts	0x0098, r1
	g_motor= 0;
 664:	10 92 ae 00 	sts	0x00AE, r1
 668:	21 e0       	ldi	r18, 0x01	; 1
 66a:	30 e0       	ldi	r19, 0x00	; 0
 66c:	81 e0       	ldi	r24, 0x01	; 1
 66e:	aa ea       	ldi	r26, 0xAA	; 170
 670:	b0 e0       	ldi	r27, 0x00	; 0
 672:	ef e2       	ldi	r30, 0x2F	; 47
 674:	f1 e0       	ldi	r31, 0x01	; 1
	
	for ( i = 0 ; i< MOTOR_MAX ;i++)
	{
		g_speed[i] = 1;
 676:	21 93       	st	Z+, r18
 678:	31 93       	st	Z+, r19
		g_angle[i] = 1;
 67a:	2d 93       	st	X+, r18
 67c:	3d 93       	st	X+, r19
 67e:	81 50       	subi	r24, 0x01	; 1
 680:	87 ff       	sbrs	r24, 7
 682:	f9 cf       	rjmp	.-14     	; 0x676
	} 
	sei();
 684:	78 94       	sei
 686:	08 95       	ret

00000688 <main>:
 
}

void main()
{
 688:	cc e5       	ldi	r28, 0x5C	; 92
 68a:	d8 e0       	ldi	r29, 0x08	; 8
 68c:	de bf       	out	0x3e, r29	; 62
 68e:	cd bf       	out	0x3d, r28	; 61
  uint8_t sw1,sw2,i;
   uint16_t k;
   int16_t backemf;
  int8_t d1,d2;
  uint8_t show[3] = {0,'f','b'};
 690:	6e 01       	movw	r12, r28
 692:	08 94       	sec
 694:	c1 1c       	adc	r12, r1
 696:	d1 1c       	adc	r13, r1
 698:	83 e0       	ldi	r24, 0x03	; 3
 69a:	e4 e9       	ldi	r30, 0x94	; 148
 69c:	f0 e0       	ldi	r31, 0x00	; 0
 69e:	d6 01       	movw	r26, r12
 6a0:	01 90       	ld	r0, Z+
 6a2:	0d 92       	st	X+, r0
 6a4:	8a 95       	dec	r24
 6a6:	e1 f7       	brne	.-8      	; 0x6a0
   init_board();
 6a8:	0e 94 25 03 	call	0x64a
  d1 = 0;
 6ac:	ff 24       	eor	r15, r15
  d2 = 0;
 6ae:	ef 2c       	mov	r14, r15
  backemf =0;
  while (1)
  {
   sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
 6b0:	80 b3       	in	r24, 0x10	; 16
   
   if (!sw1) // SW1  Press
 6b2:	98 2f       	mov	r25, r24
 6b4:	98 70       	andi	r25, 0x08	; 8
 6b6:	83 fd       	sbrc	r24, 3
 6b8:	17 c0       	rjmp	.+46     	; 0x6e8
    {   	
		d1++;
 6ba:	e3 94       	inc	r14
	     if (d1 > MOTOR_BACKWARD)
 6bc:	b2 e0       	ldi	r27, 0x02	; 2
 6be:	be 15       	cp	r27, r14
 6c0:	0c f4       	brge	.+2      	; 0x6c4
			d1 = MOTOR_STOP;
 6c2:	e9 2e       	mov	r14, r25
 6c4:	03 ef       	ldi	r16, 0xF3	; 243
 6c6:	11 e0       	ldi	r17, 0x01	; 1
		for (k = 0; k < 500 ;k++)                         // Delay for key bounce
				delay(6000);						
 6c8:	80 e7       	ldi	r24, 0x70	; 112
 6ca:	97 e1       	ldi	r25, 0x17	; 23
 6cc:	0e 94 5f 00 	call	0xbe
 6d0:	01 50       	subi	r16, 0x01	; 1
 6d2:	10 40       	sbci	r17, 0x00	; 0
 6d4:	17 ff       	sbrs	r17, 7
 6d6:	f8 cf       	rjmp	.-16     	; 0x6c8
		g_mode[0] = d1;
 6d8:	e0 92 9d 00 	sts	0x009D, r14
		g_angle[0] = 1;    // Continuous move
 6dc:	81 e0       	ldi	r24, 0x01	; 1
 6de:	90 e0       	ldi	r25, 0x00	; 0
 6e0:	90 93 ab 00 	sts	0x00AB, r25
 6e4:	80 93 aa 00 	sts	0x00AA, r24

	}
   
   sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
 6e8:	83 b3       	in	r24, 0x13	; 19
   if (!sw2) // SW2 Press
 6ea:	98 2f       	mov	r25, r24
 6ec:	94 70       	andi	r25, 0x04	; 4
 6ee:	82 fd       	sbrc	r24, 2
 6f0:	17 c0       	rjmp	.+46     	; 0x720
   {
        d2++;
 6f2:	f3 94       	inc	r15
		if (d2 > MOTOR_BACKWARD)
 6f4:	82 e0       	ldi	r24, 0x02	; 2
 6f6:	8f 15       	cp	r24, r15
 6f8:	0c f4       	brge	.+2      	; 0x6fc
			d2 = MOTOR_STOP;
 6fa:	f9 2e       	mov	r15, r25
 6fc:	03 ef       	ldi	r16, 0xF3	; 243
 6fe:	11 e0       	ldi	r17, 0x01	; 1
 		for (k = 0; k < 500 ;k++)                         // Delay for key bounce		
 				delay(6000);
 700:	80 e7       	ldi	r24, 0x70	; 112
 702:	97 e1       	ldi	r25, 0x17	; 23
 704:	0e 94 5f 00 	call	0xbe
 708:	01 50       	subi	r16, 0x01	; 1
 70a:	10 40       	sbci	r17, 0x00	; 0
 70c:	17 ff       	sbrs	r17, 7
 70e:	f8 cf       	rjmp	.-16     	; 0x700
		g_mode[1] = d2;
 710:	f0 92 9e 00 	sts	0x009E, r15
		g_angle[1] = 1;    // Continuous move	
 714:	81 e0       	ldi	r24, 0x01	; 1
 716:	90 e0       	ldi	r25, 0x00	; 0
 718:	90 93 ad 00 	sts	0x00AD, r25
 71c:	80 93 ac 00 	sts	0x00AC, r24
   }

// Command decode
    if ( g_cmd_decode)
 720:	80 91 98 00 	lds	r24, 0x0098
 724:	88 23       	and	r24, r24
 726:	71 f0       	breq	.+28     	; 0x744
	{
// Decode command	
   	    cmd_decode ();
 728:	0e 94 37 01 	call	0x26e
		g_cmd_decode = 0; 
 72c:	10 92 98 00 	sts	0x0098, r1
		g_pos[g_motor] = 0;
 730:	80 91 ae 00 	lds	r24, 0x00AE
 734:	e8 2f       	mov	r30, r24
 736:	ff 27       	eor	r31, r31
 738:	ee 0f       	add	r30, r30
 73a:	ff 1f       	adc	r31, r31
 73c:	e7 56       	subi	r30, 0x67	; 103
 73e:	ff 4f       	sbci	r31, 0xFF	; 255
 740:	10 82       	st	Z, r1
 742:	11 82       	std	Z+1, r1	; 0x01
	}
	
 	
    for (i = 0 ; i < MOTOR_MAX ; i++)
 744:	e0 e0       	ldi	r30, 0x00	; 0
	{

// 7 Segments display	

		d7segment_display(show[g_mode[i]],i+1);
 746:	1e 2f       	mov	r17, r30
 748:	1f 5f       	subi	r17, 0xFF	; 255
 74a:	ff 27       	eor	r31, r31
 74c:	e3 56       	subi	r30, 0x63	; 99
 74e:	ff 4f       	sbci	r31, 0xFF	; 255
 750:	80 81       	ld	r24, Z
 752:	f6 01       	movw	r30, r12
 754:	e8 0f       	add	r30, r24
 756:	f1 1d       	adc	r31, r1
 758:	61 2f       	mov	r22, r17
 75a:	80 81       	ld	r24, Z
 75c:	0e 94 b8 03 	call	0x770
        delay(10000);
 760:	80 e1       	ldi	r24, 0x10	; 16
 762:	97 e2       	ldi	r25, 0x27	; 39
 764:	0e 94 5f 00 	call	0xbe
 768:	e1 2f       	mov	r30, r17
 76a:	12 30       	cpi	r17, 0x02	; 2
 76c:	60 f3       	brcs	.-40     	; 0x746
 76e:	a0 cf       	rjmp	.-192    	; 0x6b0

00000770 <d7segment_display>:
#include "Dual_7Segment.h"

void d7segment_display( int8_t num, uint8_t digit)
{
 switch (num)
 770:	99 27       	eor	r25, r25
 772:	87 fd       	sbrc	r24, 7
 774:	90 95       	com	r25
 776:	86 30       	cpi	r24, 0x06	; 6
 778:	91 05       	cpc	r25, r1
 77a:	09 f4       	brne	.+2      	; 0x77e
 77c:	41 c0       	rjmp	.+130    	; 0x800
 77e:	87 30       	cpi	r24, 0x07	; 7
 780:	91 05       	cpc	r25, r1
 782:	8c f4       	brge	.+34     	; 0x7a6
 784:	82 30       	cpi	r24, 0x02	; 2
 786:	91 05       	cpc	r25, r1
 788:	59 f1       	breq	.+86     	; 0x7e0
 78a:	83 30       	cpi	r24, 0x03	; 3
 78c:	91 05       	cpc	r25, r1
 78e:	2c f4       	brge	.+10     	; 0x79a
 790:	00 97       	sbiw	r24, 0x00	; 0
 792:	11 f1       	breq	.+68     	; 0x7d8
 794:	01 97       	sbiw	r24, 0x01	; 1
 796:	11 f1       	breq	.+68     	; 0x7dc
 798:	37 c0       	rjmp	.+110    	; 0x808
 79a:	84 30       	cpi	r24, 0x04	; 4
 79c:	91 05       	cpc	r25, r1
 79e:	21 f1       	breq	.+72     	; 0x7e8
 7a0:	05 97       	sbiw	r24, 0x05	; 5
 7a2:	24 f5       	brge	.+72     	; 0x7ec
 7a4:	1f c0       	rjmp	.+62     	; 0x7e4
 7a6:	89 30       	cpi	r24, 0x09	; 9
 7a8:	91 05       	cpc	r25, r1
 7aa:	31 f1       	breq	.+76     	; 0x7f8
 7ac:	8a 30       	cpi	r24, 0x0A	; 10
 7ae:	91 05       	cpc	r25, r1
 7b0:	34 f4       	brge	.+12     	; 0x7be
 7b2:	87 30       	cpi	r24, 0x07	; 7
 7b4:	91 05       	cpc	r25, r1
 7b6:	e1 f0       	breq	.+56     	; 0x7f0
 7b8:	08 97       	sbiw	r24, 0x08	; 8
 7ba:	e1 f0       	breq	.+56     	; 0x7f4
 7bc:	25 c0       	rjmp	.+74     	; 0x808
 7be:	82 36       	cpi	r24, 0x62	; 98
 7c0:	91 05       	cpc	r25, r1
 7c2:	f1 f0       	breq	.+60     	; 0x800
 7c4:	83 36       	cpi	r24, 0x63	; 99
 7c6:	91 05       	cpc	r25, r1
 7c8:	1c f4       	brge	.+6      	; 0x7d0
 7ca:	0a 97       	sbiw	r24, 0x0a	; 10
 7cc:	d9 f0       	breq	.+54     	; 0x804
 7ce:	1c c0       	rjmp	.+56     	; 0x808
 7d0:	86 36       	cpi	r24, 0x66	; 102
 7d2:	91 05       	cpc	r25, r1
 7d4:	99 f0       	breq	.+38     	; 0x7fc
 7d6:	18 c0       	rjmp	.+48     	; 0x808
 {
	case 0:
		_7SEGMENT_PORT = _7SEGMENT_0;
 7d8:	8f e3       	ldi	r24, 0x3F	; 63
 7da:	15 c0       	rjmp	.+42     	; 0x806
		break;
	case 1:
		_7SEGMENT_PORT = _7SEGMENT_1;
 7dc:	86 e0       	ldi	r24, 0x06	; 6
 7de:	13 c0       	rjmp	.+38     	; 0x806
		break;
	case 2:
		_7SEGMENT_PORT = _7SEGMENT_2;
 7e0:	8b e5       	ldi	r24, 0x5B	; 91
 7e2:	11 c0       	rjmp	.+34     	; 0x806
		break;
	case 3:
		_7SEGMENT_PORT = _7SEGMENT_3;
 7e4:	8f e4       	ldi	r24, 0x4F	; 79
 7e6:	0f c0       	rjmp	.+30     	; 0x806
		break;
	case 4:
		_7SEGMENT_PORT = _7SEGMENT_4;
 7e8:	86 e6       	ldi	r24, 0x66	; 102
 7ea:	0d c0       	rjmp	.+26     	; 0x806
		break;
	case 5:
		_7SEGMENT_PORT = _7SEGMENT_5;
 7ec:	8d e6       	ldi	r24, 0x6D	; 109
 7ee:	0b c0       	rjmp	.+22     	; 0x806
		break;
	case 6:
		_7SEGMENT_PORT = _7SEGMENT_6;
		break;
	case 7:
		_7SEGMENT_PORT = _7SEGMENT_7;
 7f0:	87 e0       	ldi	r24, 0x07	; 7
 7f2:	09 c0       	rjmp	.+18     	; 0x806
		break;
	case 8:
		_7SEGMENT_PORT = _7SEGMENT_8;
 7f4:	8f e7       	ldi	r24, 0x7F	; 127
 7f6:	07 c0       	rjmp	.+14     	; 0x806
		break;
	case 9:
		_7SEGMENT_PORT = _7SEGMENT_9;
 7f8:	87 e6       	ldi	r24, 0x67	; 103
 7fa:	05 c0       	rjmp	.+10     	; 0x806
	    break;
	case 'f':
	    _7SEGMENT_PORT = _7SEGMENT_C_F;
 7fc:	81 e7       	ldi	r24, 0x71	; 113
 7fe:	03 c0       	rjmp	.+6      	; 0x806
		break;
	case 'b':
	    _7SEGMENT_PORT = _7SEGMENT_C_B;
 800:	8c e7       	ldi	r24, 0x7C	; 124
 802:	01 c0       	rjmp	.+2      	; 0x806
		break;
	case DOT:
		_7SEGMENT_PORT = _7SEGMENT_DOT;
 804:	80 e8       	ldi	r24, 0x80	; 128
 806:	88 bb       	out	0x18, r24	; 24
		break;
 
 }
// Out digit
	 
    if ( digit == 1 )
 808:	61 30       	cpi	r22, 0x01	; 1
 80a:	19 f4       	brne	.+6      	; 0x812
	{  // ON Digit 1 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT1);
 80c:	ab 98       	cbi	0x15, 3	; 21
	   // OFF Digit 2 
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT2;
 80e:	ac 9a       	sbi	0x15, 4	; 21
 810:	08 95       	ret
	}
	if ( digit == 2 )
 812:	62 30       	cpi	r22, 0x02	; 2
 814:	11 f4       	brne	.+4      	; 0x81a
	{  // ON Digit 2 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT2);
 816:	ac 98       	cbi	0x15, 4	; 21
	   // OFF Digit 1
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT1;
 818:	ab 9a       	sbi	0x15, 3	; 21
 81a:	08 95       	ret
 81c:	08 95       	ret

0000081e <d7segment_init>:
	}	

}	


/* Initial 7 Segments. Set port to output before use 
*/
void d7segment_init (void)
{
// Set direction for output for 7 Segment
	_7SEGMENT_DIGIT_DIR   = 0xFF;
 81e:	8f ef       	ldi	r24, 0xFF	; 255
 820:	87 bb       	out	0x17, r24	; 23
	_7SEGMENT_PORT_DIR	  |= _7SEGMENT_DIGIT1 | _7SEGMENT_DIGIT2;
 822:	84 b3       	in	r24, 0x14	; 20
 824:	88 61       	ori	r24, 0x18	; 24
 826:	84 bb       	out	0x14, r24	; 20
 
// Set direction for input for SW 
	_7SEGMENT_SW1_DIR	&=  ~(_7SEGMENT_SW1);
 828:	8b 98       	cbi	0x11, 3	; 17
	_7SEGMENT_SW2_DIR	&=  ~(_7SEGMENT_SW2);
 82a:	a2 98       	cbi	0x14, 2	; 20

// Enable pull up
    _7SEGMENT_SW1_PORT   |= _7SEGMENT_SW1;
 82c:	93 9a       	sbi	0x12, 3	; 18
    _7SEGMENT_SW2_PORT   |= _7SEGMENT_SW2;
 82e:	aa 9a       	sbi	0x15, 2	; 21
 830:	08 95       	ret

00000832 <init_motor>:
//	OCR1A = 0x007F;
//	OCR1B = 0x007F;

// Test on TIMER0
    TCCR0  |= _BV(WGM00) |_BV(WGM01) | _BV(CS01) | _BV(CS00)  ;   // Clk/64 Pwm
 832:	83 b7       	in	r24, 0x33	; 51
 834:	8b 64       	ori	r24, 0x4B	; 75
 836:	83 bf       	out	0x33, r24	; 51
    OCR0    = 0x80;
 838:	80 e8       	ldi	r24, 0x80	; 128
 83a:	8c bf       	out	0x3c, r24	; 60
	TIMSK  |=  _BV(OCIE0) | _BV(TOIE0);	
 83c:	89 b7       	in	r24, 0x39	; 57
 83e:	83 60       	ori	r24, 0x03	; 3
 840:	89 bf       	out	0x39, r24	; 57

    MOTOR_DIRECTION_DIR  |= 	MOTORA_1 | MOTORA_2 | MOTORB_1 | MOTORB_2;
 842:	8a b3       	in	r24, 0x1a	; 26
 844:	80 6f       	ori	r24, 0xF0	; 240
 846:	8a bb       	out	0x1a, r24	; 26
	MOTOR_ENABLE12_DIR	 |= 	MOTOR_ENABLE12;
 848:	8d 9a       	sbi	0x11, 5	; 17
	MOTOR_ENABLE34_DIR	 |=  	MOTOR_ENABLE34;		
 84a:	8c 9a       	sbi	0x11, 4	; 17
 84c:	08 95       	ret

0000084e <motor_control>:
}


// speed from 1 - 10

void  motor_control (uint8_t port, uint8_t direction) 
{
 84e:	38 2f       	mov	r19, r24
 850:	86 2f       	mov	r24, r22
  
   uint8_t  controlA,controlB;
   
   switch (direction)
 852:	99 27       	eor	r25, r25
 854:	81 30       	cpi	r24, 0x01	; 1
 856:	91 05       	cpc	r25, r1
 858:	49 f0       	breq	.+18     	; 0x86c
 85a:	82 30       	cpi	r24, 0x02	; 2
 85c:	91 05       	cpc	r25, r1
 85e:	74 f0       	brlt	.+28     	; 0x87c
 860:	82 30       	cpi	r24, 0x02	; 2
 862:	91 05       	cpc	r25, r1
 864:	31 f0       	breq	.+12     	; 0x872
 866:	03 97       	sbiw	r24, 0x03	; 3
 868:	39 f0       	breq	.+14     	; 0x878
 86a:	08 c0       	rjmp	.+16     	; 0x87c
   {
     case MOTOR_FORWARD:
	    controlA = 0;
 86c:	20 e0       	ldi	r18, 0x00	; 0
		controlB = 0xFF;
 86e:	9f ef       	ldi	r25, 0xFF	; 255
		break;
 870:	07 c0       	rjmp	.+14     	; 0x880
	 case MOTOR_BACKWARD:
        controlA = 0xFF;
 872:	2f ef       	ldi	r18, 0xFF	; 255
		controlB = 0;
 874:	90 e0       	ldi	r25, 0x00	; 0
		break;
 876:	04 c0       	rjmp	.+8      	; 0x880
	 case MOTOR_STOP:
	    controlA = 0;
		controlB = 0;
		break;
	case MOTOR_BRAKE:
	    controlA = 0xFF;
 878:	9f ef       	ldi	r25, 0xFF	; 255
 87a:	01 c0       	rjmp	.+2      	; 0x87e
		controlB = 0xFF;
		break;
	default:
	    controlA = 0;
 87c:	90 e0       	ldi	r25, 0x00	; 0
		controlB = 0;
 87e:	29 2f       	mov	r18, r25
   }
 if (port == 1)
 880:	31 30       	cpi	r19, 0x01	; 1
 882:	59 f4       	brne	.+22     	; 0x89a
   {
       MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;
 884:	95 9a       	sbi	0x12, 5	; 18
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORA_1 | MOTORA_2); 
 886:	8b b3       	in	r24, 0x1b	; 27
 888:	8f 7c       	andi	r24, 0xCF	; 207
 88a:	8b bb       	out	0x1b, r24	; 27
	  MOTOR_DIRECTION_CONTROL |= ((MOTORA_1 & controlA ) | (MOTORA_2 & controlB));
 88c:	20 71       	andi	r18, 0x10	; 16
 88e:	90 72       	andi	r25, 0x20	; 32
 890:	29 2b       	or	r18, r25
 892:	8b b3       	in	r24, 0x1b	; 27
 894:	82 2b       	or	r24, r18
 896:	8b bb       	out	0x1b, r24	; 27
 898:	08 95       	ret
  }
  if (port == 2)
 89a:	32 30       	cpi	r19, 0x02	; 2
 89c:	51 f4       	brne	.+20     	; 0x8b2
   {
  	  MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
 89e:	94 9a       	sbi	0x12, 4	; 18
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORB_1 | MOTORB_2); 
 8a0:	8b b3       	in	r24, 0x1b	; 27
 8a2:	8f 73       	andi	r24, 0x3F	; 63
 8a4:	8b bb       	out	0x1b, r24	; 27
  	  MOTOR_DIRECTION_CONTROL |= ((MOTORB_1 & controlA ) | (MOTORB_2 & controlB));
 8a6:	20 74       	andi	r18, 0x40	; 64
 8a8:	90 78       	andi	r25, 0x80	; 128
 8aa:	29 2b       	or	r18, r25
 8ac:	8b b3       	in	r24, 0x1b	; 27
 8ae:	82 2b       	or	r24, r18
 8b0:	8b bb       	out	0x1b, r24	; 27
 8b2:	08 95       	ret
 8b4:	08 95       	ret

000008b6 <init_ir>:

void init_ir()
{
 //Set Direction
    IR_DDR_PORT &= ~IR_ICP; 
 8b6:	8e 98       	cbi	0x11, 6	; 17
	
	TCCR1B  |= ( _BV(ICNC1) | _BV(CS12) | _BV(CS10));			// Time 1 input to clock/1024 input capture on falling edge  noise cancel
 8b8:	8e b5       	in	r24, 0x2e	; 46
 8ba:	85 68       	ori	r24, 0x85	; 133
 8bc:	8e bd       	out	0x2e, r24	; 46
	TIMSK   |= _BV(TICIE1);   								// Enable input capture enable 
 8be:	89 b7       	in	r24, 0x39	; 57
 8c0:	80 62       	ori	r24, 0x20	; 32
 8c2:	89 bf       	out	0x39, r24	; 57
	sei();
 8c4:	78 94       	sei
 8c6:	08 95       	ret

000008c8 <sony_ir_decode>:
}
/*  Decode for Sony remote TV IR 
			Input  Input capturn counter 16 bit register
		   Output  0  = no code detect
				   ir_decode  = detect IR code 
				   
	Algorithm
		Calculate pulse width by substract ICP counter. from pulse width 
		can determine whether it is  START BIT 		 =  XX
									  BIT1 			 =  XX
		until 12 bits then return ir code							  
									 
*/

uint16_t sony_ir_decode ( uint16_t capture_counter)
{
 8c8:	bc 01       	movw	r22, r24
  static 	uint16_t  	prev_capture_counter = 0;
  static 	uint8_t   	stop_bit = 0;
  static	uint16_t	ir_code = 0;
 			uint16_t	width  = 0;	  

      if ( capture_counter > prev_capture_counter)
 8ca:	80 91 a1 00 	lds	r24, 0x00A1
 8ce:	90 91 a2 00 	lds	r25, 0x00A2
 8d2:	9b 01       	movw	r18, r22
 8d4:	28 1b       	sub	r18, r24
 8d6:	39 0b       	sbc	r19, r25
			width = capture_counter - prev_capture_counter;
	  else
			width = capture_counter+(MAX_INT16 - prev_capture_counter);
//Check for start bit
     if ( width > IR_TV_PULSE_WIDTH)
 8d8:	2a 30       	cpi	r18, 0x0A	; 10
 8da:	31 05       	cpc	r19, r1
 8dc:	20 f1       	brcs	.+72     	; 0x926
	 {
		  if (width > IR_TV_START_BIT)  			//  Found Start bit 
 8de:	26 32       	cpi	r18, 0x26	; 38
 8e0:	31 05       	cpc	r19, r1
 8e2:	58 f0       	brcs	.+22     	; 0x8fa
			    {
				  stop_bit = 0;
 8e4:	10 92 a3 00 	sts	0x00A3, r1
				  prev_capture_counter = 0;
 8e8:	10 92 a2 00 	sts	0x00A2, r1
 8ec:	10 92 a1 00 	sts	0x00A1, r1
				  ir_code = 0;     			// New code
 8f0:	10 92 a5 00 	sts	0x00A5, r1
 8f4:	10 92 a4 00 	sts	0x00A4, r1
 8f8:	16 c0       	rjmp	.+44     	; 0x926
 8fa:	80 91 a4 00 	lds	r24, 0x00A4
 8fe:	90 91 a5 00 	lds	r25, 0x00A5
 902:	40 91 a3 00 	lds	r20, 0x00A3
				}
		  else if (width > IR_TV_BIT1)	  		// bit 1 (3T)
 906:	2a 31       	cpi	r18, 0x1A	; 26
 908:	31 05       	cpc	r19, r1
 90a:	20 f0       	brcs	.+8      	; 0x914
				{
				   ir_code <<= 1;    			//Shift right
 90c:	88 0f       	add	r24, r24
 90e:	99 1f       	adc	r25, r25
				   ir_code  |= 1;    			// Or 1
 910:	81 60       	ori	r24, 0x01	; 1
 912:	02 c0       	rjmp	.+4      	; 0x918
				    stop_bit++;
				}
		        else 	  // bit 0
				{
					ir_code  <<=  1;  //Shift right
 914:	88 0f       	add	r24, r24
 916:	99 1f       	adc	r25, r25
 918:	90 93 a5 00 	sts	0x00A5, r25
 91c:	80 93 a4 00 	sts	0x00A4, r24
					stop_bit++;
 920:	4f 5f       	subi	r20, 0xFF	; 255
 922:	40 93 a3 00 	sts	0x00A3, r20
				}
	}
	prev_capture_counter = capture_counter;
 926:	70 93 a2 00 	sts	0x00A2, r23
 92a:	60 93 a1 00 	sts	0x00A1, r22
	if (stop_bit == IR_TV_STOP_BIT)
 92e:	80 91 a3 00 	lds	r24, 0x00A3
 932:	8c 30       	cpi	r24, 0x0C	; 12
 934:	39 f4       	brne	.+14     	; 0x944
	{       //End code dispatch command
  	    stop_bit = 0;
 936:	10 92 a3 00 	sts	0x00A3, r1

		return ir_code;
 93a:	80 91 a4 00 	lds	r24, 0x00A4
 93e:	90 91 a5 00 	lds	r25, 0x00A5
 942:	08 95       	ret
			
//Note if  SELFTEST is selected g_irint = 0;
	}   
	else
		return 0;		// No code detect yet
 944:	80 e0       	ldi	r24, 0x00	; 0
 946:	90 e0       	ldi	r25, 0x00	; 0
}
 948:	08 95       	ret
 94a:	08 95       	ret

0000094c <uart_init>:
{
 
// Initialize UART  
    
    UCSRC  = 0x86;    // 8 bit non parity  1 stop bit
 94c:	86 e8       	ldi	r24, 0x86	; 134
 94e:	80 bd       	out	0x20, r24	; 32
     UCSRB  = 0x98;    // Enable RX Interrupt and Enable TX, RX pin
 950:	88 e9       	ldi	r24, 0x98	; 152
 952:	8a b9       	out	0x0a, r24	; 10
//    UCSRB  = 0B8;    // Enable RX Interrupt, Data registerempty interrupt enable and Enable TX, RX pin 1011-1000
	UBRRL  = 0x67;    // Speed 9600 UBRR = 103 at 16 MHZ
 954:	87 e6       	ldi	r24, 0x67	; 103
 956:	89 b9       	out	0x09, r24	; 9
	UBRRH  = 0;
 958:	10 bc       	out	0x20, r1	; 32
//    DDRD = 0x00;	 
 
	g_rx_ptr = 0;
 95a:	10 92 a7 00 	sts	0x00A7, r1
	g_tx_ptr = 0;
 95e:	10 92 a6 00 	sts	0x00A6, r1
 962:	08 95       	ret

00000964 <uart_put_RX>:
 /* Set baud rate */
 
}

/*
Put character into Rx buffer

Return  = Success 0
        = Fail   Buffer Full
		
*/
uint8_t uart_put_RX ( uint8_t ch)
{
 964:	98 2f       	mov	r25, r24
   if ((g_rx_ptr < MAX_BUFF)) 
 966:	80 91 a7 00 	lds	r24, 0x00A7
 96a:	87 fd       	sbrc	r24, 7
 96c:	10 c0       	rjmp	.+32     	; 0x98e
   {
//  End with Null
		g_rx_buff[g_rx_ptr] = ch;
 96e:	e8 2f       	mov	r30, r24
 970:	ff 27       	eor	r31, r31
 972:	ed 5c       	subi	r30, 0xCD	; 205
 974:	fe 4f       	sbci	r31, 0xFE	; 254
 976:	90 83       	st	Z, r25
		g_rx_ptr++;
 978:	8f 5f       	subi	r24, 0xFF	; 255
 97a:	80 93 a7 00 	sts	0x00A7, r24
		g_rx_buff[g_rx_ptr] = 0;   // End with null characters
 97e:	e8 2f       	mov	r30, r24
 980:	ff 27       	eor	r31, r31
 982:	ed 5c       	subi	r30, 0xCD	; 205
 984:	fe 4f       	sbci	r31, 0xFE	; 254
 986:	10 82       	st	Z, r1
		return 0;
 988:	80 e0       	ldi	r24, 0x00	; 0
 98a:	90 e0       	ldi	r25, 0x00	; 0
 98c:	08 95       	ret
    }
   else  // Buffer full do nothing  return error
   {
        return UART_BUFFER_FULL;
 98e:	82 e0       	ldi	r24, 0x02	; 2
 990:	90 e0       	ldi	r25, 0x00	; 0
   }
}
 992:	08 95       	ret
 994:	08 95       	ret

00000996 <uart_get_RX>:

// Get character from RX buffer

uint8_t uart_get_RX (void)
{
   uint8_t  i,j,ch;
   if (g_rx_ptr)
 996:	80 91 a7 00 	lds	r24, 0x00A7
 99a:	88 23       	and	r24, r24
 99c:	a1 f0       	breq	.+40     	; 0x9c6
   {
		ch = g_rx_buff[0];
 99e:	90 91 33 01 	lds	r25, 0x0133
        i =  g_rx_ptr;
 9a2:	28 2f       	mov	r18, r24
        g_rx_ptr--;
 9a4:	21 50       	subi	r18, 0x01	; 1
 9a6:	20 93 a7 00 	sts	0x00A7, r18
 9aa:	2f 5f       	subi	r18, 0xFF	; 255
		j = 0;
 9ac:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_rx_buff[j] =  g_rx_buff[j+1];
 9ae:	e3 2f       	mov	r30, r19
 9b0:	ff 27       	eor	r31, r31
 9b2:	ed 5c       	subi	r30, 0xCD	; 205
 9b4:	fe 4f       	sbci	r31, 0xFE	; 254
 9b6:	81 81       	ldd	r24, Z+1	; 0x01
 9b8:	80 83       	st	Z, r24
	      j++;
 9ba:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
 9bc:	21 50       	subi	r18, 0x01	; 1
 9be:	b9 f7       	brne	.-18     	; 0x9ae
		}
		return ch;
 9c0:	89 2f       	mov	r24, r25
 9c2:	99 27       	eor	r25, r25
 9c4:	08 95       	ret
   }
   return 0;
 9c6:	80 e0       	ldi	r24, 0x00	; 0
 9c8:	90 e0       	ldi	r25, 0x00	; 0
}
 9ca:	08 95       	ret
 9cc:	08 95       	ret

000009ce <uart_put_TX>:

/* Put character into g_tx_buff
    INPUT  : Character to put in buffer
	Output : 0  OK
		   : UART_BUFFER_FULL  Buffer full
*/

uint8_t uart_put_TX ( uint8_t ch)
{
 9ce:	98 2f       	mov	r25, r24
// If exceed buffer do nothing until buffer is flushed
    if ((g_tx_ptr > MAX_BUFF)) 
 9d0:	80 91 a6 00 	lds	r24, 0x00A6
 9d4:	81 38       	cpi	r24, 0x81	; 129
 9d6:	18 f0       	brcs	.+6      	; 0x9de
    {
		return UART_BUFFER_FULL;   // No increase pointer
 9d8:	82 e0       	ldi	r24, 0x02	; 2
 9da:	90 e0       	ldi	r25, 0x00	; 0
 9dc:	08 95       	ret
    }
	g_tx_buff[g_tx_ptr]= ch;
 9de:	e8 2f       	mov	r30, r24
 9e0:	ff 27       	eor	r31, r31
 9e2:	ed 54       	subi	r30, 0x4D	; 77
 9e4:	fe 4f       	sbci	r31, 0xFE	; 254
 9e6:	90 83       	st	Z, r25
	g_tx_ptr++;
 9e8:	8f 5f       	subi	r24, 0xFF	; 255
 9ea:	80 93 a6 00 	sts	0x00A6, r24
	g_tx_buff[g_tx_ptr] = 0;    // Put null character at the end
 9ee:	e8 2f       	mov	r30, r24
 9f0:	ff 27       	eor	r31, r31
 9f2:	ed 54       	subi	r30, 0x4D	; 77
 9f4:	fe 4f       	sbci	r31, 0xFE	; 254
 9f6:	10 82       	st	Z, r1
	return 0;
 9f8:	80 e0       	ldi	r24, 0x00	; 0
 9fa:	90 e0       	ldi	r25, 0x00	; 0
}
 9fc:	08 95       	ret
 9fe:	08 95       	ret

00000a00 <uart_get_TX>:


// Get character from TX buffer
uint8_t uart_get_TX (void)
{
   uint8_t i,j,ch =0;
   
   if ( g_tx_ptr)
 a00:	80 91 a6 00 	lds	r24, 0x00A6
 a04:	88 23       	and	r24, r24
 a06:	a1 f0       	breq	.+40     	; 0xa30
   {
		i  =  g_tx_ptr;
 a08:	28 2f       	mov	r18, r24
		g_tx_ptr--;
 a0a:	21 50       	subi	r18, 0x01	; 1
 a0c:	20 93 a6 00 	sts	0x00A6, r18
 a10:	2f 5f       	subi	r18, 0xFF	; 255
		ch =  g_tx_buff[0];   // Start from 0 FIFO
 a12:	90 91 b3 01 	lds	r25, 0x01B3
		j = 0;
 a16:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_tx_buff[j] =  g_tx_buff[j+1];
 a18:	e3 2f       	mov	r30, r19
 a1a:	ff 27       	eor	r31, r31
 a1c:	ed 54       	subi	r30, 0x4D	; 77
 a1e:	fe 4f       	sbci	r31, 0xFE	; 254
 a20:	81 81       	ldd	r24, Z+1	; 0x01
 a22:	80 83       	st	Z, r24
	      j++;
 a24:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
 a26:	21 50       	subi	r18, 0x01	; 1
 a28:	b9 f7       	brne	.-18     	; 0xa18
		}
		return ch;
 a2a:	89 2f       	mov	r24, r25
 a2c:	99 27       	eor	r25, r25
 a2e:	08 95       	ret
   }
   return 0;
 a30:	80 e0       	ldi	r24, 0x00	; 0
 a32:	90 e0       	ldi	r25, 0x00	; 0
}
 a34:	08 95       	ret
 a36:	08 95       	ret

00000a38 <uart_getc>:


uint8_t uart_getc(void)
{
    uint8_t ch;
	ch = uart_get_RX();
 a38:	0e 94 cb 04 	call	0x996
    return ch ;
}
 a3c:	99 27       	eor	r25, r25
 a3e:	08 95       	ret

00000a40 <uart_putc>:

uint8_t uart_putc(uint8_t c)
{
    uart_put_TX(c);
 a40:	0e 94 e7 04 	call	0x9ce
// Enable interrupt UART Data Register empty
  UCSRB  |=  (1<<UDRIE);	
 a44:	55 9a       	sbi	0x0a, 5	; 10
//    while ( !(UCSRA & (1<< UDRE)));
//	UDR = c;
    return 0;

}
 a46:	80 e0       	ldi	r24, 0x00	; 0
 a48:	90 e0       	ldi	r25, 0x00	; 0
 a4a:	08 95       	ret

00000a4c <uart_puts>:


/*************************************************************************
Function: uart_puts()
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const uint8_t *s )
{
 a4c:	cf 93       	push	r28
 a4e:	df 93       	push	r29
 a50:	ec 01       	movw	r28, r24
    while (*s) 
      uart_putc(*s++);
 a52:	88 81       	ld	r24, Y
 a54:	88 23       	and	r24, r24
 a56:	21 f0       	breq	.+8      	; 0xa60
 a58:	89 91       	ld	r24, Y+
 a5a:	0e 94 20 05 	call	0xa40
 a5e:	f9 cf       	rjmp	.-14     	; 0xa52
   uart_putc(0x0D); // CR
 a60:	8d e0       	ldi	r24, 0x0D	; 13
 a62:	0e 94 20 05 	call	0xa40
	uart_putc(0x0A); // LF
 a66:	8a e0       	ldi	r24, 0x0A	; 10
 a68:	0e 94 20 05 	call	0xa40
 a6c:	df 91       	pop	r29
 a6e:	cf 91       	pop	r28
 a70:	08 95       	ret

00000a72 <debug_value>:
}

/*
Show debug value
*/

void  debug_value ( int16_t value, uint8_t radix)
{
 a72:	cf 93       	push	r28
 a74:	df 93       	push	r29
 a76:	cd b7       	in	r28, 0x3d	; 61
 a78:	de b7       	in	r29, 0x3e	; 62
 a7a:	64 97       	sbiw	r28, 0x14	; 20
 a7c:	0f b6       	in	r0, 0x3f	; 63
 a7e:	f8 94       	cli
 a80:	de bf       	out	0x3e, r29	; 62
 a82:	0f be       	out	0x3f, r0	; 63
 a84:	cd bf       	out	0x3d, r28	; 61
 a86:	26 2f       	mov	r18, r22
   uint8_t  buff[20];
   
   itoa (value,buff, radix);
 a88:	33 27       	eor	r19, r19
 a8a:	a9 01       	movw	r20, r18
 a8c:	be 01       	movw	r22, r28
 a8e:	6f 5f       	subi	r22, 0xFF	; 255
 a90:	7f 4f       	sbci	r23, 0xFF	; 255
 a92:	0e 94 8c 06 	call	0xd18
    uart_puts ( buff);
 a96:	ce 01       	movw	r24, r28
 a98:	01 96       	adiw	r24, 0x01	; 1
 a9a:	0e 94 26 05 	call	0xa4c
 a9e:	64 96       	adiw	r28, 0x14	; 20
 aa0:	0f b6       	in	r0, 0x3f	; 63
 aa2:	f8 94       	cli
 aa4:	de bf       	out	0x3e, r29	; 62
 aa6:	0f be       	out	0x3f, r0	; 63
 aa8:	cd bf       	out	0x3d, r28	; 61
 aaa:	df 91       	pop	r29
 aac:	cf 91       	pop	r28
 aae:	08 95       	ret

00000ab0 <adc_init>:
      Bit 5   left or right adjust bit in ADLAR
*/
void adc_init(uint8_t voltage)
{
    ADCSRA = 0xC7 | (1<< ADEN);
 ab0:	97 ec       	ldi	r25, 0xC7	; 199
 ab2:	96 b9       	out	0x06, r25	; 6
	
// Set voltage reference 	
	ADMUX  =  voltage << 6;
 ab4:	82 95       	swap	r24
 ab6:	88 0f       	add	r24, r24
 ab8:	88 0f       	add	r24, r24
 aba:	80 7c       	andi	r24, 0xC0	; 192
 abc:	87 b9       	out	0x07, r24	; 7

// Set input for ADC pin
    DDRA    &= 0xF0;	
 abe:	8a b3       	in	r24, 0x1a	; 26
 ac0:	80 7f       	andi	r24, 0xF0	; 240
 ac2:	8a bb       	out	0x1a, r24	; 26
 ac4:	08 95       	ret

00000ac6 <adc_enable_int>:

}

/*
  Input mode = 0  Disable
        mode > 0  Enable


*/
void  adc_enable_int (uint8_t mode)
{
    if (mode)
 ac6:	88 23       	and	r24, r24
 ac8:	19 f0       	breq	.+6      	; 0xad0
	{
		ADCSRA  |= ( (1 << ADEN) | (1 << ADIE) | (1<< ADSC));
 aca:	86 b1       	in	r24, 0x06	; 6
 acc:	88 6c       	ori	r24, 0xC8	; 200
 ace:	02 c0       	rjmp	.+4      	; 0xad4
    }
	else
	{
		ADCSRA  &= ~((1 << ADIE) | (1<< ADSC));
 ad0:	86 b1       	in	r24, 0x06	; 6
 ad2:	87 7b       	andi	r24, 0xB7	; 183
 ad4:	86 b9       	out	0x06, r24	; 6
 ad6:	08 95       	ret
 ad8:	08 95       	ret

00000ada <read_adc>:
	}
}


/*
Read adc value		
	
	INPUT :  channel  to read adc  ( See table for Differential INput and Gain)
    Polling mode 
*/

int16_t read_adc(uint8_t channel)
{
  int16_t  value;
  
 
// Before that need to clear ADATE and ADEN
    ADCSRA &= ~((1 << ADEN) | (1<< ADATE));
 ada:	96 b1       	in	r25, 0x06	; 6
 adc:	9f 75       	andi	r25, 0x5F	; 95
 ade:	96 b9       	out	0x06, r25	; 6

// Set channel
    ADMUX |= channel;
 ae0:	97 b1       	in	r25, 0x07	; 7
 ae2:	98 2b       	or	r25, r24
 ae4:	97 b9       	out	0x07, r25	; 7
	
// Enable conversion
	ADCSRA |= (1<<ADEN);
 ae6:	37 9a       	sbi	0x06, 7	; 6
// Start conversion
 
    
// Check whether conversion is complete
 
    ADCSRA |= (1<<ADSC);         // do single conversion
 ae8:	36 9a       	sbi	0x06, 6	; 6
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
 aea:	34 9b       	sbis	0x06, 4	; 6
 aec:	fe cf       	rjmp	.-4      	; 0xaea

//Read value
//      value = ADCL;            // read out ADCL register
//      value += (ADCH << 8);    // read out ADCH register        
	value = ADCW;
 aee:	84 b1       	in	r24, 0x04	; 4
 af0:	95 b1       	in	r25, 0x05	; 5
 af2:	08 95       	ret

00000af4 <text_decode>:

*/ 

uint8_t text_decode (uint8_t *buffer, uint8_t *cmd_argument)
{
 af4:	cf 92       	push	r12
 af6:	df 92       	push	r13
 af8:	ef 92       	push	r14
 afa:	ff 92       	push	r15
 afc:	0f 93       	push	r16
 afe:	1f 93       	push	r17
 b00:	cf 93       	push	r28
 b02:	7c 01       	movw	r14, r24

 uint8_t  found,ch,ch2,cmd_no,j,k,index,cmd_complete;
 uint8_t  state = WAIT_CMD_STATE, quote  = 0;
 b04:	51 e0       	ldi	r21, 0x01	; 1
 static uint16_t i=0; // Keep pointer for next command decode
 cmd_complete = 0;
 b06:	cc 24       	eor	r12, r12
 cmd_no 	= 0;
 b08:	dc 2c       	mov	r13, r12
 index 		= 0;
 b0a:	4c 2d       	mov	r20, r12
 
 cmd_argument  = buffer;
 
 while (*(buffer+i))	  		//End with NULL
 {
// Check with delimiter

 	 j = 0;
	 found = 0;
	
	switch (state)
	{
	  case WAIT_CMD_STATE:   // If found first character in command table  then go to get_cmd state
 		j = 0;
		while ((ch = pgm_read_byte(&text_cmd[j][0])))     //Check first charaters in cmd table
		{ 
		  if (*(buffer+i) == ch)
		  {
			state = GET_CMD_STATE;   // Found delimiter
			*(cmd_argument) = ch;
			index = 1;
			break; 
		  }
		 j++;
		}  
	    break;
	  case GET_CMD_STATE:
	    ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
		if (found)
		{
        	*(cmd_argument+index) = 0x00;
		     if (ch == '=')
			 {
// Check command number 
  				for (k = 0; k < CMD_NUM ; k++)
				{
					if (!(strcasecmp_P(cmd_argument,&text_cmd[k][0])))  // Found then keep command
					{
						cmd_no  = k+1;   // Start from 0 
						break;
					}
				}
// clear index
  				index = 0;
			    state = WAIT_ARG_STATE;	
			 }	
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}
		break;
		
	  case WAIT_ARG_STATE:
		ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
				
		if ( ch == '"')   // Start quote
		{
			quote ^= 1;   // Toggle quote	
			state = GET_ARG_STATE;   
 			index = 0;
		}
		
		if (!found)    // Not delimiter start get Argument
		{
			state = GET_ARG_STATE;   
			*(cmd_argument) = ch;
			index = 1;
		}
		break;	
	  case	GET_ARG_STATE:
	  	ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
 		if ( ch == '"')     // End quote
		{
			quote ^= 1;   // Toggle quote	
   		}
		if ( quote)
		{
         	found = 0; //  ignore all characters after the quote until found quote again
// Cancel quote
            
		}	
		if (found)
		{	
            cmd_complete = 1;
			*(cmd_argument+index) = 0;
		    state = WAIT_CMD_STATE;
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}  
		break;
	}
	
	if(cmd_complete)   // COmmand both cmd number and argument
	{
		return cmd_no;	 	 
	}
	i++;
 b0c:	e0 91 a8 00 	lds	r30, 0x00A8
 b10:	f0 91 a9 00 	lds	r31, 0x00A9
 b14:	ee 0d       	add	r30, r14
 b16:	ff 1d       	adc	r31, r15
 b18:	80 81       	ld	r24, Z
 b1a:	88 23       	and	r24, r24
 b1c:	09 f4       	brne	.+2      	; 0xb20
 b1e:	c1 c0       	rjmp	.+386    	; 0xca2
 b20:	30 e0       	ldi	r19, 0x00	; 0
 b22:	85 2f       	mov	r24, r21
 b24:	99 27       	eor	r25, r25
 b26:	82 30       	cpi	r24, 0x02	; 2
 b28:	91 05       	cpc	r25, r1
 b2a:	79 f1       	breq	.+94     	; 0xb8a
 b2c:	83 30       	cpi	r24, 0x03	; 3
 b2e:	91 05       	cpc	r25, r1
 b30:	1c f4       	brge	.+6      	; 0xb38
 b32:	01 97       	sbiw	r24, 0x01	; 1
 b34:	59 f0       	breq	.+22     	; 0xb4c
 b36:	ab c0       	rjmp	.+342    	; 0xc8e
 b38:	83 30       	cpi	r24, 0x03	; 3
 b3a:	91 05       	cpc	r25, r1
 b3c:	09 f4       	brne	.+2      	; 0xb40
 b3e:	5a c0       	rjmp	.+180    	; 0xbf4
 b40:	04 97       	sbiw	r24, 0x04	; 4
 b42:	09 f4       	brne	.+2      	; 0xb46
 b44:	7b c0       	rjmp	.+246    	; 0xc3c
 b46:	a3 c0       	rjmp	.+326    	; 0xc8e
 b48:	52 e0       	ldi	r21, 0x02	; 2
 b4a:	72 c0       	rjmp	.+228    	; 0xc30
 b4c:	23 2f       	mov	r18, r19
 b4e:	ec e5       	ldi	r30, 0x5C	; 92
 b50:	f0 e0       	ldi	r31, 0x00	; 0
 b52:	94 91       	lpm	r25, Z
 b54:	99 23       	and	r25, r25
 b56:	09 f4       	brne	.+2      	; 0xb5a
 b58:	9a c0       	rjmp	.+308    	; 0xc8e
 b5a:	e0 91 a8 00 	lds	r30, 0x00A8
 b5e:	f0 91 a9 00 	lds	r31, 0x00A9
 b62:	ee 0d       	add	r30, r14
 b64:	ff 1d       	adc	r31, r15
 b66:	80 81       	ld	r24, Z
 b68:	3a e0       	ldi	r19, 0x0A	; 10
 b6a:	89 17       	cp	r24, r25
 b6c:	69 f3       	breq	.-38     	; 0xb48
 b6e:	2f 5f       	subi	r18, 0xFF	; 255
 b70:	23 9f       	mul	r18, r19
 b72:	f0 01       	movw	r30, r0
 b74:	11 24       	eor	r1, r1
 b76:	e4 5a       	subi	r30, 0xA4	; 164
 b78:	ff 4f       	sbci	r31, 0xFF	; 255
 b7a:	94 91       	lpm	r25, Z
 b7c:	99 23       	and	r25, r25
 b7e:	a9 f7       	brne	.-22     	; 0xb6a
 b80:	86 c0       	rjmp	.+268    	; 0xc8e
 b82:	31 e0       	ldi	r19, 0x01	; 1
 b84:	17 c0       	rjmp	.+46     	; 0xbb4
 b86:	c2 2e       	mov	r12, r18
 b88:	30 c0       	rjmp	.+96     	; 0xbea
 b8a:	e0 91 a8 00 	lds	r30, 0x00A8
 b8e:	f0 91 a9 00 	lds	r31, 0x00A9
 b92:	ee 0d       	add	r30, r14
 b94:	ff 1d       	adc	r31, r15
 b96:	90 81       	ld	r25, Z
 b98:	23 2f       	mov	r18, r19
 b9a:	e4 e5       	ldi	r30, 0x54	; 84
 b9c:	f0 e0       	ldi	r31, 0x00	; 0
 b9e:	84 91       	lpm	r24, Z
 ba0:	88 23       	and	r24, r24
 ba2:	41 f0       	breq	.+16     	; 0xbb4
 ba4:	98 17       	cp	r25, r24
 ba6:	69 f3       	breq	.-38     	; 0xb82
 ba8:	2f 5f       	subi	r18, 0xFF	; 255
 baa:	e2 2f       	mov	r30, r18
 bac:	ff 27       	eor	r31, r31
 bae:	ec 5a       	subi	r30, 0xAC	; 172
 bb0:	ff 4f       	sbci	r31, 0xFF	; 255
 bb2:	f5 cf       	rjmp	.-22     	; 0xb9e
 bb4:	e4 2f       	mov	r30, r20
 bb6:	ff 27       	eor	r31, r31
 bb8:	33 23       	and	r19, r19
 bba:	09 f4       	brne	.+2      	; 0xbbe
 bbc:	64 c0       	rjmp	.+200    	; 0xc86
 bbe:	ee 0d       	add	r30, r14
 bc0:	ff 1d       	adc	r31, r15
 bc2:	10 82       	st	Z, r1
 bc4:	9d 33       	cpi	r25, 0x3D	; 61
 bc6:	09 f0       	breq	.+2      	; 0xbca
 bc8:	62 c0       	rjmp	.+196    	; 0xc8e
 bca:	c0 81       	ld	r28, Z
 bcc:	0c e5       	ldi	r16, 0x5C	; 92
 bce:	10 e0       	ldi	r17, 0x00	; 0
 bd0:	b8 01       	movw	r22, r16
 bd2:	c7 01       	movw	r24, r14
 bd4:	0e 94 b9 06 	call	0xd72
 bd8:	2c 2f       	mov	r18, r28
 bda:	2f 5f       	subi	r18, 0xFF	; 255
 bdc:	89 2b       	or	r24, r25
 bde:	99 f2       	breq	.-90     	; 0xb86
 be0:	c2 2f       	mov	r28, r18
 be2:	06 5f       	subi	r16, 0xF6	; 246
 be4:	1f 4f       	sbci	r17, 0xFF	; 255
 be6:	24 30       	cpi	r18, 0x04	; 4
 be8:	98 f3       	brcs	.-26     	; 0xbd0
 bea:	40 e0       	ldi	r20, 0x00	; 0
 bec:	53 e0       	ldi	r21, 0x03	; 3
 bee:	4f c0       	rjmp	.+158    	; 0xc8e
 bf0:	31 e0       	ldi	r19, 0x01	; 1
 bf2:	15 c0       	rjmp	.+42     	; 0xc1e
 bf4:	e0 91 a8 00 	lds	r30, 0x00A8
 bf8:	f0 91 a9 00 	lds	r31, 0x00A9
 bfc:	ee 0d       	add	r30, r14
 bfe:	ff 1d       	adc	r31, r15
 c00:	90 81       	ld	r25, Z
 c02:	23 2f       	mov	r18, r19
 c04:	e4 e5       	ldi	r30, 0x54	; 84
 c06:	f0 e0       	ldi	r31, 0x00	; 0
 c08:	84 91       	lpm	r24, Z
 c0a:	88 23       	and	r24, r24
 c0c:	41 f0       	breq	.+16     	; 0xc1e
 c0e:	98 17       	cp	r25, r24
 c10:	79 f3       	breq	.-34     	; 0xbf0
 c12:	2f 5f       	subi	r18, 0xFF	; 255
 c14:	e2 2f       	mov	r30, r18
 c16:	ff 27       	eor	r31, r31
 c18:	ec 5a       	subi	r30, 0xAC	; 172
 c1a:	ff 4f       	sbci	r31, 0xFF	; 255
 c1c:	f5 cf       	rjmp	.-22     	; 0xc08
 c1e:	92 32       	cpi	r25, 0x22	; 34
 c20:	21 f4       	brne	.+8      	; 0xc2a
 c22:	81 e0       	ldi	r24, 0x01	; 1
 c24:	d8 26       	eor	r13, r24
 c26:	54 e0       	ldi	r21, 0x04	; 4
 c28:	40 e0       	ldi	r20, 0x00	; 0
 c2a:	33 23       	and	r19, r19
 c2c:	81 f5       	brne	.+96     	; 0xc8e
 c2e:	54 e0       	ldi	r21, 0x04	; 4
 c30:	f7 01       	movw	r30, r14
 c32:	90 83       	st	Z, r25
 c34:	41 e0       	ldi	r20, 0x01	; 1
 c36:	2b c0       	rjmp	.+86     	; 0xc8e
 c38:	31 e0       	ldi	r19, 0x01	; 1
 c3a:	15 c0       	rjmp	.+42     	; 0xc66
 c3c:	e0 91 a8 00 	lds	r30, 0x00A8
 c40:	f0 91 a9 00 	lds	r31, 0x00A9
 c44:	ee 0d       	add	r30, r14
 c46:	ff 1d       	adc	r31, r15
 c48:	90 81       	ld	r25, Z
 c4a:	23 2f       	mov	r18, r19
 c4c:	e4 e5       	ldi	r30, 0x54	; 84
 c4e:	f0 e0       	ldi	r31, 0x00	; 0
 c50:	84 91       	lpm	r24, Z
 c52:	88 23       	and	r24, r24
 c54:	41 f0       	breq	.+16     	; 0xc66
 c56:	98 17       	cp	r25, r24
 c58:	79 f3       	breq	.-34     	; 0xc38
 c5a:	2f 5f       	subi	r18, 0xFF	; 255
 c5c:	e2 2f       	mov	r30, r18
 c5e:	ff 27       	eor	r31, r31
 c60:	ec 5a       	subi	r30, 0xAC	; 172
 c62:	ff 4f       	sbci	r31, 0xFF	; 255
 c64:	f5 cf       	rjmp	.-22     	; 0xc50
 c66:	92 32       	cpi	r25, 0x22	; 34
 c68:	11 f4       	brne	.+4      	; 0xc6e
 c6a:	81 e0       	ldi	r24, 0x01	; 1
 c6c:	d8 26       	eor	r13, r24
 c6e:	d1 10       	cpse	r13, r1
 c70:	30 e0       	ldi	r19, 0x00	; 0
 c72:	e4 2f       	mov	r30, r20
 c74:	ff 27       	eor	r31, r31
 c76:	33 23       	and	r19, r19
 c78:	31 f0       	breq	.+12     	; 0xc86
 c7a:	ee 0d       	add	r30, r14
 c7c:	ff 1d       	adc	r31, r15
 c7e:	10 82       	st	Z, r1
 c80:	8c 2d       	mov	r24, r12
 c82:	99 27       	eor	r25, r25
 c84:	14 c0       	rjmp	.+40     	; 0xcae
 c86:	ee 0d       	add	r30, r14
 c88:	ff 1d       	adc	r31, r15
 c8a:	90 83       	st	Z, r25
 c8c:	4f 5f       	subi	r20, 0xFF	; 255
 c8e:	e0 91 a8 00 	lds	r30, 0x00A8
 c92:	f0 91 a9 00 	lds	r31, 0x00A9
 c96:	31 96       	adiw	r30, 0x01	; 1
 c98:	f0 93 a9 00 	sts	0x00A9, r31
 c9c:	e0 93 a8 00 	sts	0x00A8, r30
 ca0:	39 cf       	rjmp	.-398    	; 0xb14
 }
  i = 0;
 ca2:	10 92 a9 00 	sts	0x00A9, r1
 ca6:	10 92 a8 00 	sts	0x00A8, r1
  return 0xFF;  // End of Buffer
 caa:	8f ef       	ldi	r24, 0xFF	; 255
 cac:	90 e0       	ldi	r25, 0x00	; 0
 cae:	cf 91       	pop	r28
 cb0:	1f 91       	pop	r17
 cb2:	0f 91       	pop	r16
 cb4:	ff 90       	pop	r15
 cb6:	ef 90       	pop	r14
 cb8:	df 90       	pop	r13
 cba:	cf 90       	pop	r12
 cbc:	08 95       	ret

00000cbe <atoi>:
 cbe:	fc 01       	movw	r30, r24
 cc0:	88 27       	eor	r24, r24
 cc2:	99 27       	eor	r25, r25
 cc4:	e8 94       	clt

00000cc6 <.atoi_loop>:
 cc6:	21 91       	ld	r18, Z+
 cc8:	22 23       	and	r18, r18
 cca:	f1 f0       	breq	.+60     	; 0xd08
 ccc:	20 32       	cpi	r18, 0x20	; 32
 cce:	d9 f3       	breq	.-10     	; 0xcc6
 cd0:	29 30       	cpi	r18, 0x09	; 9
 cd2:	c9 f3       	breq	.-14     	; 0xcc6
 cd4:	2a 30       	cpi	r18, 0x0A	; 10
 cd6:	b9 f3       	breq	.-18     	; 0xcc6
 cd8:	2c 30       	cpi	r18, 0x0C	; 12
 cda:	a9 f3       	breq	.-22     	; 0xcc6
 cdc:	2d 30       	cpi	r18, 0x0D	; 13
 cde:	99 f3       	breq	.-26     	; 0xcc6
 ce0:	26 37       	cpi	r18, 0x76	; 118
 ce2:	89 f3       	breq	.-30     	; 0xcc6
 ce4:	2b 32       	cpi	r18, 0x2B	; 43
 ce6:	19 f0       	breq	.+6      	; 0xcee
 ce8:	2d 32       	cpi	r18, 0x2D	; 45
 cea:	21 f4       	brne	.+8      	; 0xcf4

00000cec <.atoi_neg>:
 cec:	68 94       	set

00000cee <.atoi_loop2>:
 cee:	21 91       	ld	r18, Z+
 cf0:	22 23       	and	r18, r18
 cf2:	51 f0       	breq	.+20     	; 0xd08

00000cf4 <.atoi_digit>:
 cf4:	20 33       	cpi	r18, 0x30	; 48
 cf6:	44 f0       	brlt	.+16     	; 0xd08
 cf8:	2a 33       	cpi	r18, 0x3A	; 58
 cfa:	34 f4       	brge	.+12     	; 0xd08
 cfc:	20 53       	subi	r18, 0x30	; 48
 cfe:	0e 94 b1 06 	call	0xd62
 d02:	82 0f       	add	r24, r18
 d04:	91 1d       	adc	r25, r1
 d06:	f3 cf       	rjmp	.-26     	; 0xcee

00000d08 <.atoi_sig>:
 d08:	81 15       	cp	r24, r1
 d0a:	91 05       	cpc	r25, r1
 d0c:	21 f0       	breq	.+8      	; 0xd16
 d0e:	1e f4       	brtc	.+6      	; 0xd16
 d10:	80 95       	com	r24
 d12:	90 95       	com	r25
 d14:	01 96       	adiw	r24, 0x01	; 1

00000d16 <.atoi_done>:
 d16:	08 95       	ret

00000d18 <itoa>:
 d18:	e6 2f       	mov	r30, r22
 d1a:	f7 2f       	mov	r31, r23
 d1c:	2e 2f       	mov	r18, r30
 d1e:	3f 2f       	mov	r19, r31
 d20:	e8 94       	clt
 d22:	42 30       	cpi	r20, 0x02	; 2
 d24:	cc f0       	brlt	.+50     	; 0xd58
 d26:	45 32       	cpi	r20, 0x25	; 37
 d28:	bc f4       	brge	.+46     	; 0xd58
 d2a:	4a 30       	cpi	r20, 0x0A	; 10
 d2c:	29 f4       	brne	.+10     	; 0xd38
 d2e:	97 fb       	bst	r25, 7
 d30:	1e f4       	brtc	.+6      	; 0xd38
 d32:	90 95       	com	r25
 d34:	81 95       	neg	r24
 d36:	9f 4f       	sbci	r25, 0xFF	; 255

00000d38 <divide_loop>:
 d38:	64 2f       	mov	r22, r20
 d3a:	77 27       	eor	r23, r23
 d3c:	0e 94 dc 06 	call	0xdb8
 d40:	80 5d       	subi	r24, 0xD0	; 208
 d42:	8a 33       	cpi	r24, 0x3A	; 58
 d44:	0c f0       	brlt	.+2      	; 0xd48
 d46:	89 5d       	subi	r24, 0xD9	; 217

00000d48 <L_10>:
 d48:	81 93       	st	Z+, r24
 d4a:	86 2f       	mov	r24, r22
 d4c:	97 2f       	mov	r25, r23
 d4e:	00 97       	sbiw	r24, 0x00	; 0
 d50:	99 f7       	brne	.-26     	; 0xd38
 d52:	16 f4       	brtc	.+4      	; 0xd58
 d54:	5d e2       	ldi	r21, 0x2D	; 45
 d56:	51 93       	st	Z+, r21

00000d58 <terminate>:
 d58:	93 2f       	mov	r25, r19
 d5a:	82 2f       	mov	r24, r18
 d5c:	10 82       	st	Z, r1
 d5e:	0c 94 cc 06 	jmp	0xd98

00000d62 <__mulhi_const_10>:
 d62:	7a e0       	ldi	r23, 0x0A	; 10
 d64:	97 9f       	mul	r25, r23
 d66:	90 2d       	mov	r25, r0
 d68:	87 9f       	mul	r24, r23
 d6a:	80 2d       	mov	r24, r0
 d6c:	91 0d       	add	r25, r1
 d6e:	11 24       	eor	r1, r1
 d70:	08 95       	ret

00000d72 <strcasecmp_P>:
 d72:	fb 01       	movw	r30, r22
 d74:	dc 01       	movw	r26, r24

00000d76 <.strcasecmp_P_loop>:
 d76:	8d 91       	ld	r24, X+
 d78:	05 90       	lpm	r0, Z+
 d7a:	60 2d       	mov	r22, r0
 d7c:	50 2d       	mov	r21, r0
 d7e:	50 62       	ori	r21, 0x20	; 32
 d80:	51 36       	cpi	r21, 0x61	; 97
 d82:	24 f0       	brlt	.+8      	; 0xd8c
 d84:	5b 37       	cpi	r21, 0x7B	; 123
 d86:	14 f4       	brge	.+4      	; 0xd8c
 d88:	60 62       	ori	r22, 0x20	; 32
 d8a:	80 62       	ori	r24, 0x20	; 32

00000d8c <.strcasecmp_P_tst>:
 d8c:	86 1b       	sub	r24, r22
 d8e:	11 f4       	brne	.+4      	; 0xd94
 d90:	00 20       	and	r0, r0
 d92:	89 f7       	brne	.-30     	; 0xd76

00000d94 <.strcasecmp_P_done>:
 d94:	99 0b       	sbc	r25, r25
 d96:	08 95       	ret

00000d98 <strrev>:
 d98:	dc 01       	movw	r26, r24
 d9a:	fc 01       	movw	r30, r24

00000d9c <.strrev_eos>:
 d9c:	01 90       	ld	r0, Z+
 d9e:	00 20       	and	r0, r0
 da0:	e9 f7       	brne	.-6      	; 0xd9c
 da2:	32 97       	sbiw	r30, 0x02	; 2

00000da4 <.strrev_loop>:
 da4:	ae 17       	cp	r26, r30
 da6:	bf 07       	cpc	r27, r31
 da8:	30 f4       	brcc	.+12     	; 0xdb6
 daa:	7c 91       	ld	r23, X
 dac:	60 81       	ld	r22, Z
 dae:	70 83       	st	Z, r23
 db0:	31 97       	sbiw	r30, 0x01	; 1
 db2:	6d 93       	st	X+, r22
 db4:	f7 cf       	rjmp	.-18     	; 0xda4

00000db6 <.strrev_done>:
 db6:	08 95       	ret

00000db8 <__udivmodhi4>:
 db8:	aa 1b       	sub	r26, r26
 dba:	bb 1b       	sub	r27, r27
 dbc:	51 e1       	ldi	r21, 0x11	; 17
 dbe:	07 c0       	rjmp	.+14     	; 0xdce

00000dc0 <__udivmodhi4_loop>:
 dc0:	aa 1f       	adc	r26, r26
 dc2:	bb 1f       	adc	r27, r27
 dc4:	a6 17       	cp	r26, r22
 dc6:	b7 07       	cpc	r27, r23
 dc8:	10 f0       	brcs	.+4      	; 0xdce
 dca:	a6 1b       	sub	r26, r22
 dcc:	b7 0b       	sbc	r27, r23

00000dce <__udivmodhi4_ep>:
 dce:	88 1f       	adc	r24, r24
 dd0:	99 1f       	adc	r25, r25
 dd2:	5a 95       	dec	r21
 dd4:	a9 f7       	brne	.-22     	; 0xdc0
 dd6:	80 95       	com	r24
 dd8:	90 95       	com	r25
 dda:	bc 01       	movw	r22, r24
 ddc:	cd 01       	movw	r24, r26
 dde:	08 95       	ret
