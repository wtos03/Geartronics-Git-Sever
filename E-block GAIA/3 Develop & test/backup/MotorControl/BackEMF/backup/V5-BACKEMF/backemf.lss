
backemf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001124  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000054  00800060  00001124  000011b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000312  008000b4  008000b4  0000120c  2**0
                  ALLOC
  3 .noinit       00000000  008003c6  008003c6  0000120c  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  0000120c  2**0
                  CONTENTS
  5 .stab         00002694  00000000  00000000  0000120c  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000fe9  00000000  00000000  000038a0  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 42 00 	jmp	0x84
       4:	0c 94 5d 00 	jmp	0xba
       8:	0c 94 5d 00 	jmp	0xba
       c:	0c 94 5d 00 	jmp	0xba
      10:	0c 94 53 03 	jmp	0x6a6
      14:	0c 94 2d 03 	jmp	0x65a
      18:	0c 94 db 03 	jmp	0x7b6
      1c:	0c 94 5d 00 	jmp	0xba
      20:	0c 94 5d 00 	jmp	0xba
      24:	0c 94 5d 00 	jmp	0xba
      28:	0c 94 07 03 	jmp	0x60e
      2c:	0c 94 da 02 	jmp	0x5b4
      30:	0c 94 5d 00 	jmp	0xba
      34:	0c 94 81 03 	jmp	0x702
      38:	0c 94 b2 03 	jmp	0x764
      3c:	0c 94 5d 00 	jmp	0xba
      40:	0c 94 5d 00 	jmp	0xba
      44:	0c 94 5d 00 	jmp	0xba
      48:	0c 94 5d 00 	jmp	0xba
      4c:	0c 94 5d 00 	jmp	0xba
      50:	0c 94 5d 00 	jmp	0xba

00000054 <__ctors_end>:
      54:	3d 22       	and	r3, r29
      56:	20 09       	sbc	r18, r0
      58:	2c 0d       	add	r18, r12
      5a:	0a 00       	.word	0x000a	; ????

0000005c <text_cmd>:
      5c:	6d 6f 74 6f 72 00 00 00 00 00 73 70 65 65 64 00     motor.....speed.
      6c:	00 00 00 00 61 6e 67 6c 65 00 00 00 00 00 00 00     ....angle.......
	...

00000084 <__init>:
      84:	11 24       	eor	r1, r1
      86:	1f be       	out	0x3f, r1	; 63
      88:	cf e5       	ldi	r28, 0x5F	; 95
      8a:	d8 e0       	ldi	r29, 0x08	; 8
      8c:	de bf       	out	0x3e, r29	; 62
      8e:	cd bf       	out	0x3d, r28	; 61

00000090 <__do_copy_data>:
      90:	10 e0       	ldi	r17, 0x00	; 0
      92:	a0 e6       	ldi	r26, 0x60	; 96
      94:	b0 e0       	ldi	r27, 0x00	; 0
      96:	e4 e2       	ldi	r30, 0x24	; 36
      98:	f1 e1       	ldi	r31, 0x11	; 17
      9a:	02 c0       	rjmp	.+4      	; 0xa0

0000009c <.do_copy_data_loop>:
      9c:	05 90       	lpm	r0, Z+
      9e:	0d 92       	st	X+, r0

000000a0 <.do_copy_data_start>:
      a0:	a4 3b       	cpi	r26, 0xB4	; 180
      a2:	b1 07       	cpc	r27, r17
      a4:	d9 f7       	brne	.-10     	; 0x9c

000000a6 <__do_clear_bss>:
      a6:	13 e0       	ldi	r17, 0x03	; 3
      a8:	a4 eb       	ldi	r26, 0xB4	; 180
      aa:	b0 e0       	ldi	r27, 0x00	; 0
      ac:	01 c0       	rjmp	.+2      	; 0xb0

000000ae <.do_clear_bss_loop>:
      ae:	1d 92       	st	X+, r1

000000b0 <.do_clear_bss_start>:
      b0:	a6 3c       	cpi	r26, 0xC6	; 198
      b2:	b1 07       	cpc	r27, r17
      b4:	e1 f7       	brne	.-8      	; 0xae
      b6:	0c 94 33 04 	jmp	0x866

000000ba <__bad_interrupt>:
      ba:	0c 94 00 00 	jmp	0x0

000000be <delay>:

void delay ( uint16_t  time)
{
   uint16_t i;
   for (i = 0 ; i < time; i++);
      be:	00 97       	sbiw	r24, 0x00	; 0
      c0:	11 f0       	breq	.+4      	; 0xc6
      c2:	01 97       	sbiw	r24, 0x01	; 1
      c4:	fc cf       	rjmp	.-8      	; 0xbe
      c6:	08 95       	ret

000000c8 <set_motor_parameter>:

}

void  set_motor_parameter ( uint8_t mode)
{
   switch (mode)
      c8:	99 27       	eor	r25, r25
      ca:	82 30       	cpi	r24, 0x02	; 2
      cc:	91 05       	cpc	r25, r1
      ce:	81 f0       	breq	.+32     	; 0xf0
      d0:	83 30       	cpi	r24, 0x03	; 3
      d2:	91 05       	cpc	r25, r1
      d4:	2c f4       	brge	.+10     	; 0xe0
      d6:	00 97       	sbiw	r24, 0x00	; 0
      d8:	79 f1       	breq	.+94     	; 0x138
      da:	01 97       	sbiw	r24, 0x01	; 1
      dc:	39 f0       	breq	.+14     	; 0xec
      de:	2c c0       	rjmp	.+88     	; 0x138
      e0:	84 30       	cpi	r24, 0x04	; 4
      e2:	91 05       	cpc	r25, r1
      e4:	f9 f0       	breq	.+62     	; 0x124
      e6:	05 97       	sbiw	r24, 0x05	; 5
      e8:	11 f1       	breq	.+68     	; 0x12e
      ea:	26 c0       	rjmp	.+76     	; 0x138
   {
    case  MOTOR_FORWARD:
        g_mode[0] = MOTOR_FORWARD;		
      ec:	81 e0       	ldi	r24, 0x01	; 1
      ee:	01 c0       	rjmp	.+2      	; 0xf2
		g_mode[1] = MOTOR_FORWARD;
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case  MOTOR_BACKWARD:
		g_mode[0] = MOTOR_BACKWARD;
      f0:	82 e0       	ldi	r24, 0x02	; 2
      f2:	80 93 bd 00 	sts	0x00BD, r24
		g_mode[1] = MOTOR_BACKWARD;
      f6:	80 93 be 00 	sts	0x00BE, r24
		g_angle[0] = 1;
      fa:	81 e0       	ldi	r24, 0x01	; 1
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	a0 e0       	ldi	r26, 0x00	; 0
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	80 93 cb 00 	sts	0x00CB, r24
     106:	90 93 cc 00 	sts	0x00CC, r25
     10a:	a0 93 cd 00 	sts	0x00CD, r26
     10e:	b0 93 ce 00 	sts	0x00CE, r27
		g_angle[1] = 1;
     112:	80 93 cf 00 	sts	0x00CF, r24
     116:	90 93 d0 00 	sts	0x00D0, r25
     11a:	a0 93 d1 00 	sts	0x00D1, r26
     11e:	b0 93 d2 00 	sts	0x00D2, r27
		break;
     122:	08 95       	ret
    case MOTOR_STOP:
		g_mode[0]  = MOTOR_STOP;
		g_mode[1]  = MOTOR_STOP;
		g_angle[0] = 0;
		g_angle[1] = 0;
		break;
	case MOTOR_TURN_LEFT:
		g_mode[0] = MOTOR_FORWARD;		
     124:	81 e0       	ldi	r24, 0x01	; 1
     126:	80 93 bd 00 	sts	0x00BD, r24
		g_mode[1] = MOTOR_BACKWARD;
     12a:	82 e0       	ldi	r24, 0x02	; 2
     12c:	e4 cf       	rjmp	.-56     	; 0xf6
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case MOTOR_TURN_RIGHT:
		g_mode[0] = MOTOR_BACKWARD;
     12e:	82 e0       	ldi	r24, 0x02	; 2
     130:	80 93 bd 00 	sts	0x00BD, r24
		g_mode[1] = MOTOR_FORWARD;
     134:	81 e0       	ldi	r24, 0x01	; 1
     136:	df cf       	rjmp	.-66     	; 0xf6
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	 default:
	 	g_mode[0]  = MOTOR_STOP;
     138:	10 92 bd 00 	sts	0x00BD, r1
		g_mode[1]  = MOTOR_STOP;
     13c:	10 92 be 00 	sts	0x00BE, r1
		g_angle[0] = 0;
     140:	10 92 cb 00 	sts	0x00CB, r1
     144:	10 92 cc 00 	sts	0x00CC, r1
     148:	10 92 cd 00 	sts	0x00CD, r1
     14c:	10 92 ce 00 	sts	0x00CE, r1
		g_angle[1] = 0;
     150:	10 92 cf 00 	sts	0x00CF, r1
     154:	10 92 d0 00 	sts	0x00D0, r1
     158:	10 92 d1 00 	sts	0x00D1, r1
     15c:	10 92 d2 00 	sts	0x00D2, r1
     160:	08 95       	ret
     162:	08 95       	ret

00000164 <remote_decode>:
		break;
   }
  
}

/* This subroutine will handle IR remote decode by getting remote code from Interrupt handle for input capture
and will response  to each remote key. For other applications user can modified here for different remote active
However this routine support Sony remote control only
   global effect   g_irint;
*/

void remote_decode ( uint16_t ircode)
{ 
     164:	cf 93       	push	r28

  uint8_t set_speed = 8 ;
     166:	c8 e0       	ldi	r28, 0x08	; 8
  switch ( ircode)
     168:	26 e0       	ldi	r18, 0x06	; 6
     16a:	80 31       	cpi	r24, 0x10	; 16
     16c:	92 07       	cpc	r25, r18
     16e:	09 f4       	brne	.+2      	; 0x172
     170:	5e c0       	rjmp	.+188    	; 0x22e
     172:	26 e0       	ldi	r18, 0x06	; 6
     174:	81 31       	cpi	r24, 0x11	; 17
     176:	92 07       	cpc	r25, r18
     178:	20 f5       	brcc	.+72     	; 0x1c2
     17a:	21 e0       	ldi	r18, 0x01	; 1
     17c:	80 31       	cpi	r24, 0x10	; 16
     17e:	92 07       	cpc	r25, r18
     180:	09 f4       	brne	.+2      	; 0x184
     182:	94 c0       	rjmp	.+296    	; 0x2ac
     184:	21 e0       	ldi	r18, 0x01	; 1
     186:	81 31       	cpi	r24, 0x11	; 17
     188:	92 07       	cpc	r25, r18
     18a:	48 f4       	brcc	.+18     	; 0x19e
     18c:	80 31       	cpi	r24, 0x10	; 16
     18e:	91 05       	cpc	r25, r1
     190:	09 f4       	brne	.+2      	; 0x194
     192:	41 c0       	rjmp	.+130    	; 0x216
     194:	80 39       	cpi	r24, 0x90	; 144
     196:	91 05       	cpc	r25, r1
     198:	09 f4       	brne	.+2      	; 0x19c
     19a:	7f c0       	rjmp	.+254    	; 0x29a
     19c:	87 c0       	rjmp	.+270    	; 0x2ac
     19e:	24 e0       	ldi	r18, 0x04	; 4
     1a0:	80 31       	cpi	r24, 0x10	; 16
     1a2:	92 07       	cpc	r25, r18
     1a4:	09 f4       	brne	.+2      	; 0x1a8
     1a6:	3b c0       	rjmp	.+118    	; 0x21e
     1a8:	24 e0       	ldi	r18, 0x04	; 4
     1aa:	81 31       	cpi	r24, 0x11	; 17
     1ac:	92 07       	cpc	r25, r18
     1ae:	20 f4       	brcc	.+8      	; 0x1b8
     1b0:	80 51       	subi	r24, 0x10	; 16
     1b2:	92 40       	sbci	r25, 0x02	; 2
     1b4:	c1 f1       	breq	.+112    	; 0x226
     1b6:	7a c0       	rjmp	.+244    	; 0x2ac
     1b8:	80 59       	subi	r24, 0x90	; 144
     1ba:	94 40       	sbci	r25, 0x04	; 4
     1bc:	09 f4       	brne	.+2      	; 0x1c0
     1be:	71 c0       	rjmp	.+226    	; 0x2a2
     1c0:	75 c0       	rjmp	.+234    	; 0x2ac
     1c2:	2a e0       	ldi	r18, 0x0A	; 10
     1c4:	80 31       	cpi	r24, 0x10	; 16
     1c6:	92 07       	cpc	r25, r18
     1c8:	81 f1       	breq	.+96     	; 0x22a
     1ca:	2a e0       	ldi	r18, 0x0A	; 10
     1cc:	81 31       	cpi	r24, 0x11	; 17
     1ce:	92 07       	cpc	r25, r18
     1d0:	88 f4       	brcc	.+34     	; 0x1f4
     1d2:	28 e0       	ldi	r18, 0x08	; 8
     1d4:	80 39       	cpi	r24, 0x90	; 144
     1d6:	92 07       	cpc	r25, r18
     1d8:	09 f4       	brne	.+2      	; 0x1dc
     1da:	61 c0       	rjmp	.+194    	; 0x29e
     1dc:	28 e0       	ldi	r18, 0x08	; 8
     1de:	81 39       	cpi	r24, 0x91	; 145
     1e0:	92 07       	cpc	r25, r18
     1e2:	20 f4       	brcc	.+8      	; 0x1ec
     1e4:	80 51       	subi	r24, 0x10	; 16
     1e6:	98 40       	sbci	r25, 0x08	; 8
     1e8:	c1 f0       	breq	.+48     	; 0x21a
     1ea:	60 c0       	rjmp	.+192    	; 0x2ac
     1ec:	80 51       	subi	r24, 0x10	; 16
     1ee:	99 40       	sbci	r25, 0x09	; 9
     1f0:	11 f1       	breq	.+68     	; 0x236
     1f2:	5c c0       	rjmp	.+184    	; 0x2ac
     1f4:	2c e0       	ldi	r18, 0x0C	; 12
     1f6:	80 39       	cpi	r24, 0x90	; 144
     1f8:	92 07       	cpc	r25, r18
     1fa:	09 f4       	brne	.+2      	; 0x1fe
     1fc:	54 c0       	rjmp	.+168    	; 0x2a6
     1fe:	2c e0       	ldi	r18, 0x0C	; 12
     200:	81 39       	cpi	r24, 0x91	; 145
     202:	92 07       	cpc	r25, r18
     204:	20 f4       	brcc	.+8      	; 0x20e
     206:	80 51       	subi	r24, 0x10	; 16
     208:	9c 40       	sbci	r25, 0x0C	; 12
     20a:	59 f0       	breq	.+22     	; 0x222
     20c:	4f c0       	rjmp	.+158    	; 0x2ac
     20e:	80 51       	subi	r24, 0x10	; 16
     210:	9e 40       	sbci	r25, 0x0E	; 14
     212:	79 f0       	breq	.+30     	; 0x232
     214:	4b c0       	rjmp	.+150    	; 0x2ac
	   {
	    case IR_TV_1:	
 			set_speed = 0;
     216:	c0 e0       	ldi	r28, 0x00	; 0
			 break;
     218:	49 c0       	rjmp	.+146    	; 0x2ac
		case IR_TV_2:
			set_speed =1;
     21a:	c1 e0       	ldi	r28, 0x01	; 1
			break;
     21c:	47 c0       	rjmp	.+142    	; 0x2ac
	    case IR_TV_3:
 			set_speed =2;			
     21e:	c2 e0       	ldi	r28, 0x02	; 2
			break;
     220:	45 c0       	rjmp	.+138    	; 0x2ac
		case IR_TV_4:
 			set_speed =3;			
     222:	c3 e0       	ldi	r28, 0x03	; 3
			 break;
     224:	43 c0       	rjmp	.+134    	; 0x2ac
	    case IR_TV_5:
 			set_speed =4;			
     226:	c4 e0       	ldi	r28, 0x04	; 4
			 break;
     228:	41 c0       	rjmp	.+130    	; 0x2ac
		case IR_TV_6:
 			set_speed = 5;			
     22a:	c5 e0       	ldi	r28, 0x05	; 5
			 break;
     22c:	3f c0       	rjmp	.+126    	; 0x2ac
	    case IR_TV_7:
 			set_speed = 6;			
     22e:	c6 e0       	ldi	r28, 0x06	; 6
			break;
     230:	3d c0       	rjmp	.+122    	; 0x2ac
		case IR_TV_8:
 			set_speed = 7;			
     232:	c7 e0       	ldi	r28, 0x07	; 7
			break;
     234:	3b c0       	rjmp	.+118    	; 0x2ac
	    case IR_TV_9:
 			set_speed =8;			
			break;
		case IR_TV_0:
			set_motor_parameter (MOTOR_STOP);
     236:	80 e0       	ldi	r24, 0x00	; 0
     238:	0e 94 64 00 	call	0xc8
			uart_puts ("Voltage SUM 1");
     23c:	8b e6       	ldi	r24, 0x6B	; 107
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	0e 94 24 06 	call	0xc48
			debug_lvalue(g_pos[0],10);
     244:	4a e0       	ldi	r20, 0x0A	; 10
     246:	60 91 b5 00 	lds	r22, 0x00B5
     24a:	70 91 b6 00 	lds	r23, 0x00B6
     24e:	80 91 b7 00 	lds	r24, 0x00B7
     252:	90 91 b8 00 	lds	r25, 0x00B8
     256:	0e 94 56 06 	call	0xcac
			g_pos[0] =0;
     25a:	10 92 b5 00 	sts	0x00B5, r1
     25e:	10 92 b6 00 	sts	0x00B6, r1
     262:	10 92 b7 00 	sts	0x00B7, r1
     266:	10 92 b8 00 	sts	0x00B8, r1
			uart_puts ("Voltage SUM 2");
     26a:	89 e7       	ldi	r24, 0x79	; 121
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	0e 94 24 06 	call	0xc48
			debug_lvalue(g_pos[1],10);
     272:	4a e0       	ldi	r20, 0x0A	; 10
     274:	60 91 b9 00 	lds	r22, 0x00B9
     278:	70 91 ba 00 	lds	r23, 0x00BA
     27c:	80 91 bb 00 	lds	r24, 0x00BB
     280:	90 91 bc 00 	lds	r25, 0x00BC
     284:	0e 94 56 06 	call	0xcac
			g_pos[1] =0;
     288:	10 92 b9 00 	sts	0x00B9, r1
     28c:	10 92 ba 00 	sts	0x00BA, r1
     290:	10 92 bb 00 	sts	0x00BB, r1
     294:	10 92 bc 00 	sts	0x00BC, r1
			break;
     298:	09 c0       	rjmp	.+18     	; 0x2ac
		case IR_TV_CHUP:
			set_motor_parameter(MOTOR_FORWARD);
     29a:	81 e0       	ldi	r24, 0x01	; 1
     29c:	05 c0       	rjmp	.+10     	; 0x2a8
			break;
		case IR_TV_CHDOWN:							
			set_motor_parameter(MOTOR_BACKWARD);
     29e:	82 e0       	ldi	r24, 0x02	; 2
     2a0:	03 c0       	rjmp	.+6      	; 0x2a8
			break;
		case IR_TV_TVMUTE:
			break;
		case  IR_TV_TVPOWER:
		  	break;
		case   IR_TV_TVAV:
		    break;
		case  IR_TV_VOLUP:
            set_motor_parameter(MOTOR_TURN_LEFT);
     2a2:	84 e0       	ldi	r24, 0x04	; 4
     2a4:	01 c0       	rjmp	.+2      	; 0x2a8
			break;
		case  IR_TV_VOLDOWN:                 			
		    set_motor_parameter(MOTOR_TURN_RIGHT);
     2a6:	85 e0       	ldi	r24, 0x05	; 5
     2a8:	0e 94 64 00 	call	0xc8
			break;
		default:
 //			set_motor_parameter (MOTOR_STOP);
			break;
 	   }
	   g_speed[1] = g_speed_table[set_speed]; 
     2ac:	ec 2f       	mov	r30, r28
     2ae:	ff 27       	eor	r31, r31
     2b0:	ee 59       	subi	r30, 0x9E	; 158
     2b2:	ff 4f       	sbci	r31, 0xFF	; 255
     2b4:	80 81       	ld	r24, Z
     2b6:	99 27       	eor	r25, r25
     2b8:	90 93 d1 01 	sts	0x01D1, r25
     2bc:	80 93 d0 01 	sts	0x01D0, r24
	   g_speed[0] = g_speed[1];
     2c0:	90 93 cf 01 	sts	0x01CF, r25
     2c4:	80 93 ce 01 	sts	0x01CE, r24
     2c8:	cf 91       	pop	r28
     2ca:	08 95       	ret

000002cc <cmd_decode>:

}



/* Command decode from g_rcv_buffer  will decode and action according to command in buffer
 
*/

int16_t cmd_decode (void)
{
     2cc:	ff 92       	push	r15
     2ce:	0f 93       	push	r16
     2d0:	1f 93       	push	r17
     2d2:	cf 93       	push	r28
     2d4:	df 93       	push	r29

 uint8_t  cmd_no =0;
 uint8_t  *cmd_argument;
 uint8_t  *buffer_ptr;
 uint8_t   i;
 
// Should repeat until end of buffer
 
// Loop until end of text

   buffer_ptr   = g_rcv_buff;
   cmd_argument = g_rcv_buff;
     
   while ( cmd_no !=  CMD_LINE_END)     // Until end of line which mean g_motor will change
   {
 		cmd_no =  text_decode (buffer_ptr,cmd_argument);
     2d6:	64 ed       	ldi	r22, 0xD4	; 212
     2d8:	70 e0       	ldi	r23, 0x00	; 0
     2da:	cb 01       	movw	r24, r22
     2dc:	0e 94 a4 06 	call	0xd48
     2e0:	f8 2e       	mov	r15, r24
#ifdef DEBUG		
		uart_puts("Command :");
     2e2:	87 e8       	ldi	r24, 0x87	; 135
     2e4:	90 e0       	ldi	r25, 0x00	; 0
     2e6:	0e 94 24 06 	call	0xc48
		uart_putc(0x30+cmd_no);
     2ea:	8f 2d       	mov	r24, r15
     2ec:	80 5d       	subi	r24, 0xD0	; 208
     2ee:	0e 94 1e 06 	call	0xc3c
		uart_putc('*');
     2f2:	8a e2       	ldi	r24, 0x2A	; 42
     2f4:	0e 94 1e 06 	call	0xc3c
		uart_puts(cmd_argument);
     2f8:	84 ed       	ldi	r24, 0xD4	; 212
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	0e 94 24 06 	call	0xc48
#endif        
 		switch (cmd_no)
     300:	8f 2d       	mov	r24, r15
     302:	99 27       	eor	r25, r25
     304:	82 30       	cpi	r24, 0x02	; 2
     306:	91 05       	cpc	r25, r1
     308:	c9 f0       	breq	.+50     	; 0x33c
     30a:	83 30       	cpi	r24, 0x03	; 3
     30c:	91 05       	cpc	r25, r1
     30e:	1c f4       	brge	.+6      	; 0x316
     310:	01 97       	sbiw	r24, 0x01	; 1
     312:	21 f0       	breq	.+8      	; 0x31c
     314:	93 c0       	rjmp	.+294    	; 0x43c
     316:	03 97       	sbiw	r24, 0x03	; 3
     318:	81 f1       	breq	.+96     	; 0x37a
     31a:	90 c0       	rjmp	.+288    	; 0x43c
		{
			case MOTOR_CMD: 
				g_motor = (uint8_t)atoi(cmd_argument);
     31c:	84 ed       	ldi	r24, 0xD4	; 212
     31e:	90 e0       	ldi	r25, 0x00	; 0
     320:	0e 94 89 07 	call	0xf12
     324:	80 93 d3 00 	sts	0x00D3, r24
				if (g_motor > 0)
     328:	28 2f       	mov	r18, r24
     32a:	88 23       	and	r24, r24
     32c:	21 f0       	breq	.+8      	; 0x336
				   g_motor--;                //  > 0 Start from 0 need -1
     32e:	21 50       	subi	r18, 0x01	; 1
     330:	20 93 d3 00 	sts	0x00D3, r18
     334:	87 c0       	rjmp	.+270    	; 0x444
				else
				   g_motor = 0;
     336:	80 93 d3 00 	sts	0x00D3, r24
 				break;
     33a:	84 c0       	rjmp	.+264    	; 0x444
			case  SPEED_CMD:	
				i = (uint8_t)atoi(cmd_argument);
     33c:	84 ed       	ldi	r24, 0xD4	; 212
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	0e 94 89 07 	call	0xf12
     344:	e8 2f       	mov	r30, r24
				if ( i >=  MOTOR_MAX_SPEED)
     346:	89 30       	cpi	r24, 0x09	; 9
     348:	10 f0       	brcs	.+4      	; 0x34e
						i = MOTOR_MAX_SPEED;    // Start from 0
     34a:	e9 e0       	ldi	r30, 0x09	; 9
     34c:	01 c0       	rjmp	.+2      	; 0x350
				if (i)   // i > 0; 		
     34e:	81 11       	cpse	r24, r1
					i--;   //Start from 0;		
     350:	e1 50       	subi	r30, 0x01	; 1
				g_speed[g_motor] =  g_speed_table[i];
     352:	80 91 d3 00 	lds	r24, 0x00D3
     356:	c8 2f       	mov	r28, r24
     358:	dd 27       	eor	r29, r29
     35a:	de 01       	movw	r26, r28
     35c:	ac 0f       	add	r26, r28
     35e:	bd 1f       	adc	r27, r29
     360:	a2 53       	subi	r26, 0x32	; 50
     362:	be 4f       	sbci	r27, 0xFE	; 254
     364:	ff 27       	eor	r31, r31
     366:	ee 59       	subi	r30, 0x9E	; 158
     368:	ff 4f       	sbci	r31, 0xFF	; 255
     36a:	80 81       	ld	r24, Z
     36c:	99 27       	eor	r25, r25
     36e:	8d 93       	st	X+, r24
     370:	9c 93       	st	X, r25
				if (g_speed[g_motor] == 0)
     372:	89 2b       	or	r24, r25
     374:	09 f0       	breq	.+2      	; 0x378
     376:	66 c0       	rjmp	.+204    	; 0x444
     378:	32 c0       	rjmp	.+100    	; 0x3de
				        g_mode[g_motor] = MOTOR_STOP;
  				break;
			case  ANGLE_CMD:   // Can be - 
				g_angle[g_motor] = atoi(cmd_argument);
     37a:	80 91 d3 00 	lds	r24, 0x00D3
     37e:	c8 2f       	mov	r28, r24
     380:	dd 27       	eor	r29, r29
     382:	8e 01       	movw	r16, r28
     384:	00 0f       	add	r16, r16
     386:	11 1f       	adc	r17, r17
     388:	00 0f       	add	r16, r16
     38a:	11 1f       	adc	r17, r17
     38c:	05 53       	subi	r16, 0x35	; 53
     38e:	1f 4f       	sbci	r17, 0xFF	; 255
     390:	84 ed       	ldi	r24, 0xD4	; 212
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	0e 94 89 07 	call	0xf12
     398:	9c 01       	movw	r18, r24
     39a:	44 27       	eor	r20, r20
     39c:	37 fd       	sbrc	r19, 7
     39e:	40 95       	com	r20
     3a0:	54 2f       	mov	r21, r20
     3a2:	f8 01       	movw	r30, r16
     3a4:	20 83       	st	Z, r18
     3a6:	31 83       	std	Z+1, r19	; 0x01
     3a8:	42 83       	std	Z+2, r20	; 0x02
     3aa:	53 83       	std	Z+3, r21	; 0x03
				if (g_angle[g_motor] < 0)
     3ac:	57 ff       	sbrs	r21, 7
     3ae:	12 c0       	rjmp	.+36     	; 0x3d4
				{   
						g_mode[g_motor] = MOTOR_BACKWARD;
     3b0:	fe 01       	movw	r30, r28
     3b2:	e3 54       	subi	r30, 0x43	; 67
     3b4:	ff 4f       	sbci	r31, 0xFF	; 255
     3b6:	82 e0       	ldi	r24, 0x02	; 2
     3b8:	80 83       	st	Z, r24
// Set g_angle to positive value by invert all bit and +1                
                        g_angle[g_motor] = (~(g_angle[g_motor])+1);
     3ba:	66 27       	eor	r22, r22
     3bc:	77 27       	eor	r23, r23
     3be:	cb 01       	movw	r24, r22
     3c0:	62 1b       	sub	r22, r18
     3c2:	73 0b       	sbc	r23, r19
     3c4:	84 0b       	sbc	r24, r20
     3c6:	95 0b       	sbc	r25, r21
     3c8:	f8 01       	movw	r30, r16
     3ca:	60 83       	st	Z, r22
     3cc:	71 83       	std	Z+1, r23	; 0x01
     3ce:	82 83       	std	Z+2, r24	; 0x02
     3d0:	93 83       	std	Z+3, r25	; 0x03
     3d2:	18 c0       	rjmp	.+48     	; 0x404
                        if  (g_angle[g_motor] > 1)
						{
 						   g_angle[g_motor] *= MOTOR_ANGLE_COEF;
						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
						}		
				}	
				else  if (g_angle[g_motor] == 0)
     3d4:	21 15       	cp	r18, r1
     3d6:	31 05       	cpc	r19, r1
     3d8:	41 05       	cpc	r20, r1
     3da:	51 05       	cpc	r21, r1
     3dc:	21 f4       	brne	.+8      	; 0x3e6
				        g_mode[g_motor] = MOTOR_STOP;
     3de:	c3 54       	subi	r28, 0x43	; 67
     3e0:	df 4f       	sbci	r29, 0xFF	; 255
     3e2:	18 82       	st	Y, r1
     3e4:	2f c0       	rjmp	.+94     	; 0x444
				else	  
				{
					if ((g_angle[g_motor] > 0))   //  +
     3e6:	12 16       	cp	r1, r18
     3e8:	13 06       	cpc	r1, r19
     3ea:	14 06       	cpc	r1, r20
     3ec:	15 06       	cpc	r1, r21
     3ee:	2c f4       	brge	.+10     	; 0x3fa
						g_mode[g_motor] = MOTOR_FORWARD;
     3f0:	fe 01       	movw	r30, r28
     3f2:	e3 54       	subi	r30, 0x43	; 67
     3f4:	ff 4f       	sbci	r31, 0xFF	; 255
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	80 83       	st	Z, r24
					if  (g_angle[g_motor] > 1)
     3fa:	f8 01       	movw	r30, r16
     3fc:	60 81       	ld	r22, Z
     3fe:	71 81       	ldd	r23, Z+1	; 0x01
     400:	82 81       	ldd	r24, Z+2	; 0x02
     402:	93 81       	ldd	r25, Z+3	; 0x03
     404:	62 30       	cpi	r22, 0x02	; 2
     406:	71 05       	cpc	r23, r1
     408:	81 05       	cpc	r24, r1
     40a:	91 05       	cpc	r25, r1
     40c:	dc f0       	brlt	.+54     	; 0x444
					{
 						g_angle[g_motor] *=  MOTOR_ANGLE_COEF;	
     40e:	24 e6       	ldi	r18, 0x64	; 100
     410:	30 e0       	ldi	r19, 0x00	; 0
     412:	40 e0       	ldi	r20, 0x00	; 0
     414:	50 e0       	ldi	r21, 0x00	; 0
     416:	0e 94 3d 08 	call	0x107a
     41a:	dc 01       	movw	r26, r24
     41c:	cb 01       	movw	r24, r22
     41e:	f8 01       	movw	r30, r16
     420:	80 83       	st	Z, r24
     422:	91 83       	std	Z+1, r25	; 0x01
     424:	a2 83       	std	Z+2, r26	; 0x02
     426:	b3 83       	std	Z+3, r27	; 0x03
						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
     428:	cc 0f       	add	r28, r28
     42a:	dd 1f       	adc	r29, r29
     42c:	c2 53       	subi	r28, 0x32	; 50
     42e:	de 4f       	sbci	r29, 0xFE	; 254
     430:	80 91 67 00 	lds	r24, 0x0067
     434:	99 27       	eor	r25, r25
     436:	88 83       	st	Y, r24
     438:	99 83       	std	Y+1, r25	; 0x01
					}
 				}
				break;	
     43a:	04 c0       	rjmp	.+8      	; 0x444
 			default:
			    uart_puts("Command not found ");
     43c:	81 e9       	ldi	r24, 0x91	; 145
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	0e 94 24 06 	call	0xc48
 		        break;	  
     444:	ff ef       	ldi	r31, 0xFF	; 255
     446:	ff 16       	cp	r15, r31
     448:	09 f0       	breq	.+2      	; 0x44c
     44a:	45 cf       	rjmp	.-374    	; 0x2d6
		}		
    }
 return 0; 
}
     44c:	80 e0       	ldi	r24, 0x00	; 0
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	df 91       	pop	r29
     452:	cf 91       	pop	r28
     454:	1f 91       	pop	r17
     456:	0f 91       	pop	r16
     458:	ff 90       	pop	r15
     45a:	08 95       	ret

0000045c <calculate_backemf>:

/* Calculate backemf and save in g_pos

*/
void calculate_backemf (uint8_t motor)
{
     45c:	cf 92       	push	r12
     45e:	df 92       	push	r13
     460:	ef 92       	push	r14
     462:	ff 92       	push	r15
     464:	0f 93       	push	r16
     466:	1f 93       	push	r17
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	18 2f       	mov	r17, r24
     int16_t backemf=0;
  // Read backemf
     static uint8_t  i = 0;

	adc_init(3);
     46e:	83 e0       	ldi	r24, 0x03	; 3
     470:	0e 94 81 06 	call	0xd02
	backemf = read_adc(g_adc_channel[motor]);	
     474:	01 2f       	mov	r16, r17
     476:	11 27       	eor	r17, r17
     478:	f8 01       	movw	r30, r16
     47a:	e0 5a       	subi	r30, 0xA0	; 160
     47c:	ff 4f       	sbci	r31, 0xFF	; 255
     47e:	80 81       	ld	r24, Z
     480:	0e 94 96 06 	call	0xd2c
     484:	ec 01       	movw	r28, r24


// Cut offset	
	if ((backemf > 0) && (backemf < MOTOR_OFFSET))
     486:	01 97       	sbiw	r24, 0x01	; 1
     488:	c1 97       	sbiw	r24, 0x31	; 49
     48a:	10 f4       	brcc	.+4      	; 0x490
			backemf =0;
     48c:	c0 e0       	ldi	r28, 0x00	; 0
     48e:	d0 e0       	ldi	r29, 0x00	; 0
			
// Negative convert to positive with 2 complement	
	if (g_mode[motor] == MOTOR_STOP)   
     490:	f8 01       	movw	r30, r16
     492:	e3 54       	subi	r30, 0x43	; 67
     494:	ff 4f       	sbci	r31, 0xFF	; 255
     496:	80 81       	ld	r24, Z
     498:	88 23       	and	r24, r24
     49a:	51 f4       	brne	.+20     	; 0x4b0
    {	
		if (backemf & 0x200)
     49c:	ce 01       	movw	r24, r28
     49e:	89 2f       	mov	r24, r25
     4a0:	99 27       	eor	r25, r25
     4a2:	86 95       	lsr	r24
     4a4:	80 ff       	sbrs	r24, 0
     4a6:	04 c0       	rjmp	.+8      	; 0x4b0
		{
		    backemf = (~(backemf) & (0x03FF))+1;
     4a8:	c0 95       	com	r28
     4aa:	d0 95       	com	r29
     4ac:	d3 70       	andi	r29, 0x03	; 3
     4ae:	21 96       	adiw	r28, 0x01	; 1
 		}		
	}		
			
	if (g_mode[motor] == MOTOR_FORWARD)   // Motor stop backemf -  Forward backemf +
     4b0:	f8 01       	movw	r30, r16
     4b2:	e3 54       	subi	r30, 0x43	; 67
     4b4:	ff 4f       	sbci	r31, 0xFF	; 255
     4b6:	80 81       	ld	r24, Z
     4b8:	81 30       	cpi	r24, 0x01	; 1
     4ba:	79 f4       	brne	.+30     	; 0x4da
    {	
		if (backemf & 0x200)
     4bc:	ce 01       	movw	r24, r28
     4be:	89 2f       	mov	r24, r25
     4c0:	99 27       	eor	r25, r25
     4c2:	86 95       	lsr	r24
     4c4:	9c 01       	movw	r18, r24
     4c6:	21 70       	andi	r18, 0x01	; 1
     4c8:	30 70       	andi	r19, 0x00	; 0
     4ca:	80 ff       	sbrs	r24, 0
     4cc:	05 c0       	rjmp	.+10     	; 0x4d8
		{
		    backemf = (~(backemf) & (0x03FF))+1;
     4ce:	c0 95       	com	r28
     4d0:	d0 95       	com	r29
     4d2:	d3 70       	andi	r29, 0x03	; 3
     4d4:	21 96       	adiw	r28, 0x01	; 1
     4d6:	01 c0       	rjmp	.+2      	; 0x4da
 		}
		else
			backemf = 0;
     4d8:	e9 01       	movw	r28, r18
    }
	if (g_mode[motor] == MOTOR_BACKWARD)   // Motor stop backemf +  backward backemf -
     4da:	f8 01       	movw	r30, r16
     4dc:	e3 54       	subi	r30, 0x43	; 67
     4de:	ff 4f       	sbci	r31, 0xFF	; 255
     4e0:	80 81       	ld	r24, Z
     4e2:	82 30       	cpi	r24, 0x02	; 2
     4e4:	41 f4       	brne	.+16     	; 0x4f6
    {	
		if (backemf & 0x200)
     4e6:	ce 01       	movw	r24, r28
     4e8:	89 2f       	mov	r24, r25
     4ea:	99 27       	eor	r25, r25
     4ec:	86 95       	lsr	r24
     4ee:	80 ff       	sbrs	r24, 0
     4f0:	02 c0       	rjmp	.+4      	; 0x4f6
		{
			backemf =0;
     4f2:	c0 e0       	ldi	r28, 0x00	; 0
     4f4:	d0 e0       	ldi	r29, 0x00	; 0
		}
    }
	
	g_pos[motor] += backemf;
     4f6:	68 01       	movw	r12, r16
     4f8:	cc 0c       	add	r12, r12
     4fa:	dd 1c       	adc	r13, r13
     4fc:	cc 0c       	add	r12, r12
     4fe:	dd 1c       	adc	r13, r13
     500:	95 eb       	ldi	r25, 0xB5	; 181
     502:	e9 2e       	mov	r14, r25
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	f9 2e       	mov	r15, r25
     508:	ec 0c       	add	r14, r12
     50a:	fd 1c       	adc	r15, r13
     50c:	ce 01       	movw	r24, r28
     50e:	aa 27       	eor	r26, r26
     510:	97 fd       	sbrc	r25, 7
     512:	a0 95       	com	r26
     514:	ba 2f       	mov	r27, r26
     516:	f7 01       	movw	r30, r14
     518:	20 81       	ld	r18, Z
     51a:	31 81       	ldd	r19, Z+1	; 0x01
     51c:	42 81       	ldd	r20, Z+2	; 0x02
     51e:	53 81       	ldd	r21, Z+3	; 0x03
     520:	28 0f       	add	r18, r24
     522:	39 1f       	adc	r19, r25
     524:	4a 1f       	adc	r20, r26
     526:	5b 1f       	adc	r21, r27
     528:	20 83       	st	Z, r18
     52a:	31 83       	std	Z+1, r19	; 0x01
     52c:	42 83       	std	Z+2, r20	; 0x02
     52e:	53 83       	std	Z+3, r21	; 0x03
    if (g_mode[motor] != MOTOR_STOP)	
     530:	03 54       	subi	r16, 0x43	; 67
     532:	1f 4f       	sbci	r17, 0xFF	; 255
     534:	f8 01       	movw	r30, r16
     536:	80 81       	ld	r24, Z
     538:	88 23       	and	r24, r24
     53a:	31 f0       	breq	.+12     	; 0x548
 	{   
//	    i++;
//		if ( i == 100 )
		{
			debug_value(backemf,10);
     53c:	6a e0       	ldi	r22, 0x0A	; 10
     53e:	ce 01       	movw	r24, r28
     540:	0e 94 37 06 	call	0xc6e
			i = 0;
     544:	10 92 bf 00 	sts	0x00BF, r1
		}
	}	
//Compare voltage	
	if (((g_angle[motor] > 1)) && ( g_mode[motor] != MOTOR_STOP))
     548:	f6 01       	movw	r30, r12
     54a:	e5 53       	subi	r30, 0x35	; 53
     54c:	ff 4f       	sbci	r31, 0xFF	; 255
     54e:	20 81       	ld	r18, Z
     550:	31 81       	ldd	r19, Z+1	; 0x01
     552:	42 81       	ldd	r20, Z+2	; 0x02
     554:	53 81       	ldd	r21, Z+3	; 0x03
     556:	22 30       	cpi	r18, 0x02	; 2
     558:	31 05       	cpc	r19, r1
     55a:	41 05       	cpc	r20, r1
     55c:	51 05       	cpc	r21, r1
     55e:	0c f1       	brlt	.+66     	; 0x5a2
     560:	f8 01       	movw	r30, r16
     562:	80 81       	ld	r24, Z
     564:	88 23       	and	r24, r24
     566:	e9 f0       	breq	.+58     	; 0x5a2
	{   
			if ( g_pos[motor]  >= (g_angle[motor]))  //  Check for position
     568:	f7 01       	movw	r30, r14
     56a:	80 81       	ld	r24, Z
     56c:	91 81       	ldd	r25, Z+1	; 0x01
     56e:	a2 81       	ldd	r26, Z+2	; 0x02
     570:	b3 81       	ldd	r27, Z+3	; 0x03
     572:	82 17       	cp	r24, r18
     574:	93 07       	cpc	r25, r19
     576:	a4 07       	cpc	r26, r20
     578:	b5 07       	cpc	r27, r21
     57a:	9c f0       	brlt	.+38     	; 0x5a2
			{
//				delay(3);
				g_mode[motor] = MOTOR_STOP;
     57c:	f8 01       	movw	r30, r16
     57e:	10 82       	st	Z, r1
				uart_puts ("Voltage SUM");
     580:	84 ea       	ldi	r24, 0xA4	; 164
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	0e 94 24 06 	call	0xc48
				debug_lvalue(g_pos[motor],10);
     588:	4a e0       	ldi	r20, 0x0A	; 10
     58a:	f7 01       	movw	r30, r14
     58c:	60 81       	ld	r22, Z
     58e:	71 81       	ldd	r23, Z+1	; 0x01
     590:	82 81       	ldd	r24, Z+2	; 0x02
     592:	93 81       	ldd	r25, Z+3	; 0x03
     594:	0e 94 56 06 	call	0xcac
				g_pos[motor] =0;				
     598:	f7 01       	movw	r30, r14
     59a:	10 82       	st	Z, r1
     59c:	11 82       	std	Z+1, r1	; 0x01
     59e:	12 82       	std	Z+2, r1	; 0x02
     5a0:	13 82       	std	Z+3, r1	; 0x03
     5a2:	df 91       	pop	r29
     5a4:	cf 91       	pop	r28
     5a6:	1f 91       	pop	r17
     5a8:	0f 91       	pop	r16
     5aa:	ff 90       	pop	r15
     5ac:	ef 90       	pop	r14
     5ae:	df 90       	pop	r13
     5b0:	cf 90       	pop	r12
     5b2:	08 95       	ret

000005b4 <__vector_11>:
			}
	}
    		
}



// Interrupt Vector table
// Couter timer 0 reach top  
//    ON Motor   0 - OCR0  ON   OCR0 - 0xFF OFF
 SIGNAL (SIG_OVERFLOW0)   
{
     5b4:	1f 92       	push	r1
     5b6:	0f 92       	push	r0
     5b8:	0f b6       	in	r0, 0x3f	; 63
     5ba:	0f 92       	push	r0
     5bc:	11 24       	eor	r1, r1
     5be:	2f 93       	push	r18
     5c0:	3f 93       	push	r19
     5c2:	4f 93       	push	r20
     5c4:	5f 93       	push	r21
     5c6:	6f 93       	push	r22
     5c8:	7f 93       	push	r23
     5ca:	8f 93       	push	r24
     5cc:	9f 93       	push	r25
     5ce:	af 93       	push	r26
     5d0:	bf 93       	push	r27
     5d2:	ef 93       	push	r30
     5d4:	ff 93       	push	r31
 	calculate_backemf(0);
     5d6:	80 e0       	ldi	r24, 0x00	; 0
     5d8:	0e 94 2e 02 	call	0x45c
    OCR0 =  g_speed[0];
     5dc:	80 91 ce 01 	lds	r24, 0x01CE
     5e0:	8c bf       	out	0x3c, r24	; 60
    motor_control(1, g_mode[0]);
     5e2:	60 91 bd 00 	lds	r22, 0x00BD
     5e6:	81 e0       	ldi	r24, 0x01	; 1
     5e8:	0e 94 2a 05 	call	0xa54
     5ec:	ff 91       	pop	r31
     5ee:	ef 91       	pop	r30
     5f0:	bf 91       	pop	r27
     5f2:	af 91       	pop	r26
     5f4:	9f 91       	pop	r25
     5f6:	8f 91       	pop	r24
     5f8:	7f 91       	pop	r23
     5fa:	6f 91       	pop	r22
     5fc:	5f 91       	pop	r21
     5fe:	4f 91       	pop	r20
     600:	3f 91       	pop	r19
     602:	2f 91       	pop	r18
     604:	0f 90       	pop	r0
     606:	0f be       	out	0x3f, r0	; 63
     608:	0f 90       	pop	r0
     60a:	1f 90       	pop	r1
     60c:	18 95       	reti

0000060e <__vector_10>:
		
}

// Counter timer 0 reach OCR0  OFF MOTOR
 SIGNAL (SIG_OUTPUT_COMPARE0)
{
     60e:	1f 92       	push	r1
     610:	0f 92       	push	r0
     612:	0f b6       	in	r0, 0x3f	; 63
     614:	0f 92       	push	r0
     616:	11 24       	eor	r1, r1
     618:	2f 93       	push	r18
     61a:	3f 93       	push	r19
     61c:	4f 93       	push	r20
     61e:	5f 93       	push	r21
     620:	6f 93       	push	r22
     622:	7f 93       	push	r23
     624:	8f 93       	push	r24
     626:	9f 93       	push	r25
     628:	af 93       	push	r26
     62a:	bf 93       	push	r27
     62c:	ef 93       	push	r30
     62e:	ff 93       	push	r31
		motor_control(1, MOTOR_STOP);
     630:	60 e0       	ldi	r22, 0x00	; 0
     632:	81 e0       	ldi	r24, 0x01	; 1
     634:	0e 94 2a 05 	call	0xa54
     638:	ff 91       	pop	r31
     63a:	ef 91       	pop	r30
     63c:	bf 91       	pop	r27
     63e:	af 91       	pop	r26
     640:	9f 91       	pop	r25
     642:	8f 91       	pop	r24
     644:	7f 91       	pop	r23
     646:	6f 91       	pop	r22
     648:	5f 91       	pop	r21
     64a:	4f 91       	pop	r20
     64c:	3f 91       	pop	r19
     64e:	2f 91       	pop	r18
     650:	0f 90       	pop	r0
     652:	0f be       	out	0x3f, r0	; 63
     654:	0f 90       	pop	r0
     656:	1f 90       	pop	r1
     658:	18 95       	reti

0000065a <__vector_5>:
}
 
// TIMER2 will opposite with timer 0 to balance calculate backemf between timer0 and timer2
// Couter timer 2 reach top  
//    ON Motor   0 - OCR2  ON   OCR2 - 0xFF FF
 SIGNAL (SIG_OVERFLOW2)   
{
     65a:	1f 92       	push	r1
     65c:	0f 92       	push	r0
     65e:	0f b6       	in	r0, 0x3f	; 63
     660:	0f 92       	push	r0
     662:	11 24       	eor	r1, r1
     664:	2f 93       	push	r18
     666:	3f 93       	push	r19
     668:	4f 93       	push	r20
     66a:	5f 93       	push	r21
     66c:	6f 93       	push	r22
     66e:	7f 93       	push	r23
     670:	8f 93       	push	r24
     672:	9f 93       	push	r25
     674:	af 93       	push	r26
     676:	bf 93       	push	r27
     678:	ef 93       	push	r30
     67a:	ff 93       	push	r31
   	motor_control(2, MOTOR_STOP);
     67c:	60 e0       	ldi	r22, 0x00	; 0
     67e:	82 e0       	ldi	r24, 0x02	; 2
     680:	0e 94 2a 05 	call	0xa54
     684:	ff 91       	pop	r31
     686:	ef 91       	pop	r30
     688:	bf 91       	pop	r27
     68a:	af 91       	pop	r26
     68c:	9f 91       	pop	r25
     68e:	8f 91       	pop	r24
     690:	7f 91       	pop	r23
     692:	6f 91       	pop	r22
     694:	5f 91       	pop	r21
     696:	4f 91       	pop	r20
     698:	3f 91       	pop	r19
     69a:	2f 91       	pop	r18
     69c:	0f 90       	pop	r0
     69e:	0f be       	out	0x3f, r0	; 63
     6a0:	0f 90       	pop	r0
     6a2:	1f 90       	pop	r1
     6a4:	18 95       	reti

000006a6 <__vector_4>:
   
}

// Counter timer 2 reach OCR2  ON MOTOR
 SIGNAL (SIG_OUTPUT_COMPARE2)
{
     6a6:	1f 92       	push	r1
     6a8:	0f 92       	push	r0
     6aa:	0f b6       	in	r0, 0x3f	; 63
     6ac:	0f 92       	push	r0
     6ae:	11 24       	eor	r1, r1
     6b0:	2f 93       	push	r18
     6b2:	3f 93       	push	r19
     6b4:	4f 93       	push	r20
     6b6:	5f 93       	push	r21
     6b8:	6f 93       	push	r22
     6ba:	7f 93       	push	r23
     6bc:	8f 93       	push	r24
     6be:	9f 93       	push	r25
     6c0:	af 93       	push	r26
     6c2:	bf 93       	push	r27
     6c4:	ef 93       	push	r30
     6c6:	ff 93       	push	r31
	calculate_backemf(1);
     6c8:	81 e0       	ldi	r24, 0x01	; 1
     6ca:	0e 94 2e 02 	call	0x45c
  	OCR2 =  0xFF - g_speed[1];   // Because opposite with timer0
     6ce:	80 91 d0 01 	lds	r24, 0x01D0
     6d2:	80 95       	com	r24
     6d4:	83 bd       	out	0x23, r24	; 35
   motor_control(2, g_mode[1]);
     6d6:	60 91 be 00 	lds	r22, 0x00BE
     6da:	82 e0       	ldi	r24, 0x02	; 2
     6dc:	0e 94 2a 05 	call	0xa54
     6e0:	ff 91       	pop	r31
     6e2:	ef 91       	pop	r30
     6e4:	bf 91       	pop	r27
     6e6:	af 91       	pop	r26
     6e8:	9f 91       	pop	r25
     6ea:	8f 91       	pop	r24
     6ec:	7f 91       	pop	r23
     6ee:	6f 91       	pop	r22
     6f0:	5f 91       	pop	r21
     6f2:	4f 91       	pop	r20
     6f4:	3f 91       	pop	r19
     6f6:	2f 91       	pop	r18
     6f8:	0f 90       	pop	r0
     6fa:	0f be       	out	0x3f, r0	; 63
     6fc:	0f 90       	pop	r0
     6fe:	1f 90       	pop	r1
     700:	18 95       	reti

00000702 <__vector_13>:
 
}
 
  
 
 
/* UART receiver ready
*/

SIGNAL(SIG_UART_RECV)
{
     702:	1f 92       	push	r1
     704:	0f 92       	push	r0
     706:	0f b6       	in	r0, 0x3f	; 63
     708:	0f 92       	push	r0
     70a:	11 24       	eor	r1, r1
     70c:	2f 93       	push	r18
     70e:	8f 93       	push	r24
     710:	9f 93       	push	r25
     712:	ef 93       	push	r30
     714:	ff 93       	push	r31
  static uint16_t i= 0;
  uint8_t ch;
  ch = UDR;
     716:	2c b1       	in	r18, 0x0c	; 12

	g_rcv_buff[i] = ch;    
     718:	80 91 c0 00 	lds	r24, 0x00C0
     71c:	90 91 c1 00 	lds	r25, 0x00C1
     720:	fc 01       	movw	r30, r24
     722:	ec 52       	subi	r30, 0x2C	; 44
     724:	ff 4f       	sbci	r31, 0xFF	; 255
     726:	20 83       	st	Z, r18
	i++;
     728:	fc 01       	movw	r30, r24
     72a:	31 96       	adiw	r30, 0x01	; 1
     72c:	f0 93 c1 00 	sts	0x00C1, r31
     730:	e0 93 c0 00 	sts	0x00C0, r30
 
// Found 0xOD or 0x0A end with null
   if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
     734:	2d 30       	cpi	r18, 0x0D	; 13
     736:	11 f0       	breq	.+4      	; 0x73c
     738:	2a 30       	cpi	r18, 0x0A	; 10
     73a:	51 f4       	brne	.+20     	; 0x750
   {	
    	g_rcv_buff[i]  = 0;   // End with null
     73c:	ec 52       	subi	r30, 0x2C	; 44
     73e:	ff 4f       	sbci	r31, 0xFF	; 255
     740:	10 82       	st	Z, r1
		i = 0;
     742:	10 92 c1 00 	sts	0x00C1, r1
     746:	10 92 c0 00 	sts	0x00C0, r1
  		g_cmd_decode = 1;
     74a:	81 e0       	ldi	r24, 0x01	; 1
     74c:	80 93 b4 00 	sts	0x00B4, r24
     750:	ff 91       	pop	r31
     752:	ef 91       	pop	r30
     754:	9f 91       	pop	r25
     756:	8f 91       	pop	r24
     758:	2f 91       	pop	r18
     75a:	0f 90       	pop	r0
     75c:	0f be       	out	0x3f, r0	; 63
     75e:	0f 90       	pop	r0
     760:	1f 90       	pop	r1
     762:	18 95       	reti

00000764 <__vector_14>:
   }
}

  

/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/

SIGNAL(SIG_UART_DATA)
{ 
     764:	1f 92       	push	r1
     766:	0f 92       	push	r0
     768:	0f b6       	in	r0, 0x3f	; 63
     76a:	0f 92       	push	r0
     76c:	11 24       	eor	r1, r1
     76e:	2f 93       	push	r18
     770:	3f 93       	push	r19
     772:	4f 93       	push	r20
     774:	5f 93       	push	r21
     776:	6f 93       	push	r22
     778:	7f 93       	push	r23
     77a:	8f 93       	push	r24
     77c:	9f 93       	push	r25
     77e:	af 93       	push	r26
     780:	bf 93       	push	r27
     782:	ef 93       	push	r30
     784:	ff 93       	push	r31
    uint8_t  ch;
	if ((ch = uart_get_TX()))
     786:	0e 94 fe 05 	call	0xbfc
     78a:	88 23       	and	r24, r24
     78c:	11 f0       	breq	.+4      	; 0x792
	{
 		UDR = ch;
     78e:	8c b9       	out	0x0c, r24	; 12
     790:	01 c0       	rjmp	.+2      	; 0x794
	}	
	else 
// No character disable  interrupt to avoid repetable call Enable again when
//	send character in putc procedure
	{
	    UCSRB &=  ~(1<<UDRIE);
     792:	55 98       	cbi	0x0a, 5	; 10
     794:	ff 91       	pop	r31
     796:	ef 91       	pop	r30
     798:	bf 91       	pop	r27
     79a:	af 91       	pop	r26
     79c:	9f 91       	pop	r25
     79e:	8f 91       	pop	r24
     7a0:	7f 91       	pop	r23
     7a2:	6f 91       	pop	r22
     7a4:	5f 91       	pop	r21
     7a6:	4f 91       	pop	r20
     7a8:	3f 91       	pop	r19
     7aa:	2f 91       	pop	r18
     7ac:	0f 90       	pop	r0
     7ae:	0f be       	out	0x3f, r0	; 63
     7b0:	0f 90       	pop	r0
     7b2:	1f 90       	pop	r1
     7b4:	18 95       	reti

000007b6 <__vector_6>:
	}
	
}

 
 
/* Interrupt handle for Input Capture
This routine will detect/ process the Sony IR remote command. Protocol using Sony remote control
INPUT   :  Infrared signal from  ICP pin
		   Command table 
		  

OUTPUT 	: g_num  Number of message to display
		: g_control.display_mode   Display mode of message
		: g_start_bit
		

*/
SIGNAL(SIG_INPUT_CAPTURE1)
{
     7b6:	1f 92       	push	r1
     7b8:	0f 92       	push	r0
     7ba:	0f b6       	in	r0, 0x3f	; 63
     7bc:	0f 92       	push	r0
     7be:	11 24       	eor	r1, r1
     7c0:	2f 93       	push	r18
     7c2:	3f 93       	push	r19
     7c4:	4f 93       	push	r20
     7c6:	5f 93       	push	r21
     7c8:	6f 93       	push	r22
     7ca:	7f 93       	push	r23
     7cc:	8f 93       	push	r24
     7ce:	9f 93       	push	r25
     7d0:	af 93       	push	r26
     7d2:	bf 93       	push	r27
     7d4:	ef 93       	push	r30
     7d6:	ff 93       	push	r31
	uint16_t  ir_code;
    ir_code = ICR1;
     7d8:	26 b5       	in	r18, 0x26	; 38
     7da:	37 b5       	in	r19, 0x27	; 39
	cli(); 
     7dc:	f8 94       	cli

    TCCR1B  |= _BV(ICES1);	     // Rising edge
     7de:	8e b5       	in	r24, 0x2e	; 46
     7e0:	80 64       	ori	r24, 0x40	; 64
     7e2:	8e bd       	out	0x2e, r24	; 46
 	ir_code  = sony_ir_decode(ir_code);  
     7e4:	c9 01       	movw	r24, r18
     7e6:	0e 94 62 05 	call	0xac4
 	if (ir_code)
     7ea:	00 97       	sbiw	r24, 0x00	; 0
     7ec:	29 f0       	breq	.+10     	; 0x7f8
	{       //End code dispatch command    
 
		remote_decode (ir_code);
     7ee:	0e 94 b2 00 	call	0x164
// Return to falling edge for Start		
		TCCR1B  &= ~(_BV(ICES1));
     7f2:	8e b5       	in	r24, 0x2e	; 46
     7f4:	8f 7b       	andi	r24, 0xBF	; 191
     7f6:	8e bd       	out	0x2e, r24	; 46
		

//Note if  SELFTEST is selected g_irint = 0;
	} 
    sei();
     7f8:	78 94       	sei
     7fa:	ff 91       	pop	r31
     7fc:	ef 91       	pop	r30
     7fe:	bf 91       	pop	r27
     800:	af 91       	pop	r26
     802:	9f 91       	pop	r25
     804:	8f 91       	pop	r24
     806:	7f 91       	pop	r23
     808:	6f 91       	pop	r22
     80a:	5f 91       	pop	r21
     80c:	4f 91       	pop	r20
     80e:	3f 91       	pop	r19
     810:	2f 91       	pop	r18
     812:	0f 90       	pop	r0
     814:	0f be       	out	0x3f, r0	; 63
     816:	0f 90       	pop	r0
     818:	1f 90       	pop	r1
     81a:	18 95       	reti

0000081c <init_board>:
 
}


void init_board()
{
    uint8_t i;
	d7segment_init();
     81c:	0e 94 0e 05 	call	0xa1c
	init_ir();
     820:	0e 94 59 05 	call	0xab2
	init_motor();
     824:	0e 94 18 05 	call	0xa30
	uart_init(); 
     828:	0e 94 a4 05 	call	0xb48
    adc_init(3);   // 2.56 BG as reference 
     82c:	83 e0       	ldi	r24, 0x03	; 3
     82e:	0e 94 81 06 	call	0xd02
	
	g_cmd_decode = 0; 
     832:	10 92 b4 00 	sts	0x00B4, r1
	g_motor= 0;
     836:	10 92 d3 00 	sts	0x00D3, r1
     83a:	61 e0       	ldi	r22, 0x01	; 1
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	21 e0       	ldi	r18, 0x01	; 1
     840:	30 e0       	ldi	r19, 0x00	; 0
     842:	40 e0       	ldi	r20, 0x00	; 0
     844:	50 e0       	ldi	r21, 0x00	; 0
     846:	ab ec       	ldi	r26, 0xCB	; 203
     848:	b0 e0       	ldi	r27, 0x00	; 0
     84a:	81 e0       	ldi	r24, 0x01	; 1
     84c:	ee ec       	ldi	r30, 0xCE	; 206
     84e:	f1 e0       	ldi	r31, 0x01	; 1
	
	for ( i = 0 ; i< MOTOR_MAX ;i++)
	{
		g_speed[i] = 1;
     850:	61 93       	st	Z+, r22
     852:	71 93       	st	Z+, r23
		g_angle[i] = 1;
     854:	2d 93       	st	X+, r18
     856:	3d 93       	st	X+, r19
     858:	4d 93       	st	X+, r20
     85a:	5d 93       	st	X+, r21
     85c:	81 50       	subi	r24, 0x01	; 1
     85e:	87 ff       	sbrs	r24, 7
     860:	f7 cf       	rjmp	.-18     	; 0x850
	} 
	sei();
     862:	78 94       	sei
     864:	08 95       	ret

00000866 <main>:
 
}

void main()
{
     866:	cc e5       	ldi	r28, 0x5C	; 92
     868:	d8 e0       	ldi	r29, 0x08	; 8
     86a:	de bf       	out	0x3e, r29	; 62
     86c:	cd bf       	out	0x3d, r28	; 61
  uint8_t sw1,sw2,i;
   uint16_t k;
   int16_t backemf;
  int8_t d1,d2;
  uint8_t show[3] = {0,'f','b'};
     86e:	6e 01       	movw	r12, r28
     870:	08 94       	sec
     872:	c1 1c       	adc	r12, r1
     874:	d1 1c       	adc	r13, r1
     876:	83 e0       	ldi	r24, 0x03	; 3
     878:	e0 eb       	ldi	r30, 0xB0	; 176
     87a:	f0 e0       	ldi	r31, 0x00	; 0
     87c:	d6 01       	movw	r26, r12
     87e:	01 90       	ld	r0, Z+
     880:	0d 92       	st	X+, r0
     882:	8a 95       	dec	r24
     884:	e1 f7       	brne	.-8      	; 0x87e
   init_board();
     886:	0e 94 0e 04 	call	0x81c
  d1 = 0;
     88a:	ff 24       	eor	r15, r15
  d2 = 0;
     88c:	ef 2c       	mov	r14, r15
  backemf =0;
  while (1)
  {
   sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
     88e:	80 b3       	in	r24, 0x10	; 16
   
   if (!sw1) // SW1  Press
     890:	98 2f       	mov	r25, r24
     892:	98 70       	andi	r25, 0x08	; 8
     894:	83 fd       	sbrc	r24, 3
     896:	1d c0       	rjmp	.+58     	; 0x8d2
    {   	
		d1++;
     898:	e3 94       	inc	r14
	     if (d1 > MOTOR_BACKWARD)
     89a:	b2 e0       	ldi	r27, 0x02	; 2
     89c:	be 15       	cp	r27, r14
     89e:	0c f4       	brge	.+2      	; 0x8a2
			d1 = MOTOR_STOP;
     8a0:	e9 2e       	mov	r14, r25
     8a2:	03 ef       	ldi	r16, 0xF3	; 243
     8a4:	11 e0       	ldi	r17, 0x01	; 1
		for (k = 0; k < 500 ;k++)                         // Delay for key bounce
				delay(6000);						
     8a6:	80 e7       	ldi	r24, 0x70	; 112
     8a8:	97 e1       	ldi	r25, 0x17	; 23
     8aa:	0e 94 5f 00 	call	0xbe
     8ae:	01 50       	subi	r16, 0x01	; 1
     8b0:	10 40       	sbci	r17, 0x00	; 0
     8b2:	17 ff       	sbrs	r17, 7
     8b4:	f8 cf       	rjmp	.-16     	; 0x8a6
		g_mode[0] = d1;
     8b6:	e0 92 bd 00 	sts	0x00BD, r14
		g_angle[0] = 1;    // Continuous move
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	a0 e0       	ldi	r26, 0x00	; 0
     8c0:	b0 e0       	ldi	r27, 0x00	; 0
     8c2:	80 93 cb 00 	sts	0x00CB, r24
     8c6:	90 93 cc 00 	sts	0x00CC, r25
     8ca:	a0 93 cd 00 	sts	0x00CD, r26
     8ce:	b0 93 ce 00 	sts	0x00CE, r27

	}
   
   sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
     8d2:	83 b3       	in	r24, 0x13	; 19
   if (!sw2) // SW2 Press
     8d4:	98 2f       	mov	r25, r24
     8d6:	94 70       	andi	r25, 0x04	; 4
     8d8:	82 fd       	sbrc	r24, 2
     8da:	1d c0       	rjmp	.+58     	; 0x916
   {
        d2++;
     8dc:	f3 94       	inc	r15
		if (d2 > MOTOR_BACKWARD)
     8de:	82 e0       	ldi	r24, 0x02	; 2
     8e0:	8f 15       	cp	r24, r15
     8e2:	0c f4       	brge	.+2      	; 0x8e6
			d2 = MOTOR_STOP;
     8e4:	f9 2e       	mov	r15, r25
     8e6:	03 ef       	ldi	r16, 0xF3	; 243
     8e8:	11 e0       	ldi	r17, 0x01	; 1
 		for (k = 0; k < 500 ;k++)                         // Delay for key bounce		
 				delay(6000);
     8ea:	80 e7       	ldi	r24, 0x70	; 112
     8ec:	97 e1       	ldi	r25, 0x17	; 23
     8ee:	0e 94 5f 00 	call	0xbe
     8f2:	01 50       	subi	r16, 0x01	; 1
     8f4:	10 40       	sbci	r17, 0x00	; 0
     8f6:	17 ff       	sbrs	r17, 7
     8f8:	f8 cf       	rjmp	.-16     	; 0x8ea
		g_mode[1] = d2;
     8fa:	f0 92 be 00 	sts	0x00BE, r15
		g_angle[1] = 1;    // Continuous move	
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	a0 e0       	ldi	r26, 0x00	; 0
     904:	b0 e0       	ldi	r27, 0x00	; 0
     906:	80 93 cf 00 	sts	0x00CF, r24
     90a:	90 93 d0 00 	sts	0x00D0, r25
     90e:	a0 93 d1 00 	sts	0x00D1, r26
     912:	b0 93 d2 00 	sts	0x00D2, r27
   }

// Command decode
    if ( g_cmd_decode)
     916:	80 91 b4 00 	lds	r24, 0x00B4
     91a:	88 23       	and	r24, r24
     91c:	91 f0       	breq	.+36     	; 0x942
	{
// Decode command	
   	    cmd_decode ();
     91e:	0e 94 66 01 	call	0x2cc
		g_cmd_decode = 0; 
     922:	10 92 b4 00 	sts	0x00B4, r1
		g_pos[g_motor] = 0;
     926:	80 91 d3 00 	lds	r24, 0x00D3
     92a:	e8 2f       	mov	r30, r24
     92c:	ff 27       	eor	r31, r31
     92e:	ee 0f       	add	r30, r30
     930:	ff 1f       	adc	r31, r31
     932:	ee 0f       	add	r30, r30
     934:	ff 1f       	adc	r31, r31
     936:	eb 54       	subi	r30, 0x4B	; 75
     938:	ff 4f       	sbci	r31, 0xFF	; 255
     93a:	10 82       	st	Z, r1
     93c:	11 82       	std	Z+1, r1	; 0x01
     93e:	12 82       	std	Z+2, r1	; 0x02
     940:	13 82       	std	Z+3, r1	; 0x03
	}
	
 	
    for (i = 0 ; i < MOTOR_MAX ; i++)
     942:	e0 e0       	ldi	r30, 0x00	; 0
	{

// 7 Segments display	

		d7segment_display(show[g_mode[i]],i+1);
     944:	1e 2f       	mov	r17, r30
     946:	1f 5f       	subi	r17, 0xFF	; 255
     948:	ff 27       	eor	r31, r31
     94a:	e3 54       	subi	r30, 0x43	; 67
     94c:	ff 4f       	sbci	r31, 0xFF	; 255
     94e:	80 81       	ld	r24, Z
     950:	f6 01       	movw	r30, r12
     952:	e8 0f       	add	r30, r24
     954:	f1 1d       	adc	r31, r1
     956:	61 2f       	mov	r22, r17
     958:	80 81       	ld	r24, Z
     95a:	0e 94 b7 04 	call	0x96e
        delay(500);
     95e:	84 ef       	ldi	r24, 0xF4	; 244
     960:	91 e0       	ldi	r25, 0x01	; 1
     962:	0e 94 5f 00 	call	0xbe
     966:	e1 2f       	mov	r30, r17
     968:	12 30       	cpi	r17, 0x02	; 2
     96a:	60 f3       	brcs	.-40     	; 0x944
     96c:	90 cf       	rjmp	.-224    	; 0x88e

0000096e <d7segment_display>:
#include "Dual_7Segment.h"

void d7segment_display( int8_t num, uint8_t digit)
{
 switch (num)
     96e:	99 27       	eor	r25, r25
     970:	87 fd       	sbrc	r24, 7
     972:	90 95       	com	r25
     974:	86 30       	cpi	r24, 0x06	; 6
     976:	91 05       	cpc	r25, r1
     978:	09 f4       	brne	.+2      	; 0x97c
     97a:	41 c0       	rjmp	.+130    	; 0x9fe
     97c:	87 30       	cpi	r24, 0x07	; 7
     97e:	91 05       	cpc	r25, r1
     980:	8c f4       	brge	.+34     	; 0x9a4
     982:	82 30       	cpi	r24, 0x02	; 2
     984:	91 05       	cpc	r25, r1
     986:	59 f1       	breq	.+86     	; 0x9de
     988:	83 30       	cpi	r24, 0x03	; 3
     98a:	91 05       	cpc	r25, r1
     98c:	2c f4       	brge	.+10     	; 0x998
     98e:	00 97       	sbiw	r24, 0x00	; 0
     990:	11 f1       	breq	.+68     	; 0x9d6
     992:	01 97       	sbiw	r24, 0x01	; 1
     994:	11 f1       	breq	.+68     	; 0x9da
     996:	37 c0       	rjmp	.+110    	; 0xa06
     998:	84 30       	cpi	r24, 0x04	; 4
     99a:	91 05       	cpc	r25, r1
     99c:	21 f1       	breq	.+72     	; 0x9e6
     99e:	05 97       	sbiw	r24, 0x05	; 5
     9a0:	24 f5       	brge	.+72     	; 0x9ea
     9a2:	1f c0       	rjmp	.+62     	; 0x9e2
     9a4:	89 30       	cpi	r24, 0x09	; 9
     9a6:	91 05       	cpc	r25, r1
     9a8:	31 f1       	breq	.+76     	; 0x9f6
     9aa:	8a 30       	cpi	r24, 0x0A	; 10
     9ac:	91 05       	cpc	r25, r1
     9ae:	34 f4       	brge	.+12     	; 0x9bc
     9b0:	87 30       	cpi	r24, 0x07	; 7
     9b2:	91 05       	cpc	r25, r1
     9b4:	e1 f0       	breq	.+56     	; 0x9ee
     9b6:	08 97       	sbiw	r24, 0x08	; 8
     9b8:	e1 f0       	breq	.+56     	; 0x9f2
     9ba:	25 c0       	rjmp	.+74     	; 0xa06
     9bc:	82 36       	cpi	r24, 0x62	; 98
     9be:	91 05       	cpc	r25, r1
     9c0:	f1 f0       	breq	.+60     	; 0x9fe
     9c2:	83 36       	cpi	r24, 0x63	; 99
     9c4:	91 05       	cpc	r25, r1
     9c6:	1c f4       	brge	.+6      	; 0x9ce
     9c8:	0a 97       	sbiw	r24, 0x0a	; 10
     9ca:	d9 f0       	breq	.+54     	; 0xa02
     9cc:	1c c0       	rjmp	.+56     	; 0xa06
     9ce:	86 36       	cpi	r24, 0x66	; 102
     9d0:	91 05       	cpc	r25, r1
     9d2:	99 f0       	breq	.+38     	; 0x9fa
     9d4:	18 c0       	rjmp	.+48     	; 0xa06
 {
	case 0:
		_7SEGMENT_PORT = _7SEGMENT_0;
     9d6:	8f e3       	ldi	r24, 0x3F	; 63
     9d8:	15 c0       	rjmp	.+42     	; 0xa04
		break;
	case 1:
		_7SEGMENT_PORT = _7SEGMENT_1;
     9da:	86 e0       	ldi	r24, 0x06	; 6
     9dc:	13 c0       	rjmp	.+38     	; 0xa04
		break;
	case 2:
		_7SEGMENT_PORT = _7SEGMENT_2;
     9de:	8b e5       	ldi	r24, 0x5B	; 91
     9e0:	11 c0       	rjmp	.+34     	; 0xa04
		break;
	case 3:
		_7SEGMENT_PORT = _7SEGMENT_3;
     9e2:	8f e4       	ldi	r24, 0x4F	; 79
     9e4:	0f c0       	rjmp	.+30     	; 0xa04
		break;
	case 4:
		_7SEGMENT_PORT = _7SEGMENT_4;
     9e6:	86 e6       	ldi	r24, 0x66	; 102
     9e8:	0d c0       	rjmp	.+26     	; 0xa04
		break;
	case 5:
		_7SEGMENT_PORT = _7SEGMENT_5;
     9ea:	8d e6       	ldi	r24, 0x6D	; 109
     9ec:	0b c0       	rjmp	.+22     	; 0xa04
		break;
	case 6:
		_7SEGMENT_PORT = _7SEGMENT_6;
		break;
	case 7:
		_7SEGMENT_PORT = _7SEGMENT_7;
     9ee:	87 e0       	ldi	r24, 0x07	; 7
     9f0:	09 c0       	rjmp	.+18     	; 0xa04
		break;
	case 8:
		_7SEGMENT_PORT = _7SEGMENT_8;
     9f2:	8f e7       	ldi	r24, 0x7F	; 127
     9f4:	07 c0       	rjmp	.+14     	; 0xa04
		break;
	case 9:
		_7SEGMENT_PORT = _7SEGMENT_9;
     9f6:	87 e6       	ldi	r24, 0x67	; 103
     9f8:	05 c0       	rjmp	.+10     	; 0xa04
	    break;
	case 'f':
	    _7SEGMENT_PORT = _7SEGMENT_C_F;
     9fa:	81 e7       	ldi	r24, 0x71	; 113
     9fc:	03 c0       	rjmp	.+6      	; 0xa04
		break;
	case 'b':
	    _7SEGMENT_PORT = _7SEGMENT_C_B;
     9fe:	8c e7       	ldi	r24, 0x7C	; 124
     a00:	01 c0       	rjmp	.+2      	; 0xa04
		break;
	case DOT:
		_7SEGMENT_PORT = _7SEGMENT_DOT;
     a02:	80 e8       	ldi	r24, 0x80	; 128
     a04:	88 bb       	out	0x18, r24	; 24
		break;
 
 }
// Out digit
	 
    if ( digit == 1 )
     a06:	61 30       	cpi	r22, 0x01	; 1
     a08:	19 f4       	brne	.+6      	; 0xa10
	{  // ON Digit 1 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT1);
     a0a:	ab 98       	cbi	0x15, 3	; 21
	   // OFF Digit 2 
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT2;
     a0c:	ac 9a       	sbi	0x15, 4	; 21
     a0e:	08 95       	ret
	}
	if ( digit == 2 )
     a10:	62 30       	cpi	r22, 0x02	; 2
     a12:	11 f4       	brne	.+4      	; 0xa18
	{  // ON Digit 2 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT2);
     a14:	ac 98       	cbi	0x15, 4	; 21
	   // OFF Digit 1
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT1;
     a16:	ab 9a       	sbi	0x15, 3	; 21
     a18:	08 95       	ret
     a1a:	08 95       	ret

00000a1c <d7segment_init>:
	}	

}	


/* Initial 7 Segments. Set port to output before use 
*/
void d7segment_init (void)
{
// Set direction for output for 7 Segment
	_7SEGMENT_DIGIT_DIR   = 0xFF;
     a1c:	8f ef       	ldi	r24, 0xFF	; 255
     a1e:	87 bb       	out	0x17, r24	; 23
	_7SEGMENT_PORT_DIR	  |= _7SEGMENT_DIGIT1 | _7SEGMENT_DIGIT2;
     a20:	84 b3       	in	r24, 0x14	; 20
     a22:	88 61       	ori	r24, 0x18	; 24
     a24:	84 bb       	out	0x14, r24	; 20
 
// Set direction for input for SW 
	_7SEGMENT_SW1_DIR	&=  ~(_7SEGMENT_SW1);
     a26:	8b 98       	cbi	0x11, 3	; 17
	_7SEGMENT_SW2_DIR	&=  ~(_7SEGMENT_SW2);
     a28:	a2 98       	cbi	0x14, 2	; 20

// Enable pull up
    _7SEGMENT_SW1_PORT   |= _7SEGMENT_SW1;
     a2a:	93 9a       	sbi	0x12, 3	; 18
    _7SEGMENT_SW2_PORT   |= _7SEGMENT_SW2;
     a2c:	aa 9a       	sbi	0x15, 2	; 21
     a2e:	08 95       	ret

00000a30 <init_motor>:
 

//   TIMER0
//     TCCR0  |= _BV(WGM00) |_BV(WGM01) | _BV(CS01) | _BV(CS00)  ;   // Clk/64 Fast Pwm
    TCCR0  |= _BV(WGM00) |_BV(WGM01) | _BV(CS02)    ;   // Clk/256 Pwm
     a30:	83 b7       	in	r24, 0x33	; 51
     a32:	8c 64       	ori	r24, 0x4C	; 76
     a34:	83 bf       	out	0x33, r24	; 51
    OCR0    = 0x80;
     a36:	90 e8       	ldi	r25, 0x80	; 128
     a38:	9c bf       	out	0x3c, r25	; 60
	
	
//   TIMER2
//     TCCR2  |= _BV(WGM20) | _BV(CS22) ;   // Clk/64 Pwm
     TCCR2  |= _BV(WGM20) |_BV(WGM21) | _BV(CS22) | _BV(CS21) ;   // Clk/256 Pwm
     a3a:	85 b5       	in	r24, 0x25	; 37
     a3c:	8e 64       	ori	r24, 0x4E	; 78
     a3e:	85 bd       	out	0x25, r24	; 37
      OCR2   = 0x80;
     a40:	93 bd       	out	0x23, r25	; 35
	
	
	
// Enable Interrupt 	Watch out nest interrupt 
	TIMSK  |=  _BV(OCIE0) | _BV(TOIE0) | _BV(OCIE2) | _BV(TOIE2);	
     a42:	89 b7       	in	r24, 0x39	; 57
     a44:	83 6c       	ori	r24, 0xC3	; 195
     a46:	89 bf       	out	0x39, r24	; 57
 
    MOTOR_DIRECTION_DIR  |= 	MOTORA_1 | MOTORA_2 | MOTORB_1 | MOTORB_2;
     a48:	8a b3       	in	r24, 0x1a	; 26
     a4a:	80 6f       	ori	r24, 0xF0	; 240
     a4c:	8a bb       	out	0x1a, r24	; 26
	MOTOR_ENABLE12_DIR	 |= 	MOTOR_ENABLE12;
     a4e:	8d 9a       	sbi	0x11, 5	; 17
	MOTOR_ENABLE34_DIR	 |=  	MOTOR_ENABLE34;		
     a50:	8c 9a       	sbi	0x11, 4	; 17
     a52:	08 95       	ret

00000a54 <motor_control>:
}


// speed from 1 - 10

void  motor_control (uint8_t port, uint8_t direction) 
{
     a54:	38 2f       	mov	r19, r24
     a56:	86 2f       	mov	r24, r22
  
   uint8_t  controlA,controlB;
   
   switch (direction)
     a58:	99 27       	eor	r25, r25
     a5a:	81 30       	cpi	r24, 0x01	; 1
     a5c:	91 05       	cpc	r25, r1
     a5e:	31 f0       	breq	.+12     	; 0xa6c
     a60:	82 30       	cpi	r24, 0x02	; 2
     a62:	91 05       	cpc	r25, r1
     a64:	4c f0       	brlt	.+18     	; 0xa78
     a66:	02 97       	sbiw	r24, 0x02	; 2
     a68:	21 f0       	breq	.+8      	; 0xa72
     a6a:	06 c0       	rjmp	.+12     	; 0xa78
   {
     case MOTOR_FORWARD:
	    controlA = 0;
     a6c:	20 e0       	ldi	r18, 0x00	; 0
		controlB = 0xFF;
     a6e:	9f ef       	ldi	r25, 0xFF	; 255
		break;
     a70:	05 c0       	rjmp	.+10     	; 0xa7c
	 case MOTOR_BACKWARD:
        controlA = 0xFF;
     a72:	2f ef       	ldi	r18, 0xFF	; 255
		controlB = 0;
     a74:	90 e0       	ldi	r25, 0x00	; 0
		break;
     a76:	02 c0       	rjmp	.+4      	; 0xa7c
	 case MOTOR_STOP:
	    controlA = 0;
		controlB = 0;
		break;
//	case MOTOR_BRAKE:
//	    controlA = 0xFF;
//		controlB = 0xFF;
//		break;
	default:
	    controlA = 0;
     a78:	90 e0       	ldi	r25, 0x00	; 0
		controlB = 0;
     a7a:	29 2f       	mov	r18, r25
   }
 if (port == 1)
     a7c:	31 30       	cpi	r19, 0x01	; 1
     a7e:	59 f4       	brne	.+22     	; 0xa96
   {
       MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;
     a80:	95 9a       	sbi	0x12, 5	; 18
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORA_1 | MOTORA_2); 
     a82:	8b b3       	in	r24, 0x1b	; 27
     a84:	8f 7c       	andi	r24, 0xCF	; 207
     a86:	8b bb       	out	0x1b, r24	; 27
	  MOTOR_DIRECTION_CONTROL |= ((MOTORA_1 & controlA ) | (MOTORA_2 & controlB));
     a88:	20 71       	andi	r18, 0x10	; 16
     a8a:	90 72       	andi	r25, 0x20	; 32
     a8c:	29 2b       	or	r18, r25
     a8e:	8b b3       	in	r24, 0x1b	; 27
     a90:	82 2b       	or	r24, r18
     a92:	8b bb       	out	0x1b, r24	; 27
     a94:	08 95       	ret
  }
  if (port == 2)
     a96:	32 30       	cpi	r19, 0x02	; 2
     a98:	51 f4       	brne	.+20     	; 0xaae
   {
  	  MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
     a9a:	94 9a       	sbi	0x12, 4	; 18
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORB_1 | MOTORB_2); 
     a9c:	8b b3       	in	r24, 0x1b	; 27
     a9e:	8f 73       	andi	r24, 0x3F	; 63
     aa0:	8b bb       	out	0x1b, r24	; 27
  	  MOTOR_DIRECTION_CONTROL |= ((MOTORB_1 & controlA ) | (MOTORB_2 & controlB));
     aa2:	20 74       	andi	r18, 0x40	; 64
     aa4:	90 78       	andi	r25, 0x80	; 128
     aa6:	29 2b       	or	r18, r25
     aa8:	8b b3       	in	r24, 0x1b	; 27
     aaa:	82 2b       	or	r24, r18
     aac:	8b bb       	out	0x1b, r24	; 27
     aae:	08 95       	ret
     ab0:	08 95       	ret

00000ab2 <init_ir>:

void init_ir()
{
 //Set Direction
    IR_DDR_PORT &= ~IR_ICP; 
     ab2:	8e 98       	cbi	0x11, 6	; 17
	
	TCCR1B  |= ( _BV(ICNC1) | _BV(CS12) | _BV(CS10));			// Time 1 input to clock/1024 input capture on falling edge  noise cancel
     ab4:	8e b5       	in	r24, 0x2e	; 46
     ab6:	85 68       	ori	r24, 0x85	; 133
     ab8:	8e bd       	out	0x2e, r24	; 46
	TIMSK   |= _BV(TICIE1);   								// Enable input capture enable 
     aba:	89 b7       	in	r24, 0x39	; 57
     abc:	80 62       	ori	r24, 0x20	; 32
     abe:	89 bf       	out	0x39, r24	; 57
	sei();
     ac0:	78 94       	sei
     ac2:	08 95       	ret

00000ac4 <sony_ir_decode>:
}
/*  Decode for Sony remote TV IR 
			Input  Input capturn counter 16 bit register
		   Output  0  = no code detect
				   ir_decode  = detect IR code 
				   
	Algorithm
		Calculate pulse width by substract ICP counter. from pulse width 
		can determine whether it is  START BIT 		 =  XX
									  BIT1 			 =  XX
		until 12 bits then return ir code							  
									 
*/

uint16_t sony_ir_decode ( uint16_t capture_counter)
{
     ac4:	bc 01       	movw	r22, r24
  static 	uint16_t  	prev_capture_counter = 0;
  static 	uint8_t   	stop_bit = 0;
  static	uint16_t	ir_code = 0;
 			uint16_t	width  = 0;	  

      if ( capture_counter > prev_capture_counter)
     ac6:	80 91 c2 00 	lds	r24, 0x00C2
     aca:	90 91 c3 00 	lds	r25, 0x00C3
     ace:	9b 01       	movw	r18, r22
     ad0:	28 1b       	sub	r18, r24
     ad2:	39 0b       	sbc	r19, r25
			width = capture_counter - prev_capture_counter;
	  else
			width = capture_counter+(MAX_INT16 - prev_capture_counter);
//Check for start bit
     if ( width > IR_TV_PULSE_WIDTH)
     ad4:	2a 30       	cpi	r18, 0x0A	; 10
     ad6:	31 05       	cpc	r19, r1
     ad8:	20 f1       	brcs	.+72     	; 0xb22
	 {
		  if (width > IR_TV_START_BIT)  			//  Found Start bit 
     ada:	26 32       	cpi	r18, 0x26	; 38
     adc:	31 05       	cpc	r19, r1
     ade:	58 f0       	brcs	.+22     	; 0xaf6
			    {
				  stop_bit = 0;
     ae0:	10 92 c4 00 	sts	0x00C4, r1
				  prev_capture_counter = 0;
     ae4:	10 92 c3 00 	sts	0x00C3, r1
     ae8:	10 92 c2 00 	sts	0x00C2, r1
				  ir_code = 0;     			// New code
     aec:	10 92 c6 00 	sts	0x00C6, r1
     af0:	10 92 c5 00 	sts	0x00C5, r1
     af4:	16 c0       	rjmp	.+44     	; 0xb22
     af6:	80 91 c5 00 	lds	r24, 0x00C5
     afa:	90 91 c6 00 	lds	r25, 0x00C6
     afe:	40 91 c4 00 	lds	r20, 0x00C4
				}
		  else if (width > IR_TV_BIT1)	  		// bit 1 (3T)
     b02:	2a 31       	cpi	r18, 0x1A	; 26
     b04:	31 05       	cpc	r19, r1
     b06:	20 f0       	brcs	.+8      	; 0xb10
				{
				   ir_code <<= 1;    			//Shift right
     b08:	88 0f       	add	r24, r24
     b0a:	99 1f       	adc	r25, r25
				   ir_code  |= 1;    			// Or 1
     b0c:	81 60       	ori	r24, 0x01	; 1
     b0e:	02 c0       	rjmp	.+4      	; 0xb14
				    stop_bit++;
				}
		        else 	  // bit 0
				{
					ir_code  <<=  1;  //Shift right
     b10:	88 0f       	add	r24, r24
     b12:	99 1f       	adc	r25, r25
     b14:	90 93 c6 00 	sts	0x00C6, r25
     b18:	80 93 c5 00 	sts	0x00C5, r24
					stop_bit++;
     b1c:	4f 5f       	subi	r20, 0xFF	; 255
     b1e:	40 93 c4 00 	sts	0x00C4, r20
				}
	}
	prev_capture_counter = capture_counter;
     b22:	70 93 c3 00 	sts	0x00C3, r23
     b26:	60 93 c2 00 	sts	0x00C2, r22
	if (stop_bit == IR_TV_STOP_BIT)
     b2a:	80 91 c4 00 	lds	r24, 0x00C4
     b2e:	8c 30       	cpi	r24, 0x0C	; 12
     b30:	39 f4       	brne	.+14     	; 0xb40
	{       //End code dispatch command
  	    stop_bit = 0;
     b32:	10 92 c4 00 	sts	0x00C4, r1

		return ir_code;
     b36:	80 91 c5 00 	lds	r24, 0x00C5
     b3a:	90 91 c6 00 	lds	r25, 0x00C6
     b3e:	08 95       	ret
			
//Note if  SELFTEST is selected g_irint = 0;
	}   
	else
		return 0;		// No code detect yet
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	90 e0       	ldi	r25, 0x00	; 0
}
     b44:	08 95       	ret
     b46:	08 95       	ret

00000b48 <uart_init>:
{
 
// Initialize UART  
    
    UCSRC  = 0x86;    // 8 bit non parity  1 stop bit
     b48:	86 e8       	ldi	r24, 0x86	; 134
     b4a:	80 bd       	out	0x20, r24	; 32
     UCSRB  = 0x98;    // Enable RX Interrupt and Enable TX, RX pin
     b4c:	88 e9       	ldi	r24, 0x98	; 152
     b4e:	8a b9       	out	0x0a, r24	; 10
//    UCSRB  = 0B8;    // Enable RX Interrupt, Data registerempty interrupt enable and Enable TX, RX pin 1011-1000
	UBRRL  = 0x67;    // Speed 9600 UBRR = 103 at 16 MHZ
     b50:	87 e6       	ldi	r24, 0x67	; 103
     b52:	89 b9       	out	0x09, r24	; 9
//	UBRRL  = 51;      // Speed = 19.2 K at 16 Mhz
	UBRRH  = 0;
     b54:	10 bc       	out	0x20, r1	; 32
//    DDRD = 0x00;	 
 
	g_rx_ptr = 0;
     b56:	10 92 c8 00 	sts	0x00C8, r1
	g_tx_ptr = 0;
     b5a:	10 92 c7 00 	sts	0x00C7, r1
     b5e:	08 95       	ret

00000b60 <uart_put_RX>:
 /* Set baud rate */
 
}

/*
Put character into Rx buffer

Return  = Success 0
        = Fail   Buffer Full
		
*/
uint8_t uart_put_RX ( uint8_t ch)
{
     b60:	98 2f       	mov	r25, r24
   if ((g_rx_ptr < MAX_BUFF)) 
     b62:	80 91 c8 00 	lds	r24, 0x00C8
     b66:	8a 3f       	cpi	r24, 0xFA	; 250
     b68:	80 f4       	brcc	.+32     	; 0xb8a
   {
//  End with Null
		g_rx_buff[g_rx_ptr] = ch;
     b6a:	e8 2f       	mov	r30, r24
     b6c:	ff 27       	eor	r31, r31
     b6e:	ee 52       	subi	r30, 0x2E	; 46
     b70:	fe 4f       	sbci	r31, 0xFE	; 254
     b72:	90 83       	st	Z, r25
		g_rx_ptr++;
     b74:	8f 5f       	subi	r24, 0xFF	; 255
     b76:	80 93 c8 00 	sts	0x00C8, r24
		g_rx_buff[g_rx_ptr] = 0;   // End with null characters
     b7a:	e8 2f       	mov	r30, r24
     b7c:	ff 27       	eor	r31, r31
     b7e:	ee 52       	subi	r30, 0x2E	; 46
     b80:	fe 4f       	sbci	r31, 0xFE	; 254
     b82:	10 82       	st	Z, r1
		return 0;
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	08 95       	ret
    }
   else  // Buffer full do nothing  return error
   {
        return UART_BUFFER_FULL;
     b8a:	82 e0       	ldi	r24, 0x02	; 2
     b8c:	90 e0       	ldi	r25, 0x00	; 0
   }
}
     b8e:	08 95       	ret
     b90:	08 95       	ret

00000b92 <uart_get_RX>:

// Get character from RX buffer

uint8_t uart_get_RX (void)
{
   uint8_t  i,j,ch;
   if (g_rx_ptr)
     b92:	80 91 c8 00 	lds	r24, 0x00C8
     b96:	88 23       	and	r24, r24
     b98:	a1 f0       	breq	.+40     	; 0xbc2
   {
		ch = g_rx_buff[0];
     b9a:	90 91 d2 01 	lds	r25, 0x01D2
        i =  g_rx_ptr;
     b9e:	28 2f       	mov	r18, r24
        g_rx_ptr--;
     ba0:	21 50       	subi	r18, 0x01	; 1
     ba2:	20 93 c8 00 	sts	0x00C8, r18
     ba6:	2f 5f       	subi	r18, 0xFF	; 255
		j = 0;
     ba8:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_rx_buff[j] =  g_rx_buff[j+1];
     baa:	e3 2f       	mov	r30, r19
     bac:	ff 27       	eor	r31, r31
     bae:	ee 52       	subi	r30, 0x2E	; 46
     bb0:	fe 4f       	sbci	r31, 0xFE	; 254
     bb2:	81 81       	ldd	r24, Z+1	; 0x01
     bb4:	80 83       	st	Z, r24
	      j++;
     bb6:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
     bb8:	21 50       	subi	r18, 0x01	; 1
     bba:	b9 f7       	brne	.-18     	; 0xbaa
		}
		return ch;
     bbc:	89 2f       	mov	r24, r25
     bbe:	99 27       	eor	r25, r25
     bc0:	08 95       	ret
   }
   return 0;
     bc2:	80 e0       	ldi	r24, 0x00	; 0
     bc4:	90 e0       	ldi	r25, 0x00	; 0
}
     bc6:	08 95       	ret
     bc8:	08 95       	ret

00000bca <uart_put_TX>:

/* Put character into g_tx_buff
    INPUT  : Character to put in buffer
	Output : 0  OK
		   : UART_BUFFER_FULL  Buffer full
*/

uint8_t uart_put_TX ( uint8_t ch)
{
     bca:	98 2f       	mov	r25, r24
// If exceed buffer do nothing until buffer is flushed
    if ((g_tx_ptr > MAX_BUFF)) 
     bcc:	80 91 c7 00 	lds	r24, 0x00C7
     bd0:	8b 3f       	cpi	r24, 0xFB	; 251
     bd2:	18 f0       	brcs	.+6      	; 0xbda
    {
		return UART_BUFFER_FULL;   // No increase pointer
     bd4:	82 e0       	ldi	r24, 0x02	; 2
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	08 95       	ret
    }
	g_tx_buff[g_tx_ptr]= ch;
     bda:	e8 2f       	mov	r30, r24
     bdc:	ff 27       	eor	r31, r31
     bde:	e4 53       	subi	r30, 0x34	; 52
     be0:	fd 4f       	sbci	r31, 0xFD	; 253
     be2:	90 83       	st	Z, r25
	g_tx_ptr++;
     be4:	8f 5f       	subi	r24, 0xFF	; 255
     be6:	80 93 c7 00 	sts	0x00C7, r24
	g_tx_buff[g_tx_ptr] = 0;    // Put null character at the end
     bea:	e8 2f       	mov	r30, r24
     bec:	ff 27       	eor	r31, r31
     bee:	e4 53       	subi	r30, 0x34	; 52
     bf0:	fd 4f       	sbci	r31, 0xFD	; 253
     bf2:	10 82       	st	Z, r1
	return 0;
     bf4:	80 e0       	ldi	r24, 0x00	; 0
     bf6:	90 e0       	ldi	r25, 0x00	; 0
}
     bf8:	08 95       	ret
     bfa:	08 95       	ret

00000bfc <uart_get_TX>:


// Get character from TX buffer
uint8_t uart_get_TX (void)
{
   uint8_t i,j,ch =0;
   
   if ( g_tx_ptr)
     bfc:	80 91 c7 00 	lds	r24, 0x00C7
     c00:	88 23       	and	r24, r24
     c02:	a1 f0       	breq	.+40     	; 0xc2c
   {
		i  =  g_tx_ptr;
     c04:	28 2f       	mov	r18, r24
		g_tx_ptr--;
     c06:	21 50       	subi	r18, 0x01	; 1
     c08:	20 93 c7 00 	sts	0x00C7, r18
     c0c:	2f 5f       	subi	r18, 0xFF	; 255
		ch =  g_tx_buff[0];   // Start from 0 FIFO
     c0e:	90 91 cc 02 	lds	r25, 0x02CC
		j = 0;
     c12:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_tx_buff[j] =  g_tx_buff[j+1];
     c14:	e3 2f       	mov	r30, r19
     c16:	ff 27       	eor	r31, r31
     c18:	e4 53       	subi	r30, 0x34	; 52
     c1a:	fd 4f       	sbci	r31, 0xFD	; 253
     c1c:	81 81       	ldd	r24, Z+1	; 0x01
     c1e:	80 83       	st	Z, r24
	      j++;
     c20:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
     c22:	21 50       	subi	r18, 0x01	; 1
     c24:	b9 f7       	brne	.-18     	; 0xc14
		}
		return ch;
     c26:	89 2f       	mov	r24, r25
     c28:	99 27       	eor	r25, r25
     c2a:	08 95       	ret
   }
   return 0;
     c2c:	80 e0       	ldi	r24, 0x00	; 0
     c2e:	90 e0       	ldi	r25, 0x00	; 0
}
     c30:	08 95       	ret
     c32:	08 95       	ret

00000c34 <uart_getc>:


uint8_t uart_getc(void)
{
    uint8_t ch;
	ch = uart_get_RX();
     c34:	0e 94 c9 05 	call	0xb92
    return ch ;
}
     c38:	99 27       	eor	r25, r25
     c3a:	08 95       	ret

00000c3c <uart_putc>:

uint8_t uart_putc(uint8_t c)
{
  
  uart_put_TX(c);
     c3c:	0e 94 e5 05 	call	0xbca
// Enable interrupt UART Data Register empty
  UCSRB  |=  (1<<UDRIE);	
     c40:	55 9a       	sbi	0x0a, 5	; 10
//    while ( !(UCSRA & (1<< UDRE)));
//	UDR = c;
    return 0;

}
     c42:	80 e0       	ldi	r24, 0x00	; 0
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	08 95       	ret

00000c48 <uart_puts>:


/*************************************************************************
Function: uart_puts()
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const uint8_t *s )
{
     c48:	cf 93       	push	r28
     c4a:	df 93       	push	r29
     c4c:	ec 01       	movw	r28, r24
    while (*s) 
      uart_putc(*s++);
     c4e:	88 81       	ld	r24, Y
     c50:	88 23       	and	r24, r24
     c52:	21 f0       	breq	.+8      	; 0xc5c
     c54:	89 91       	ld	r24, Y+
     c56:	0e 94 1e 06 	call	0xc3c
     c5a:	f9 cf       	rjmp	.-14     	; 0xc4e
   uart_putc(0x0D); // CR
     c5c:	8d e0       	ldi	r24, 0x0D	; 13
     c5e:	0e 94 1e 06 	call	0xc3c
	uart_putc(0x0A); // LF
     c62:	8a e0       	ldi	r24, 0x0A	; 10
     c64:	0e 94 1e 06 	call	0xc3c
     c68:	df 91       	pop	r29
     c6a:	cf 91       	pop	r28
     c6c:	08 95       	ret

00000c6e <debug_value>:
}

/*
Show debug value
*/

void  debug_value ( int16_t value, uint8_t radix)
{
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	cd b7       	in	r28, 0x3d	; 61
     c74:	de b7       	in	r29, 0x3e	; 62
     c76:	64 97       	sbiw	r28, 0x14	; 20
     c78:	0f b6       	in	r0, 0x3f	; 63
     c7a:	f8 94       	cli
     c7c:	de bf       	out	0x3e, r29	; 62
     c7e:	0f be       	out	0x3f, r0	; 63
     c80:	cd bf       	out	0x3d, r28	; 61
     c82:	26 2f       	mov	r18, r22
   uint8_t  buff[20];
   
   itoa (value,buff, radix);
     c84:	33 27       	eor	r19, r19
     c86:	a9 01       	movw	r20, r18
     c88:	be 01       	movw	r22, r28
     c8a:	6f 5f       	subi	r22, 0xFF	; 255
     c8c:	7f 4f       	sbci	r23, 0xFF	; 255
     c8e:	0e 94 b6 07 	call	0xf6c
    uart_puts ( buff);
     c92:	ce 01       	movw	r24, r28
     c94:	01 96       	adiw	r24, 0x01	; 1
     c96:	0e 94 24 06 	call	0xc48
     c9a:	64 96       	adiw	r28, 0x14	; 20
     c9c:	0f b6       	in	r0, 0x3f	; 63
     c9e:	f8 94       	cli
     ca0:	de bf       	out	0x3e, r29	; 62
     ca2:	0f be       	out	0x3f, r0	; 63
     ca4:	cd bf       	out	0x3d, r28	; 61
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	08 95       	ret

00000cac <debug_lvalue>:

}



void  debug_lvalue ( int32_t value, uint8_t radix)
{
     cac:	ef 92       	push	r14
     cae:	ff 92       	push	r15
     cb0:	0f 93       	push	r16
     cb2:	1f 93       	push	r17
     cb4:	cf 93       	push	r28
     cb6:	df 93       	push	r29
     cb8:	cd b7       	in	r28, 0x3d	; 61
     cba:	de b7       	in	r29, 0x3e	; 62
     cbc:	a8 97       	sbiw	r28, 0x28	; 40
     cbe:	0f b6       	in	r0, 0x3f	; 63
     cc0:	f8 94       	cli
     cc2:	de bf       	out	0x3e, r29	; 62
     cc4:	0f be       	out	0x3f, r0	; 63
     cc6:	cd bf       	out	0x3d, r28	; 61
     cc8:	7b 01       	movw	r14, r22
     cca:	8c 01       	movw	r16, r24
     ccc:	84 2f       	mov	r24, r20
   uint8_t  buff[40];
   
   ltoa (value,buff, radix);
     cce:	99 27       	eor	r25, r25
     cd0:	9c 01       	movw	r18, r24
     cd2:	ae 01       	movw	r20, r28
     cd4:	4f 5f       	subi	r20, 0xFF	; 255
     cd6:	5f 4f       	sbci	r21, 0xFF	; 255
     cd8:	c8 01       	movw	r24, r16
     cda:	b7 01       	movw	r22, r14
     cdc:	0e 94 db 07 	call	0xfb6
    uart_puts ( buff);
     ce0:	ce 01       	movw	r24, r28
     ce2:	01 96       	adiw	r24, 0x01	; 1
     ce4:	0e 94 24 06 	call	0xc48
     ce8:	a8 96       	adiw	r28, 0x28	; 40
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	de bf       	out	0x3e, r29	; 62
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	cd bf       	out	0x3d, r28	; 61
     cf4:	df 91       	pop	r29
     cf6:	cf 91       	pop	r28
     cf8:	1f 91       	pop	r17
     cfa:	0f 91       	pop	r16
     cfc:	ff 90       	pop	r15
     cfe:	ef 90       	pop	r14
     d00:	08 95       	ret

00000d02 <adc_init>:
      Bit 5   left or right adjust bit in ADLAR
*/
void adc_init(uint8_t voltage)
{
    ADCSRA = 0xC7 | (1<< ADEN);
     d02:	97 ec       	ldi	r25, 0xC7	; 199
     d04:	96 b9       	out	0x06, r25	; 6
	
// Set voltage reference 	
	ADMUX  =  voltage << 6;
     d06:	82 95       	swap	r24
     d08:	88 0f       	add	r24, r24
     d0a:	88 0f       	add	r24, r24
     d0c:	80 7c       	andi	r24, 0xC0	; 192
     d0e:	87 b9       	out	0x07, r24	; 7

// Set input for ADC pin
    DDRA    &= 0xF0;	
     d10:	8a b3       	in	r24, 0x1a	; 26
     d12:	80 7f       	andi	r24, 0xF0	; 240
     d14:	8a bb       	out	0x1a, r24	; 26
     d16:	08 95       	ret

00000d18 <adc_enable_int>:

}

/*
  Input mode = 0  Disable
        mode > 0  Enable


*/
void  adc_enable_int (uint8_t mode)
{
    if (mode)
     d18:	88 23       	and	r24, r24
     d1a:	19 f0       	breq	.+6      	; 0xd22
	{
		ADCSRA  |= ( (1 << ADEN) | (1 << ADIE) | (1<< ADSC));
     d1c:	86 b1       	in	r24, 0x06	; 6
     d1e:	88 6c       	ori	r24, 0xC8	; 200
     d20:	02 c0       	rjmp	.+4      	; 0xd26
    }
	else
	{
		ADCSRA  &= ~((1 << ADIE) | (1<< ADSC));
     d22:	86 b1       	in	r24, 0x06	; 6
     d24:	87 7b       	andi	r24, 0xB7	; 183
     d26:	86 b9       	out	0x06, r24	; 6
     d28:	08 95       	ret
     d2a:	08 95       	ret

00000d2c <read_adc>:
	}
}


/*
Read adc value		
	
	INPUT :  channel  to read adc  ( See table for Differential INput and Gain)
    Polling mode 
*/

int16_t read_adc(uint8_t channel)
{
  int16_t  value;
  
 
// Before that need to clear ADATE and ADEN
    ADCSRA &= ~((1 << ADEN) | (1<< ADATE));
     d2c:	96 b1       	in	r25, 0x06	; 6
     d2e:	9f 75       	andi	r25, 0x5F	; 95
     d30:	96 b9       	out	0x06, r25	; 6

// Set channel
    ADMUX |= channel;
     d32:	97 b1       	in	r25, 0x07	; 7
     d34:	98 2b       	or	r25, r24
     d36:	97 b9       	out	0x07, r25	; 7
	
// Enable conversion
	ADCSRA |= (1<<ADEN);
     d38:	37 9a       	sbi	0x06, 7	; 6
// Start conversion
 
    
// Check whether conversion is complete
 
    ADCSRA |= (1<<ADSC);         // do single conversion
     d3a:	36 9a       	sbi	0x06, 6	; 6
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
     d3c:	34 9b       	sbis	0x06, 4	; 6
     d3e:	fe cf       	rjmp	.-4      	; 0xd3c

//Read value
//      value = ADCL;            // read out ADCL register
//      value += (ADCH << 8);    // read out ADCH register        
	value = ADCW;
     d40:	84 b1       	in	r24, 0x04	; 4
     d42:	95 b1       	in	r25, 0x05	; 5
// Stop conversion
    ADCSRA &= ~(1 << ADEN);
     d44:	37 98       	cbi	0x06, 7	; 6
     d46:	08 95       	ret

00000d48 <text_decode>:

*/ 

uint8_t text_decode (uint8_t *buffer, uint8_t *cmd_argument)
{
     d48:	cf 92       	push	r12
     d4a:	df 92       	push	r13
     d4c:	ef 92       	push	r14
     d4e:	ff 92       	push	r15
     d50:	0f 93       	push	r16
     d52:	1f 93       	push	r17
     d54:	cf 93       	push	r28
     d56:	7c 01       	movw	r14, r24

 uint8_t  found,ch,ch2,cmd_no,j,k,index,cmd_complete;
 uint8_t  state = WAIT_CMD_STATE, quote  = 0;
     d58:	51 e0       	ldi	r21, 0x01	; 1
 static uint16_t i=0; // Keep pointer for next command decode
 cmd_complete = 0;
     d5a:	cc 24       	eor	r12, r12
 cmd_no 	= 0;
     d5c:	dc 2c       	mov	r13, r12
 index 		= 0;
     d5e:	4c 2d       	mov	r20, r12
 
 cmd_argument  = buffer;
 
 while (*(buffer+i))	  		//End with NULL
 {
// Check with delimiter

 	 j = 0;
	 found = 0;
	
	switch (state)
	{
	  case WAIT_CMD_STATE:   // If found first character in command table  then go to get_cmd state
 		j = 0;
		while ((ch = pgm_read_byte(&text_cmd[j][0])))     //Check first charaters in cmd table
		{ 
		  if (*(buffer+i) == ch)
		  {
			state = GET_CMD_STATE;   // Found delimiter
			*(cmd_argument) = ch;
			index = 1;
			break; 
		  }
		 j++;
		}  
	    break;
	  case GET_CMD_STATE:
	    ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
		if (found)
		{
        	*(cmd_argument+index) = 0x00;
		     if (ch == '=')
			 {
// Check command number 
  				for (k = 0; k < CMD_NUM ; k++)
				{
					if (!(strcasecmp_P(cmd_argument,&text_cmd[k][0])))  // Found then keep command
					{
						cmd_no  = k+1;   // Start from 0 
						break;
					}
				}
// clear index
  				index = 0;
			    state = WAIT_ARG_STATE;	
			 }	
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}
		break;
		
	  case WAIT_ARG_STATE:
		ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
				
		if ( ch == '"')   // Start quote
		{
			quote ^= 1;   // Toggle quote	
			state = GET_ARG_STATE;   
 			index = 0;
		}
		
		if (!found)    // Not delimiter start get Argument
		{
			state = GET_ARG_STATE;   
			*(cmd_argument) = ch;
			index = 1;
		}
		break;	
	  case	GET_ARG_STATE:
	  	ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
 		if ( ch == '"')     // End quote
		{
			quote ^= 1;   // Toggle quote	
   		}
		if ( quote)
		{
         	found = 0; //  ignore all characters after the quote until found quote again
// Cancel quote
            
		}	
		if (found)
		{	
            cmd_complete = 1;
			*(cmd_argument+index) = 0;
		    state = WAIT_CMD_STATE;
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}  
		break;
	}
	
	if(cmd_complete)   // COmmand both cmd number and argument
	{
		return cmd_no;	 	 
	}
	i++;
     d60:	e0 91 c9 00 	lds	r30, 0x00C9
     d64:	f0 91 ca 00 	lds	r31, 0x00CA
     d68:	ee 0d       	add	r30, r14
     d6a:	ff 1d       	adc	r31, r15
     d6c:	80 81       	ld	r24, Z
     d6e:	88 23       	and	r24, r24
     d70:	09 f4       	brne	.+2      	; 0xd74
     d72:	c1 c0       	rjmp	.+386    	; 0xef6
     d74:	30 e0       	ldi	r19, 0x00	; 0
     d76:	85 2f       	mov	r24, r21
     d78:	99 27       	eor	r25, r25
     d7a:	82 30       	cpi	r24, 0x02	; 2
     d7c:	91 05       	cpc	r25, r1
     d7e:	79 f1       	breq	.+94     	; 0xdde
     d80:	83 30       	cpi	r24, 0x03	; 3
     d82:	91 05       	cpc	r25, r1
     d84:	1c f4       	brge	.+6      	; 0xd8c
     d86:	01 97       	sbiw	r24, 0x01	; 1
     d88:	59 f0       	breq	.+22     	; 0xda0
     d8a:	ab c0       	rjmp	.+342    	; 0xee2
     d8c:	83 30       	cpi	r24, 0x03	; 3
     d8e:	91 05       	cpc	r25, r1
     d90:	09 f4       	brne	.+2      	; 0xd94
     d92:	5a c0       	rjmp	.+180    	; 0xe48
     d94:	04 97       	sbiw	r24, 0x04	; 4
     d96:	09 f4       	brne	.+2      	; 0xd9a
     d98:	7b c0       	rjmp	.+246    	; 0xe90
     d9a:	a3 c0       	rjmp	.+326    	; 0xee2
     d9c:	52 e0       	ldi	r21, 0x02	; 2
     d9e:	72 c0       	rjmp	.+228    	; 0xe84
     da0:	23 2f       	mov	r18, r19
     da2:	ec e5       	ldi	r30, 0x5C	; 92
     da4:	f0 e0       	ldi	r31, 0x00	; 0
     da6:	94 91       	lpm	r25, Z
     da8:	99 23       	and	r25, r25
     daa:	09 f4       	brne	.+2      	; 0xdae
     dac:	9a c0       	rjmp	.+308    	; 0xee2
     dae:	e0 91 c9 00 	lds	r30, 0x00C9
     db2:	f0 91 ca 00 	lds	r31, 0x00CA
     db6:	ee 0d       	add	r30, r14
     db8:	ff 1d       	adc	r31, r15
     dba:	80 81       	ld	r24, Z
     dbc:	3a e0       	ldi	r19, 0x0A	; 10
     dbe:	89 17       	cp	r24, r25
     dc0:	69 f3       	breq	.-38     	; 0xd9c
     dc2:	2f 5f       	subi	r18, 0xFF	; 255
     dc4:	23 9f       	mul	r18, r19
     dc6:	f0 01       	movw	r30, r0
     dc8:	11 24       	eor	r1, r1
     dca:	e4 5a       	subi	r30, 0xA4	; 164
     dcc:	ff 4f       	sbci	r31, 0xFF	; 255
     dce:	94 91       	lpm	r25, Z
     dd0:	99 23       	and	r25, r25
     dd2:	a9 f7       	brne	.-22     	; 0xdbe
     dd4:	86 c0       	rjmp	.+268    	; 0xee2
     dd6:	31 e0       	ldi	r19, 0x01	; 1
     dd8:	17 c0       	rjmp	.+46     	; 0xe08
     dda:	c2 2e       	mov	r12, r18
     ddc:	30 c0       	rjmp	.+96     	; 0xe3e
     dde:	e0 91 c9 00 	lds	r30, 0x00C9
     de2:	f0 91 ca 00 	lds	r31, 0x00CA
     de6:	ee 0d       	add	r30, r14
     de8:	ff 1d       	adc	r31, r15
     dea:	90 81       	ld	r25, Z
     dec:	23 2f       	mov	r18, r19
     dee:	e4 e5       	ldi	r30, 0x54	; 84
     df0:	f0 e0       	ldi	r31, 0x00	; 0
     df2:	84 91       	lpm	r24, Z
     df4:	88 23       	and	r24, r24
     df6:	41 f0       	breq	.+16     	; 0xe08
     df8:	98 17       	cp	r25, r24
     dfa:	69 f3       	breq	.-38     	; 0xdd6
     dfc:	2f 5f       	subi	r18, 0xFF	; 255
     dfe:	e2 2f       	mov	r30, r18
     e00:	ff 27       	eor	r31, r31
     e02:	ec 5a       	subi	r30, 0xAC	; 172
     e04:	ff 4f       	sbci	r31, 0xFF	; 255
     e06:	f5 cf       	rjmp	.-22     	; 0xdf2
     e08:	e4 2f       	mov	r30, r20
     e0a:	ff 27       	eor	r31, r31
     e0c:	33 23       	and	r19, r19
     e0e:	09 f4       	brne	.+2      	; 0xe12
     e10:	64 c0       	rjmp	.+200    	; 0xeda
     e12:	ee 0d       	add	r30, r14
     e14:	ff 1d       	adc	r31, r15
     e16:	10 82       	st	Z, r1
     e18:	9d 33       	cpi	r25, 0x3D	; 61
     e1a:	09 f0       	breq	.+2      	; 0xe1e
     e1c:	62 c0       	rjmp	.+196    	; 0xee2
     e1e:	c0 81       	ld	r28, Z
     e20:	0c e5       	ldi	r16, 0x5C	; 92
     e22:	10 e0       	ldi	r17, 0x00	; 0
     e24:	b8 01       	movw	r22, r16
     e26:	c7 01       	movw	r24, r14
     e28:	0e 94 1a 08 	call	0x1034
     e2c:	2c 2f       	mov	r18, r28
     e2e:	2f 5f       	subi	r18, 0xFF	; 255
     e30:	89 2b       	or	r24, r25
     e32:	99 f2       	breq	.-90     	; 0xdda
     e34:	c2 2f       	mov	r28, r18
     e36:	06 5f       	subi	r16, 0xF6	; 246
     e38:	1f 4f       	sbci	r17, 0xFF	; 255
     e3a:	24 30       	cpi	r18, 0x04	; 4
     e3c:	98 f3       	brcs	.-26     	; 0xe24
     e3e:	40 e0       	ldi	r20, 0x00	; 0
     e40:	53 e0       	ldi	r21, 0x03	; 3
     e42:	4f c0       	rjmp	.+158    	; 0xee2
     e44:	31 e0       	ldi	r19, 0x01	; 1
     e46:	15 c0       	rjmp	.+42     	; 0xe72
     e48:	e0 91 c9 00 	lds	r30, 0x00C9
     e4c:	f0 91 ca 00 	lds	r31, 0x00CA
     e50:	ee 0d       	add	r30, r14
     e52:	ff 1d       	adc	r31, r15
     e54:	90 81       	ld	r25, Z
     e56:	23 2f       	mov	r18, r19
     e58:	e4 e5       	ldi	r30, 0x54	; 84
     e5a:	f0 e0       	ldi	r31, 0x00	; 0
     e5c:	84 91       	lpm	r24, Z
     e5e:	88 23       	and	r24, r24
     e60:	41 f0       	breq	.+16     	; 0xe72
     e62:	98 17       	cp	r25, r24
     e64:	79 f3       	breq	.-34     	; 0xe44
     e66:	2f 5f       	subi	r18, 0xFF	; 255
     e68:	e2 2f       	mov	r30, r18
     e6a:	ff 27       	eor	r31, r31
     e6c:	ec 5a       	subi	r30, 0xAC	; 172
     e6e:	ff 4f       	sbci	r31, 0xFF	; 255
     e70:	f5 cf       	rjmp	.-22     	; 0xe5c
     e72:	92 32       	cpi	r25, 0x22	; 34
     e74:	21 f4       	brne	.+8      	; 0xe7e
     e76:	81 e0       	ldi	r24, 0x01	; 1
     e78:	d8 26       	eor	r13, r24
     e7a:	54 e0       	ldi	r21, 0x04	; 4
     e7c:	40 e0       	ldi	r20, 0x00	; 0
     e7e:	33 23       	and	r19, r19
     e80:	81 f5       	brne	.+96     	; 0xee2
     e82:	54 e0       	ldi	r21, 0x04	; 4
     e84:	f7 01       	movw	r30, r14
     e86:	90 83       	st	Z, r25
     e88:	41 e0       	ldi	r20, 0x01	; 1
     e8a:	2b c0       	rjmp	.+86     	; 0xee2
     e8c:	31 e0       	ldi	r19, 0x01	; 1
     e8e:	15 c0       	rjmp	.+42     	; 0xeba
     e90:	e0 91 c9 00 	lds	r30, 0x00C9
     e94:	f0 91 ca 00 	lds	r31, 0x00CA
     e98:	ee 0d       	add	r30, r14
     e9a:	ff 1d       	adc	r31, r15
     e9c:	90 81       	ld	r25, Z
     e9e:	23 2f       	mov	r18, r19
     ea0:	e4 e5       	ldi	r30, 0x54	; 84
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	84 91       	lpm	r24, Z
     ea6:	88 23       	and	r24, r24
     ea8:	41 f0       	breq	.+16     	; 0xeba
     eaa:	98 17       	cp	r25, r24
     eac:	79 f3       	breq	.-34     	; 0xe8c
     eae:	2f 5f       	subi	r18, 0xFF	; 255
     eb0:	e2 2f       	mov	r30, r18
     eb2:	ff 27       	eor	r31, r31
     eb4:	ec 5a       	subi	r30, 0xAC	; 172
     eb6:	ff 4f       	sbci	r31, 0xFF	; 255
     eb8:	f5 cf       	rjmp	.-22     	; 0xea4
     eba:	92 32       	cpi	r25, 0x22	; 34
     ebc:	11 f4       	brne	.+4      	; 0xec2
     ebe:	81 e0       	ldi	r24, 0x01	; 1
     ec0:	d8 26       	eor	r13, r24
     ec2:	d1 10       	cpse	r13, r1
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	e4 2f       	mov	r30, r20
     ec8:	ff 27       	eor	r31, r31
     eca:	33 23       	and	r19, r19
     ecc:	31 f0       	breq	.+12     	; 0xeda
     ece:	ee 0d       	add	r30, r14
     ed0:	ff 1d       	adc	r31, r15
     ed2:	10 82       	st	Z, r1
     ed4:	8c 2d       	mov	r24, r12
     ed6:	99 27       	eor	r25, r25
     ed8:	14 c0       	rjmp	.+40     	; 0xf02
     eda:	ee 0d       	add	r30, r14
     edc:	ff 1d       	adc	r31, r15
     ede:	90 83       	st	Z, r25
     ee0:	4f 5f       	subi	r20, 0xFF	; 255
     ee2:	e0 91 c9 00 	lds	r30, 0x00C9
     ee6:	f0 91 ca 00 	lds	r31, 0x00CA
     eea:	31 96       	adiw	r30, 0x01	; 1
     eec:	f0 93 ca 00 	sts	0x00CA, r31
     ef0:	e0 93 c9 00 	sts	0x00C9, r30
     ef4:	39 cf       	rjmp	.-398    	; 0xd68
 }
  i = 0;
     ef6:	10 92 ca 00 	sts	0x00CA, r1
     efa:	10 92 c9 00 	sts	0x00C9, r1
  return 0xFF;  // End of Buffer
     efe:	8f ef       	ldi	r24, 0xFF	; 255
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	cf 91       	pop	r28
     f04:	1f 91       	pop	r17
     f06:	0f 91       	pop	r16
     f08:	ff 90       	pop	r15
     f0a:	ef 90       	pop	r14
     f0c:	df 90       	pop	r13
     f0e:	cf 90       	pop	r12
     f10:	08 95       	ret

00000f12 <atoi>:
     f12:	fc 01       	movw	r30, r24
     f14:	88 27       	eor	r24, r24
     f16:	99 27       	eor	r25, r25
     f18:	e8 94       	clt

00000f1a <.atoi_loop>:
     f1a:	21 91       	ld	r18, Z+
     f1c:	22 23       	and	r18, r18
     f1e:	f1 f0       	breq	.+60     	; 0xf5c
     f20:	20 32       	cpi	r18, 0x20	; 32
     f22:	d9 f3       	breq	.-10     	; 0xf1a
     f24:	29 30       	cpi	r18, 0x09	; 9
     f26:	c9 f3       	breq	.-14     	; 0xf1a
     f28:	2a 30       	cpi	r18, 0x0A	; 10
     f2a:	b9 f3       	breq	.-18     	; 0xf1a
     f2c:	2c 30       	cpi	r18, 0x0C	; 12
     f2e:	a9 f3       	breq	.-22     	; 0xf1a
     f30:	2d 30       	cpi	r18, 0x0D	; 13
     f32:	99 f3       	breq	.-26     	; 0xf1a
     f34:	26 37       	cpi	r18, 0x76	; 118
     f36:	89 f3       	breq	.-30     	; 0xf1a
     f38:	2b 32       	cpi	r18, 0x2B	; 43
     f3a:	19 f0       	breq	.+6      	; 0xf42
     f3c:	2d 32       	cpi	r18, 0x2D	; 45
     f3e:	21 f4       	brne	.+8      	; 0xf48

00000f40 <.atoi_neg>:
     f40:	68 94       	set

00000f42 <.atoi_loop2>:
     f42:	21 91       	ld	r18, Z+
     f44:	22 23       	and	r18, r18
     f46:	51 f0       	breq	.+20     	; 0xf5c

00000f48 <.atoi_digit>:
     f48:	20 33       	cpi	r18, 0x30	; 48
     f4a:	44 f0       	brlt	.+16     	; 0xf5c
     f4c:	2a 33       	cpi	r18, 0x3A	; 58
     f4e:	34 f4       	brge	.+12     	; 0xf5c
     f50:	20 53       	subi	r18, 0x30	; 48
     f52:	0e 94 12 08 	call	0x1024
     f56:	82 0f       	add	r24, r18
     f58:	91 1d       	adc	r25, r1
     f5a:	f3 cf       	rjmp	.-26     	; 0xf42

00000f5c <.atoi_sig>:
     f5c:	81 15       	cp	r24, r1
     f5e:	91 05       	cpc	r25, r1
     f60:	21 f0       	breq	.+8      	; 0xf6a
     f62:	1e f4       	brtc	.+6      	; 0xf6a
     f64:	80 95       	com	r24
     f66:	90 95       	com	r25
     f68:	01 96       	adiw	r24, 0x01	; 1

00000f6a <.atoi_done>:
     f6a:	08 95       	ret

00000f6c <itoa>:
     f6c:	e6 2f       	mov	r30, r22
     f6e:	f7 2f       	mov	r31, r23
     f70:	2e 2f       	mov	r18, r30
     f72:	3f 2f       	mov	r19, r31
     f74:	e8 94       	clt
     f76:	42 30       	cpi	r20, 0x02	; 2
     f78:	cc f0       	brlt	.+50     	; 0xfac
     f7a:	45 32       	cpi	r20, 0x25	; 37
     f7c:	bc f4       	brge	.+46     	; 0xfac
     f7e:	4a 30       	cpi	r20, 0x0A	; 10
     f80:	29 f4       	brne	.+10     	; 0xf8c
     f82:	97 fb       	bst	r25, 7
     f84:	1e f4       	brtc	.+6      	; 0xf8c
     f86:	90 95       	com	r25
     f88:	81 95       	neg	r24
     f8a:	9f 4f       	sbci	r25, 0xFF	; 255

00000f8c <divide_loop>:
     f8c:	64 2f       	mov	r22, r20
     f8e:	77 27       	eor	r23, r23
     f90:	0e 94 5c 08 	call	0x10b8
     f94:	80 5d       	subi	r24, 0xD0	; 208
     f96:	8a 33       	cpi	r24, 0x3A	; 58
     f98:	0c f0       	brlt	.+2      	; 0xf9c
     f9a:	89 5d       	subi	r24, 0xD9	; 217

00000f9c <L_10>:
     f9c:	81 93       	st	Z+, r24
     f9e:	86 2f       	mov	r24, r22
     fa0:	97 2f       	mov	r25, r23
     fa2:	00 97       	sbiw	r24, 0x00	; 0
     fa4:	99 f7       	brne	.-26     	; 0xf8c
     fa6:	16 f4       	brtc	.+4      	; 0xfac
     fa8:	5d e2       	ldi	r21, 0x2D	; 45
     faa:	51 93       	st	Z+, r21

00000fac <terminate>:
     fac:	93 2f       	mov	r25, r19
     fae:	82 2f       	mov	r24, r18
     fb0:	10 82       	st	Z, r1
     fb2:	0c 94 2d 08 	jmp	0x105a

00000fb6 <ltoa>:
     fb6:	f5 2f       	mov	r31, r21
     fb8:	e4 2f       	mov	r30, r20
     fba:	cf 93       	push	r28
     fbc:	ff 93       	push	r31
     fbe:	ef 93       	push	r30
     fc0:	22 30       	cpi	r18, 0x02	; 2
     fc2:	54 f1       	brlt	.+84     	; 0x1018
     fc4:	25 32       	cpi	r18, 0x25	; 37
     fc6:	44 f5       	brge	.+80     	; 0x1018
     fc8:	c2 2f       	mov	r28, r18
     fca:	e8 94       	clt
     fcc:	ca 30       	cpi	r28, 0x0A	; 10
     fce:	49 f4       	brne	.+18     	; 0xfe2
     fd0:	97 fb       	bst	r25, 7
     fd2:	3e f4       	brtc	.+14     	; 0xfe2
     fd4:	90 95       	com	r25
     fd6:	80 95       	com	r24
     fd8:	70 95       	com	r23
     fda:	61 95       	neg	r22
     fdc:	7f 4f       	sbci	r23, 0xFF	; 255
     fde:	8f 4f       	sbci	r24, 0xFF	; 255
     fe0:	9f 4f       	sbci	r25, 0xFF	; 255

00000fe2 <divide_loop>:
     fe2:	2c 2f       	mov	r18, r28
     fe4:	33 27       	eor	r19, r19
     fe6:	44 27       	eor	r20, r20
     fe8:	55 27       	eor	r21, r21
     fea:	ff 93       	push	r31
     fec:	ef 93       	push	r30
     fee:	0e 94 70 08 	call	0x10e0
     ff2:	ef 91       	pop	r30
     ff4:	ff 91       	pop	r31
     ff6:	60 5d       	subi	r22, 0xD0	; 208
     ff8:	6a 33       	cpi	r22, 0x3A	; 58
     ffa:	0c f0       	brlt	.+2      	; 0xffe
     ffc:	69 5d       	subi	r22, 0xD9	; 217

00000ffe <L_10>:
     ffe:	61 93       	st	Z+, r22
    1000:	62 2f       	mov	r22, r18
    1002:	73 2f       	mov	r23, r19
    1004:	84 2f       	mov	r24, r20
    1006:	95 2f       	mov	r25, r21
    1008:	60 50       	subi	r22, 0x00	; 0
    100a:	70 40       	sbci	r23, 0x00	; 0
    100c:	80 40       	sbci	r24, 0x00	; 0
    100e:	90 40       	sbci	r25, 0x00	; 0
    1010:	41 f7       	brne	.-48     	; 0xfe2
    1012:	16 f4       	brtc	.+4      	; 0x1018
    1014:	cd e2       	ldi	r28, 0x2D	; 45
    1016:	c1 93       	st	Z+, r28

00001018 <conv_finished>:
    1018:	10 82       	st	Z, r1
    101a:	8f 91       	pop	r24
    101c:	9f 91       	pop	r25
    101e:	cf 91       	pop	r28
    1020:	0c 94 2d 08 	jmp	0x105a

00001024 <__mulhi_const_10>:
    1024:	7a e0       	ldi	r23, 0x0A	; 10
    1026:	97 9f       	mul	r25, r23
    1028:	90 2d       	mov	r25, r0
    102a:	87 9f       	mul	r24, r23
    102c:	80 2d       	mov	r24, r0
    102e:	91 0d       	add	r25, r1
    1030:	11 24       	eor	r1, r1
    1032:	08 95       	ret

00001034 <strcasecmp_P>:
    1034:	fb 01       	movw	r30, r22
    1036:	dc 01       	movw	r26, r24

00001038 <.strcasecmp_P_loop>:
    1038:	8d 91       	ld	r24, X+
    103a:	05 90       	lpm	r0, Z+
    103c:	60 2d       	mov	r22, r0
    103e:	50 2d       	mov	r21, r0
    1040:	50 62       	ori	r21, 0x20	; 32
    1042:	51 36       	cpi	r21, 0x61	; 97
    1044:	24 f0       	brlt	.+8      	; 0x104e
    1046:	5b 37       	cpi	r21, 0x7B	; 123
    1048:	14 f4       	brge	.+4      	; 0x104e
    104a:	60 62       	ori	r22, 0x20	; 32
    104c:	80 62       	ori	r24, 0x20	; 32

0000104e <.strcasecmp_P_tst>:
    104e:	86 1b       	sub	r24, r22
    1050:	11 f4       	brne	.+4      	; 0x1056
    1052:	00 20       	and	r0, r0
    1054:	89 f7       	brne	.-30     	; 0x1038

00001056 <.strcasecmp_P_done>:
    1056:	99 0b       	sbc	r25, r25
    1058:	08 95       	ret

0000105a <strrev>:
    105a:	dc 01       	movw	r26, r24
    105c:	fc 01       	movw	r30, r24

0000105e <.strrev_eos>:
    105e:	01 90       	ld	r0, Z+
    1060:	00 20       	and	r0, r0
    1062:	e9 f7       	brne	.-6      	; 0x105e
    1064:	32 97       	sbiw	r30, 0x02	; 2

00001066 <.strrev_loop>:
    1066:	ae 17       	cp	r26, r30
    1068:	bf 07       	cpc	r27, r31
    106a:	30 f4       	brcc	.+12     	; 0x1078
    106c:	7c 91       	ld	r23, X
    106e:	60 81       	ld	r22, Z
    1070:	70 83       	st	Z, r23
    1072:	31 97       	sbiw	r30, 0x01	; 1
    1074:	6d 93       	st	X+, r22
    1076:	f7 cf       	rjmp	.-18     	; 0x1066

00001078 <.strrev_done>:
    1078:	08 95       	ret

0000107a <__mulsi3>:
    107a:	62 9f       	mul	r22, r18
    107c:	d0 01       	movw	r26, r0
    107e:	73 9f       	mul	r23, r19
    1080:	f0 01       	movw	r30, r0
    1082:	82 9f       	mul	r24, r18
    1084:	e0 0d       	add	r30, r0
    1086:	f1 1d       	adc	r31, r1
    1088:	64 9f       	mul	r22, r20
    108a:	e0 0d       	add	r30, r0
    108c:	f1 1d       	adc	r31, r1
    108e:	92 9f       	mul	r25, r18
    1090:	f0 0d       	add	r31, r0
    1092:	83 9f       	mul	r24, r19
    1094:	f0 0d       	add	r31, r0
    1096:	74 9f       	mul	r23, r20
    1098:	f0 0d       	add	r31, r0
    109a:	65 9f       	mul	r22, r21
    109c:	f0 0d       	add	r31, r0
    109e:	99 27       	eor	r25, r25
    10a0:	72 9f       	mul	r23, r18
    10a2:	b0 0d       	add	r27, r0
    10a4:	e1 1d       	adc	r30, r1
    10a6:	f9 1f       	adc	r31, r25
    10a8:	63 9f       	mul	r22, r19
    10aa:	b0 0d       	add	r27, r0
    10ac:	e1 1d       	adc	r30, r1
    10ae:	f9 1f       	adc	r31, r25
    10b0:	bd 01       	movw	r22, r26
    10b2:	cf 01       	movw	r24, r30
    10b4:	11 24       	eor	r1, r1
    10b6:	08 95       	ret

000010b8 <__udivmodhi4>:
    10b8:	aa 1b       	sub	r26, r26
    10ba:	bb 1b       	sub	r27, r27
    10bc:	51 e1       	ldi	r21, 0x11	; 17
    10be:	07 c0       	rjmp	.+14     	; 0x10ce

000010c0 <__udivmodhi4_loop>:
    10c0:	aa 1f       	adc	r26, r26
    10c2:	bb 1f       	adc	r27, r27
    10c4:	a6 17       	cp	r26, r22
    10c6:	b7 07       	cpc	r27, r23
    10c8:	10 f0       	brcs	.+4      	; 0x10ce
    10ca:	a6 1b       	sub	r26, r22
    10cc:	b7 0b       	sbc	r27, r23

000010ce <__udivmodhi4_ep>:
    10ce:	88 1f       	adc	r24, r24
    10d0:	99 1f       	adc	r25, r25
    10d2:	5a 95       	dec	r21
    10d4:	a9 f7       	brne	.-22     	; 0x10c0
    10d6:	80 95       	com	r24
    10d8:	90 95       	com	r25
    10da:	bc 01       	movw	r22, r24
    10dc:	cd 01       	movw	r24, r26
    10de:	08 95       	ret

000010e0 <__udivmodsi4>:
    10e0:	a1 e2       	ldi	r26, 0x21	; 33
    10e2:	1a 2e       	mov	r1, r26
    10e4:	aa 1b       	sub	r26, r26
    10e6:	bb 1b       	sub	r27, r27
    10e8:	fd 01       	movw	r30, r26
    10ea:	0d c0       	rjmp	.+26     	; 0x1106

000010ec <__udivmodsi4_loop>:
    10ec:	aa 1f       	adc	r26, r26
    10ee:	bb 1f       	adc	r27, r27
    10f0:	ee 1f       	adc	r30, r30
    10f2:	ff 1f       	adc	r31, r31
    10f4:	a2 17       	cp	r26, r18
    10f6:	b3 07       	cpc	r27, r19
    10f8:	e4 07       	cpc	r30, r20
    10fa:	f5 07       	cpc	r31, r21
    10fc:	20 f0       	brcs	.+8      	; 0x1106
    10fe:	a2 1b       	sub	r26, r18
    1100:	b3 0b       	sbc	r27, r19
    1102:	e4 0b       	sbc	r30, r20
    1104:	f5 0b       	sbc	r31, r21

00001106 <__udivmodsi4_ep>:
    1106:	66 1f       	adc	r22, r22
    1108:	77 1f       	adc	r23, r23
    110a:	88 1f       	adc	r24, r24
    110c:	99 1f       	adc	r25, r25
    110e:	1a 94       	dec	r1
    1110:	69 f7       	brne	.-38     	; 0x10ec
    1112:	60 95       	com	r22
    1114:	70 95       	com	r23
    1116:	80 95       	com	r24
    1118:	90 95       	com	r25
    111a:	9b 01       	movw	r18, r22
    111c:	ac 01       	movw	r20, r24
    111e:	bd 01       	movw	r22, r26
    1120:	cf 01       	movw	r24, r30
    1122:	08 95       	ret
