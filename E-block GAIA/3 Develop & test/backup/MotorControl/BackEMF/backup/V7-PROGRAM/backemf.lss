
backemf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000012a2  00000000  00000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000184  00800060  000012a2  00001356  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000313  008001e4  008001e4  000014da  2**0
                  ALLOC
  3 .noinit       00000000  008004f7  008004f7  000015d4  2**0
                  CONTENTS
  4 .eeprom       000000fa  00810000  00810000  000014da  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .stab         00002940  00000000  00000000  000015d4  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      0000106a  00000000  00000000  00003f14  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4c 00 	jmp	0x98
       4:	0c 94 67 00 	jmp	0xce
       8:	0c 94 67 00 	jmp	0xce
       c:	0c 94 67 00 	jmp	0xce
      10:	0c 94 e8 03 	jmp	0x7d0
      14:	0c 94 dd 03 	jmp	0x7ba
      18:	0c 94 85 04 	jmp	0x90a
      1c:	0c 94 67 00 	jmp	0xce
      20:	0c 94 67 00 	jmp	0xce
      24:	0c 94 67 00 	jmp	0xce
      28:	0c 94 d2 03 	jmp	0x7a4
      2c:	0c 94 a4 03 	jmp	0x748
      30:	0c 94 67 00 	jmp	0xce
      34:	0c 94 17 04 	jmp	0x82e
      38:	0c 94 5c 04 	jmp	0x8b8
      3c:	0c 94 67 00 	jmp	0xce
      40:	0c 94 67 00 	jmp	0xce
      44:	0c 94 67 00 	jmp	0xce
      48:	0c 94 67 00 	jmp	0xce
      4c:	0c 94 67 00 	jmp	0xce
      50:	0c 94 67 00 	jmp	0xce

00000054 <__ctors_end>:
      54:	3d 22       	and	r3, r29
      56:	20 09       	sbc	r18, r0
      58:	2c 0d       	add	r18, r12
      5a:	0a 00       	.word	0x000a	; ????

0000005c <text_cmd>:
      5c:	6d 6f 74 6f 72 00 00 00 00 00 73 70 65 65 64 00     motor.....speed.
      6c:	00 00 00 00 61 6e 67 6c 65 00 00 00 00 00 70 72     ....angle.....pr
      7c:	6f 67 72 61 6d 00 00 00 73 61 76 65 00 00 00 00     ogram...save....
	...

00000098 <__init>:
      98:	11 24       	eor	r1, r1
      9a:	1f be       	out	0x3f, r1	; 63
      9c:	cf e5       	ldi	r28, 0x5F	; 95
      9e:	d8 e0       	ldi	r29, 0x08	; 8
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	cd bf       	out	0x3d, r28	; 61

000000a4 <__do_copy_data>:
      a4:	11 e0       	ldi	r17, 0x01	; 1
      a6:	a0 e6       	ldi	r26, 0x60	; 96
      a8:	b0 e0       	ldi	r27, 0x00	; 0
      aa:	e2 ea       	ldi	r30, 0xA2	; 162
      ac:	f2 e1       	ldi	r31, 0x12	; 18
      ae:	02 c0       	rjmp	.+4      	; 0xb4

000000b0 <.do_copy_data_loop>:
      b0:	05 90       	lpm	r0, Z+
      b2:	0d 92       	st	X+, r0

000000b4 <.do_copy_data_start>:
      b4:	a4 3e       	cpi	r26, 0xE4	; 228
      b6:	b1 07       	cpc	r27, r17
      b8:	d9 f7       	brne	.-10     	; 0xb0

000000ba <__do_clear_bss>:
      ba:	14 e0       	ldi	r17, 0x04	; 4
      bc:	a4 ee       	ldi	r26, 0xE4	; 228
      be:	b1 e0       	ldi	r27, 0x01	; 1
      c0:	01 c0       	rjmp	.+2      	; 0xc4

000000c2 <.do_clear_bss_loop>:
      c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
      c4:	a7 3f       	cpi	r26, 0xF7	; 247
      c6:	b1 07       	cpc	r27, r17
      c8:	e1 f7       	brne	.-8      	; 0xc2
      ca:	0c 94 df 04 	jmp	0x9be

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0x0

000000d2 <delay>:

void delay ( uint16_t  time)
{
   uint16_t i;
   for (i = 0 ; i < time; i++);
      d2:	00 97       	sbiw	r24, 0x00	; 0
      d4:	11 f0       	breq	.+4      	; 0xda
      d6:	01 97       	sbiw	r24, 0x01	; 1
      d8:	fc cf       	rjmp	.-8      	; 0xd2
      da:	08 95       	ret

000000dc <set_motor_parameter>:

}

void  set_motor_parameter ( uint8_t mode)
{
   switch (mode)
      dc:	99 27       	eor	r25, r25
      de:	82 30       	cpi	r24, 0x02	; 2
      e0:	91 05       	cpc	r25, r1
      e2:	81 f0       	breq	.+32     	; 0x104
      e4:	83 30       	cpi	r24, 0x03	; 3
      e6:	91 05       	cpc	r25, r1
      e8:	2c f4       	brge	.+10     	; 0xf4
      ea:	00 97       	sbiw	r24, 0x00	; 0
      ec:	79 f1       	breq	.+94     	; 0x14c
      ee:	01 97       	sbiw	r24, 0x01	; 1
      f0:	39 f0       	breq	.+14     	; 0x100
      f2:	2c c0       	rjmp	.+88     	; 0x14c
      f4:	84 30       	cpi	r24, 0x04	; 4
      f6:	91 05       	cpc	r25, r1
      f8:	f9 f0       	breq	.+62     	; 0x138
      fa:	05 97       	sbiw	r24, 0x05	; 5
      fc:	11 f1       	breq	.+68     	; 0x142
      fe:	26 c0       	rjmp	.+76     	; 0x14c
   {
    case  MOTOR_FORWARD:
        g_mode[0] = MOTOR_FORWARD;		
     100:	81 e0       	ldi	r24, 0x01	; 1
     102:	01 c0       	rjmp	.+2      	; 0x106
		g_mode[1] = MOTOR_FORWARD;
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case  MOTOR_BACKWARD:
		g_mode[0] = MOTOR_BACKWARD;
     104:	82 e0       	ldi	r24, 0x02	; 2
     106:	80 93 f0 01 	sts	0x01F0, r24
		g_mode[1] = MOTOR_BACKWARD;
     10a:	80 93 f1 01 	sts	0x01F1, r24
		g_angle[0] = 1;
     10e:	81 e0       	ldi	r24, 0x01	; 1
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	a0 e0       	ldi	r26, 0x00	; 0
     114:	b0 e0       	ldi	r27, 0x00	; 0
     116:	80 93 fe 01 	sts	0x01FE, r24
     11a:	90 93 ff 01 	sts	0x01FF, r25
     11e:	a0 93 00 02 	sts	0x0200, r26
     122:	b0 93 01 02 	sts	0x0201, r27
		g_angle[1] = 1;
     126:	80 93 02 02 	sts	0x0202, r24
     12a:	90 93 03 02 	sts	0x0203, r25
     12e:	a0 93 04 02 	sts	0x0204, r26
     132:	b0 93 05 02 	sts	0x0205, r27
		break;
     136:	08 95       	ret
    case MOTOR_STOP:
		g_mode[0]  = MOTOR_STOP;
		g_mode[1]  = MOTOR_STOP;
		g_angle[0] = 0;
		g_angle[1] = 0;
		break;
	case MOTOR_TURN_LEFT:
		g_mode[0] = MOTOR_FORWARD;		
     138:	81 e0       	ldi	r24, 0x01	; 1
     13a:	80 93 f0 01 	sts	0x01F0, r24
		g_mode[1] = MOTOR_BACKWARD;
     13e:	82 e0       	ldi	r24, 0x02	; 2
     140:	e4 cf       	rjmp	.-56     	; 0x10a
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case MOTOR_TURN_RIGHT:
		g_mode[0] = MOTOR_BACKWARD;
     142:	82 e0       	ldi	r24, 0x02	; 2
     144:	80 93 f0 01 	sts	0x01F0, r24
		g_mode[1] = MOTOR_FORWARD;
     148:	81 e0       	ldi	r24, 0x01	; 1
     14a:	df cf       	rjmp	.-66     	; 0x10a
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	 default:
	 	g_mode[0]  = MOTOR_STOP;
     14c:	10 92 f0 01 	sts	0x01F0, r1
		g_mode[1]  = MOTOR_STOP;
     150:	10 92 f1 01 	sts	0x01F1, r1
		g_angle[0] = 0;
     154:	10 92 fe 01 	sts	0x01FE, r1
     158:	10 92 ff 01 	sts	0x01FF, r1
     15c:	10 92 00 02 	sts	0x0200, r1
     160:	10 92 01 02 	sts	0x0201, r1
		g_angle[1] = 0;
     164:	10 92 02 02 	sts	0x0202, r1
     168:	10 92 03 02 	sts	0x0203, r1
     16c:	10 92 04 02 	sts	0x0204, r1
     170:	10 92 05 02 	sts	0x0205, r1
     174:	08 95       	ret
     176:	08 95       	ret

00000178 <cmd_decode>:
		break;
   }
  
}



/* Command decode from g_rcv_buffer  will decode and action according to command in buffer
 
*/

int16_t cmd_decode (uint8_t *buffer_ptr)
{
     178:	df 92       	push	r13
     17a:	ef 92       	push	r14
     17c:	ff 92       	push	r15
     17e:	0f 93       	push	r16
     180:	1f 93       	push	r17
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
     186:	7c 01       	movw	r14, r24

 uint8_t  cmd_no =0;
 uint8_t  *cmd_argument;
 uint8_t   i,j;
 
// Should repeat until end of buffer
 
// Loop until end of text

   cmd_argument = buffer_ptr;
     
   while ( cmd_no !=  CMD_LINE_END)     // Until end of line which mean g_motor will change
   {
 		cmd_no =  text_decode (buffer_ptr,cmd_argument);
     188:	b7 01       	movw	r22, r14
     18a:	c7 01       	movw	r24, r14
     18c:	0e 94 50 07 	call	0xea0
     190:	d8 2e       	mov	r13, r24
#ifdef DEBUG		
		uart_puts("Command :");
     192:	85 e6       	ldi	r24, 0x65	; 101
     194:	91 e0       	ldi	r25, 0x01	; 1
     196:	0e 94 d0 06 	call	0xda0
		uart_putc(0x30+cmd_no);
     19a:	8d 2d       	mov	r24, r13
     19c:	80 5d       	subi	r24, 0xD0	; 208
     19e:	0e 94 ca 06 	call	0xd94
		uart_putc('*');
     1a2:	8a e2       	ldi	r24, 0x2A	; 42
     1a4:	0e 94 ca 06 	call	0xd94
		uart_puts(cmd_argument);
     1a8:	c7 01       	movw	r24, r14
     1aa:	0e 94 d0 06 	call	0xda0
#endif        
 		switch (cmd_no)
     1ae:	8d 2d       	mov	r24, r13
     1b0:	99 27       	eor	r25, r25
     1b2:	83 30       	cpi	r24, 0x03	; 3
     1b4:	91 05       	cpc	r25, r1
     1b6:	09 f4       	brne	.+2      	; 0x1ba
     1b8:	3e c0       	rjmp	.+124    	; 0x236
     1ba:	84 30       	cpi	r24, 0x04	; 4
     1bc:	91 05       	cpc	r25, r1
     1be:	34 f4       	brge	.+12     	; 0x1cc
     1c0:	81 30       	cpi	r24, 0x01	; 1
     1c2:	91 05       	cpc	r25, r1
     1c4:	59 f0       	breq	.+22     	; 0x1dc
     1c6:	02 97       	sbiw	r24, 0x02	; 2
     1c8:	c1 f0       	breq	.+48     	; 0x1fa
     1ca:	e3 c0       	rjmp	.+454    	; 0x392
     1cc:	84 30       	cpi	r24, 0x04	; 4
     1ce:	91 05       	cpc	r25, r1
     1d0:	09 f4       	brne	.+2      	; 0x1d4
     1d2:	8e c0       	rjmp	.+284    	; 0x2f0
     1d4:	05 97       	sbiw	r24, 0x05	; 5
     1d6:	09 f4       	brne	.+2      	; 0x1da
     1d8:	a1 c0       	rjmp	.+322    	; 0x31c
     1da:	db c0       	rjmp	.+438    	; 0x392
		{
			case MOTOR_CMD: 
				g_motor = (uint8_t)atoi(cmd_argument);
     1dc:	c7 01       	movw	r24, r14
     1de:	0e 94 35 08 	call	0x106a
     1e2:	80 93 06 02 	sts	0x0206, r24
				if (g_motor > 0)
     1e6:	28 2f       	mov	r18, r24
     1e8:	88 23       	and	r24, r24
     1ea:	21 f0       	breq	.+8      	; 0x1f4
				   g_motor--;                //  > 0 Start from 0 need -1
     1ec:	21 50       	subi	r18, 0x01	; 1
     1ee:	20 93 06 02 	sts	0x0206, r18
     1f2:	d3 c0       	rjmp	.+422    	; 0x39a
				else
				   g_motor = 0;
     1f4:	80 93 06 02 	sts	0x0206, r24
 				break;
     1f8:	d0 c0       	rjmp	.+416    	; 0x39a
			case  SPEED_CMD:	
				i = (uint8_t)atoi(cmd_argument);
     1fa:	c7 01       	movw	r24, r14
     1fc:	0e 94 35 08 	call	0x106a
     200:	18 2f       	mov	r17, r24
				if ( i >=  MOTOR_MAX_SPEED)
     202:	89 30       	cpi	r24, 0x09	; 9
     204:	10 f0       	brcs	.+4      	; 0x20a
						i = MOTOR_MAX_SPEED;    // Start from 0
     206:	19 e0       	ldi	r17, 0x09	; 9
     208:	01 c0       	rjmp	.+2      	; 0x20c
				if (i)   // i > 0; 		
     20a:	81 11       	cpse	r24, r1
					i--;   //Start from 0;		
     20c:	11 50       	subi	r17, 0x01	; 1
				g_speed[g_motor] =  g_speed_table[i];
     20e:	80 91 06 02 	lds	r24, 0x0206
     212:	c8 2f       	mov	r28, r24
     214:	dd 27       	eor	r29, r29
     216:	de 01       	movw	r26, r28
     218:	af 5f       	subi	r26, 0xFF	; 255
     21a:	bc 4f       	sbci	r27, 0xFC	; 252
     21c:	e1 2f       	mov	r30, r17
     21e:	ff 27       	eor	r31, r31
     220:	e4 5a       	subi	r30, 0xA4	; 164
     222:	fe 4f       	sbci	r31, 0xFE	; 254
     224:	20 81       	ld	r18, Z
     226:	2c 93       	st	X, r18
				if (g_speed[g_motor] == 0)
     228:	22 23       	and	r18, r18
     22a:	09 f0       	breq	.+2      	; 0x22e
     22c:	b6 c0       	rjmp	.+364    	; 0x39a
				        g_mode[g_motor] = MOTOR_STOP;
     22e:	c0 51       	subi	r28, 0x10	; 16
     230:	de 4f       	sbci	r29, 0xFE	; 254
     232:	28 83       	st	Y, r18
  				break;
     234:	b2 c0       	rjmp	.+356    	; 0x39a
			case  ANGLE_CMD:   // Can be - 		
    			g_angle[g_motor] = atoi(cmd_argument);
     236:	80 91 06 02 	lds	r24, 0x0206
     23a:	c8 2f       	mov	r28, r24
     23c:	dd 27       	eor	r29, r29
     23e:	8e 01       	movw	r16, r28
     240:	00 0f       	add	r16, r16
     242:	11 1f       	adc	r17, r17
     244:	00 0f       	add	r16, r16
     246:	11 1f       	adc	r17, r17
     248:	02 50       	subi	r16, 0x02	; 2
     24a:	1e 4f       	sbci	r17, 0xFE	; 254
     24c:	c7 01       	movw	r24, r14
     24e:	0e 94 35 08 	call	0x106a
     252:	9c 01       	movw	r18, r24
     254:	44 27       	eor	r20, r20
     256:	37 fd       	sbrc	r19, 7
     258:	40 95       	com	r20
     25a:	54 2f       	mov	r21, r20
     25c:	f8 01       	movw	r30, r16
     25e:	20 83       	st	Z, r18
     260:	31 83       	std	Z+1, r19	; 0x01
     262:	42 83       	std	Z+2, r20	; 0x02
     264:	53 83       	std	Z+3, r21	; 0x03
				if (g_angle[g_motor] < 0)
     266:	57 ff       	sbrs	r21, 7
     268:	12 c0       	rjmp	.+36     	; 0x28e
				{   
						g_mode[g_motor] = MOTOR_BACKWARD;
     26a:	fe 01       	movw	r30, r28
     26c:	e0 51       	subi	r30, 0x10	; 16
     26e:	fe 4f       	sbci	r31, 0xFE	; 254
     270:	82 e0       	ldi	r24, 0x02	; 2
     272:	80 83       	st	Z, r24
 
// Set g_angle to positive value by invert all bit and +1                
                        g_angle[g_motor] = (~(g_angle[g_motor])+1);
     274:	66 27       	eor	r22, r22
     276:	77 27       	eor	r23, r23
     278:	cb 01       	movw	r24, r22
     27a:	62 1b       	sub	r22, r18
     27c:	73 0b       	sbc	r23, r19
     27e:	84 0b       	sbc	r24, r20
     280:	95 0b       	sbc	r25, r21
     282:	f8 01       	movw	r30, r16
     284:	60 83       	st	Z, r22
     286:	71 83       	std	Z+1, r23	; 0x01
     288:	82 83       	std	Z+2, r24	; 0x02
     28a:	93 83       	std	Z+3, r25	; 0x03
     28c:	18 c0       	rjmp	.+48     	; 0x2be
                        if  (g_angle[g_motor] > 1)
						{
 						   g_angle[g_motor] *= MOTOR_ANGLE_COEF;
 						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
						}		
				}	
				else  if (g_angle[g_motor] == 0)
     28e:	21 15       	cp	r18, r1
     290:	31 05       	cpc	r19, r1
     292:	41 05       	cpc	r20, r1
     294:	51 05       	cpc	r21, r1
     296:	21 f4       	brne	.+8      	; 0x2a0
				       {  	
							g_mode[g_motor] = MOTOR_STOP;
     298:	c0 51       	subi	r28, 0x10	; 16
     29a:	de 4f       	sbci	r29, 0xFE	; 254
     29c:	18 82       	st	Y, r1
     29e:	7d c0       	rjmp	.+250    	; 0x39a
 					   }
				else	  
				{
					if ((g_angle[g_motor] > 0))   //  +
     2a0:	12 16       	cp	r1, r18
     2a2:	13 06       	cpc	r1, r19
     2a4:	14 06       	cpc	r1, r20
     2a6:	15 06       	cpc	r1, r21
     2a8:	2c f4       	brge	.+10     	; 0x2b4
					{
						g_mode[g_motor] = MOTOR_FORWARD;
     2aa:	fe 01       	movw	r30, r28
     2ac:	e0 51       	subi	r30, 0x10	; 16
     2ae:	fe 4f       	sbci	r31, 0xFE	; 254
     2b0:	81 e0       	ldi	r24, 0x01	; 1
     2b2:	80 83       	st	Z, r24
 					}
					if  (g_angle[g_motor] > 1)
     2b4:	f8 01       	movw	r30, r16
     2b6:	60 81       	ld	r22, Z
     2b8:	71 81       	ldd	r23, Z+1	; 0x01
     2ba:	82 81       	ldd	r24, Z+2	; 0x02
     2bc:	93 81       	ldd	r25, Z+3	; 0x03
     2be:	62 30       	cpi	r22, 0x02	; 2
     2c0:	71 05       	cpc	r23, r1
     2c2:	81 05       	cpc	r24, r1
     2c4:	91 05       	cpc	r25, r1
     2c6:	0c f4       	brge	.+2      	; 0x2ca
     2c8:	68 c0       	rjmp	.+208    	; 0x39a
					{
 						g_angle[g_motor] *=  MOTOR_ANGLE_COEF;	
     2ca:	24 e6       	ldi	r18, 0x64	; 100
     2cc:	30 e0       	ldi	r19, 0x00	; 0
     2ce:	40 e0       	ldi	r20, 0x00	; 0
     2d0:	50 e0       	ldi	r21, 0x00	; 0
     2d2:	0e 94 fc 08 	call	0x11f8
     2d6:	dc 01       	movw	r26, r24
     2d8:	cb 01       	movw	r24, r22
     2da:	f8 01       	movw	r30, r16
     2dc:	80 83       	st	Z, r24
     2de:	91 83       	std	Z+1, r25	; 0x01
     2e0:	a2 83       	std	Z+2, r26	; 0x02
     2e2:	b3 83       	std	Z+3, r27	; 0x03
 						g_speed[g_motor]  = g_speed_table[MOTOR_ANGLE_SPEED] ;
     2e4:	cf 5f       	subi	r28, 0xFF	; 255
     2e6:	dc 4f       	sbci	r29, 0xFC	; 252
     2e8:	80 91 5f 01 	lds	r24, 0x015F
     2ec:	88 83       	st	Y, r24
					}
 				}
				break;	
     2ee:	55 c0       	rjmp	.+170    	; 0x39a
			case PROGRAM_CMD:
				g_program_flag = (uint8_t)atoi(cmd_argument);
     2f0:	c7 01       	movw	r24, r14
     2f2:	0e 94 35 08 	call	0x106a
     2f6:	80 93 e6 01 	sts	0x01E6, r24
				if (g_program_flag)   // Start  program save in buffer
     2fa:	88 23       	and	r24, r24
     2fc:	19 f0       	breq	.+6      	; 0x304
				{
					uart_puts ("Program Start to save : ");
     2fe:	8f e6       	ldi	r24, 0x6F	; 111
     300:	91 e0       	ldi	r25, 0x01	; 1
     302:	40 c0       	rjmp	.+128    	; 0x384
				     g_program_index = 0;
				}
				else
				{  
					uart_puts ("Program End : ");
     304:	88 e8       	ldi	r24, 0x88	; 136
     306:	91 e0       	ldi	r25, 0x01	; 1
     308:	0e 94 d0 06 	call	0xda0
// Put null string at the end
                    uart_putc(g_program_flag+0x30);
     30c:	80 91 e6 01 	lds	r24, 0x01E6
     310:	80 5d       	subi	r24, 0xD0	; 208
     312:	0e 94 ca 06 	call	0xd94
//                  g_program_buff[g_program_index] = 0;
					uart_puts(g_program_buff);
     316:	80 e6       	ldi	r24, 0x60	; 96
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	3d c0       	rjmp	.+122    	; 0x396
//                  g_program_index = 0;				
				}
				break;
 			case SAVE_CMD:
				j = (uint8_t)atoi(cmd_argument);
     31c:	c7 01       	movw	r24, r14
     31e:	0e 94 35 08 	call	0x106a
				if ( j > 0)    // Save commmand to eeprom
     322:	88 23       	and	r24, r24
     324:	d1 f1       	breq	.+116    	; 0x39a
                {
					g_program_buff[g_program_index] = 0x00 ;  // Put null at the end
     326:	80 91 e4 01 	lds	r24, 0x01E4
     32a:	90 91 e5 01 	lds	r25, 0x01E5
     32e:	fc 01       	movw	r30, r24
     330:	e0 5a       	subi	r30, 0xA0	; 160
     332:	ff 4f       	sbci	r31, 0xFF	; 255
     334:	10 82       	st	Z, r1
                    g_program_index++;   
     336:	01 96       	adiw	r24, 0x01	; 1
     338:	90 93 e5 01 	sts	0x01E5, r25
     33c:	80 93 e4 01 	sts	0x01E4, r24
                    for ( i =0; i < g_program_index; i++)
     340:	10 81       	ld	r17, Z
     342:	89 2b       	or	r24, r25
     344:	b1 f0       	breq	.+44     	; 0x372
                    {
						while (!eeprom_is_ready());
     346:	e1 99       	sbic	0x1c, 1	; 28
     348:	fe cf       	rjmp	.-4      	; 0x346
							eeprom_write_byte(&g_program_eeprom[i],g_program_buff[i]);
     34a:	81 2f       	mov	r24, r17
     34c:	99 27       	eor	r25, r25
     34e:	fc 01       	movw	r30, r24
     350:	e0 5a       	subi	r30, 0xA0	; 160
     352:	ff 4f       	sbci	r31, 0xFF	; 255
     354:	60 81       	ld	r22, Z
     356:	80 50       	subi	r24, 0x00	; 0
     358:	90 40       	sbci	r25, 0x00	; 0
     35a:	0e 94 6a 08 	call	0x10d4
     35e:	1f 5f       	subi	r17, 0xFF	; 255
     360:	21 2f       	mov	r18, r17
     362:	33 27       	eor	r19, r19
     364:	80 91 e4 01 	lds	r24, 0x01E4
     368:	90 91 e5 01 	lds	r25, 0x01E5
     36c:	28 17       	cp	r18, r24
     36e:	39 07       	cpc	r19, r25
     370:	50 f3       	brcs	.-44     	; 0x346
					}
					debug_value( g_program_index,10);
     372:	6a e0       	ldi	r22, 0x0A	; 10
     374:	80 91 e4 01 	lds	r24, 0x01E4
     378:	90 91 e5 01 	lds	r25, 0x01E5
     37c:	0e 94 e3 06 	call	0xdc6
					uart_puts ("Save complete ");
     380:	87 e9       	ldi	r24, 0x97	; 151
     382:	91 e0       	ldi	r25, 0x01	; 1
     384:	0e 94 d0 06 	call	0xda0
					g_program_index = 0;	
     388:	10 92 e5 01 	sts	0x01E5, r1
     38c:	10 92 e4 01 	sts	0x01E4, r1
				}
				break;
     390:	04 c0       	rjmp	.+8      	; 0x39a
 			default:
			    uart_puts("Command not found ");
     392:	86 ea       	ldi	r24, 0xA6	; 166
     394:	91 e0       	ldi	r25, 0x01	; 1
     396:	0e 94 d0 06 	call	0xda0
 		        break;	  
     39a:	ff ef       	ldi	r31, 0xFF	; 255
     39c:	df 16       	cp	r13, r31
     39e:	09 f0       	breq	.+2      	; 0x3a2
     3a0:	f3 ce       	rjmp	.-538    	; 0x188
		}		
    }
 
 return 0; 
}
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	df 91       	pop	r29
     3a8:	cf 91       	pop	r28
     3aa:	1f 91       	pop	r17
     3ac:	0f 91       	pop	r16
     3ae:	ff 90       	pop	r15
     3b0:	ef 90       	pop	r14
     3b2:	df 90       	pop	r13
     3b4:	08 95       	ret

000003b6 <program_run>:





// Run program which save in eeprom or g_program_buff
//  Mode =1 run from eeprom
//  Mode =2 run from buffer
void program_run (uint8_t mode)
{
     3b6:	cf 92       	push	r12
     3b8:	df 92       	push	r13
     3ba:	ef 92       	push	r14
     3bc:	ff 92       	push	r15
     3be:	0f 93       	push	r16
     3c0:	1f 93       	push	r17
     3c2:	cf 93       	push	r28
   uint16_t i;
   uint8_t ch,j;

   if (mode == RUN_EEPROM)
     3c4:	81 30       	cpi	r24, 0x01	; 1
     3c6:	f1 f4       	brne	.+60     	; 0x404
   {
      i = 0;
     3c8:	ee 24       	eor	r14, r14
     3ca:	ff 24       	eor	r15, r15
     3cc:	20 e6       	ldi	r18, 0x60	; 96
     3ce:	c2 2e       	mov	r12, r18
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	d2 2e       	mov	r13, r18
     3d4:	00 e0       	ldi	r16, 0x00	; 0
     3d6:	10 e0       	ldi	r17, 0x00	; 0
 	  while ((ch = eeprom_read_byte(&g_program_eeprom[i])))   //Get EEPROM BYTE/BYTE
     3d8:	0b c0       	rjmp	.+22     	; 0x3f0
	  {
			g_program_buff[i] = ch;
     3da:	f6 01       	movw	r30, r12
     3dc:	c1 93       	st	Z+, r28
     3de:	6f 01       	movw	r12, r30
			uart_putc(ch);
     3e0:	8c 2f       	mov	r24, r28
     3e2:	0e 94 ca 06 	call	0xd94
			i++;
     3e6:	08 94       	sec
     3e8:	e1 1c       	adc	r14, r1
     3ea:	f1 1c       	adc	r15, r1
     3ec:	0f 5f       	subi	r16, 0xFF	; 255
     3ee:	1f 4f       	sbci	r17, 0xFF	; 255
     3f0:	c8 01       	movw	r24, r16
     3f2:	0e 94 62 08 	call	0x10c4
     3f6:	c8 2f       	mov	r28, r24
     3f8:	88 23       	and	r24, r24
     3fa:	79 f7       	brne	.-34     	; 0x3da
	  }
	  g_program_index = i;
     3fc:	f0 92 e5 01 	sts	0x01E5, r15
     400:	e0 92 e4 01 	sts	0x01E4, r14
   
   }

//   uart_puts(g_program_buff);
 
 
   i = 0;
     404:	ee 24       	eor	r14, r14
     406:	ff 24       	eor	r15, r15
   j = 0;
     408:	dd 24       	eor	r13, r13
   while ((ch = g_program_buff[i]))
   {
 		 uart_putc(ch);
		 if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
		 {	
			g_program_buff[i]  = 0;   // End with null for decode
		    cmd_decode(g_program_buff+j);
			j = i;
 			g_pos[g_motor] = 0;
		 }
		 i++;
     40a:	c0 91 60 00 	lds	r28, 0x0060
     40e:	cc 23       	and	r28, r28
     410:	49 f1       	breq	.+82     	; 0x464
     412:	00 e6       	ldi	r16, 0x60	; 96
     414:	10 e0       	ldi	r17, 0x00	; 0
     416:	8c 2f       	mov	r24, r28
     418:	0e 94 ca 06 	call	0xd94
     41c:	cd 30       	cpi	r28, 0x0D	; 13
     41e:	11 f0       	breq	.+4      	; 0x424
     420:	ca 30       	cpi	r28, 0x0A	; 10
     422:	b9 f4       	brne	.+46     	; 0x452
     424:	f8 01       	movw	r30, r16
     426:	10 82       	st	Z, r1
     428:	8d 2d       	mov	r24, r13
     42a:	99 27       	eor	r25, r25
     42c:	80 5a       	subi	r24, 0xA0	; 160
     42e:	9f 4f       	sbci	r25, 0xFF	; 255
     430:	0e 94 bc 00 	call	0x178
     434:	de 2c       	mov	r13, r14
     436:	80 91 06 02 	lds	r24, 0x0206
     43a:	e8 2f       	mov	r30, r24
     43c:	ff 27       	eor	r31, r31
     43e:	ee 0f       	add	r30, r30
     440:	ff 1f       	adc	r31, r31
     442:	ee 0f       	add	r30, r30
     444:	ff 1f       	adc	r31, r31
     446:	e8 51       	subi	r30, 0x18	; 24
     448:	fe 4f       	sbci	r31, 0xFE	; 254
     44a:	10 82       	st	Z, r1
     44c:	11 82       	std	Z+1, r1	; 0x01
     44e:	12 82       	std	Z+2, r1	; 0x02
     450:	13 82       	std	Z+3, r1	; 0x03
     452:	08 94       	sec
     454:	e1 1c       	adc	r14, r1
     456:	f1 1c       	adc	r15, r1
     458:	0f 5f       	subi	r16, 0xFF	; 255
     45a:	1f 4f       	sbci	r17, 0xFF	; 255
     45c:	f8 01       	movw	r30, r16
     45e:	c0 81       	ld	r28, Z
     460:	cc 23       	and	r28, r28
     462:	c9 f6       	brne	.-78     	; 0x416
     464:	cf 91       	pop	r28
     466:	1f 91       	pop	r17
     468:	0f 91       	pop	r16
     46a:	ff 90       	pop	r15
     46c:	ef 90       	pop	r14
     46e:	df 90       	pop	r13
     470:	cf 90       	pop	r12
     472:	08 95       	ret

00000474 <calculate_backemf>:
	 
   }
}



/* Calculate backemf and save in g_pos

*/
void  calculate_backemf (uint8_t motor)
{
     474:	bf 92       	push	r11
     476:	cf 92       	push	r12
     478:	df 92       	push	r13
     47a:	ef 92       	push	r14
     47c:	ff 92       	push	r15
     47e:	0f 93       	push	r16
     480:	1f 93       	push	r17
     482:	cf 93       	push	r28
     484:	df 93       	push	r29
     486:	b8 2e       	mov	r11, r24
     int16_t backemf=0;
  // Read backemf
     static uint8_t  i = 0;

	adc_init(1);
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	0e 94 2d 07 	call	0xe5a
	backemf = read_adc(g_adc_channel[motor]);	
     48e:	eb 2c       	mov	r14, r11
     490:	ff 24       	eor	r15, r15
     492:	f7 01       	movw	r30, r14
     494:	e6 5a       	subi	r30, 0xA6	; 166
     496:	fe 4f       	sbci	r31, 0xFE	; 254
     498:	80 81       	ld	r24, Z
     49a:	0e 94 42 07 	call	0xe84
     49e:	ec 01       	movw	r28, r24


// Cut offset	
	if ((backemf > 0) && (backemf < MOTOR_OFFSET))
     4a0:	01 97       	sbiw	r24, 0x01	; 1
     4a2:	c1 97       	sbiw	r24, 0x31	; 49
     4a4:	10 f4       	brcc	.+4      	; 0x4aa
			backemf =0;
     4a6:	c0 e0       	ldi	r28, 0x00	; 0
     4a8:	d0 e0       	ldi	r29, 0x00	; 0
			
// Negative convert to positive with 2 complement	
	if (g_mode[motor] == MOTOR_STOP)   
     4aa:	f7 01       	movw	r30, r14
     4ac:	e0 51       	subi	r30, 0x10	; 16
     4ae:	fe 4f       	sbci	r31, 0xFE	; 254
     4b0:	80 81       	ld	r24, Z
     4b2:	88 23       	and	r24, r24
     4b4:	51 f4       	brne	.+20     	; 0x4ca
    {	
		if (backemf & 0x200)
     4b6:	ce 01       	movw	r24, r28
     4b8:	89 2f       	mov	r24, r25
     4ba:	99 27       	eor	r25, r25
     4bc:	86 95       	lsr	r24
     4be:	80 ff       	sbrs	r24, 0
     4c0:	04 c0       	rjmp	.+8      	; 0x4ca
		{
		    backemf = (~(backemf) & (0x03FF))+1;
     4c2:	c0 95       	com	r28
     4c4:	d0 95       	com	r29
     4c6:	d3 70       	andi	r29, 0x03	; 3
     4c8:	21 96       	adiw	r28, 0x01	; 1
 		}		
	}		
			
	if (g_mode[motor] == MOTOR_FORWARD)   // Motor stop backemf -  Forward backemf +
     4ca:	f7 01       	movw	r30, r14
     4cc:	e0 51       	subi	r30, 0x10	; 16
     4ce:	fe 4f       	sbci	r31, 0xFE	; 254
     4d0:	80 81       	ld	r24, Z
     4d2:	81 30       	cpi	r24, 0x01	; 1
     4d4:	79 f4       	brne	.+30     	; 0x4f4
    {	
		if (backemf & 0x200)
     4d6:	ce 01       	movw	r24, r28
     4d8:	89 2f       	mov	r24, r25
     4da:	99 27       	eor	r25, r25
     4dc:	86 95       	lsr	r24
     4de:	9c 01       	movw	r18, r24
     4e0:	21 70       	andi	r18, 0x01	; 1
     4e2:	30 70       	andi	r19, 0x00	; 0
     4e4:	80 ff       	sbrs	r24, 0
     4e6:	05 c0       	rjmp	.+10     	; 0x4f2
		{
		    backemf = (~(backemf) & (0x03FF))+1;
     4e8:	c0 95       	com	r28
     4ea:	d0 95       	com	r29
     4ec:	d3 70       	andi	r29, 0x03	; 3
     4ee:	21 96       	adiw	r28, 0x01	; 1
     4f0:	01 c0       	rjmp	.+2      	; 0x4f4
 		}
		else
			backemf = 0;
     4f2:	e9 01       	movw	r28, r18
    }
	if (g_mode[motor] == MOTOR_BACKWARD)   // Motor stop backemf +  backward backemf -
     4f4:	f7 01       	movw	r30, r14
     4f6:	e0 51       	subi	r30, 0x10	; 16
     4f8:	fe 4f       	sbci	r31, 0xFE	; 254
     4fa:	80 81       	ld	r24, Z
     4fc:	82 30       	cpi	r24, 0x02	; 2
     4fe:	41 f4       	brne	.+16     	; 0x510
    {	
		if (backemf & 0x200)
     500:	ce 01       	movw	r24, r28
     502:	89 2f       	mov	r24, r25
     504:	99 27       	eor	r25, r25
     506:	86 95       	lsr	r24
     508:	80 ff       	sbrs	r24, 0
     50a:	02 c0       	rjmp	.+4      	; 0x510
		{
			backemf =0;
     50c:	c0 e0       	ldi	r28, 0x00	; 0
     50e:	d0 e0       	ldi	r29, 0x00	; 0
		}
    }
	
	g_pos[motor] += backemf;
     510:	67 01       	movw	r12, r14
     512:	cc 0c       	add	r12, r12
     514:	dd 1c       	adc	r13, r13
     516:	cc 0c       	add	r12, r12
     518:	dd 1c       	adc	r13, r13
     51a:	86 01       	movw	r16, r12
     51c:	08 51       	subi	r16, 0x18	; 24
     51e:	1e 4f       	sbci	r17, 0xFE	; 254
     520:	ce 01       	movw	r24, r28
     522:	aa 27       	eor	r26, r26
     524:	97 fd       	sbrc	r25, 7
     526:	a0 95       	com	r26
     528:	ba 2f       	mov	r27, r26
     52a:	f8 01       	movw	r30, r16
     52c:	20 81       	ld	r18, Z
     52e:	31 81       	ldd	r19, Z+1	; 0x01
     530:	42 81       	ldd	r20, Z+2	; 0x02
     532:	53 81       	ldd	r21, Z+3	; 0x03
     534:	28 0f       	add	r18, r24
     536:	39 1f       	adc	r19, r25
     538:	4a 1f       	adc	r20, r26
     53a:	5b 1f       	adc	r21, r27
     53c:	20 83       	st	Z, r18
     53e:	31 83       	std	Z+1, r19	; 0x01
     540:	42 83       	std	Z+2, r20	; 0x02
     542:	53 83       	std	Z+3, r21	; 0x03
    if (g_mode[motor] != MOTOR_STOP)	
     544:	80 ef       	ldi	r24, 0xF0	; 240
     546:	91 e0       	ldi	r25, 0x01	; 1
     548:	e8 0e       	add	r14, r24
     54a:	f9 1e       	adc	r15, r25
     54c:	f7 01       	movw	r30, r14
     54e:	80 81       	ld	r24, Z
     550:	88 23       	and	r24, r24
     552:	69 f0       	breq	.+26     	; 0x56e
 	{   
//	    i++;
//		if (i == 100 )
		{
		    uart_putc(motor+0x30);
     554:	8b 2d       	mov	r24, r11
     556:	80 5d       	subi	r24, 0xD0	; 208
     558:	0e 94 ca 06 	call	0xd94
			uart_putc('-');
     55c:	8d e2       	ldi	r24, 0x2D	; 45
     55e:	0e 94 ca 06 	call	0xd94
			debug_value(backemf,10);
     562:	6a e0       	ldi	r22, 0x0A	; 10
     564:	ce 01       	movw	r24, r28
     566:	0e 94 e3 06 	call	0xdc6
			i = 0;
     56a:	10 92 f2 01 	sts	0x01F2, r1
		}
	}	
//Compare voltage	
	if (((g_angle[motor] > 1)) && ( g_mode[motor] != MOTOR_STOP))
     56e:	f6 01       	movw	r30, r12
     570:	e2 50       	subi	r30, 0x02	; 2
     572:	fe 4f       	sbci	r31, 0xFE	; 254
     574:	20 81       	ld	r18, Z
     576:	31 81       	ldd	r19, Z+1	; 0x01
     578:	42 81       	ldd	r20, Z+2	; 0x02
     57a:	53 81       	ldd	r21, Z+3	; 0x03
     57c:	22 30       	cpi	r18, 0x02	; 2
     57e:	31 05       	cpc	r19, r1
     580:	41 05       	cpc	r20, r1
     582:	51 05       	cpc	r21, r1
     584:	0c f1       	brlt	.+66     	; 0x5c8
     586:	f7 01       	movw	r30, r14
     588:	80 81       	ld	r24, Z
     58a:	88 23       	and	r24, r24
     58c:	e9 f0       	breq	.+58     	; 0x5c8
	{   
//Compare voltage sum	
		if ( g_pos[motor]  >= (g_angle[motor]))  //  Check for position
     58e:	f8 01       	movw	r30, r16
     590:	80 81       	ld	r24, Z
     592:	91 81       	ldd	r25, Z+1	; 0x01
     594:	a2 81       	ldd	r26, Z+2	; 0x02
     596:	b3 81       	ldd	r27, Z+3	; 0x03
     598:	82 17       	cp	r24, r18
     59a:	93 07       	cpc	r25, r19
     59c:	a4 07       	cpc	r26, r20
     59e:	b5 07       	cpc	r27, r21
     5a0:	9c f0       	brlt	.+38     	; 0x5c8
		{
			g_mode[motor] = MOTOR_STOP;			
     5a2:	f7 01       	movw	r30, r14
     5a4:	10 82       	st	Z, r1
 			uart_puts ("Voltage SUM");
     5a6:	89 eb       	ldi	r24, 0xB9	; 185
     5a8:	91 e0       	ldi	r25, 0x01	; 1
     5aa:	0e 94 d0 06 	call	0xda0
			debug_lvalue(g_pos[motor],10);
     5ae:	4a e0       	ldi	r20, 0x0A	; 10
     5b0:	f8 01       	movw	r30, r16
     5b2:	60 81       	ld	r22, Z
     5b4:	71 81       	ldd	r23, Z+1	; 0x01
     5b6:	82 81       	ldd	r24, Z+2	; 0x02
     5b8:	93 81       	ldd	r25, Z+3	; 0x03
     5ba:	0e 94 02 07 	call	0xe04
			g_pos[motor] =0;				
     5be:	f8 01       	movw	r30, r16
     5c0:	10 82       	st	Z, r1
     5c2:	11 82       	std	Z+1, r1	; 0x01
     5c4:	12 82       	std	Z+2, r1	; 0x02
     5c6:	13 82       	std	Z+3, r1	; 0x03
     5c8:	df 91       	pop	r29
     5ca:	cf 91       	pop	r28
     5cc:	1f 91       	pop	r17
     5ce:	0f 91       	pop	r16
     5d0:	ff 90       	pop	r15
     5d2:	ef 90       	pop	r14
     5d4:	df 90       	pop	r13
     5d6:	cf 90       	pop	r12
     5d8:	bf 90       	pop	r11
     5da:	08 95       	ret

000005dc <remote_decode>:
		}
	}
 		
}



/* This subroutine will handle IR remote decode by getting remote code from Interrupt handle for input capture
and will response  to each remote key. For other applications user can modified here for different remote active
However this routine support Sony remote control only
   global effect   g_irint;
*/

void remote_decode ( uint16_t ircode)
{ 
     5dc:	cf 93       	push	r28

  uint8_t set_speed = 8 ;
     5de:	c8 e0       	ldi	r28, 0x08	; 8
  switch ( ircode)
     5e0:	28 e0       	ldi	r18, 0x08	; 8
     5e2:	80 31       	cpi	r24, 0x10	; 16
     5e4:	92 07       	cpc	r25, r18
     5e6:	09 f4       	brne	.+2      	; 0x5ea
     5e8:	57 c0       	rjmp	.+174    	; 0x698
     5ea:	28 e0       	ldi	r18, 0x08	; 8
     5ec:	81 31       	cpi	r24, 0x11	; 17
     5ee:	92 07       	cpc	r25, r18
     5f0:	30 f5       	brcc	.+76     	; 0x63e
     5f2:	22 e0       	ldi	r18, 0x02	; 2
     5f4:	80 31       	cpi	r24, 0x10	; 16
     5f6:	92 07       	cpc	r25, r18
     5f8:	09 f4       	brne	.+2      	; 0x5fc
     5fa:	54 c0       	rjmp	.+168    	; 0x6a4
     5fc:	22 e0       	ldi	r18, 0x02	; 2
     5fe:	81 31       	cpi	r24, 0x11	; 17
     600:	92 07       	cpc	r25, r18
     602:	60 f4       	brcc	.+24     	; 0x61c
     604:	80 39       	cpi	r24, 0x90	; 144
     606:	91 05       	cpc	r25, r1
     608:	09 f4       	brne	.+2      	; 0x60c
     60a:	86 c0       	rjmp	.+268    	; 0x718
     60c:	81 39       	cpi	r24, 0x91	; 145
     60e:	91 05       	cpc	r25, r1
     610:	08 f0       	brcs	.+2      	; 0x614
     612:	8f c0       	rjmp	.+286    	; 0x732
     614:	40 97       	sbiw	r24, 0x10	; 16
     616:	09 f4       	brne	.+2      	; 0x61a
     618:	3d c0       	rjmp	.+122    	; 0x694
     61a:	8b c0       	rjmp	.+278    	; 0x732
     61c:	24 e0       	ldi	r18, 0x04	; 4
     61e:	80 39       	cpi	r24, 0x90	; 144
     620:	92 07       	cpc	r25, r18
     622:	09 f4       	brne	.+2      	; 0x626
     624:	81 c0       	rjmp	.+258    	; 0x728
     626:	24 e0       	ldi	r18, 0x04	; 4
     628:	81 39       	cpi	r24, 0x91	; 145
     62a:	92 07       	cpc	r25, r18
     62c:	20 f4       	brcc	.+8      	; 0x636
     62e:	80 51       	subi	r24, 0x10	; 16
     630:	94 40       	sbci	r25, 0x04	; 4
     632:	a1 f1       	breq	.+104    	; 0x69c
     634:	7e c0       	rjmp	.+252    	; 0x732
     636:	80 51       	subi	r24, 0x10	; 16
     638:	96 40       	sbci	r25, 0x06	; 6
     63a:	c1 f1       	breq	.+112    	; 0x6ac
     63c:	7a c0       	rjmp	.+244    	; 0x732
     63e:	2a e0       	ldi	r18, 0x0A	; 10
     640:	80 35       	cpi	r24, 0x50	; 80
     642:	92 07       	cpc	r25, r18
     644:	09 f4       	brne	.+2      	; 0x648
     646:	6c c0       	rjmp	.+216    	; 0x720
     648:	2a e0       	ldi	r18, 0x0A	; 10
     64a:	81 35       	cpi	r24, 0x51	; 81
     64c:	92 07       	cpc	r25, r18
     64e:	88 f4       	brcc	.+34     	; 0x672
     650:	29 e0       	ldi	r18, 0x09	; 9
     652:	80 31       	cpi	r24, 0x10	; 16
     654:	92 07       	cpc	r25, r18
     656:	71 f1       	breq	.+92     	; 0x6b4
     658:	29 e0       	ldi	r18, 0x09	; 9
     65a:	81 31       	cpi	r24, 0x11	; 17
     65c:	92 07       	cpc	r25, r18
     65e:	28 f4       	brcc	.+10     	; 0x66a
     660:	80 59       	subi	r24, 0x90	; 144
     662:	98 40       	sbci	r25, 0x08	; 8
     664:	09 f4       	brne	.+2      	; 0x668
     666:	5a c0       	rjmp	.+180    	; 0x71c
     668:	64 c0       	rjmp	.+200    	; 0x732
     66a:	80 51       	subi	r24, 0x10	; 16
     66c:	9a 40       	sbci	r25, 0x0A	; 10
     66e:	e1 f0       	breq	.+56     	; 0x6a8
     670:	60 c0       	rjmp	.+192    	; 0x732
     672:	2c e0       	ldi	r18, 0x0C	; 12
     674:	80 39       	cpi	r24, 0x90	; 144
     676:	92 07       	cpc	r25, r18
     678:	09 f4       	brne	.+2      	; 0x67c
     67a:	58 c0       	rjmp	.+176    	; 0x72c
     67c:	2c e0       	ldi	r18, 0x0C	; 12
     67e:	81 39       	cpi	r24, 0x91	; 145
     680:	92 07       	cpc	r25, r18
     682:	20 f4       	brcc	.+8      	; 0x68c
     684:	80 51       	subi	r24, 0x10	; 16
     686:	9c 40       	sbci	r25, 0x0C	; 12
     688:	59 f0       	breq	.+22     	; 0x6a0
     68a:	53 c0       	rjmp	.+166    	; 0x732
     68c:	80 51       	subi	r24, 0x10	; 16
     68e:	9e 40       	sbci	r25, 0x0E	; 14
     690:	79 f0       	breq	.+30     	; 0x6b0
     692:	4f c0       	rjmp	.+158    	; 0x732
	   {
	    case IR_TV_1:	
 			set_speed = 0;
     694:	c0 e0       	ldi	r28, 0x00	; 0
			 break;
     696:	4d c0       	rjmp	.+154    	; 0x732
		case IR_TV_2:
			set_speed =1;
     698:	c1 e0       	ldi	r28, 0x01	; 1
			break;
     69a:	4b c0       	rjmp	.+150    	; 0x732
	    case IR_TV_3:
 			set_speed =2;			
     69c:	c2 e0       	ldi	r28, 0x02	; 2
			break;
     69e:	49 c0       	rjmp	.+146    	; 0x732
		case IR_TV_4:
 			set_speed =3;			
     6a0:	c3 e0       	ldi	r28, 0x03	; 3
			 break;
     6a2:	47 c0       	rjmp	.+142    	; 0x732
	    case IR_TV_5:
 			set_speed =4;			
     6a4:	c4 e0       	ldi	r28, 0x04	; 4
			 break;
     6a6:	45 c0       	rjmp	.+138    	; 0x732
		case IR_TV_6:
 			set_speed = 5;			
     6a8:	c5 e0       	ldi	r28, 0x05	; 5
			 break;
     6aa:	43 c0       	rjmp	.+134    	; 0x732
	    case IR_TV_7:
 			set_speed = 6;			
     6ac:	c6 e0       	ldi	r28, 0x06	; 6
			break;
     6ae:	41 c0       	rjmp	.+130    	; 0x732
		case IR_TV_8:
 			set_speed = 7;			
     6b0:	c7 e0       	ldi	r28, 0x07	; 7
			break;
     6b2:	3f c0       	rjmp	.+126    	; 0x732
	    case IR_TV_9:
 			set_speed =8;			
			break;
		case IR_TV_0:
			set_motor_parameter (MOTOR_STOP);
     6b4:	80 e0       	ldi	r24, 0x00	; 0
     6b6:	0e 94 6e 00 	call	0xdc
			uart_puts ("Voltage SUM 1");
     6ba:	85 ec       	ldi	r24, 0xC5	; 197
     6bc:	91 e0       	ldi	r25, 0x01	; 1
     6be:	0e 94 d0 06 	call	0xda0
			debug_lvalue(g_pos[0],10);
     6c2:	4a e0       	ldi	r20, 0x0A	; 10
     6c4:	60 91 e8 01 	lds	r22, 0x01E8
     6c8:	70 91 e9 01 	lds	r23, 0x01E9
     6cc:	80 91 ea 01 	lds	r24, 0x01EA
     6d0:	90 91 eb 01 	lds	r25, 0x01EB
     6d4:	0e 94 02 07 	call	0xe04
			g_pos[0] =0;
     6d8:	10 92 e8 01 	sts	0x01E8, r1
     6dc:	10 92 e9 01 	sts	0x01E9, r1
     6e0:	10 92 ea 01 	sts	0x01EA, r1
     6e4:	10 92 eb 01 	sts	0x01EB, r1
			uart_puts ("Voltage SUM 2");
     6e8:	83 ed       	ldi	r24, 0xD3	; 211
     6ea:	91 e0       	ldi	r25, 0x01	; 1
     6ec:	0e 94 d0 06 	call	0xda0
			debug_lvalue(g_pos[1],10);
     6f0:	4a e0       	ldi	r20, 0x0A	; 10
     6f2:	60 91 ec 01 	lds	r22, 0x01EC
     6f6:	70 91 ed 01 	lds	r23, 0x01ED
     6fa:	80 91 ee 01 	lds	r24, 0x01EE
     6fe:	90 91 ef 01 	lds	r25, 0x01EF
     702:	0e 94 02 07 	call	0xe04
			g_pos[1] =0;
     706:	10 92 ec 01 	sts	0x01EC, r1
     70a:	10 92 ed 01 	sts	0x01ED, r1
     70e:	10 92 ee 01 	sts	0x01EE, r1
     712:	10 92 ef 01 	sts	0x01EF, r1
			break;
     716:	0d c0       	rjmp	.+26     	; 0x732
		case IR_TV_CHUP:
			set_motor_parameter(MOTOR_FORWARD);
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	09 c0       	rjmp	.+18     	; 0x72e
			break;
		case IR_TV_CHDOWN:							
			set_motor_parameter(MOTOR_BACKWARD);
     71c:	82 e0       	ldi	r24, 0x02	; 2
     71e:	07 c0       	rjmp	.+14     	; 0x72e
			break;
		case IR_TV_TVMUTE:
			break;
		case  IR_TV_TVPOWER:
		  	break;
		case   IR_TV_TVAV:
		    program_run(RUN_EEPROM);
     720:	81 e0       	ldi	r24, 0x01	; 1
     722:	0e 94 db 01 	call	0x3b6
		    break;
     726:	05 c0       	rjmp	.+10     	; 0x732
		case  IR_TV_VOLUP:
            set_motor_parameter(MOTOR_TURN_LEFT);
     728:	84 e0       	ldi	r24, 0x04	; 4
     72a:	01 c0       	rjmp	.+2      	; 0x72e
			break;
		case  IR_TV_VOLDOWN:                 			
		    set_motor_parameter(MOTOR_TURN_RIGHT);
     72c:	85 e0       	ldi	r24, 0x05	; 5
     72e:	0e 94 6e 00 	call	0xdc
			break;
 		default:
 //			set_motor_parameter (MOTOR_STOP);
			break;
 	   }
	   g_speed[1] = g_speed_table[set_speed]; 
     732:	ec 2f       	mov	r30, r28
     734:	ff 27       	eor	r31, r31
     736:	e4 5a       	subi	r30, 0xA4	; 164
     738:	fe 4f       	sbci	r31, 0xFE	; 254
     73a:	80 81       	ld	r24, Z
     73c:	80 93 02 03 	sts	0x0302, r24
	   g_speed[0] = g_speed[1];
     740:	80 93 01 03 	sts	0x0301, r24
     744:	cf 91       	pop	r28
     746:	08 95       	ret

00000748 <__vector_11>:

}


// Interrupt Vector table
// Couter timer 0 reach top  
//    ON Motor   0 - OCR0  ON   OCR0 - 0xFF OFF
 SIGNAL (SIG_OVERFLOW0)   
{ 
     748:	1f 92       	push	r1
     74a:	0f 92       	push	r0
     74c:	0f b6       	in	r0, 0x3f	; 63
     74e:	0f 92       	push	r0
     750:	11 24       	eor	r1, r1
     752:	2f 93       	push	r18
     754:	3f 93       	push	r19
     756:	4f 93       	push	r20
     758:	5f 93       	push	r21
     75a:	6f 93       	push	r22
     75c:	7f 93       	push	r23
     75e:	8f 93       	push	r24
     760:	9f 93       	push	r25
     762:	af 93       	push	r26
     764:	bf 93       	push	r27
     766:	ef 93       	push	r30
     768:	ff 93       	push	r31
    calculate_backemf(0); 
     76a:	80 e0       	ldi	r24, 0x00	; 0
     76c:	0e 94 3a 02 	call	0x474
	OCR0 =  g_speed[0];
     770:	80 91 01 03 	lds	r24, 0x0301
     774:	8c bf       	out	0x3c, r24	; 60
    motor_control(1, g_mode[0]);
     776:	60 91 f0 01 	lds	r22, 0x01F0
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	0e 94 d8 05 	call	0xbb0
	MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;  // Enable Motor control
     780:	95 9a       	sbi	0x12, 5	; 18
     782:	ff 91       	pop	r31
     784:	ef 91       	pop	r30
     786:	bf 91       	pop	r27
     788:	af 91       	pop	r26
     78a:	9f 91       	pop	r25
     78c:	8f 91       	pop	r24
     78e:	7f 91       	pop	r23
     790:	6f 91       	pop	r22
     792:	5f 91       	pop	r21
     794:	4f 91       	pop	r20
     796:	3f 91       	pop	r19
     798:	2f 91       	pop	r18
     79a:	0f 90       	pop	r0
     79c:	0f be       	out	0x3f, r0	; 63
     79e:	0f 90       	pop	r0
     7a0:	1f 90       	pop	r1
     7a2:	18 95       	reti

000007a4 <__vector_10>:
		
}

// Counter timer 0 reach OCR0  OFF MOTOR
 SIGNAL (SIG_OUTPUT_COMPARE0)
{
     7a4:	1f 92       	push	r1
     7a6:	0f 92       	push	r0
     7a8:	0f b6       	in	r0, 0x3f	; 63
     7aa:	0f 92       	push	r0
     7ac:	11 24       	eor	r1, r1
		MOTOR_ENABLE12_CONTROL   &= ~(MOTOR_ENABLE12);   // Disable Motor control Float motor 
     7ae:	95 98       	cbi	0x12, 5	; 18
     7b0:	0f 90       	pop	r0
     7b2:	0f be       	out	0x3f, r0	; 63
     7b4:	0f 90       	pop	r0
     7b6:	1f 90       	pop	r1
     7b8:	18 95       	reti

000007ba <__vector_5>:
//		motor_control(1, MOTOR_STOP);
}
 
// TIMER2 will opposite with timer 0 to balance calculate backemf between timer0 and timer2
// Couter timer 2 reach top  
//    ON Motor   0 - OCR2  ON   OCR2 - 0xFF FF
 SIGNAL (SIG_OVERFLOW2)   
{
     7ba:	1f 92       	push	r1
     7bc:	0f 92       	push	r0
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	0f 92       	push	r0
     7c2:	11 24       	eor	r1, r1
 	MOTOR_ENABLE34_CONTROL  &= ~(MOTOR_ENABLE34);   // Disable Motor control Float motor 
     7c4:	94 98       	cbi	0x12, 4	; 18
     7c6:	0f 90       	pop	r0
     7c8:	0f be       	out	0x3f, r0	; 63
     7ca:	0f 90       	pop	r0
     7cc:	1f 90       	pop	r1
     7ce:	18 95       	reti

000007d0 <__vector_4>:
//	motor_control(2, MOTOR_STOP);
   
}

// Counter timer 2 reach OCR2  ON MOTOR
 SIGNAL (SIG_OUTPUT_COMPARE2)
{
     7d0:	1f 92       	push	r1
     7d2:	0f 92       	push	r0
     7d4:	0f b6       	in	r0, 0x3f	; 63
     7d6:	0f 92       	push	r0
     7d8:	11 24       	eor	r1, r1
     7da:	2f 93       	push	r18
     7dc:	3f 93       	push	r19
     7de:	4f 93       	push	r20
     7e0:	5f 93       	push	r21
     7e2:	6f 93       	push	r22
     7e4:	7f 93       	push	r23
     7e6:	8f 93       	push	r24
     7e8:	9f 93       	push	r25
     7ea:	af 93       	push	r26
     7ec:	bf 93       	push	r27
     7ee:	ef 93       	push	r30
     7f0:	ff 93       	push	r31
	calculate_backemf(1);
     7f2:	81 e0       	ldi	r24, 0x01	; 1
     7f4:	0e 94 3a 02 	call	0x474
  	OCR2 =  0xFF - g_speed[1];   // Because opposite with timer0
     7f8:	80 91 02 03 	lds	r24, 0x0302
     7fc:	80 95       	com	r24
     7fe:	83 bd       	out	0x23, r24	; 35
    motor_control(2, g_mode[1]);
     800:	60 91 f1 01 	lds	r22, 0x01F1
     804:	82 e0       	ldi	r24, 0x02	; 2
     806:	0e 94 d8 05 	call	0xbb0
 	MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
     80a:	94 9a       	sbi	0x12, 4	; 18
     80c:	ff 91       	pop	r31
     80e:	ef 91       	pop	r30
     810:	bf 91       	pop	r27
     812:	af 91       	pop	r26
     814:	9f 91       	pop	r25
     816:	8f 91       	pop	r24
     818:	7f 91       	pop	r23
     81a:	6f 91       	pop	r22
     81c:	5f 91       	pop	r21
     81e:	4f 91       	pop	r20
     820:	3f 91       	pop	r19
     822:	2f 91       	pop	r18
     824:	0f 90       	pop	r0
     826:	0f be       	out	0x3f, r0	; 63
     828:	0f 90       	pop	r0
     82a:	1f 90       	pop	r1
     82c:	18 95       	reti

0000082e <__vector_13>:
 
}
 
   
/* UART receiver ready
*/

SIGNAL(SIG_UART_RECV)
{
     82e:	1f 92       	push	r1
     830:	0f 92       	push	r0
     832:	0f b6       	in	r0, 0x3f	; 63
     834:	0f 92       	push	r0
     836:	11 24       	eor	r1, r1
     838:	2f 93       	push	r18
     83a:	8f 93       	push	r24
     83c:	9f 93       	push	r25
     83e:	ef 93       	push	r30
     840:	ff 93       	push	r31
  static uint16_t i= 0;
  uint8_t ch;
  ch = UDR;
     842:	2c b1       	in	r18, 0x0c	; 12

  if (g_program_flag)   // Save into buffer
     844:	80 91 e6 01 	lds	r24, 0x01E6
     848:	88 23       	and	r24, r24
     84a:	81 f0       	breq	.+32     	; 0x86c
  {
    g_program_buff[g_program_index] = ch;
     84c:	80 91 e4 01 	lds	r24, 0x01E4
     850:	90 91 e5 01 	lds	r25, 0x01E5
     854:	fc 01       	movw	r30, r24
     856:	e0 5a       	subi	r30, 0xA0	; 160
     858:	ff 4f       	sbci	r31, 0xFF	; 255
     85a:	20 83       	st	Z, r18
	if (g_program_index < MOTOR_MAX_PROGRAM)
     85c:	8a 3f       	cpi	r24, 0xFA	; 250
     85e:	91 05       	cpc	r25, r1
     860:	28 f4       	brcc	.+10     	; 0x86c
	{
		g_program_index++; 
     862:	01 96       	adiw	r24, 0x01	; 1
     864:	90 93 e5 01 	sts	0x01E5, r25
     868:	80 93 e4 01 	sts	0x01E4, r24
	}	
  }
	g_rcv_buff[i] = ch;    
     86c:	80 91 f3 01 	lds	r24, 0x01F3
     870:	90 91 f4 01 	lds	r25, 0x01F4
     874:	fc 01       	movw	r30, r24
     876:	e9 5f       	subi	r30, 0xF9	; 249
     878:	fd 4f       	sbci	r31, 0xFD	; 253
     87a:	20 83       	st	Z, r18
	i++;
     87c:	fc 01       	movw	r30, r24
     87e:	31 96       	adiw	r30, 0x01	; 1
     880:	f0 93 f4 01 	sts	0x01F4, r31
     884:	e0 93 f3 01 	sts	0x01F3, r30
// Found 0xOD or 0x0A end with null
   if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
     888:	2d 30       	cpi	r18, 0x0D	; 13
     88a:	11 f0       	breq	.+4      	; 0x890
     88c:	2a 30       	cpi	r18, 0x0A	; 10
     88e:	51 f4       	brne	.+20     	; 0x8a4
   {	
		g_rcv_buff[i]  = 0;   // End with null
     890:	e9 5f       	subi	r30, 0xF9	; 249
     892:	fd 4f       	sbci	r31, 0xFD	; 253
     894:	10 82       	st	Z, r1
		i = 0;
     896:	10 92 f4 01 	sts	0x01F4, r1
     89a:	10 92 f3 01 	sts	0x01F3, r1
		g_cmd_decode = 1;
     89e:	81 e0       	ldi	r24, 0x01	; 1
     8a0:	80 93 e7 01 	sts	0x01E7, r24
     8a4:	ff 91       	pop	r31
     8a6:	ef 91       	pop	r30
     8a8:	9f 91       	pop	r25
     8aa:	8f 91       	pop	r24
     8ac:	2f 91       	pop	r18
     8ae:	0f 90       	pop	r0
     8b0:	0f be       	out	0x3f, r0	; 63
     8b2:	0f 90       	pop	r0
     8b4:	1f 90       	pop	r1
     8b6:	18 95       	reti

000008b8 <__vector_14>:
   }
}

  

/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/

SIGNAL(SIG_UART_DATA)
{ 
     8b8:	1f 92       	push	r1
     8ba:	0f 92       	push	r0
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	0f 92       	push	r0
     8c0:	11 24       	eor	r1, r1
     8c2:	2f 93       	push	r18
     8c4:	3f 93       	push	r19
     8c6:	4f 93       	push	r20
     8c8:	5f 93       	push	r21
     8ca:	6f 93       	push	r22
     8cc:	7f 93       	push	r23
     8ce:	8f 93       	push	r24
     8d0:	9f 93       	push	r25
     8d2:	af 93       	push	r26
     8d4:	bf 93       	push	r27
     8d6:	ef 93       	push	r30
     8d8:	ff 93       	push	r31
    uint8_t  ch;
	if ((ch = uart_get_TX()))
     8da:	0e 94 aa 06 	call	0xd54
     8de:	88 23       	and	r24, r24
     8e0:	11 f0       	breq	.+4      	; 0x8e6
	{
 		UDR = ch;
     8e2:	8c b9       	out	0x0c, r24	; 12
     8e4:	01 c0       	rjmp	.+2      	; 0x8e8
	}	
	else 
// No character disable  interrupt to avoid repetable call Enable again when
//	send character in putc procedure
	{
	    UCSRB &=  ~(1<<UDRIE);
     8e6:	55 98       	cbi	0x0a, 5	; 10
     8e8:	ff 91       	pop	r31
     8ea:	ef 91       	pop	r30
     8ec:	bf 91       	pop	r27
     8ee:	af 91       	pop	r26
     8f0:	9f 91       	pop	r25
     8f2:	8f 91       	pop	r24
     8f4:	7f 91       	pop	r23
     8f6:	6f 91       	pop	r22
     8f8:	5f 91       	pop	r21
     8fa:	4f 91       	pop	r20
     8fc:	3f 91       	pop	r19
     8fe:	2f 91       	pop	r18
     900:	0f 90       	pop	r0
     902:	0f be       	out	0x3f, r0	; 63
     904:	0f 90       	pop	r0
     906:	1f 90       	pop	r1
     908:	18 95       	reti

0000090a <__vector_6>:
	}
	
}

 
 
/* Interrupt handle for Input Capture
This routine will detect/ process the Sony IR remote command. Protocol using Sony remote control
INPUT   :  Infrared signal from  ICP pin
		   Command table 
		  

OUTPUT 	: g_num  Number of message to display
		: g_control.display_mode   Display mode of message
		: g_start_bit
		

*/
SIGNAL(SIG_INPUT_CAPTURE1)
{
     90a:	1f 92       	push	r1
     90c:	0f 92       	push	r0
     90e:	0f b6       	in	r0, 0x3f	; 63
     910:	0f 92       	push	r0
     912:	11 24       	eor	r1, r1
     914:	2f 93       	push	r18
     916:	3f 93       	push	r19
     918:	4f 93       	push	r20
     91a:	5f 93       	push	r21
     91c:	6f 93       	push	r22
     91e:	7f 93       	push	r23
     920:	8f 93       	push	r24
     922:	9f 93       	push	r25
     924:	af 93       	push	r26
     926:	bf 93       	push	r27
     928:	ef 93       	push	r30
     92a:	ff 93       	push	r31
	uint16_t  ir_code;
    ir_code = ICR1;
     92c:	26 b5       	in	r18, 0x26	; 38
     92e:	37 b5       	in	r19, 0x27	; 39
	cli(); 
     930:	f8 94       	cli

    TCCR1B  |= _BV(ICES1);	     // Rising edge
     932:	8e b5       	in	r24, 0x2e	; 46
     934:	80 64       	ori	r24, 0x40	; 64
     936:	8e bd       	out	0x2e, r24	; 46
 	ir_code  = sony_ir_decode(ir_code);  
     938:	c9 01       	movw	r24, r18
     93a:	0e 94 0e 06 	call	0xc1c
 	if (ir_code)
     93e:	00 97       	sbiw	r24, 0x00	; 0
     940:	29 f0       	breq	.+10     	; 0x94c
	{       //End code dispatch command    
 
		remote_decode (ir_code);
     942:	0e 94 ee 02 	call	0x5dc
// Return to falling edge for Start		
		TCCR1B  &= ~(_BV(ICES1));
     946:	8e b5       	in	r24, 0x2e	; 46
     948:	8f 7b       	andi	r24, 0xBF	; 191
     94a:	8e bd       	out	0x2e, r24	; 46
		

//Note if  SELFTEST is selected g_irint = 0;
	} 
    sei();
     94c:	78 94       	sei
     94e:	ff 91       	pop	r31
     950:	ef 91       	pop	r30
     952:	bf 91       	pop	r27
     954:	af 91       	pop	r26
     956:	9f 91       	pop	r25
     958:	8f 91       	pop	r24
     95a:	7f 91       	pop	r23
     95c:	6f 91       	pop	r22
     95e:	5f 91       	pop	r21
     960:	4f 91       	pop	r20
     962:	3f 91       	pop	r19
     964:	2f 91       	pop	r18
     966:	0f 90       	pop	r0
     968:	0f be       	out	0x3f, r0	; 63
     96a:	0f 90       	pop	r0
     96c:	1f 90       	pop	r1
     96e:	18 95       	reti

00000970 <init_board>:
 
}


void init_board()
{
    uint8_t i;
	d7segment_init();
     970:	0e 94 bc 05 	call	0xb78
	init_ir();
     974:	0e 94 05 06 	call	0xc0a
	init_motor();
     978:	0e 94 c6 05 	call	0xb8c
	uart_init(); 
     97c:	0e 94 50 06 	call	0xca0
    adc_init(3);   // 2.56 BG as reference 
     980:	83 e0       	ldi	r24, 0x03	; 3
     982:	0e 94 2d 07 	call	0xe5a
	
	g_cmd_decode = 0; 
     986:	10 92 e7 01 	sts	0x01E7, r1
	g_motor= 0;
     98a:	10 92 06 02 	sts	0x0206, r1
	g_program_index =0;
     98e:	10 92 e5 01 	sts	0x01E5, r1
     992:	10 92 e4 01 	sts	0x01E4, r1
     996:	91 e0       	ldi	r25, 0x01	; 1
     998:	21 e0       	ldi	r18, 0x01	; 1
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	40 e0       	ldi	r20, 0x00	; 0
     99e:	50 e0       	ldi	r21, 0x00	; 0
     9a0:	ae ef       	ldi	r26, 0xFE	; 254
     9a2:	b1 e0       	ldi	r27, 0x01	; 1
     9a4:	e1 e0       	ldi	r30, 0x01	; 1
     9a6:	f3 e0       	ldi	r31, 0x03	; 3
     9a8:	89 2f       	mov	r24, r25
	
	for ( i = 0 ; i< MOTOR_MAX ;i++)
	{
		g_speed[i] = 1;
     9aa:	91 93       	st	Z+, r25
		g_angle[i] = 1;
     9ac:	2d 93       	st	X+, r18
     9ae:	3d 93       	st	X+, r19
     9b0:	4d 93       	st	X+, r20
     9b2:	5d 93       	st	X+, r21
     9b4:	81 50       	subi	r24, 0x01	; 1
     9b6:	87 ff       	sbrs	r24, 7
     9b8:	f8 cf       	rjmp	.-16     	; 0x9aa
 	} 
	sei();
     9ba:	78 94       	sei
     9bc:	08 95       	ret

000009be <main>:
 
}

     





void main()
{
     9be:	cc e5       	ldi	r28, 0x5C	; 92
     9c0:	d8 e0       	ldi	r29, 0x08	; 8
     9c2:	de bf       	out	0x3e, r29	; 62
     9c4:	cd bf       	out	0x3d, r28	; 61
  uint8_t sw1,sw2,i;
   uint16_t k;
   int16_t backemf;
  int8_t d1,d2;
  uint8_t show[3] = {0,'f','b'};
     9c6:	6e 01       	movw	r12, r28
     9c8:	08 94       	sec
     9ca:	c1 1c       	adc	r12, r1
     9cc:	d1 1c       	adc	r13, r1
     9ce:	83 e0       	ldi	r24, 0x03	; 3
     9d0:	e1 ee       	ldi	r30, 0xE1	; 225
     9d2:	f1 e0       	ldi	r31, 0x01	; 1
     9d4:	d6 01       	movw	r26, r12
     9d6:	01 90       	ld	r0, Z+
     9d8:	0d 92       	st	X+, r0
     9da:	8a 95       	dec	r24
     9dc:	e1 f7       	brne	.-8      	; 0x9d6
   init_board();
     9de:	0e 94 b8 04 	call	0x970
  d1 = 0;
     9e2:	ff 24       	eor	r15, r15
  d2 = 0;
     9e4:	ef 2c       	mov	r14, r15
  backemf =0;
  while (1)
  {
   sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
     9e6:	80 b3       	in	r24, 0x10	; 16
   
   if (!sw1) // SW1  Press
     9e8:	98 2f       	mov	r25, r24
     9ea:	98 70       	andi	r25, 0x08	; 8
     9ec:	83 fd       	sbrc	r24, 3
     9ee:	1d c0       	rjmp	.+58     	; 0xa2a
    {   	
		d1++;
     9f0:	e3 94       	inc	r14
	     if (d1 > MOTOR_BACKWARD)
     9f2:	b2 e0       	ldi	r27, 0x02	; 2
     9f4:	be 15       	cp	r27, r14
     9f6:	0c f4       	brge	.+2      	; 0x9fa
			d1 = MOTOR_STOP;
     9f8:	e9 2e       	mov	r14, r25
     9fa:	03 ef       	ldi	r16, 0xF3	; 243
     9fc:	11 e0       	ldi	r17, 0x01	; 1
		for (k = 0; k < 500 ;k++)                         // Delay for key bounce
				delay(6000);						
     9fe:	80 e7       	ldi	r24, 0x70	; 112
     a00:	97 e1       	ldi	r25, 0x17	; 23
     a02:	0e 94 69 00 	call	0xd2
     a06:	01 50       	subi	r16, 0x01	; 1
     a08:	10 40       	sbci	r17, 0x00	; 0
     a0a:	17 ff       	sbrs	r17, 7
     a0c:	f8 cf       	rjmp	.-16     	; 0x9fe
		g_mode[0] = d1;
     a0e:	e0 92 f0 01 	sts	0x01F0, r14
		g_angle[0] = 1;    // Continuous move
     a12:	81 e0       	ldi	r24, 0x01	; 1
     a14:	90 e0       	ldi	r25, 0x00	; 0
     a16:	a0 e0       	ldi	r26, 0x00	; 0
     a18:	b0 e0       	ldi	r27, 0x00	; 0
     a1a:	80 93 fe 01 	sts	0x01FE, r24
     a1e:	90 93 ff 01 	sts	0x01FF, r25
     a22:	a0 93 00 02 	sts	0x0200, r26
     a26:	b0 93 01 02 	sts	0x0201, r27

	}
   
   sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
     a2a:	83 b3       	in	r24, 0x13	; 19
   if (!sw2) // SW2 Press
     a2c:	98 2f       	mov	r25, r24
     a2e:	94 70       	andi	r25, 0x04	; 4
     a30:	82 fd       	sbrc	r24, 2
     a32:	1d c0       	rjmp	.+58     	; 0xa6e
   {
        d2++;
     a34:	f3 94       	inc	r15
		if (d2 > MOTOR_BACKWARD)
     a36:	82 e0       	ldi	r24, 0x02	; 2
     a38:	8f 15       	cp	r24, r15
     a3a:	0c f4       	brge	.+2      	; 0xa3e
			d2 = MOTOR_STOP;
     a3c:	f9 2e       	mov	r15, r25
     a3e:	03 ef       	ldi	r16, 0xF3	; 243
     a40:	11 e0       	ldi	r17, 0x01	; 1
 		for (k = 0; k < 500 ;k++)                         // Delay for key bounce		
 				delay(6000);
     a42:	80 e7       	ldi	r24, 0x70	; 112
     a44:	97 e1       	ldi	r25, 0x17	; 23
     a46:	0e 94 69 00 	call	0xd2
     a4a:	01 50       	subi	r16, 0x01	; 1
     a4c:	10 40       	sbci	r17, 0x00	; 0
     a4e:	17 ff       	sbrs	r17, 7
     a50:	f8 cf       	rjmp	.-16     	; 0xa42
		g_mode[1] = d2;
     a52:	f0 92 f1 01 	sts	0x01F1, r15
		g_angle[1] = 1;    // Continuous move	
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	90 e0       	ldi	r25, 0x00	; 0
     a5a:	a0 e0       	ldi	r26, 0x00	; 0
     a5c:	b0 e0       	ldi	r27, 0x00	; 0
     a5e:	80 93 02 02 	sts	0x0202, r24
     a62:	90 93 03 02 	sts	0x0203, r25
     a66:	a0 93 04 02 	sts	0x0204, r26
     a6a:	b0 93 05 02 	sts	0x0205, r27
   }

// Command decode
    if ( g_cmd_decode)
     a6e:	80 91 e7 01 	lds	r24, 0x01E7
     a72:	88 23       	and	r24, r24
     a74:	a1 f0       	breq	.+40     	; 0xa9e
	{
// Decode command	
   	    cmd_decode (g_rcv_buff);
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	92 e0       	ldi	r25, 0x02	; 2
     a7a:	0e 94 bc 00 	call	0x178
		g_cmd_decode = 0; 
     a7e:	10 92 e7 01 	sts	0x01E7, r1
		g_pos[g_motor] = 0;
     a82:	80 91 06 02 	lds	r24, 0x0206
     a86:	e8 2f       	mov	r30, r24
     a88:	ff 27       	eor	r31, r31
     a8a:	ee 0f       	add	r30, r30
     a8c:	ff 1f       	adc	r31, r31
     a8e:	ee 0f       	add	r30, r30
     a90:	ff 1f       	adc	r31, r31
     a92:	e8 51       	subi	r30, 0x18	; 24
     a94:	fe 4f       	sbci	r31, 0xFE	; 254
     a96:	10 82       	st	Z, r1
     a98:	11 82       	std	Z+1, r1	; 0x01
     a9a:	12 82       	std	Z+2, r1	; 0x02
     a9c:	13 82       	std	Z+3, r1	; 0x03
	}
	
 	
    for (i = 0 ; i < MOTOR_MAX ; i++)
     a9e:	e0 e0       	ldi	r30, 0x00	; 0
	{
// 7 Segments display	
		d7segment_display(show[g_mode[i]],i+1);
     aa0:	1e 2f       	mov	r17, r30
     aa2:	1f 5f       	subi	r17, 0xFF	; 255
     aa4:	ff 27       	eor	r31, r31
     aa6:	e0 51       	subi	r30, 0x10	; 16
     aa8:	fe 4f       	sbci	r31, 0xFE	; 254
     aaa:	80 81       	ld	r24, Z
     aac:	f6 01       	movw	r30, r12
     aae:	e8 0f       	add	r30, r24
     ab0:	f1 1d       	adc	r31, r1
     ab2:	61 2f       	mov	r22, r17
     ab4:	80 81       	ld	r24, Z
     ab6:	0e 94 65 05 	call	0xaca
        delay(500);
     aba:	84 ef       	ldi	r24, 0xF4	; 244
     abc:	91 e0       	ldi	r25, 0x01	; 1
     abe:	0e 94 69 00 	call	0xd2
     ac2:	e1 2f       	mov	r30, r17
     ac4:	12 30       	cpi	r17, 0x02	; 2
     ac6:	60 f3       	brcs	.-40     	; 0xaa0
     ac8:	8e cf       	rjmp	.-228    	; 0x9e6

00000aca <d7segment_display>:
#include "Dual_7Segment.h"

void d7segment_display( int8_t num, uint8_t digit)
{
 switch (num)
     aca:	99 27       	eor	r25, r25
     acc:	87 fd       	sbrc	r24, 7
     ace:	90 95       	com	r25
     ad0:	86 30       	cpi	r24, 0x06	; 6
     ad2:	91 05       	cpc	r25, r1
     ad4:	09 f4       	brne	.+2      	; 0xad8
     ad6:	41 c0       	rjmp	.+130    	; 0xb5a
     ad8:	87 30       	cpi	r24, 0x07	; 7
     ada:	91 05       	cpc	r25, r1
     adc:	8c f4       	brge	.+34     	; 0xb00
     ade:	82 30       	cpi	r24, 0x02	; 2
     ae0:	91 05       	cpc	r25, r1
     ae2:	59 f1       	breq	.+86     	; 0xb3a
     ae4:	83 30       	cpi	r24, 0x03	; 3
     ae6:	91 05       	cpc	r25, r1
     ae8:	2c f4       	brge	.+10     	; 0xaf4
     aea:	00 97       	sbiw	r24, 0x00	; 0
     aec:	11 f1       	breq	.+68     	; 0xb32
     aee:	01 97       	sbiw	r24, 0x01	; 1
     af0:	11 f1       	breq	.+68     	; 0xb36
     af2:	37 c0       	rjmp	.+110    	; 0xb62
     af4:	84 30       	cpi	r24, 0x04	; 4
     af6:	91 05       	cpc	r25, r1
     af8:	21 f1       	breq	.+72     	; 0xb42
     afa:	05 97       	sbiw	r24, 0x05	; 5
     afc:	24 f5       	brge	.+72     	; 0xb46
     afe:	1f c0       	rjmp	.+62     	; 0xb3e
     b00:	89 30       	cpi	r24, 0x09	; 9
     b02:	91 05       	cpc	r25, r1
     b04:	31 f1       	breq	.+76     	; 0xb52
     b06:	8a 30       	cpi	r24, 0x0A	; 10
     b08:	91 05       	cpc	r25, r1
     b0a:	34 f4       	brge	.+12     	; 0xb18
     b0c:	87 30       	cpi	r24, 0x07	; 7
     b0e:	91 05       	cpc	r25, r1
     b10:	e1 f0       	breq	.+56     	; 0xb4a
     b12:	08 97       	sbiw	r24, 0x08	; 8
     b14:	e1 f0       	breq	.+56     	; 0xb4e
     b16:	25 c0       	rjmp	.+74     	; 0xb62
     b18:	82 36       	cpi	r24, 0x62	; 98
     b1a:	91 05       	cpc	r25, r1
     b1c:	f1 f0       	breq	.+60     	; 0xb5a
     b1e:	83 36       	cpi	r24, 0x63	; 99
     b20:	91 05       	cpc	r25, r1
     b22:	1c f4       	brge	.+6      	; 0xb2a
     b24:	0a 97       	sbiw	r24, 0x0a	; 10
     b26:	d9 f0       	breq	.+54     	; 0xb5e
     b28:	1c c0       	rjmp	.+56     	; 0xb62
     b2a:	86 36       	cpi	r24, 0x66	; 102
     b2c:	91 05       	cpc	r25, r1
     b2e:	99 f0       	breq	.+38     	; 0xb56
     b30:	18 c0       	rjmp	.+48     	; 0xb62
 {
	case 0:
		_7SEGMENT_PORT = _7SEGMENT_0;
     b32:	8f e3       	ldi	r24, 0x3F	; 63
     b34:	15 c0       	rjmp	.+42     	; 0xb60
		break;
	case 1:
		_7SEGMENT_PORT = _7SEGMENT_1;
     b36:	86 e0       	ldi	r24, 0x06	; 6
     b38:	13 c0       	rjmp	.+38     	; 0xb60
		break;
	case 2:
		_7SEGMENT_PORT = _7SEGMENT_2;
     b3a:	8b e5       	ldi	r24, 0x5B	; 91
     b3c:	11 c0       	rjmp	.+34     	; 0xb60
		break;
	case 3:
		_7SEGMENT_PORT = _7SEGMENT_3;
     b3e:	8f e4       	ldi	r24, 0x4F	; 79
     b40:	0f c0       	rjmp	.+30     	; 0xb60
		break;
	case 4:
		_7SEGMENT_PORT = _7SEGMENT_4;
     b42:	86 e6       	ldi	r24, 0x66	; 102
     b44:	0d c0       	rjmp	.+26     	; 0xb60
		break;
	case 5:
		_7SEGMENT_PORT = _7SEGMENT_5;
     b46:	8d e6       	ldi	r24, 0x6D	; 109
     b48:	0b c0       	rjmp	.+22     	; 0xb60
		break;
	case 6:
		_7SEGMENT_PORT = _7SEGMENT_6;
		break;
	case 7:
		_7SEGMENT_PORT = _7SEGMENT_7;
     b4a:	87 e0       	ldi	r24, 0x07	; 7
     b4c:	09 c0       	rjmp	.+18     	; 0xb60
		break;
	case 8:
		_7SEGMENT_PORT = _7SEGMENT_8;
     b4e:	8f e7       	ldi	r24, 0x7F	; 127
     b50:	07 c0       	rjmp	.+14     	; 0xb60
		break;
	case 9:
		_7SEGMENT_PORT = _7SEGMENT_9;
     b52:	87 e6       	ldi	r24, 0x67	; 103
     b54:	05 c0       	rjmp	.+10     	; 0xb60
	    break;
	case 'f':
	    _7SEGMENT_PORT = _7SEGMENT_C_F;
     b56:	81 e7       	ldi	r24, 0x71	; 113
     b58:	03 c0       	rjmp	.+6      	; 0xb60
		break;
	case 'b':
	    _7SEGMENT_PORT = _7SEGMENT_C_B;
     b5a:	8c e7       	ldi	r24, 0x7C	; 124
     b5c:	01 c0       	rjmp	.+2      	; 0xb60
		break;
	case DOT:
		_7SEGMENT_PORT = _7SEGMENT_DOT;
     b5e:	80 e8       	ldi	r24, 0x80	; 128
     b60:	88 bb       	out	0x18, r24	; 24
		break;
 
 }
// Out digit
	 
    if ( digit == 1 )
     b62:	61 30       	cpi	r22, 0x01	; 1
     b64:	19 f4       	brne	.+6      	; 0xb6c
	{  // ON Digit 1 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT1);
     b66:	ab 98       	cbi	0x15, 3	; 21
	   // OFF Digit 2 
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT2;
     b68:	ac 9a       	sbi	0x15, 4	; 21
     b6a:	08 95       	ret
	}
	if ( digit == 2 )
     b6c:	62 30       	cpi	r22, 0x02	; 2
     b6e:	11 f4       	brne	.+4      	; 0xb74
	{  // ON Digit 2 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT2);
     b70:	ac 98       	cbi	0x15, 4	; 21
	   // OFF Digit 1
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT1;
     b72:	ab 9a       	sbi	0x15, 3	; 21
     b74:	08 95       	ret
     b76:	08 95       	ret

00000b78 <d7segment_init>:
	}	

}	


/* Initial 7 Segments. Set port to output before use 
*/
void d7segment_init (void)
{
// Set direction for output for 7 Segment
	_7SEGMENT_DIGIT_DIR   = 0xFF;
     b78:	8f ef       	ldi	r24, 0xFF	; 255
     b7a:	87 bb       	out	0x17, r24	; 23
	_7SEGMENT_PORT_DIR	  |= _7SEGMENT_DIGIT1 | _7SEGMENT_DIGIT2;
     b7c:	84 b3       	in	r24, 0x14	; 20
     b7e:	88 61       	ori	r24, 0x18	; 24
     b80:	84 bb       	out	0x14, r24	; 20
 
// Set direction for input for SW 
	_7SEGMENT_SW1_DIR	&=  ~(_7SEGMENT_SW1);
     b82:	8b 98       	cbi	0x11, 3	; 17
	_7SEGMENT_SW2_DIR	&=  ~(_7SEGMENT_SW2);
     b84:	a2 98       	cbi	0x14, 2	; 20

// Enable pull up
    _7SEGMENT_SW1_PORT   |= _7SEGMENT_SW1;
     b86:	93 9a       	sbi	0x12, 3	; 18
    _7SEGMENT_SW2_PORT   |= _7SEGMENT_SW2;
     b88:	aa 9a       	sbi	0x15, 2	; 21
     b8a:	08 95       	ret

00000b8c <init_motor>:
 

//   TIMER0
//     TCCR0  |= _BV(WGM00) |_BV(WGM01) | _BV(CS01) | _BV(CS00)  ;   // Clk/64 Fast Pwm
    TCCR0  |= _BV(WGM00) |_BV(WGM01) | _BV(CS02)    ;   // Clk/256 Pwm
     b8c:	83 b7       	in	r24, 0x33	; 51
     b8e:	8c 64       	ori	r24, 0x4C	; 76
     b90:	83 bf       	out	0x33, r24	; 51
    OCR0    = 0x80;
     b92:	90 e8       	ldi	r25, 0x80	; 128
     b94:	9c bf       	out	0x3c, r25	; 60
	
	
//   TIMER2
//     TCCR2  |= _BV(WGM20) | _BV(CS22) ;   // Clk/64 Pwm
     TCCR2  |= _BV(WGM20) |_BV(WGM21) | _BV(CS22) | _BV(CS21) ;   // Clk/256 Pwm
     b96:	85 b5       	in	r24, 0x25	; 37
     b98:	8e 64       	ori	r24, 0x4E	; 78
     b9a:	85 bd       	out	0x25, r24	; 37
      OCR2   = 0x80;
     b9c:	93 bd       	out	0x23, r25	; 35
	
	
	
// Enable Interrupt 	Watch out nest interrupt 
	TIMSK  |=  _BV(OCIE0) | _BV(TOIE0) | _BV(OCIE2) | _BV(TOIE2);	
     b9e:	89 b7       	in	r24, 0x39	; 57
     ba0:	83 6c       	ori	r24, 0xC3	; 195
     ba2:	89 bf       	out	0x39, r24	; 57
 
    MOTOR_DIRECTION_DIR  |= 	MOTORA_1 | MOTORA_2 | MOTORB_1 | MOTORB_2;
     ba4:	8a b3       	in	r24, 0x1a	; 26
     ba6:	80 6f       	ori	r24, 0xF0	; 240
     ba8:	8a bb       	out	0x1a, r24	; 26
	MOTOR_ENABLE12_DIR	 |= 	MOTOR_ENABLE12;
     baa:	8d 9a       	sbi	0x11, 5	; 17
	MOTOR_ENABLE34_DIR	 |=  	MOTOR_ENABLE34;		
     bac:	8c 9a       	sbi	0x11, 4	; 17
     bae:	08 95       	ret

00000bb0 <motor_control>:
}


// speed from 1 - 10

void  motor_control (uint8_t port, uint8_t direction) 
{
     bb0:	38 2f       	mov	r19, r24
     bb2:	86 2f       	mov	r24, r22
  
   uint8_t  controlA,controlB;
   
   switch (direction)
     bb4:	99 27       	eor	r25, r25
     bb6:	81 30       	cpi	r24, 0x01	; 1
     bb8:	91 05       	cpc	r25, r1
     bba:	31 f0       	breq	.+12     	; 0xbc8
     bbc:	82 30       	cpi	r24, 0x02	; 2
     bbe:	91 05       	cpc	r25, r1
     bc0:	4c f0       	brlt	.+18     	; 0xbd4
     bc2:	02 97       	sbiw	r24, 0x02	; 2
     bc4:	21 f0       	breq	.+8      	; 0xbce
     bc6:	06 c0       	rjmp	.+12     	; 0xbd4
   {
     case MOTOR_FORWARD:
	    controlA = 0;
     bc8:	20 e0       	ldi	r18, 0x00	; 0
		controlB = 0xFF;
     bca:	9f ef       	ldi	r25, 0xFF	; 255
		break;
     bcc:	05 c0       	rjmp	.+10     	; 0xbd8
	 case MOTOR_BACKWARD:
        controlA = 0xFF;
     bce:	2f ef       	ldi	r18, 0xFF	; 255
		controlB = 0;
     bd0:	90 e0       	ldi	r25, 0x00	; 0
		break;
     bd2:	02 c0       	rjmp	.+4      	; 0xbd8
	 case MOTOR_STOP:
	    controlA = 0;
		controlB = 0;
		break;
	default:
	    controlA = 0;
     bd4:	90 e0       	ldi	r25, 0x00	; 0
		controlB = 0;
     bd6:	29 2f       	mov	r18, r25
   }
 if (port == 1)
     bd8:	31 30       	cpi	r19, 0x01	; 1
     bda:	51 f4       	brne	.+20     	; 0xbf0
   {
//       MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORA_1 | MOTORA_2); 
     bdc:	8b b3       	in	r24, 0x1b	; 27
     bde:	8f 7c       	andi	r24, 0xCF	; 207
     be0:	8b bb       	out	0x1b, r24	; 27
	  MOTOR_DIRECTION_CONTROL |= ((MOTORA_1 & controlA ) | (MOTORA_2 & controlB));
     be2:	20 71       	andi	r18, 0x10	; 16
     be4:	90 72       	andi	r25, 0x20	; 32
     be6:	29 2b       	or	r18, r25
     be8:	8b b3       	in	r24, 0x1b	; 27
     bea:	82 2b       	or	r24, r18
     bec:	8b bb       	out	0x1b, r24	; 27
     bee:	08 95       	ret
  }
  if (port == 2)
     bf0:	32 30       	cpi	r19, 0x02	; 2
     bf2:	49 f4       	brne	.+18     	; 0xc06
   {
//  	  MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORB_1 | MOTORB_2); 
     bf4:	8b b3       	in	r24, 0x1b	; 27
     bf6:	8f 73       	andi	r24, 0x3F	; 63
     bf8:	8b bb       	out	0x1b, r24	; 27
  	  MOTOR_DIRECTION_CONTROL |= ((MOTORB_1 & controlA ) | (MOTORB_2 & controlB));
     bfa:	20 74       	andi	r18, 0x40	; 64
     bfc:	90 78       	andi	r25, 0x80	; 128
     bfe:	29 2b       	or	r18, r25
     c00:	8b b3       	in	r24, 0x1b	; 27
     c02:	82 2b       	or	r24, r18
     c04:	8b bb       	out	0x1b, r24	; 27
     c06:	08 95       	ret
     c08:	08 95       	ret

00000c0a <init_ir>:

void init_ir()
{
 //Set Direction
    IR_DDR_PORT &= ~IR_ICP; 
     c0a:	8e 98       	cbi	0x11, 6	; 17
	
	TCCR1B  |= ( _BV(ICNC1) | _BV(CS12) | _BV(CS10));			// Time 1 input to clock/1024 input capture on falling edge  noise cancel
     c0c:	8e b5       	in	r24, 0x2e	; 46
     c0e:	85 68       	ori	r24, 0x85	; 133
     c10:	8e bd       	out	0x2e, r24	; 46
	TIMSK   |= _BV(TICIE1);   								// Enable input capture enable 
     c12:	89 b7       	in	r24, 0x39	; 57
     c14:	80 62       	ori	r24, 0x20	; 32
     c16:	89 bf       	out	0x39, r24	; 57
	sei();
     c18:	78 94       	sei
     c1a:	08 95       	ret

00000c1c <sony_ir_decode>:
}
/*  Decode for Sony remote TV IR 
			Input  Input capturn counter 16 bit register
		   Output  0  = no code detect
				   ir_decode  = detect IR code 
				   
	Algorithm
		Calculate pulse width by substract ICP counter. from pulse width 
		can determine whether it is  START BIT 		 =  XX
									  BIT1 			 =  XX
		until 12 bits then return ir code							  
									 
*/

uint16_t sony_ir_decode ( uint16_t capture_counter)
{
     c1c:	bc 01       	movw	r22, r24
  static 	uint16_t  	prev_capture_counter = 0;
  static 	uint8_t   	stop_bit = 0;
  static	uint16_t	ir_code = 0;
 			uint16_t	width  = 0;	  

      if ( capture_counter > prev_capture_counter)
     c1e:	80 91 f5 01 	lds	r24, 0x01F5
     c22:	90 91 f6 01 	lds	r25, 0x01F6
     c26:	9b 01       	movw	r18, r22
     c28:	28 1b       	sub	r18, r24
     c2a:	39 0b       	sbc	r19, r25
			width = capture_counter - prev_capture_counter;
	  else
			width = capture_counter+(MAX_INT16 - prev_capture_counter);
//Check for start bit
     if ( width > IR_TV_PULSE_WIDTH)
     c2c:	2a 30       	cpi	r18, 0x0A	; 10
     c2e:	31 05       	cpc	r19, r1
     c30:	20 f1       	brcs	.+72     	; 0xc7a
	 {
		  if (width > IR_TV_START_BIT)  			//  Found Start bit 
     c32:	26 32       	cpi	r18, 0x26	; 38
     c34:	31 05       	cpc	r19, r1
     c36:	58 f0       	brcs	.+22     	; 0xc4e
			    {
				  stop_bit = 0;
     c38:	10 92 f7 01 	sts	0x01F7, r1
				  prev_capture_counter = 0;
     c3c:	10 92 f6 01 	sts	0x01F6, r1
     c40:	10 92 f5 01 	sts	0x01F5, r1
				  ir_code = 0;     			// New code
     c44:	10 92 f9 01 	sts	0x01F9, r1
     c48:	10 92 f8 01 	sts	0x01F8, r1
     c4c:	16 c0       	rjmp	.+44     	; 0xc7a
     c4e:	80 91 f8 01 	lds	r24, 0x01F8
     c52:	90 91 f9 01 	lds	r25, 0x01F9
     c56:	40 91 f7 01 	lds	r20, 0x01F7
				}
		  else if (width > IR_TV_BIT1)	  		// bit 1 (3T)
     c5a:	2a 31       	cpi	r18, 0x1A	; 26
     c5c:	31 05       	cpc	r19, r1
     c5e:	20 f0       	brcs	.+8      	; 0xc68
				{
				   ir_code <<= 1;    			//Shift right
     c60:	88 0f       	add	r24, r24
     c62:	99 1f       	adc	r25, r25
				   ir_code  |= 1;    			// Or 1
     c64:	81 60       	ori	r24, 0x01	; 1
     c66:	02 c0       	rjmp	.+4      	; 0xc6c
				    stop_bit++;
				}
		        else 	  // bit 0
				{
					ir_code  <<=  1;  //Shift right
     c68:	88 0f       	add	r24, r24
     c6a:	99 1f       	adc	r25, r25
     c6c:	90 93 f9 01 	sts	0x01F9, r25
     c70:	80 93 f8 01 	sts	0x01F8, r24
					stop_bit++;
     c74:	4f 5f       	subi	r20, 0xFF	; 255
     c76:	40 93 f7 01 	sts	0x01F7, r20
				}
	}
	prev_capture_counter = capture_counter;
     c7a:	70 93 f6 01 	sts	0x01F6, r23
     c7e:	60 93 f5 01 	sts	0x01F5, r22
	if (stop_bit == IR_TV_STOP_BIT)
     c82:	80 91 f7 01 	lds	r24, 0x01F7
     c86:	8c 30       	cpi	r24, 0x0C	; 12
     c88:	39 f4       	brne	.+14     	; 0xc98
	{       //End code dispatch command
  	    stop_bit = 0;
     c8a:	10 92 f7 01 	sts	0x01F7, r1

		return ir_code;
     c8e:	80 91 f8 01 	lds	r24, 0x01F8
     c92:	90 91 f9 01 	lds	r25, 0x01F9
     c96:	08 95       	ret
			
//Note if  SELFTEST is selected g_irint = 0;
	}   
	else
		return 0;		// No code detect yet
     c98:	80 e0       	ldi	r24, 0x00	; 0
     c9a:	90 e0       	ldi	r25, 0x00	; 0
}
     c9c:	08 95       	ret
     c9e:	08 95       	ret

00000ca0 <uart_init>:
{
 
// Initialize UART  
    
    UCSRC  = 0x86;    // 8 bit non parity  1 stop bit
     ca0:	86 e8       	ldi	r24, 0x86	; 134
     ca2:	80 bd       	out	0x20, r24	; 32
     UCSRB  = 0x98;    // Enable RX Interrupt and Enable TX, RX pin
     ca4:	88 e9       	ldi	r24, 0x98	; 152
     ca6:	8a b9       	out	0x0a, r24	; 10
//    UCSRB  = 0B8;    // Enable RX Interrupt, Data registerempty interrupt enable and Enable TX, RX pin 1011-1000
	UBRRL  = 0x67;    // Speed 9600 UBRR = 103 at 16 MHZ
     ca8:	87 e6       	ldi	r24, 0x67	; 103
     caa:	89 b9       	out	0x09, r24	; 9
//	UBRRL  = 51;      // Speed = 19.2 K at 16 Mhz
	UBRRH  = 0;
     cac:	10 bc       	out	0x20, r1	; 32
//    DDRD = 0x00;	 
 
	g_rx_ptr = 0;
     cae:	10 92 fb 01 	sts	0x01FB, r1
	g_tx_ptr = 0;
     cb2:	10 92 fa 01 	sts	0x01FA, r1
     cb6:	08 95       	ret

00000cb8 <uart_put_RX>:
 /* Set baud rate */
 
}

/*
Put character into Rx buffer

Return  = Success 0
        = Fail   Buffer Full
		
*/
uint8_t uart_put_RX ( uint8_t ch)
{
     cb8:	98 2f       	mov	r25, r24
   if ((g_rx_ptr < MAX_BUFF)) 
     cba:	80 91 fb 01 	lds	r24, 0x01FB
     cbe:	8a 3f       	cpi	r24, 0xFA	; 250
     cc0:	80 f4       	brcc	.+32     	; 0xce2
   {
//  End with Null
		g_rx_buff[g_rx_ptr] = ch;
     cc2:	e8 2f       	mov	r30, r24
     cc4:	ff 27       	eor	r31, r31
     cc6:	ed 5f       	subi	r30, 0xFD	; 253
     cc8:	fc 4f       	sbci	r31, 0xFC	; 252
     cca:	90 83       	st	Z, r25
		g_rx_ptr++;
     ccc:	8f 5f       	subi	r24, 0xFF	; 255
     cce:	80 93 fb 01 	sts	0x01FB, r24
		g_rx_buff[g_rx_ptr] = 0;   // End with null characters
     cd2:	e8 2f       	mov	r30, r24
     cd4:	ff 27       	eor	r31, r31
     cd6:	ed 5f       	subi	r30, 0xFD	; 253
     cd8:	fc 4f       	sbci	r31, 0xFC	; 252
     cda:	10 82       	st	Z, r1
		return 0;
     cdc:	80 e0       	ldi	r24, 0x00	; 0
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	08 95       	ret
    }
   else  // Buffer full do nothing  return error
   {
        return UART_BUFFER_FULL;
     ce2:	82 e0       	ldi	r24, 0x02	; 2
     ce4:	90 e0       	ldi	r25, 0x00	; 0
   }
}
     ce6:	08 95       	ret
     ce8:	08 95       	ret

00000cea <uart_get_RX>:

// Get character from RX buffer

uint8_t uart_get_RX (void)
{
   uint8_t  i,j,ch;
   if (g_rx_ptr)
     cea:	80 91 fb 01 	lds	r24, 0x01FB
     cee:	88 23       	and	r24, r24
     cf0:	a1 f0       	breq	.+40     	; 0xd1a
   {
		ch = g_rx_buff[0];
     cf2:	90 91 03 03 	lds	r25, 0x0303
        i =  g_rx_ptr;
     cf6:	28 2f       	mov	r18, r24
        g_rx_ptr--;
     cf8:	21 50       	subi	r18, 0x01	; 1
     cfa:	20 93 fb 01 	sts	0x01FB, r18
     cfe:	2f 5f       	subi	r18, 0xFF	; 255
		j = 0;
     d00:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_rx_buff[j] =  g_rx_buff[j+1];
     d02:	e3 2f       	mov	r30, r19
     d04:	ff 27       	eor	r31, r31
     d06:	ed 5f       	subi	r30, 0xFD	; 253
     d08:	fc 4f       	sbci	r31, 0xFC	; 252
     d0a:	81 81       	ldd	r24, Z+1	; 0x01
     d0c:	80 83       	st	Z, r24
	      j++;
     d0e:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
     d10:	21 50       	subi	r18, 0x01	; 1
     d12:	b9 f7       	brne	.-18     	; 0xd02
		}
		return ch;
     d14:	89 2f       	mov	r24, r25
     d16:	99 27       	eor	r25, r25
     d18:	08 95       	ret
   }
   return 0;
     d1a:	80 e0       	ldi	r24, 0x00	; 0
     d1c:	90 e0       	ldi	r25, 0x00	; 0
}
     d1e:	08 95       	ret
     d20:	08 95       	ret

00000d22 <uart_put_TX>:

/* Put character into g_tx_buff
    INPUT  : Character to put in buffer
	Output : 0  OK
		   : UART_BUFFER_FULL  Buffer full
*/

uint8_t uart_put_TX ( uint8_t ch)
{
     d22:	98 2f       	mov	r25, r24
// If exceed buffer do nothing until buffer is flushed
    if ((g_tx_ptr > MAX_BUFF)) 
     d24:	80 91 fa 01 	lds	r24, 0x01FA
     d28:	8b 3f       	cpi	r24, 0xFB	; 251
     d2a:	18 f0       	brcs	.+6      	; 0xd32
    {
		return UART_BUFFER_FULL;   // No increase pointer
     d2c:	82 e0       	ldi	r24, 0x02	; 2
     d2e:	90 e0       	ldi	r25, 0x00	; 0
     d30:	08 95       	ret
    }
	g_tx_buff[g_tx_ptr]= ch;
     d32:	e8 2f       	mov	r30, r24
     d34:	ff 27       	eor	r31, r31
     d36:	e3 50       	subi	r30, 0x03	; 3
     d38:	fc 4f       	sbci	r31, 0xFC	; 252
     d3a:	90 83       	st	Z, r25
	g_tx_ptr++;
     d3c:	8f 5f       	subi	r24, 0xFF	; 255
     d3e:	80 93 fa 01 	sts	0x01FA, r24
	g_tx_buff[g_tx_ptr] = 0;    // Put null character at the end
     d42:	e8 2f       	mov	r30, r24
     d44:	ff 27       	eor	r31, r31
     d46:	e3 50       	subi	r30, 0x03	; 3
     d48:	fc 4f       	sbci	r31, 0xFC	; 252
     d4a:	10 82       	st	Z, r1
	return 0;
     d4c:	80 e0       	ldi	r24, 0x00	; 0
     d4e:	90 e0       	ldi	r25, 0x00	; 0
}
     d50:	08 95       	ret
     d52:	08 95       	ret

00000d54 <uart_get_TX>:


// Get character from TX buffer
uint8_t uart_get_TX (void)
{
   uint8_t i,j,ch =0;
   
   if ( g_tx_ptr)
     d54:	80 91 fa 01 	lds	r24, 0x01FA
     d58:	88 23       	and	r24, r24
     d5a:	a1 f0       	breq	.+40     	; 0xd84
   {
		i  =  g_tx_ptr;
     d5c:	28 2f       	mov	r18, r24
		g_tx_ptr--;
     d5e:	21 50       	subi	r18, 0x01	; 1
     d60:	20 93 fa 01 	sts	0x01FA, r18
     d64:	2f 5f       	subi	r18, 0xFF	; 255
		ch =  g_tx_buff[0];   // Start from 0 FIFO
     d66:	90 91 fd 03 	lds	r25, 0x03FD
		j = 0;
     d6a:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_tx_buff[j] =  g_tx_buff[j+1];
     d6c:	e3 2f       	mov	r30, r19
     d6e:	ff 27       	eor	r31, r31
     d70:	e3 50       	subi	r30, 0x03	; 3
     d72:	fc 4f       	sbci	r31, 0xFC	; 252
     d74:	81 81       	ldd	r24, Z+1	; 0x01
     d76:	80 83       	st	Z, r24
	      j++;
     d78:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
     d7a:	21 50       	subi	r18, 0x01	; 1
     d7c:	b9 f7       	brne	.-18     	; 0xd6c
		}
		return ch;
     d7e:	89 2f       	mov	r24, r25
     d80:	99 27       	eor	r25, r25
     d82:	08 95       	ret
   }
   return 0;
     d84:	80 e0       	ldi	r24, 0x00	; 0
     d86:	90 e0       	ldi	r25, 0x00	; 0
}
     d88:	08 95       	ret
     d8a:	08 95       	ret

00000d8c <uart_getc>:


uint8_t uart_getc(void)
{
    uint8_t ch;
	ch = uart_get_RX();
     d8c:	0e 94 75 06 	call	0xcea
    return ch ;
}
     d90:	99 27       	eor	r25, r25
     d92:	08 95       	ret

00000d94 <uart_putc>:

uint8_t uart_putc(uint8_t c)
{
  
  uart_put_TX(c);
     d94:	0e 94 91 06 	call	0xd22
// Enable interrupt UART Data Register empty
  UCSRB  |=  (1<<UDRIE);	
     d98:	55 9a       	sbi	0x0a, 5	; 10
//    while ( !(UCSRA & (1<< UDRE)));
//	UDR = c;
    return 0;

}
     d9a:	80 e0       	ldi	r24, 0x00	; 0
     d9c:	90 e0       	ldi	r25, 0x00	; 0
     d9e:	08 95       	ret

00000da0 <uart_puts>:


/*************************************************************************
Function: uart_puts()
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const uint8_t *s )
{
     da0:	cf 93       	push	r28
     da2:	df 93       	push	r29
     da4:	ec 01       	movw	r28, r24
    while (*s) 
      uart_putc(*s++);
     da6:	88 81       	ld	r24, Y
     da8:	88 23       	and	r24, r24
     daa:	21 f0       	breq	.+8      	; 0xdb4
     dac:	89 91       	ld	r24, Y+
     dae:	0e 94 ca 06 	call	0xd94
     db2:	f9 cf       	rjmp	.-14     	; 0xda6
   uart_putc(0x0D); // CR
     db4:	8d e0       	ldi	r24, 0x0D	; 13
     db6:	0e 94 ca 06 	call	0xd94
	uart_putc(0x0A); // LF
     dba:	8a e0       	ldi	r24, 0x0A	; 10
     dbc:	0e 94 ca 06 	call	0xd94
     dc0:	df 91       	pop	r29
     dc2:	cf 91       	pop	r28
     dc4:	08 95       	ret

00000dc6 <debug_value>:
}

/*
Show debug value
*/

void  debug_value ( int16_t value, uint8_t radix)
{
     dc6:	cf 93       	push	r28
     dc8:	df 93       	push	r29
     dca:	cd b7       	in	r28, 0x3d	; 61
     dcc:	de b7       	in	r29, 0x3e	; 62
     dce:	64 97       	sbiw	r28, 0x14	; 20
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	de bf       	out	0x3e, r29	; 62
     dd6:	0f be       	out	0x3f, r0	; 63
     dd8:	cd bf       	out	0x3d, r28	; 61
     dda:	26 2f       	mov	r18, r22
   uint8_t  buff[20];
   
   itoa (value,buff, radix);
     ddc:	33 27       	eor	r19, r19
     dde:	a9 01       	movw	r20, r18
     de0:	be 01       	movw	r22, r28
     de2:	6f 5f       	subi	r22, 0xFF	; 255
     de4:	7f 4f       	sbci	r23, 0xFF	; 255
     de6:	0e 94 75 08 	call	0x10ea
    uart_puts ( buff);
     dea:	ce 01       	movw	r24, r28
     dec:	01 96       	adiw	r24, 0x01	; 1
     dee:	0e 94 d0 06 	call	0xda0
     df2:	64 96       	adiw	r28, 0x14	; 20
     df4:	0f b6       	in	r0, 0x3f	; 63
     df6:	f8 94       	cli
     df8:	de bf       	out	0x3e, r29	; 62
     dfa:	0f be       	out	0x3f, r0	; 63
     dfc:	cd bf       	out	0x3d, r28	; 61
     dfe:	df 91       	pop	r29
     e00:	cf 91       	pop	r28
     e02:	08 95       	ret

00000e04 <debug_lvalue>:

}



void  debug_lvalue ( int32_t value, uint8_t radix)
{
     e04:	ef 92       	push	r14
     e06:	ff 92       	push	r15
     e08:	0f 93       	push	r16
     e0a:	1f 93       	push	r17
     e0c:	cf 93       	push	r28
     e0e:	df 93       	push	r29
     e10:	cd b7       	in	r28, 0x3d	; 61
     e12:	de b7       	in	r29, 0x3e	; 62
     e14:	a8 97       	sbiw	r28, 0x28	; 40
     e16:	0f b6       	in	r0, 0x3f	; 63
     e18:	f8 94       	cli
     e1a:	de bf       	out	0x3e, r29	; 62
     e1c:	0f be       	out	0x3f, r0	; 63
     e1e:	cd bf       	out	0x3d, r28	; 61
     e20:	7b 01       	movw	r14, r22
     e22:	8c 01       	movw	r16, r24
     e24:	84 2f       	mov	r24, r20
   uint8_t  buff[40];
   
   ltoa (value,buff, radix);
     e26:	99 27       	eor	r25, r25
     e28:	9c 01       	movw	r18, r24
     e2a:	ae 01       	movw	r20, r28
     e2c:	4f 5f       	subi	r20, 0xFF	; 255
     e2e:	5f 4f       	sbci	r21, 0xFF	; 255
     e30:	c8 01       	movw	r24, r16
     e32:	b7 01       	movw	r22, r14
     e34:	0e 94 9a 08 	call	0x1134
    uart_puts ( buff);
     e38:	ce 01       	movw	r24, r28
     e3a:	01 96       	adiw	r24, 0x01	; 1
     e3c:	0e 94 d0 06 	call	0xda0
     e40:	a8 96       	adiw	r28, 0x28	; 40
     e42:	0f b6       	in	r0, 0x3f	; 63
     e44:	f8 94       	cli
     e46:	de bf       	out	0x3e, r29	; 62
     e48:	0f be       	out	0x3f, r0	; 63
     e4a:	cd bf       	out	0x3d, r28	; 61
     e4c:	df 91       	pop	r29
     e4e:	cf 91       	pop	r28
     e50:	1f 91       	pop	r17
     e52:	0f 91       	pop	r16
     e54:	ff 90       	pop	r15
     e56:	ef 90       	pop	r14
     e58:	08 95       	ret

00000e5a <adc_init>:
      Bit 5   left or right adjust bit in ADLAR
*/
void adc_init(uint8_t voltage)
{
    ADCSRA = 0xC7 | (1<< ADEN);
     e5a:	97 ec       	ldi	r25, 0xC7	; 199
     e5c:	96 b9       	out	0x06, r25	; 6
	
// Set voltage reference 	
	ADMUX  =  voltage << 6;
     e5e:	82 95       	swap	r24
     e60:	88 0f       	add	r24, r24
     e62:	88 0f       	add	r24, r24
     e64:	80 7c       	andi	r24, 0xC0	; 192
     e66:	87 b9       	out	0x07, r24	; 7

// Set input for ADC pin
    DDRA    &= 0xF0;	
     e68:	8a b3       	in	r24, 0x1a	; 26
     e6a:	80 7f       	andi	r24, 0xF0	; 240
     e6c:	8a bb       	out	0x1a, r24	; 26
     e6e:	08 95       	ret

00000e70 <adc_enable_int>:

}

/*
  Input mode = 0  Disable
        mode > 0  Enable


*/
void  adc_enable_int (uint8_t mode)
{
    if (mode)
     e70:	88 23       	and	r24, r24
     e72:	19 f0       	breq	.+6      	; 0xe7a
	{
		ADCSRA  |= ( (1 << ADEN) | (1 << ADIE) | (1<< ADSC));
     e74:	86 b1       	in	r24, 0x06	; 6
     e76:	88 6c       	ori	r24, 0xC8	; 200
     e78:	02 c0       	rjmp	.+4      	; 0xe7e
    }
	else
	{
		ADCSRA  &= ~((1 << ADIE) | (1<< ADSC));
     e7a:	86 b1       	in	r24, 0x06	; 6
     e7c:	87 7b       	andi	r24, 0xB7	; 183
     e7e:	86 b9       	out	0x06, r24	; 6
     e80:	08 95       	ret
     e82:	08 95       	ret

00000e84 <read_adc>:
	}
}


/*
Read adc value		
	
	INPUT :  channel  to read adc  ( See table for Differential INput and Gain)
    Polling mode 
*/

int16_t read_adc(uint8_t channel)
{
  int16_t  value;
  
 
// Before that need to clear ADATE and ADEN
    ADCSRA &= ~((1 << ADEN) | (1<< ADATE));
     e84:	96 b1       	in	r25, 0x06	; 6
     e86:	9f 75       	andi	r25, 0x5F	; 95
     e88:	96 b9       	out	0x06, r25	; 6

// Set channel
    ADMUX |= channel;
     e8a:	97 b1       	in	r25, 0x07	; 7
     e8c:	98 2b       	or	r25, r24
     e8e:	97 b9       	out	0x07, r25	; 7
	
// Enable conversion
	ADCSRA |= (1<<ADEN);
     e90:	37 9a       	sbi	0x06, 7	; 6
// Start conversion
 
    
// Check whether conversion is complete
 
    ADCSRA |= (1<<ADSC);         // do single conversion
     e92:	36 9a       	sbi	0x06, 6	; 6
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
     e94:	34 9b       	sbis	0x06, 4	; 6
     e96:	fe cf       	rjmp	.-4      	; 0xe94

//Read value
//      value = ADCL;            // read out ADCL register
//      value += (ADCH << 8);    // read out ADCH register        
	value = ADCW;
     e98:	84 b1       	in	r24, 0x04	; 4
     e9a:	95 b1       	in	r25, 0x05	; 5
// Stop conversion
    ADCSRA &= ~(1 << ADEN);
     e9c:	37 98       	cbi	0x06, 7	; 6
     e9e:	08 95       	ret

00000ea0 <text_decode>:

*/ 

uint8_t text_decode (uint8_t *buffer, uint8_t *cmd_argument)
{
     ea0:	cf 92       	push	r12
     ea2:	df 92       	push	r13
     ea4:	ef 92       	push	r14
     ea6:	ff 92       	push	r15
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	cf 93       	push	r28
     eae:	7c 01       	movw	r14, r24

 uint8_t  found,ch,ch2,cmd_no,j,k,index,cmd_complete;
 uint8_t  state = WAIT_CMD_STATE, quote  = 0;
     eb0:	51 e0       	ldi	r21, 0x01	; 1
 static uint16_t i=0; // Keep pointer for next command decode
 cmd_complete = 0;
     eb2:	cc 24       	eor	r12, r12
 cmd_no 	= 0;
     eb4:	dc 2c       	mov	r13, r12
 index 		= 0;
     eb6:	4c 2d       	mov	r20, r12
 
 cmd_argument  = buffer;
 
 while (*(buffer+i))	  		//End with NULL
 {
// Check with delimiter

 	 j = 0;
	 found = 0;
	
	switch (state)
	{
	  case WAIT_CMD_STATE:   // If found first character in command table  then go to get_cmd state
 		j = 0;
		while ((ch = pgm_read_byte(&text_cmd[j][0])))     //Check first charaters in cmd table
		{ 
		  if (*(buffer+i) == ch)
		  {
			state = GET_CMD_STATE;   // Found delimiter
			*(cmd_argument) = ch;
			index = 1;
			break; 
		  }
		 j++;
		}  
	    break;
	  case GET_CMD_STATE:
	    ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
		if (found)
		{
        	*(cmd_argument+index) = 0x00;
		     if (ch == '=')
			 {
// Check command number 
  				for (k = 0; k < CMD_NUM ; k++)
				{
					if (!(strcasecmp_P(cmd_argument,&text_cmd[k][0])))  // Found then keep command
					{
						cmd_no  = k+1;   // Start from 0 
						break;
					}
				}
// clear index
  				index = 0;
			    state = WAIT_ARG_STATE;	
			 }	
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}
		break;
		
	  case WAIT_ARG_STATE:
		ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
				
		if ( ch == '"')   // Start quote
		{
			quote ^= 1;   // Toggle quote	
			state = GET_ARG_STATE;   
 			index = 0;
		}
		
		if (!found)    // Not delimiter start get Argument
		{
			state = GET_ARG_STATE;   
			*(cmd_argument) = ch;
			index = 1;
		}
		break;	
	  case	GET_ARG_STATE:
	  	ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
 		if ( ch == '"')     // End quote
		{
			quote ^= 1;   // Toggle quote	
   		}
		if ( quote)
		{
         	found = 0; //  ignore all characters after the quote until found quote again
// Cancel quote
            
		}	
		if (found)
		{	
            cmd_complete = 1;
			*(cmd_argument+index) = 0;
		    state = WAIT_CMD_STATE;
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}  
		break;
	}
	
	if(cmd_complete)   // COmmand both cmd number and argument
	{
		return cmd_no;	 	 
	}
	i++;
     eb8:	e0 91 fc 01 	lds	r30, 0x01FC
     ebc:	f0 91 fd 01 	lds	r31, 0x01FD
     ec0:	ee 0d       	add	r30, r14
     ec2:	ff 1d       	adc	r31, r15
     ec4:	80 81       	ld	r24, Z
     ec6:	88 23       	and	r24, r24
     ec8:	09 f4       	brne	.+2      	; 0xecc
     eca:	c1 c0       	rjmp	.+386    	; 0x104e
     ecc:	30 e0       	ldi	r19, 0x00	; 0
     ece:	85 2f       	mov	r24, r21
     ed0:	99 27       	eor	r25, r25
     ed2:	82 30       	cpi	r24, 0x02	; 2
     ed4:	91 05       	cpc	r25, r1
     ed6:	79 f1       	breq	.+94     	; 0xf36
     ed8:	83 30       	cpi	r24, 0x03	; 3
     eda:	91 05       	cpc	r25, r1
     edc:	1c f4       	brge	.+6      	; 0xee4
     ede:	01 97       	sbiw	r24, 0x01	; 1
     ee0:	59 f0       	breq	.+22     	; 0xef8
     ee2:	ab c0       	rjmp	.+342    	; 0x103a
     ee4:	83 30       	cpi	r24, 0x03	; 3
     ee6:	91 05       	cpc	r25, r1
     ee8:	09 f4       	brne	.+2      	; 0xeec
     eea:	5a c0       	rjmp	.+180    	; 0xfa0
     eec:	04 97       	sbiw	r24, 0x04	; 4
     eee:	09 f4       	brne	.+2      	; 0xef2
     ef0:	7b c0       	rjmp	.+246    	; 0xfe8
     ef2:	a3 c0       	rjmp	.+326    	; 0x103a
     ef4:	52 e0       	ldi	r21, 0x02	; 2
     ef6:	72 c0       	rjmp	.+228    	; 0xfdc
     ef8:	23 2f       	mov	r18, r19
     efa:	ec e5       	ldi	r30, 0x5C	; 92
     efc:	f0 e0       	ldi	r31, 0x00	; 0
     efe:	94 91       	lpm	r25, Z
     f00:	99 23       	and	r25, r25
     f02:	09 f4       	brne	.+2      	; 0xf06
     f04:	9a c0       	rjmp	.+308    	; 0x103a
     f06:	e0 91 fc 01 	lds	r30, 0x01FC
     f0a:	f0 91 fd 01 	lds	r31, 0x01FD
     f0e:	ee 0d       	add	r30, r14
     f10:	ff 1d       	adc	r31, r15
     f12:	80 81       	ld	r24, Z
     f14:	3a e0       	ldi	r19, 0x0A	; 10
     f16:	89 17       	cp	r24, r25
     f18:	69 f3       	breq	.-38     	; 0xef4
     f1a:	2f 5f       	subi	r18, 0xFF	; 255
     f1c:	23 9f       	mul	r18, r19
     f1e:	f0 01       	movw	r30, r0
     f20:	11 24       	eor	r1, r1
     f22:	e4 5a       	subi	r30, 0xA4	; 164
     f24:	ff 4f       	sbci	r31, 0xFF	; 255
     f26:	94 91       	lpm	r25, Z
     f28:	99 23       	and	r25, r25
     f2a:	a9 f7       	brne	.-22     	; 0xf16
     f2c:	86 c0       	rjmp	.+268    	; 0x103a
     f2e:	31 e0       	ldi	r19, 0x01	; 1
     f30:	17 c0       	rjmp	.+46     	; 0xf60
     f32:	c2 2e       	mov	r12, r18
     f34:	30 c0       	rjmp	.+96     	; 0xf96
     f36:	e0 91 fc 01 	lds	r30, 0x01FC
     f3a:	f0 91 fd 01 	lds	r31, 0x01FD
     f3e:	ee 0d       	add	r30, r14
     f40:	ff 1d       	adc	r31, r15
     f42:	90 81       	ld	r25, Z
     f44:	23 2f       	mov	r18, r19
     f46:	e4 e5       	ldi	r30, 0x54	; 84
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	84 91       	lpm	r24, Z
     f4c:	88 23       	and	r24, r24
     f4e:	41 f0       	breq	.+16     	; 0xf60
     f50:	98 17       	cp	r25, r24
     f52:	69 f3       	breq	.-38     	; 0xf2e
     f54:	2f 5f       	subi	r18, 0xFF	; 255
     f56:	e2 2f       	mov	r30, r18
     f58:	ff 27       	eor	r31, r31
     f5a:	ec 5a       	subi	r30, 0xAC	; 172
     f5c:	ff 4f       	sbci	r31, 0xFF	; 255
     f5e:	f5 cf       	rjmp	.-22     	; 0xf4a
     f60:	e4 2f       	mov	r30, r20
     f62:	ff 27       	eor	r31, r31
     f64:	33 23       	and	r19, r19
     f66:	09 f4       	brne	.+2      	; 0xf6a
     f68:	64 c0       	rjmp	.+200    	; 0x1032
     f6a:	ee 0d       	add	r30, r14
     f6c:	ff 1d       	adc	r31, r15
     f6e:	10 82       	st	Z, r1
     f70:	9d 33       	cpi	r25, 0x3D	; 61
     f72:	09 f0       	breq	.+2      	; 0xf76
     f74:	62 c0       	rjmp	.+196    	; 0x103a
     f76:	c0 81       	ld	r28, Z
     f78:	0c e5       	ldi	r16, 0x5C	; 92
     f7a:	10 e0       	ldi	r17, 0x00	; 0
     f7c:	b8 01       	movw	r22, r16
     f7e:	c7 01       	movw	r24, r14
     f80:	0e 94 d9 08 	call	0x11b2
     f84:	2c 2f       	mov	r18, r28
     f86:	2f 5f       	subi	r18, 0xFF	; 255
     f88:	89 2b       	or	r24, r25
     f8a:	99 f2       	breq	.-90     	; 0xf32
     f8c:	c2 2f       	mov	r28, r18
     f8e:	06 5f       	subi	r16, 0xF6	; 246
     f90:	1f 4f       	sbci	r17, 0xFF	; 255
     f92:	26 30       	cpi	r18, 0x06	; 6
     f94:	98 f3       	brcs	.-26     	; 0xf7c
     f96:	40 e0       	ldi	r20, 0x00	; 0
     f98:	53 e0       	ldi	r21, 0x03	; 3
     f9a:	4f c0       	rjmp	.+158    	; 0x103a
     f9c:	31 e0       	ldi	r19, 0x01	; 1
     f9e:	15 c0       	rjmp	.+42     	; 0xfca
     fa0:	e0 91 fc 01 	lds	r30, 0x01FC
     fa4:	f0 91 fd 01 	lds	r31, 0x01FD
     fa8:	ee 0d       	add	r30, r14
     faa:	ff 1d       	adc	r31, r15
     fac:	90 81       	ld	r25, Z
     fae:	23 2f       	mov	r18, r19
     fb0:	e4 e5       	ldi	r30, 0x54	; 84
     fb2:	f0 e0       	ldi	r31, 0x00	; 0
     fb4:	84 91       	lpm	r24, Z
     fb6:	88 23       	and	r24, r24
     fb8:	41 f0       	breq	.+16     	; 0xfca
     fba:	98 17       	cp	r25, r24
     fbc:	79 f3       	breq	.-34     	; 0xf9c
     fbe:	2f 5f       	subi	r18, 0xFF	; 255
     fc0:	e2 2f       	mov	r30, r18
     fc2:	ff 27       	eor	r31, r31
     fc4:	ec 5a       	subi	r30, 0xAC	; 172
     fc6:	ff 4f       	sbci	r31, 0xFF	; 255
     fc8:	f5 cf       	rjmp	.-22     	; 0xfb4
     fca:	92 32       	cpi	r25, 0x22	; 34
     fcc:	21 f4       	brne	.+8      	; 0xfd6
     fce:	81 e0       	ldi	r24, 0x01	; 1
     fd0:	d8 26       	eor	r13, r24
     fd2:	54 e0       	ldi	r21, 0x04	; 4
     fd4:	40 e0       	ldi	r20, 0x00	; 0
     fd6:	33 23       	and	r19, r19
     fd8:	81 f5       	brne	.+96     	; 0x103a
     fda:	54 e0       	ldi	r21, 0x04	; 4
     fdc:	f7 01       	movw	r30, r14
     fde:	90 83       	st	Z, r25
     fe0:	41 e0       	ldi	r20, 0x01	; 1
     fe2:	2b c0       	rjmp	.+86     	; 0x103a
     fe4:	31 e0       	ldi	r19, 0x01	; 1
     fe6:	15 c0       	rjmp	.+42     	; 0x1012
     fe8:	e0 91 fc 01 	lds	r30, 0x01FC
     fec:	f0 91 fd 01 	lds	r31, 0x01FD
     ff0:	ee 0d       	add	r30, r14
     ff2:	ff 1d       	adc	r31, r15
     ff4:	90 81       	ld	r25, Z
     ff6:	23 2f       	mov	r18, r19
     ff8:	e4 e5       	ldi	r30, 0x54	; 84
     ffa:	f0 e0       	ldi	r31, 0x00	; 0
     ffc:	84 91       	lpm	r24, Z
     ffe:	88 23       	and	r24, r24
    1000:	41 f0       	breq	.+16     	; 0x1012
    1002:	98 17       	cp	r25, r24
    1004:	79 f3       	breq	.-34     	; 0xfe4
    1006:	2f 5f       	subi	r18, 0xFF	; 255
    1008:	e2 2f       	mov	r30, r18
    100a:	ff 27       	eor	r31, r31
    100c:	ec 5a       	subi	r30, 0xAC	; 172
    100e:	ff 4f       	sbci	r31, 0xFF	; 255
    1010:	f5 cf       	rjmp	.-22     	; 0xffc
    1012:	92 32       	cpi	r25, 0x22	; 34
    1014:	11 f4       	brne	.+4      	; 0x101a
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	d8 26       	eor	r13, r24
    101a:	d1 10       	cpse	r13, r1
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	e4 2f       	mov	r30, r20
    1020:	ff 27       	eor	r31, r31
    1022:	33 23       	and	r19, r19
    1024:	31 f0       	breq	.+12     	; 0x1032
    1026:	ee 0d       	add	r30, r14
    1028:	ff 1d       	adc	r31, r15
    102a:	10 82       	st	Z, r1
    102c:	8c 2d       	mov	r24, r12
    102e:	99 27       	eor	r25, r25
    1030:	14 c0       	rjmp	.+40     	; 0x105a
    1032:	ee 0d       	add	r30, r14
    1034:	ff 1d       	adc	r31, r15
    1036:	90 83       	st	Z, r25
    1038:	4f 5f       	subi	r20, 0xFF	; 255
    103a:	e0 91 fc 01 	lds	r30, 0x01FC
    103e:	f0 91 fd 01 	lds	r31, 0x01FD
    1042:	31 96       	adiw	r30, 0x01	; 1
    1044:	f0 93 fd 01 	sts	0x01FD, r31
    1048:	e0 93 fc 01 	sts	0x01FC, r30
    104c:	39 cf       	rjmp	.-398    	; 0xec0
 }
  i = 0;
    104e:	10 92 fd 01 	sts	0x01FD, r1
    1052:	10 92 fc 01 	sts	0x01FC, r1
  return 0xFF;  // End of Buffer
    1056:	8f ef       	ldi	r24, 0xFF	; 255
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	cf 91       	pop	r28
    105c:	1f 91       	pop	r17
    105e:	0f 91       	pop	r16
    1060:	ff 90       	pop	r15
    1062:	ef 90       	pop	r14
    1064:	df 90       	pop	r13
    1066:	cf 90       	pop	r12
    1068:	08 95       	ret

0000106a <atoi>:
    106a:	fc 01       	movw	r30, r24
    106c:	88 27       	eor	r24, r24
    106e:	99 27       	eor	r25, r25
    1070:	e8 94       	clt

00001072 <.atoi_loop>:
    1072:	21 91       	ld	r18, Z+
    1074:	22 23       	and	r18, r18
    1076:	f1 f0       	breq	.+60     	; 0x10b4
    1078:	20 32       	cpi	r18, 0x20	; 32
    107a:	d9 f3       	breq	.-10     	; 0x1072
    107c:	29 30       	cpi	r18, 0x09	; 9
    107e:	c9 f3       	breq	.-14     	; 0x1072
    1080:	2a 30       	cpi	r18, 0x0A	; 10
    1082:	b9 f3       	breq	.-18     	; 0x1072
    1084:	2c 30       	cpi	r18, 0x0C	; 12
    1086:	a9 f3       	breq	.-22     	; 0x1072
    1088:	2d 30       	cpi	r18, 0x0D	; 13
    108a:	99 f3       	breq	.-26     	; 0x1072
    108c:	26 37       	cpi	r18, 0x76	; 118
    108e:	89 f3       	breq	.-30     	; 0x1072
    1090:	2b 32       	cpi	r18, 0x2B	; 43
    1092:	19 f0       	breq	.+6      	; 0x109a
    1094:	2d 32       	cpi	r18, 0x2D	; 45
    1096:	21 f4       	brne	.+8      	; 0x10a0

00001098 <.atoi_neg>:
    1098:	68 94       	set

0000109a <.atoi_loop2>:
    109a:	21 91       	ld	r18, Z+
    109c:	22 23       	and	r18, r18
    109e:	51 f0       	breq	.+20     	; 0x10b4

000010a0 <.atoi_digit>:
    10a0:	20 33       	cpi	r18, 0x30	; 48
    10a2:	44 f0       	brlt	.+16     	; 0x10b4
    10a4:	2a 33       	cpi	r18, 0x3A	; 58
    10a6:	34 f4       	brge	.+12     	; 0x10b4
    10a8:	20 53       	subi	r18, 0x30	; 48
    10aa:	0e 94 d1 08 	call	0x11a2
    10ae:	82 0f       	add	r24, r18
    10b0:	91 1d       	adc	r25, r1
    10b2:	f3 cf       	rjmp	.-26     	; 0x109a

000010b4 <.atoi_sig>:
    10b4:	81 15       	cp	r24, r1
    10b6:	91 05       	cpc	r25, r1
    10b8:	21 f0       	breq	.+8      	; 0x10c2
    10ba:	1e f4       	brtc	.+6      	; 0x10c2
    10bc:	80 95       	com	r24
    10be:	90 95       	com	r25
    10c0:	01 96       	adiw	r24, 0x01	; 1

000010c2 <.atoi_done>:
    10c2:	08 95       	ret

000010c4 <eeprom_read_byte>:
    10c4:	e1 99       	sbic	0x1c, 1	; 28
    10c6:	fe cf       	rjmp	.-4      	; 0x10c4
    10c8:	9f bb       	out	0x1f, r25	; 31
    10ca:	8e bb       	out	0x1e, r24	; 30
    10cc:	e0 9a       	sbi	0x1c, 0	; 28
    10ce:	99 27       	eor	r25, r25
    10d0:	8d b3       	in	r24, 0x1d	; 29
    10d2:	08 95       	ret

000010d4 <eeprom_write_byte>:
    10d4:	e1 99       	sbic	0x1c, 1	; 28
    10d6:	fe cf       	rjmp	.-4      	; 0x10d4
    10d8:	9f bb       	out	0x1f, r25	; 31
    10da:	8e bb       	out	0x1e, r24	; 30
    10dc:	6d bb       	out	0x1d, r22	; 29
    10de:	0f b6       	in	r0, 0x3f	; 63
    10e0:	f8 94       	cli
    10e2:	e2 9a       	sbi	0x1c, 2	; 28
    10e4:	e1 9a       	sbi	0x1c, 1	; 28
    10e6:	0f be       	out	0x3f, r0	; 63
    10e8:	08 95       	ret

000010ea <itoa>:
    10ea:	e6 2f       	mov	r30, r22
    10ec:	f7 2f       	mov	r31, r23
    10ee:	2e 2f       	mov	r18, r30
    10f0:	3f 2f       	mov	r19, r31
    10f2:	e8 94       	clt
    10f4:	42 30       	cpi	r20, 0x02	; 2
    10f6:	cc f0       	brlt	.+50     	; 0x112a
    10f8:	45 32       	cpi	r20, 0x25	; 37
    10fa:	bc f4       	brge	.+46     	; 0x112a
    10fc:	4a 30       	cpi	r20, 0x0A	; 10
    10fe:	29 f4       	brne	.+10     	; 0x110a
    1100:	97 fb       	bst	r25, 7
    1102:	1e f4       	brtc	.+6      	; 0x110a
    1104:	90 95       	com	r25
    1106:	81 95       	neg	r24
    1108:	9f 4f       	sbci	r25, 0xFF	; 255

0000110a <divide_loop>:
    110a:	64 2f       	mov	r22, r20
    110c:	77 27       	eor	r23, r23
    110e:	0e 94 1b 09 	call	0x1236
    1112:	80 5d       	subi	r24, 0xD0	; 208
    1114:	8a 33       	cpi	r24, 0x3A	; 58
    1116:	0c f0       	brlt	.+2      	; 0x111a
    1118:	89 5d       	subi	r24, 0xD9	; 217

0000111a <L_10>:
    111a:	81 93       	st	Z+, r24
    111c:	86 2f       	mov	r24, r22
    111e:	97 2f       	mov	r25, r23
    1120:	00 97       	sbiw	r24, 0x00	; 0
    1122:	99 f7       	brne	.-26     	; 0x110a
    1124:	16 f4       	brtc	.+4      	; 0x112a
    1126:	5d e2       	ldi	r21, 0x2D	; 45
    1128:	51 93       	st	Z+, r21

0000112a <terminate>:
    112a:	93 2f       	mov	r25, r19
    112c:	82 2f       	mov	r24, r18
    112e:	10 82       	st	Z, r1
    1130:	0c 94 ec 08 	jmp	0x11d8

00001134 <ltoa>:
    1134:	f5 2f       	mov	r31, r21
    1136:	e4 2f       	mov	r30, r20
    1138:	cf 93       	push	r28
    113a:	ff 93       	push	r31
    113c:	ef 93       	push	r30
    113e:	22 30       	cpi	r18, 0x02	; 2
    1140:	54 f1       	brlt	.+84     	; 0x1196
    1142:	25 32       	cpi	r18, 0x25	; 37
    1144:	44 f5       	brge	.+80     	; 0x1196
    1146:	c2 2f       	mov	r28, r18
    1148:	e8 94       	clt
    114a:	ca 30       	cpi	r28, 0x0A	; 10
    114c:	49 f4       	brne	.+18     	; 0x1160
    114e:	97 fb       	bst	r25, 7
    1150:	3e f4       	brtc	.+14     	; 0x1160
    1152:	90 95       	com	r25
    1154:	80 95       	com	r24
    1156:	70 95       	com	r23
    1158:	61 95       	neg	r22
    115a:	7f 4f       	sbci	r23, 0xFF	; 255
    115c:	8f 4f       	sbci	r24, 0xFF	; 255
    115e:	9f 4f       	sbci	r25, 0xFF	; 255

00001160 <divide_loop>:
    1160:	2c 2f       	mov	r18, r28
    1162:	33 27       	eor	r19, r19
    1164:	44 27       	eor	r20, r20
    1166:	55 27       	eor	r21, r21
    1168:	ff 93       	push	r31
    116a:	ef 93       	push	r30
    116c:	0e 94 2f 09 	call	0x125e
    1170:	ef 91       	pop	r30
    1172:	ff 91       	pop	r31
    1174:	60 5d       	subi	r22, 0xD0	; 208
    1176:	6a 33       	cpi	r22, 0x3A	; 58
    1178:	0c f0       	brlt	.+2      	; 0x117c
    117a:	69 5d       	subi	r22, 0xD9	; 217

0000117c <L_10>:
    117c:	61 93       	st	Z+, r22
    117e:	62 2f       	mov	r22, r18
    1180:	73 2f       	mov	r23, r19
    1182:	84 2f       	mov	r24, r20
    1184:	95 2f       	mov	r25, r21
    1186:	60 50       	subi	r22, 0x00	; 0
    1188:	70 40       	sbci	r23, 0x00	; 0
    118a:	80 40       	sbci	r24, 0x00	; 0
    118c:	90 40       	sbci	r25, 0x00	; 0
    118e:	41 f7       	brne	.-48     	; 0x1160
    1190:	16 f4       	brtc	.+4      	; 0x1196
    1192:	cd e2       	ldi	r28, 0x2D	; 45
    1194:	c1 93       	st	Z+, r28

00001196 <conv_finished>:
    1196:	10 82       	st	Z, r1
    1198:	8f 91       	pop	r24
    119a:	9f 91       	pop	r25
    119c:	cf 91       	pop	r28
    119e:	0c 94 ec 08 	jmp	0x11d8

000011a2 <__mulhi_const_10>:
    11a2:	7a e0       	ldi	r23, 0x0A	; 10
    11a4:	97 9f       	mul	r25, r23
    11a6:	90 2d       	mov	r25, r0
    11a8:	87 9f       	mul	r24, r23
    11aa:	80 2d       	mov	r24, r0
    11ac:	91 0d       	add	r25, r1
    11ae:	11 24       	eor	r1, r1
    11b0:	08 95       	ret

000011b2 <strcasecmp_P>:
    11b2:	fb 01       	movw	r30, r22
    11b4:	dc 01       	movw	r26, r24

000011b6 <.strcasecmp_P_loop>:
    11b6:	8d 91       	ld	r24, X+
    11b8:	05 90       	lpm	r0, Z+
    11ba:	60 2d       	mov	r22, r0
    11bc:	50 2d       	mov	r21, r0
    11be:	50 62       	ori	r21, 0x20	; 32
    11c0:	51 36       	cpi	r21, 0x61	; 97
    11c2:	24 f0       	brlt	.+8      	; 0x11cc
    11c4:	5b 37       	cpi	r21, 0x7B	; 123
    11c6:	14 f4       	brge	.+4      	; 0x11cc
    11c8:	60 62       	ori	r22, 0x20	; 32
    11ca:	80 62       	ori	r24, 0x20	; 32

000011cc <.strcasecmp_P_tst>:
    11cc:	86 1b       	sub	r24, r22
    11ce:	11 f4       	brne	.+4      	; 0x11d4
    11d0:	00 20       	and	r0, r0
    11d2:	89 f7       	brne	.-30     	; 0x11b6

000011d4 <.strcasecmp_P_done>:
    11d4:	99 0b       	sbc	r25, r25
    11d6:	08 95       	ret

000011d8 <strrev>:
    11d8:	dc 01       	movw	r26, r24
    11da:	fc 01       	movw	r30, r24

000011dc <.strrev_eos>:
    11dc:	01 90       	ld	r0, Z+
    11de:	00 20       	and	r0, r0
    11e0:	e9 f7       	brne	.-6      	; 0x11dc
    11e2:	32 97       	sbiw	r30, 0x02	; 2

000011e4 <.strrev_loop>:
    11e4:	ae 17       	cp	r26, r30
    11e6:	bf 07       	cpc	r27, r31
    11e8:	30 f4       	brcc	.+12     	; 0x11f6
    11ea:	7c 91       	ld	r23, X
    11ec:	60 81       	ld	r22, Z
    11ee:	70 83       	st	Z, r23
    11f0:	31 97       	sbiw	r30, 0x01	; 1
    11f2:	6d 93       	st	X+, r22
    11f4:	f7 cf       	rjmp	.-18     	; 0x11e4

000011f6 <.strrev_done>:
    11f6:	08 95       	ret

000011f8 <__mulsi3>:
    11f8:	62 9f       	mul	r22, r18
    11fa:	d0 01       	movw	r26, r0
    11fc:	73 9f       	mul	r23, r19
    11fe:	f0 01       	movw	r30, r0
    1200:	82 9f       	mul	r24, r18
    1202:	e0 0d       	add	r30, r0
    1204:	f1 1d       	adc	r31, r1
    1206:	64 9f       	mul	r22, r20
    1208:	e0 0d       	add	r30, r0
    120a:	f1 1d       	adc	r31, r1
    120c:	92 9f       	mul	r25, r18
    120e:	f0 0d       	add	r31, r0
    1210:	83 9f       	mul	r24, r19
    1212:	f0 0d       	add	r31, r0
    1214:	74 9f       	mul	r23, r20
    1216:	f0 0d       	add	r31, r0
    1218:	65 9f       	mul	r22, r21
    121a:	f0 0d       	add	r31, r0
    121c:	99 27       	eor	r25, r25
    121e:	72 9f       	mul	r23, r18
    1220:	b0 0d       	add	r27, r0
    1222:	e1 1d       	adc	r30, r1
    1224:	f9 1f       	adc	r31, r25
    1226:	63 9f       	mul	r22, r19
    1228:	b0 0d       	add	r27, r0
    122a:	e1 1d       	adc	r30, r1
    122c:	f9 1f       	adc	r31, r25
    122e:	bd 01       	movw	r22, r26
    1230:	cf 01       	movw	r24, r30
    1232:	11 24       	eor	r1, r1
    1234:	08 95       	ret

00001236 <__udivmodhi4>:
    1236:	aa 1b       	sub	r26, r26
    1238:	bb 1b       	sub	r27, r27
    123a:	51 e1       	ldi	r21, 0x11	; 17
    123c:	07 c0       	rjmp	.+14     	; 0x124c

0000123e <__udivmodhi4_loop>:
    123e:	aa 1f       	adc	r26, r26
    1240:	bb 1f       	adc	r27, r27
    1242:	a6 17       	cp	r26, r22
    1244:	b7 07       	cpc	r27, r23
    1246:	10 f0       	brcs	.+4      	; 0x124c
    1248:	a6 1b       	sub	r26, r22
    124a:	b7 0b       	sbc	r27, r23

0000124c <__udivmodhi4_ep>:
    124c:	88 1f       	adc	r24, r24
    124e:	99 1f       	adc	r25, r25
    1250:	5a 95       	dec	r21
    1252:	a9 f7       	brne	.-22     	; 0x123e
    1254:	80 95       	com	r24
    1256:	90 95       	com	r25
    1258:	bc 01       	movw	r22, r24
    125a:	cd 01       	movw	r24, r26
    125c:	08 95       	ret

0000125e <__udivmodsi4>:
    125e:	a1 e2       	ldi	r26, 0x21	; 33
    1260:	1a 2e       	mov	r1, r26
    1262:	aa 1b       	sub	r26, r26
    1264:	bb 1b       	sub	r27, r27
    1266:	fd 01       	movw	r30, r26
    1268:	0d c0       	rjmp	.+26     	; 0x1284

0000126a <__udivmodsi4_loop>:
    126a:	aa 1f       	adc	r26, r26
    126c:	bb 1f       	adc	r27, r27
    126e:	ee 1f       	adc	r30, r30
    1270:	ff 1f       	adc	r31, r31
    1272:	a2 17       	cp	r26, r18
    1274:	b3 07       	cpc	r27, r19
    1276:	e4 07       	cpc	r30, r20
    1278:	f5 07       	cpc	r31, r21
    127a:	20 f0       	brcs	.+8      	; 0x1284
    127c:	a2 1b       	sub	r26, r18
    127e:	b3 0b       	sbc	r27, r19
    1280:	e4 0b       	sbc	r30, r20
    1282:	f5 0b       	sbc	r31, r21

00001284 <__udivmodsi4_ep>:
    1284:	66 1f       	adc	r22, r22
    1286:	77 1f       	adc	r23, r23
    1288:	88 1f       	adc	r24, r24
    128a:	99 1f       	adc	r25, r25
    128c:	1a 94       	dec	r1
    128e:	69 f7       	brne	.-38     	; 0x126a
    1290:	60 95       	com	r22
    1292:	70 95       	com	r23
    1294:	80 95       	com	r24
    1296:	90 95       	com	r25
    1298:	9b 01       	movw	r18, r22
    129a:	ac 01       	movw	r20, r24
    129c:	bd 01       	movw	r22, r26
    129e:	cf 01       	movw	r24, r30
    12a0:	08 95       	ret
