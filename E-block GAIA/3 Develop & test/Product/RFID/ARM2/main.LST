ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 1   


ARM COMPILER V2.32a, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe main.c THUMB TABS(4) 

stmt  level    source

    1          
    2          //----------- include header file -------------
    3          #include "LPC213x.h"
    4          #include <stdio.h>
    5          #include "type.h"
    6          #include "RfidReader.h"
    7          #include "settime.h"
    8          #include "keypad.h"
    9          #include "serial.h"
   10          #include "spi.h"
   11          #include "mmc.h"
   12          #include "LCD.h"
   13          
   14          
   15          
   16          // ------------- Constant Value -------------
   17          #define COMPARE 0
   18          #define CHANGEPASS 1
   19          #define SETTIME 2
   20          #define SAVE 3
   21          #define DELETE 4
   22          #define ADDPASSWORD 5
   23          #define DELETEPASSWORD 6
   24          #define CONFIG 10
   25          
   26          #define MAX_PASSWORD_USER 5
   27          #define MAX_PASSWORD 9
   28          #define MAX_RFID_CARD 50
   29          #define MAX_NUMBER_USER 50
   30          
   31          #define MAX_BLOCK_NUM 512
   32          
   33          // ------------- Golbal variable -------------
   34          long timestate = 0;
   35          int state;
   36          int lMemTem = 0;
   37          int lMemRFID = 0;
   38          int lPasswordUser = 0;
   39          int lPasswordUserTime = 0;
   40          char menuold = '1';
   41          char tempkey[MAX_PASSWORD]; // temp for store word from keypad
   42          char password[MAX_PASSWORD] = "111"; // password
   43          unsigned char temppic[504]; // temp for load picture from SD/MMC
   44          
   45          //check message new program for sd/mmc
   46          char ckmsg[] = "E-block Check 9"; // change this number for clear data in sd/mmc
   47          
   48          typedef struct RFIDStorage
   49          {
   50              int datarfid;
   51              int day;
   52              int month;
   53              int year;
   54              int hour;
   55              int minute;
   56              int sec;
   57          }RFIDStorage;
   58          
   59          typedef struct PasswordStorage
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 2   

   60          {
   61              char passwordUser[MAX_PASSWORD_USER];
   62              int day;
   63              int month;
   64              int year;
   65              int hour;
   66              int minute;
   67              int sec;
   68          }PasswordStorage;
   69          
   70          RFIDStorage memoryTem[MAX_RFID_CARD], memoryRFID[MAX_RFID_CARD];
   71          PasswordStorage PassUserTime[MAX_NUMBER_USER], PassUser[MAX_NUMBER_USER];
   72          
   73                                          
   74          //-------- function prototype ---------
   75          int receive_keypad(int);
   76          int check_password();
   77          void change_password();
   78          void loadpic_mmc(int);
   79          void cleardata(); 
   80          
   81          extern void delay_ms(long int ms); // use function from keypad.h/keypad.c
   82          
   83          //this function clear temp of keypad(tempkey)
   84          void cleardata(){
   85   1          int i;
   86   1          
   87   1          for(i = 0;i < MAX_PASSWORD;i++)
   88   1          {
   89   2               tempkey[i] = '\0';
   90   2          }
   91   1      }
   92          
   93          //this function receive charecter from keypad and store it to string tempkey
   94          int receive_keypad(int mode)
   95          {
   96   1          char key = '$';
   97   1          int i = 0,initial;
   98   1          long sec_starts;
   99   1          sec_starts = (sec()+30)%60; // set time out 30 second
  100   1      
  101   1          // each function that call this fuction has individual receive style    
  102   1          // so it has been divide to many mode 
  103   1          if(mode == 1)// mode 1 is use for change password
  104   1          {
  105   2              cleardata(); // clear tempkey
  106   2              do
  107   2              {
  108   3                  key = keypad(); // receivce charecter from keypad
  109   3                  if(key != '$') // keypad sent $ if no key has been press so ignore it
  110   3                  {   
  111   4                      if(key == '*') // end receive when key * has been press
  112   4                      {
  113   5                          tempkey[i] = '\0';
  114   5                          key = '*';
  115   5                          printf("\n");
  116   5                      }
  117   4                      else if(key == '#') // delete data when key # has been press
  118   4                      {
  119   5                          if(i > 0)
  120   5                          {
  121   6                              lcd_gotoxy(10+(4*(i-1))+(5*(i-1)),3); // set position for lcd
  122   6                              lcd_put_char(' '); // put charecter to lcd
  123   6                              i--;
  124   6                              printf("\b \b");
  125   6                          }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 3   

  126   5                      }
  127   4                      else if(i == MAX_PASSWORD-1) // if reach last charecter then not do anything
  128   4                      {
  129   5      
  130   5                      }
  131   4                      else // put charecter to string tempkey
  132   4                      {
  133   5                          printf("%c",key);
  134   5                          lcd_gotoxy(10+(4*i)+(5*i),3); // set position for lcd
  135   5                          lcd_put_char(key); // put charecter to lcd
  136   5                          tempkey[i] = key;
  137   5                          i++;
  138   5                      }
  139   4                  }
  140   3                  if((sec()- sec_starts) == 0) // check time out
  141   3                  {
  142   4                      cleardata(); // clear tempkey
  143   4                      return 0; // if receive fail then return 0
  144   4                  }
  145   3              }while(key != '*'); // exit loop when key * has been press
  146   2          }
  147   1          else if(mode == 2) // mode 2 use for check password user to open door
  148   1          {
  149   2              i = 1; // start at second charecter since first charecter as been collect before
  150   2              lcd_gotoxy(8,4); // set position for lcd
  151   2              lcd_put_char('*'); // put charecter to lcd
  152   2              do
  153   2              {
  154   3                  key = keypad(); // receivce charecter from keypad
  155   3                  if(key != '$') // keypad sent $ if no key has been press so ignore it
  156   3                  {
  157   4                      if(i == (MAX_PASSWORD_USER-1)) // auto end receive when reach last charecter
  158   4                      {
  159   5                          tempkey[i] = '\0';
  160   5                          printf("\n");
  161   5                      }
  162   4                      else if(key == '#') // delete data when key # has been press
  163   4                      {
  164   5                          if(i > 0)
  165   5                          {
  166   6                              lcd_gotoxy(8+(4*(i-1))+(5*(i-1)),4); // set position for lcd
  167   6                              lcd_put_char(' '); // put charecter to lcd
  168   6                              i--;
  169   6                              printf("\b \b");
  170   6                              if(i == 0) // exit and wait receive first charecter
  171   6                              {
  172   7                                  tempkey[i] = '\0';
  173   7                                  return 0; // if receive fail then return 0
  174   7                              }
  175   6                          }
  176   5                      }
  177   4                      else if(key != '*')// if charecter is not * and # then put to string tempkey
  178   4                      {
  179   5                          printf("%c",key);
  180   5                          lcd_gotoxy(8+(4*i)+(5*i),4); // set position for lcd
  181   5                          lcd_put_char('*'); // put charecter to lcd
  182   5                          tempkey[i] = key;
  183   5                          i++;
  184   5                      }
  185   4                  }       
  186   3                  if((sec()- sec_starts) == 0) // check time out
  187   3                  {
  188   4                      cleardata(); // clear tempkey
  189   4                      return 0; // if receive fail then return 0
  190   4                  }
  191   3              }while(i != (MAX_PASSWORD_USER-1)); // exit loop when reach last charecter
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 4   

  192   2          }
  193   1          else if(mode == 3) // mode 3 use for add and delete password user
  194   1          {
  195   2              cleardata(); // clear tempkey
  196   2              do
  197   2              {
  198   3                  key = keypad(); // receivce charecter from keypad
  199   3                  if(key != '$') // keypad sent $ if no key has been press so ignore it
  200   3                  {
  201   4                  
  202   4                      if((key == '*')&&(i == MAX_PASSWORD_USER-1)) // end receive when key * has been press and reach last 
             -charecter
  203   4                      {
  204   5                          tempkey[i] = '\0';
  205   5                          key = '*';
  206   5                          printf("\n");
  207   5                      }
  208   4                      else if(key == '#') // delete data when key # has been press
  209   4                      {
  210   5                          if(i > 0)
  211   5                          {
  212   6                              lcd_gotoxy(24+(4*(i-1))+(5*(i-1)),3); // set position for lcd
  213   6                              lcd_put_char(' '); // put charecter to lcd
  214   6                              i--;
  215   6                              printf("\b \b");
  216   6                          }
  217   5                      }
  218   4                      else if(i == MAX_PASSWORD_USER-1) // if reach last charecter then not do anything
  219   4                      {
  220   5      
  221   5                      }
  222   4                      else if(key != '*') // if charecter is not * and # then put to string tempkey
  223   4                      {
  224   5                          printf("%c",key);
  225   5                          lcd_gotoxy(24+(4*i)+(5*i),3); // set position for lcd
  226   5                          lcd_put_char(key); // put charecter to lcd
  227   5                          tempkey[i] = key;
  228   5                          i++;
  229   5                      }
  230   4                  }       
  231   3                  if((sec()- sec_starts) == 0) // check time out
  232   3                  {
  233   4                      cleardata(); // clear tempkey
  234   4                      return 0; // if receive fail then return 0
  235   4                  }
  236   3              }while((key != '*')||(i != (MAX_PASSWORD_USER-1))); // exit loop when key * has been press and reach la
             -st charecter
  237   2          }
  238   1          else if(mode == 4) // mode 4 use for select menu (state config)
  239   1          {
  240   2              cleardata(); // clear tempkey
  241   2              printf(" ");
  242   2              initial = 1;
  243   2              do
  244   2              {
  245   3                  key = keypad(); // receivce charecter from keypad
  246   3                  if(initial == 1) // auto select one menu when open menu
  247   3                  {
  248   4                      key = menuold;
  249   4                      initial = 0;
  250   4                  }
  251   3                  else if(tempkey[0] != '\0') // when exit from function, that fuction menu will be select
  252   3                  {
  253   4                      menuold = tempkey[0];
  254   4                  }
  255   3      
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 5   

  256   3      
  257   3                  if(key != '$') // keypad sent $ if no key has been press so ignore it
  258   3                  {
  259   4                      
  260   4                      if(key == '*') // end receive (confirm select) when key * has been press
  261   4                      {
  262   5                          tempkey[1] = '\0';
  263   5                          key = '*';
  264   5                          printf("\n");
  265   5                      }
  266   4                      else if(key == '#') // exit menu when key # has been press
  267   4                      {
  268   5                          tempkey[0] = '\0';
  269   5                          menuold = '1';
  270   5                          printf("\n");
  271   5                          return 0; // if receive fail then return 0
  272   5                      }
  273   4                      else if(key == '1') // select menu 1 change password when key 1 has been press
  274   4                      {
  275   5                          printf("\b%c",key);
  276   5                          tempkey[0] = key;
  277   5                          loadpic_mmc(403); // load picture from sd/mmc
  278   5                          lcd_fill_picture(temppic); // show picture on lcd
  279   5                      }
  280   4                      else if(key == '2') // select menu 2 set date time when key 2 has been press
  281   4                      {
  282   5                          printf("\b%c",key);
  283   5                          tempkey[0] = key;
  284   5                          loadpic_mmc(404); // load picture from sd/mmc
  285   5                          lcd_fill_picture(temppic); // show picture on lcd
  286   5                      }
  287   4                      else if(key == '3') // select menu 3 save rfid card when key 3 has been press
  288   4                      {
  289   5                          printf("\b%c",key);
  290   5                          tempkey[0] = key;
  291   5                          loadpic_mmc(405); // load picture from sd/mmc
  292   5                          lcd_fill_picture(temppic); // show picture on lcd
  293   5                      }
  294   4                      else if(key == '4') // select menu 4 delete rfid card when key 4 has been press
  295   4                      {
  296   5                          printf("\b%c",key);
  297   5                          tempkey[0] = key;
  298   5                          loadpic_mmc(406); // load picture from sd/mmc
  299   5                          lcd_fill_picture(temppic); // show picture on lcd
  300   5                      }
  301   4                      else if(key == '5') // select menu 5 add password user when key 5 has been press
  302   4                      {
  303   5                          printf("\b%c",key);
  304   5                          tempkey[0] = key;
  305   5                          loadpic_mmc(407); // load picture from sd/mmc
  306   5                          lcd_fill_picture(temppic); // show picture on lcd
  307   5                      }
  308   4                      else if(key == '6') // select menu 6 delete password user when key 6 has been press
  309   4                      {
  310   5                          printf("\b%c",key);
  311   5                          tempkey[0] = key;
  312   5                          loadpic_mmc(408); // load picture from sd/mmc
  313   5                          lcd_fill_picture(temppic); // show picture on lcd
  314   5                      }
  315   4                      else if(key == '7') // select menu 7 show information of rfid card when key 7 has been press
  316   4                      {
  317   5                          printf("\b%c",key);
  318   5                          tempkey[0] = key;
  319   5                          loadpic_mmc(409); // load picture from sd/mmc
  320   5                          lcd_fill_picture(temppic); // show picture on lcd
  321   5                      }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 6   

  322   4                      else if(key == '8') // select menu 8 show information of password user when key 8 has been press
  323   4                      {
  324   5                          printf("\b%c",key);
  325   5                          tempkey[0] = key;
  326   5                          loadpic_mmc(410); // load picture from sd/mmc
  327   5                          lcd_fill_picture(temppic); // show picture on lcd
  328   5                      }
  329   4                      else if(key == '9') // select menu 9 show date time and card or password that use to open door when k
             -ey 9 has been press
  330   4                      {
  331   5                          printf("\b%c",key);
  332   5                          tempkey[0] = key;
  333   5                          loadpic_mmc(411); // load picture from sd/mmc
  334   5                          lcd_fill_picture(temppic); // show picture on lcd
  335   5                      }
  336   4                      else if(key == '0') // select menu 0 show date and time when key 0 has been press
  337   4                      {
  338   5                          printf("\b%c",key);
  339   5                          tempkey[0] = key;
  340   5                          loadpic_mmc(412); // load picture from sd/mmc
  341   5                          lcd_fill_picture(temppic); // show picture on lcd
  342   5                      }
  343   4                  }
  344   3                  if((sec()- sec_starts) == 0) // check time out
  345   3                  {
  346   4                      cleardata(); // clear tempkey
  347   4                      menuold = '1';
  348   4                      return 0; // if receive fail then return 0
  349   4                  }
  350   3              }while((key != '*')&&(key != '#'));// exit loop key * or # has been press
  351   2          }
  352   1          else if(mode == 5)// mode 5 for password enter menu
  353   1          {
  354   2              cleardata(); // clear tempkey
  355   2              do
  356   2              {
  357   3                  key = keypad(); // receivce charecter from keypad
  358   3                  if(key != '$') // keypad sent $ if no key has been press so ignore it
  359   3                  {
  360   4                      
  361   4                      if(key == '*') // end receive when key * has been press
  362   4                      {
  363   5                          tempkey[i] = '\0';
  364   5                          key = '*';
  365   5                          printf("\n");
  366   5                      }
  367   4                      else if(key == '#') // delete data when key # has been press
  368   4                      {
  369   5                          if(i > 0)
  370   5                          {
  371   6                              lcd_gotoxy(8+(2*(i-1))+(5*(i-1)),4); // set position for lcd
  372   6                              lcd_put_char(' '); // put charecter to lcd
  373   6                              i--;
  374   6                              printf("\b \b");
  375   6                          }
  376   5                      }
  377   4                      else if(i == MAX_PASSWORD-1) // if reach last charecter then not do anything
  378   4                      {
  379   5      
  380   5                      }
  381   4                      else // put charecter to string tempkey
  382   4                      {
  383   5                          lcd_gotoxy(8+(2*i)+(5*i),4); // set position for lcd
  384   5                          lcd_put_char('*'); // put charecter to lcd
  385   5                          printf("%c",key);
  386   5                          tempkey[i] = key;
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 7   

  387   5                          i++;
  388   5                      }
  389   4                  }
  390   3                  if((sec()- sec_starts) == 0) // check time out
  391   3                  {
  392   4                      cleardata(); // clear tempkey
  393   4                      return 0; // if receive fail then return 0
  394   4                  }
  395   3              }while(key != '*'); // exit loop when key * has been press
  396   2          }
  397   1          else if(mode == 6) // mode 6 for enter day, month and year
  398   1          {
  399   2              cleardata(); // clear tempkey
  400   2              do
  401   2              {
  402   3                  key = keypad(); // receivce charecter from keypad
  403   3                  if(key != '$') // keypad sent $ if no key has been press so ignore it
  404   3                  {
  405   4                  
  406   4                      if((key == '*')&&(i == 8)) // end receive when key * has been press and reach last charecter
  407   4                      {
  408   5                          tempkey[i] = '\0';
  409   5                          key = '*';
  410   5                          printf("\n");
  411   5                      }
  412   4                      else if(key == '#') // delete data when key # has been press
  413   4                      {
  414   5                          if(i > 0)
  415   5                          {
  416   6                              lcd_gotoxy(8+(4*(i-1))+(5*(i-1)),3); // set position for lcd
  417   6                              lcd_put_char(' '); // put charecter to lcd
  418   6                              i--;
  419   6                              printf("\b \b");
  420   6                          }
  421   5                      }
  422   4                      else if(i == 8) // if reach last charecter then not do anything
  423   4                      {
  424   5      
  425   5                      }
  426   4                      else if(key != '*') // if charecter is not * and # then put to string tempkey
  427   4                      {
  428   5                          lcd_gotoxy(8+(4*i)+(5*i),3); // set position for lcd
  429   5                          lcd_put_char(key); // put charecter to lcd
  430   5                          printf("%c",key);
  431   5                          tempkey[i] = key;
  432   5                          i++;
  433   5                      }
  434   4                  }       
  435   3                  if((sec()- sec_starts) == 0) // check time out
  436   3                  {
  437   4                      cleardata(); // clear tempkey
  438   4                      return 0; // if receive fail then return 0
  439   4                  }
  440   3              }while((key != '*')||(i != 8)); // exit loop when key * has been press and reach last charecter
  441   2          }
  442   1          else if(mode == 7) // mode 7 for enter hour and minute
  443   1          {
  444   2              cleardata(); // clear tempkey
  445   2              do
  446   2              {
  447   3                  key = keypad(); // receivce charecter from keypad
  448   3                  if(key != '$') // keypad sent $ if no key has been press so ignore it
  449   3                  {
  450   4                  
  451   4                      if((key == '*')&&(i == 4)) // end receive when key * has been press and reach last charecter
  452   4                      {
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 8   

  453   5                          tempkey[i] = '\0';
  454   5                          key = '*';
  455   5                          printf("\n");
  456   5                      }
  457   4                      else if(key == '#') // delete data when key # has been press
  458   4                      {
  459   5                          if(i > 0)
  460   5                          {
  461   6                              lcd_gotoxy(20+(4*(i-1))+(5*(i-1)),3); // set position for lcd
  462   6                              lcd_put_char(' '); // put charecter to lcd
  463   6                              i--;
  464   6                              printf("\b \b");
  465   6                          }
  466   5                      }
  467   4                      else if(i == 4) // if reach last charecter then not do anything
  468   4                      {
  469   5      
  470   5                      }
  471   4                      else if(key != '*') // if charecter is not * and # then put to string tempkey
  472   4                      {
  473   5                          printf("%c",key);
  474   5                          lcd_gotoxy(20+(4*i)+(5*i),3); // set position for lcd
  475   5                          lcd_put_char(key); // put charecter to lcd
  476   5                          tempkey[i] = key;
  477   5                          i++;
  478   5                      }
  479   4                  }       
  480   3                  if((sec()- sec_starts) == 0) // check time out
  481   3                  {
  482   4                      cleardata(); // clear tempkey
  483   4                      return 0; // if receive fail then return 0
  484   4                  }
  485   3              }while((key != '*')||(i != 4)); // exit loop when key * has been press and reach last charecter
  486   2          }
  487   1      
  488   1          return 1; // if receive complete then return 1
  489   1      }
  490          
  491          // this function use for check password both password user and password to enter menu
  492          // if use for check password user select 1
  493          // if use for check password to enter menu select 2
  494          int check_password(int sel)
  495          {
  496   1          int i,j,wrong_pass = 0;
  497   1          if(sel == 1) // enter mode check password user
  498   1          {
  499   2              for(i = 0;i< MAX_NUMBER_USER;i++) // loop for check all password user
  500   2              {
  501   3                  wrong_pass = 1; 
  502   3                 for(j = 0;j < MAX_PASSWORD_USER;j++) // loop compare password user with that password receive from u
             -ser
  503   3                 {
  504   4                      if(tempkey[j] != PassUser[i].passwordUser[j]) // if has different set wrong_pass to 0
  505   4                      {
  506   5                         wrong_pass = 0;
  507   5                      }
  508   4                      
  509   4                      // if both password user and password receive from user reach end then exit
  510   4                      if((tempkey[j] == '\0') && (PassUser[i].passwordUser[j] == '\0'))
  511   4                      {
  512   5                          if(j == 0)// if no data in password receive from user then set wrong_pass to 0
  513   5                              wrong_pass = 0;
  514   5                          j = MAX_PASSWORD_USER;
  515   5                      }
  516   4                 }
  517   3                 if(wrong_pass) // if wrong_pass is 1 then password user is correct and return 1
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 9   

  518   3                      return 1;
  519   3              }
  520   2              return 0; // password user not correct and return 0
  521   2          }
  522   1          else if(sel == 2) // enter mode check password to enter menu
  523   1          {
  524   2              for(i = 0;i < MAX_PASSWORD;i++)
  525   2              {
  526   3                  // if has different between password and password receive from user then return 0
  527   3                  if(tempkey[i] != password[i])
  528   3                      return 0;
  529   3      
  530   3                  // if both password and password receive from user reach end then exit
  531   3                  if((tempkey[i] == '\0') && (password[i] == '\0'))
  532   3                  {
  533   4                      i = MAX_PASSWORD;
  534   4                  }
  535   3              }
  536   2      
  537   2              return 1; // password is correct and return 1
  538   2          }
  539   1          else
  540   1              return 0;
  541   1      }
  542          
  543          // this function use for change password of enter menu
  544          void change_password()
  545          {
  546   1          int i;
  547   1          if(tempkey[0] == '\0') // if no data then exit
  548   1          {
  549   2              return;
  550   2          }
  551   1          for(i = 0;i < MAX_PASSWORD;i++) // set new password 
  552   1          {
  553   2               password[i] = tempkey[i];
  554   2          }
  555   1      }
  556          
  557          // this function use for change state to Compare
  558          void setStateCompare(void){
  559   1          printf("\n*****************\n");
  560   1          printf("* State Compare *\n");
  561   1          printf("*****************\n");
  562   1          state = COMPARE;
  563   1          loadpic_mmc(401); // load picture from sd/mmc
  564   1          lcd_fill_picture(temppic); // show picture on lcd
  565   1      }
  566          
  567          // this function use for change state to Config
  568          void setStateConfig(void){
  569   1          printf("\n****************\n");
  570   1          printf("* State Config *\n");
  571   1          printf("****************\n");
  572   1          printf("[1] Change password\n");
  573   1          printf("[2] Set time\n");
  574   1          printf("[3] Save RFID card\n");
  575   1          printf("[4] Delete RFID card\n");
  576   1          printf("[5] Add password user\n");
  577   1          printf("[6] Delete password user\n");
  578   1          printf("[7] Show RFID card save time\n");
  579   1          printf("[8] Show password user save time\n");
  580   1          printf("[9] Show Stamp time\n");
  581   1          printf("[0] Show time\n");
  582   1          printf("Select Menu :");
  583   1          state = CONFIG; 
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 10  

  584   1      }
  585          
  586          // this function use for change state to Change password
  587          void setStateChangepass(void){
  588   1          printf("*************************\n");
  589   1          printf("* State Change Password *\n");
  590   1          printf("*************************\n");
  591   1          printf("Enter New Password :");
  592   1          state = CHANGEPASS;
  593   1      }
  594          
  595          // this function use for change state to Set time
  596          void setStateSettime(void){
  597   1          printf("******************\n");
  598   1          printf("* State Set Time *\n");
  599   1          printf("******************\n");
  600   1          printf("Enter Time (ddmmyyyy) :");
  601   1          state = SETTIME;
  602   1      }
  603          
  604          // this function use for change state to Save
  605          void setStateSave(void){
  606   1          printf("**************\n");
  607   1          printf("* State Save *\n");
  608   1          printf("**************\n");
  609   1          printf("Please Stamp Card in 1 minute\n");
  610   1          loadpic_mmc(418); // load picture from sd/mmc
  611   1          lcd_fill_picture(temppic); // show picture on lcd
  612   1          state = SAVE; 
  613   1      }
  614          
  615          // this function use for change state to Delete
  616          void setStateDelete(void){
  617   1          printf("****************\n");
  618   1          printf("* State Delete *\n");
  619   1          printf("****************\n");
  620   1          printf("Please Stamp Card in 1 minute\n");
  621   1          loadpic_mmc(418); // load picture from sd/mmc
  622   1          lcd_fill_picture(temppic); // show picture on lcd
  623   1          state = DELETE; 
  624   1      }
  625          
  626          // this function use for change state to Add password
  627          void setStateAddPassword(void){
  628   1          printf("**********************\n");
  629   1          printf("* State Add Password *\n");
  630   1          printf("**********************\n");
  631   1          printf("Enter Password User :");
  632   1          loadpic_mmc(419); // load picture from sd/mmc
  633   1          lcd_fill_picture(temppic); // show picture on lcd
  634   1          state = ADDPASSWORD; 
  635   1      }
  636          
  637          // this function use for change state to Delete password
  638          void setStateDeletePassword(void){
  639   1          printf("*************************\n");
  640   1          printf("* State Delete Password *\n");
  641   1          printf("*************************\n");
  642   1          printf("Enter Password User :");
  643   1          loadpic_mmc(419); // load picture from sd/mmc
  644   1          lcd_fill_picture(temppic); // show picture on lcd
  645   1          state = DELETEPASSWORD; 
  646   1      }
  647          
  648          // this function use for check ID of RFID card
  649          int CheckRFIDCard(int rfid)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 11  

  650          {
  651   1           int i;
  652   1           for(i=0;i<MAX_RFID_CARD;i++) // loop for check all card
  653   1           {
  654   2               if( memoryRFID[i].datarfid == rfid) // if ID of RFID card that stamp and ID of RFID card in system
  655   2                                                   // is match then return 1
  656   2               {
  657   3                   return 1;
  658   3               }
  659   2           }
  660   1           return 0; // not found match ID of card then return 0
  661   1          
  662   1      }
  663          
  664          // this function use for collect ID of RFID card, date and time that open door
  665          void inputMemTem(int datarfid)
  666          {
  667   1            // collect data
  668   1            memoryTem[lMemTem].datarfid = datarfid;
  669   1            memoryTem[lMemTem].day = day();
  670   1            memoryTem[lMemTem].month = month();
  671   1            memoryTem[lMemTem].year = year();
  672   1            memoryTem[lMemTem].hour = hour();
  673   1            memoryTem[lMemTem].minute = minute();
  674   1            memoryTem[lMemTem].sec = sec();
  675   1            lMemTem++; // increase number of card that use to open door
  676   1            if( lMemTem == MAX_RFID_CARD) // if number of card reach to maximun then reset number of card to 0
  677   1            {
  678   2                lMemTem = 0;
  679   2            }
  680   1      }
  681          
  682          // this function use for add ID of RFID card and add time to system
  683          int inputMemRFID(int inrfid)
  684          {
  685   1            int i;
  686   1            if( lMemRFID == MAX_RFID_CARD) // if number of card is full then return 0
  687   1            {
  688   2                return 0;
  689   2            }
  690   1            for(i=0;i<MAX_RFID_CARD;i++) // if card already save then return 0
  691   1            {
  692   2               if( memoryRFID[i].datarfid == inrfid)
  693   2               {
  694   3                   return 0;
  695   3               }
  696   2            }
  697   1      
  698   1            // add card to system
  699   1            memoryRFID[lMemRFID].datarfid = inrfid;
  700   1            memoryRFID[lMemRFID].day = day();
  701   1            memoryRFID[lMemRFID].month = month();
  702   1            memoryRFID[lMemRFID].year = year();
  703   1            memoryRFID[lMemRFID].hour = hour();
  704   1            memoryRFID[lMemRFID].minute = minute();
  705   1            memoryRFID[lMemRFID].sec = sec();
  706   1            lMemRFID++; // increase number of card in system
  707   1            return 1; // return 1 when add card is done
  708   1      }
  709          
  710          // this function use for delete ID of RFID card and card information to system
  711          int deleteMemRFID(int inrfid)
  712          {
  713   1           int i;
  714   1           for(i=0;i<MAX_RFID_CARD;i++)
  715   1           {
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 12  

  716   2               if( memoryRFID[i].datarfid == inrfid) // if ID of card that stamp and ID of card in system is match
             - then delete 
  717   2               {
  718   3                   memoryRFID[i] = memoryRFID[--lMemRFID]; // copy data of last card to data of match card
  719   3                                                           // and decrease number of card in system
  720   3                   memoryRFID[lMemRFID].datarfid = 0; // remove data of last card
  721   3                   return 1; // return 1 when done
  722   3               }
  723   2           }
  724   1           return 0; // not found ID of card then return 0
  725   1      }
  726          
  727          // this function use for add password user and add time to system
  728          int addPasswordUser()
  729          {
  730   1          int i;
  731   1          if(lPasswordUser == MAX_NUMBER_USER) // if number of password user is full then return 0
  732   1          {
  733   2              return 0;
  734   2          }
  735   1          else if(check_password(1) == 1) // if password user already save then return 0
  736   1          {
  737   2              return 0;
  738   2          }
  739   1          else // add password user to system
  740   1          {
  741   2              for(i = 0;i < MAX_PASSWORD_USER;i++)
  742   2              {
  743   3                  PassUser[lPasswordUser].passwordUser[i] = tempkey[i];
  744   3              }
  745   2              PassUser[lPasswordUser].day = day();
  746   2              PassUser[lPasswordUser].month = month();
  747   2              PassUser[lPasswordUser].year = year();
  748   2              PassUser[lPasswordUser].hour = hour();
  749   2              PassUser[lPasswordUser].minute = minute();
  750   2              PassUser[lPasswordUser].sec = sec();
  751   2              lPasswordUser++; // increase number of password user in system 
  752   2          }
  753   1          return 1; // add passord user complete then return 1
  754   1      }
  755          
  756          // this function use for collect password user, date and time that open door
  757          void addPasswordUserTime()
  758          {
  759   1          int i;
  760   1          // collect data
  761   1          for(i = 0;i < MAX_PASSWORD_USER;i++)
  762   1          {
  763   2              PassUserTime[lPasswordUserTime].passwordUser[i] = tempkey[i];
  764   2          }
  765   1          PassUserTime[lPasswordUserTime].day = day();
  766   1          PassUserTime[lPasswordUserTime].month = month();
  767   1          PassUserTime[lPasswordUserTime].year = year();
  768   1          PassUserTime[lPasswordUserTime].hour = hour();
  769   1          PassUserTime[lPasswordUserTime].minute = minute();
  770   1          PassUserTime[lPasswordUserTime].sec = sec();
  771   1          lPasswordUserTime++; // increase number of password user that use to open door
  772   1          if( lPasswordUserTime == MAX_NUMBER_USER)  // if number of password user reach to maximun then reset num
             -ber of card to 0
  773   1          {
  774   2              lPasswordUserTime = 0;
  775   2          }   
  776   1      }
  777          
  778          // this function use for delete password user and password user information to system
  779          int deletePasswordUser()
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 13  

  780          {
  781   1          int i,j,check_correct = 0;
  782   1          if(check_password(1) == 1) // if has password user same as password that receive from user then delete
  783   1          {
  784   2              for(i = 0;i < MAX_NUMBER_USER;i++)
  785   2              {
  786   3                  check_correct = 1;
  787   3                  for(j = 0;j < MAX_PASSWORD_USER;j++)
  788   3                  {
  789   4                      // if has different between password user and password that receive from user
  790   4                      // then set check_correct to 0 for skip delete section
  791   4                      if(tempkey[j] != PassUser[i].passwordUser[j])
  792   4                      {
  793   5                          check_correct = 0;
  794   5                      }
  795   4                  }
  796   3                  if(check_correct == 1) // if check_correct is 1 then delete current password user
  797   3                  {
  798   4                      lPasswordUser--; // decrease number of password user
  799   4                      for(j = 0;j < MAX_PASSWORD_USER;j++)
  800   4                      {
  801   5                          // copy data of last password user to data of current password user
  802   5                          PassUser[i] = PassUser[lPasswordUser];
  803   5                      }
  804   4                      PassUser[lPasswordUser].passwordUser[0] = '\0'; // clear data of last password user
  805   4                  }
  806   3              }
  807   2          }
  808   1          else // if not has password user same as password that receive from user then return 0
  809   1          {
  810   2              return 0;
  811   2          }
  812   1          return 1; // if delete complete then return 1
  813   1      }
  814          
  815          // this function use for open door                           
  816          void opendoor()
  817          {
  818   1          //IODIR0 |= (1<<10);
  819   1          //IOSET0 = (1<<10);
  820   1          
  821   1          loadpic_mmc(413); // load picture from sd/mmc
  822   1          lcd_fill_picture(temppic); // show picture on lcd
  823   1          delay_ms(500);
  824   1          loadpic_mmc(414); // load picture from sd/mmc
  825   1          lcd_fill_picture(temppic); // show picture on lcd
  826   1      
  827   1          delay_ms(5000);
  828   1          
  829   1          loadpic_mmc(413); // load picture from sd/mmc
  830   1          lcd_fill_picture(temppic); // show picture on lcd
  831   1          delay_ms(1000);
  832   1          loadpic_mmc(401); // load picture from sd/mmc
  833   1          lcd_fill_picture(temppic); // show picture on lcd
  834   1          //IOCLR0 = (1<<10);
  835   1      }
  836          
  837          // this function use for load data from sd/mmc
  838          int loaddata_mmc()
  839          {
  840   1          /*
  841   1             block 0 for check and password
  842   1             block 1 to 50 for password user
  843   1             block 51 to 100 for RFID Card data
  844   1             block 101 to 150 for RFID stamp time
  845   1             block 151 to 200 fot password user time
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 14  

  846   1             block 201 for global variable
  847   1      
  848   1             block 401 for pic state compare
  849   1             block 402 for pic enter password to state config
  850   1             block 403 for menu 1 change password
  851   1             block 404 for menu 2 set time
  852   1             block 405 for menu 3 save rfid card
  853   1             block 406 for menu 4 delete rfid card
  854   1             block 407 for menu 5 add password user
  855   1             block 408 for menu 6 delete password user
  856   1             block 409 for menu 7 RFID save time
  857   1             block 410 for menu 8 Password User save time
  858   1             block 411 for menu 9 Stamp time
  859   1             block 412 for menu 0 Show time
  860   1      
  861   1             block 413 for pic close door
  862   1             block 414 for pic open door
  863   1             block 415 for pic check fail
  864   1             block 416 for pic store complete
  865   1             block 417 for pic store fail
  866   1             block 418 for pic wait card
  867   1             block 419 for pic wait pass
  868   1             block 420 for pic delete complete
  869   1             block 421 for pic delete fail
  870   1             block 422 for pic Enter day month year time
  871   1             block 423 for pic Enter Time
  872   1           */
  873   1          int i = 0,j = 0;
  874   1          int temp[MMC_DATA_SIZE/4];
  875   1      
  876   1          
  877   1          // load block 0
  878   1          mmc_read_block_int(0,temp); // load data to temp
  879   1      
  880   1          // check message for new program if different then load fail
  881   1          for(i = 0;i < sizeof(ckmsg);i++)
  882   1          {
  883   2              if(temp[i] != ckmsg[i])
  884   2                  return 0;
  885   2          }
  886   1          printf("\n");
  887   1          for(j = 0;j < i;j++)
  888   1          {
  889   2              printf("%c",temp[j]);
  890   2          }
  891   1          printf("\n");
  892   1      
  893   1          // copy password from temp
  894   1          for(j = 0;j < MAX_PASSWORD;j++)
  895   1          {
  896   2              password[j] = temp[i];
  897   2              i++; 
  898   2          }
  899   1      
  900   1          // load block 1-50
  901   1          for(i = 0;i < MAX_NUMBER_USER;i++)
  902   1          {
  903   2              mmc_read_block_int(1+i,temp); // load data to temp
  904   2              
  905   2              // if temp has data then copy password user and save time to password user storage
  906   2              if(temp[0] != '\0')
  907   2              {
  908   3                  for(j = 0;j < MAX_PASSWORD_USER;j++)
  909   3                  {
  910   4                      PassUser[i].passwordUser[j] = temp[j];
  911   4                  }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 15  

  912   3                  PassUser[i].day = temp[MAX_PASSWORD_USER];
  913   3                  PassUser[i].month = temp[MAX_PASSWORD_USER+1];
  914   3                  PassUser[i].year = temp[MAX_PASSWORD_USER+2];
  915   3                  PassUser[i].hour = temp[MAX_PASSWORD_USER+3];
  916   3                  PassUser[i].minute = temp[MAX_PASSWORD_USER+4];
  917   3                  PassUser[i].sec = temp[MAX_PASSWORD_USER+5];
  918   3              }
  919   2          }
  920   1          
  921   1          // load block 51-100
  922   1          for(i = 0;i < MAX_RFID_CARD;i++)
  923   1          {
  924   2              mmc_read_block_int(51+i,temp); // load data to temp
  925   2              
  926   2              // if temp has data then copy ID of RFID card and save time to RFID card storage
  927   2              if(temp[0] != 0)
  928   2              {
  929   3                  memoryRFID[i].datarfid = temp[0];
  930   3                  memoryRFID[i].day = temp[1];
  931   3                  memoryRFID[i].month = temp[2];
  932   3                  memoryRFID[i].year = temp[3];
  933   3                  memoryRFID[i].hour = temp[4];
  934   3                  memoryRFID[i].minute = temp[5];
  935   3                  memoryRFID[i].sec = temp[6];
  936   3              }
  937   2          }
  938   1          
  939   1          // load block 101-150
  940   1          for(i = 0;i < MAX_RFID_CARD;i++)
  941   1          {
  942   2              mmc_read_block_int(101+i,temp); // load data to temp
  943   2              
  944   2              // if temp has data then copy to RFID card open door time storage
  945   2              if(temp[0] != 0)
  946   2              {
  947   3                  memoryTem[i].datarfid = temp[0];
  948   3                  memoryTem[i].day = temp[1];
  949   3                  memoryTem[i].month = temp[2];
  950   3                  memoryTem[i].year = temp[3];
  951   3                  memoryTem[i].hour = temp[4];
  952   3                  memoryTem[i].minute = temp[5];
  953   3                  memoryTem[i].sec = temp[6];
  954   3              }
  955   2          } 
  956   1      
  957   1          // load block 151-200
  958   1          for(i = 0;i < MAX_NUMBER_USER;i++)
  959   1          {
  960   2              mmc_read_block_int(151+i,temp); // load data to temp
  961   2      
  962   2              // if temp has data then copy to password user open door time storage
  963   2              if(temp[0] != '\0')
  964   2              {
  965   3                  for(j = 0;j < MAX_PASSWORD_USER;j++)
  966   3                  {
  967   4                      PassUserTime[i].passwordUser[j] = temp[j];
  968   4                  }
  969   3                  PassUserTime[i].day = temp[MAX_PASSWORD_USER];
  970   3                  PassUserTime[i].month = temp[MAX_PASSWORD_USER+1];
  971   3                  PassUserTime[i].year = temp[MAX_PASSWORD_USER+2];
  972   3                  PassUserTime[i].hour = temp[MAX_PASSWORD_USER+3];
  973   3                  PassUserTime[i].minute = temp[MAX_PASSWORD_USER+4];
  974   3                  PassUserTime[i].sec = temp[MAX_PASSWORD_USER+5];
  975   3              }
  976   2          }
  977   1          
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 16  

  978   1          // load block 201
  979   1          mmc_read_block_int(201,temp); // load data to temp
  980   1          
  981   1          // copy data from temp to global variable
  982   1          lMemTem = temp[0];
  983   1          lMemRFID = temp[1];
  984   1          lPasswordUser = temp[2]; 
  985   1          lPasswordUserTime = temp[3];
  986   1      
  987   1          return 1; // if load complete then return 1
  988   1      }
  989          
  990          // this function use for save data to sd/mmc 
  991          // number = 0 is for check message and password
  992          // number = 1 is for password user
  993          // number = 2 is for RFID Card data
  994          // number = 3 is for RFID card open door time
  995          // number = 4 is for password user open door time  
  996          int savedata_mmc(int number)
  997          {
  998   1          /*
  999   1             block 0 for check and password ===> Number 0
 1000   1             block 1 to 50 for password user ===> Number 1
 1001   1             block 51 to 100 for RFID Card data ===> Number 2
 1002   1             block 101 to 150 for RFID stamp time ===> Number 3
 1003   1             block 151 to 200 fot password user time ===>Number 4
 1004   1             block 201 for global variable
 1005   1      
 1006   1             block 401 for pic state compare
 1007   1             block 402 for pic enter password to state config
 1008   1             block 403 for menu 1 change password
 1009   1             block 404 for menu 2 set time
 1010   1             block 405 for menu 3 save rfid card
 1011   1             block 406 for menu 4 delete rfid card
 1012   1             block 407 for menu 5 add password user
 1013   1             block 408 for menu 6 delete password user
 1014   1             block 409 for menu 7 RFID save time
 1015   1             block 410 for menu 8 Password User save time
 1016   1             block 411 for menu 9 Stamp time
 1017   1             block 412 for menu 0 Show time
 1018   1      
 1019   1             block 413 for pic close door
 1020   1             block 414 for pic open door
 1021   1             block 415 for pic check fail
 1022   1             block 416 for pic store complete
 1023   1             block 417 for pic store fail
 1024   1             block 418 for pic wait card
 1025   1             block 419 for pic wait pass
 1026   1             block 420 for pic delete complete
 1027   1             block 421 for pic delete fail
 1028   1             block 422 for pic Enter day month year time
 1029   1             block 423 for pic Enter Time
 1030   1           */
 1031   1          int i = 0,j = 0;
 1032   1          int temp[MMC_DATA_SIZE/4];
 1033   1          
 1034   1          if(number == 0) // number = 0 is for check message and password
 1035   1          {
 1036   2              // add check message for new program to temp
 1037   2              for(i = 0;i < sizeof(ckmsg);i++)
 1038   2              {
 1039   3                  temp[i] = ckmsg[i];
 1040   3              }
 1041   2      
 1042   2              // add password to temp
 1043   2              for(j = 0;j < MAX_PASSWORD;j++)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 17  

 1044   2              {
 1045   3                  temp[i] = password[j];
 1046   3                  i++; 
 1047   3              }
 1048   2      
 1049   2              // write data from temp to mmc 
 1050   2              if(mmc_write_block_int(0,temp) != 0)
 1051   2              {
 1052   3                  return 0; // write fail return 0
 1053   3              }
 1054   2              return 1;   
 1055   2          }
 1056   1          else if(number == 1) // number = 1 is for password user
 1057   1          {
 1058   2              for(i = 0;i < MAX_NUMBER_USER;i++)
 1059   2              {
 1060   3                  // if password user has data then add password user and save time to temp
 1061   3                  if(PassUser[i].passwordUser[0] != '\0')
 1062   3                  {
 1063   4                      for(j = 0;j < MAX_PASSWORD_USER;j++)
 1064   4                      {
 1065   5                          temp[j] = PassUser[i].passwordUser[j];
 1066   5                      }
 1067   4                      temp[MAX_PASSWORD_USER] = PassUser[i].day;
 1068   4                      temp[MAX_PASSWORD_USER+1] = PassUser[i].month;
 1069   4                      temp[MAX_PASSWORD_USER+2] = PassUser[i].year;
 1070   4                      temp[MAX_PASSWORD_USER+3] = PassUser[i].hour;
 1071   4                      temp[MAX_PASSWORD_USER+4] = PassUser[i].minute;
 1072   4                      temp[MAX_PASSWORD_USER+5] = PassUser[i].sec;
 1073   4      
 1074   4                      // write data from temp to mmc
 1075   4                      if(mmc_write_block_int(1+i,temp) != 0)
 1076   4                      {
 1077   5                          return 0; // write fail return 0
 1078   5                      }
 1079   4                  }
 1080   3                  // if password user not has data then add no data to temp
 1081   3                  else
 1082   3                  {
 1083   4                      temp[0] = '\0';
 1084   4      
 1085   4                      // write data from temp to mmc
 1086   4                      if(mmc_write_block_int(1+i,temp) != 0)
 1087   4                      {
 1088   5                          return 0; // write fail return 0
 1089   5                      }
 1090   4                  }
 1091   3              }
 1092   2      
 1093   2              // add global variable to temp
 1094   2              temp[0] = lMemTem;
 1095   2              temp[1] = lMemRFID;
 1096   2              temp[2] = lPasswordUser;
 1097   2              temp[3] = lPasswordUserTime;
 1098   2      
 1099   2              // write data from temp to mmc
 1100   2              if(mmc_write_block_int(201,temp) != 0)
 1101   2              {
 1102   3                  return 0; // write fail return 0
 1103   3              }
 1104   2      
 1105   2              return 1; // write complete return 1
 1106   2          }
 1107   1          else if(number == 2) // number = 2 is for RFID Card data
 1108   1          {
 1109   2              for(i = 0;i < MAX_RFID_CARD;i++)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 18  

 1110   2              {
 1111   3                  // if RFID card has data then add ID of RFID card and save time to temp
 1112   3                  if(memoryRFID[i].datarfid != 0)
 1113   3                  {
 1114   4                      temp[0] = memoryRFID[i].datarfid;
 1115   4                      temp[1] = memoryRFID[i].day;
 1116   4                      temp[2] = memoryRFID[i].month;
 1117   4                      temp[3] = memoryRFID[i].year;
 1118   4                      temp[4] = memoryRFID[i].hour;
 1119   4                      temp[5] = memoryRFID[i].minute;
 1120   4                      temp[6] = memoryRFID[i].sec;
 1121   4      
 1122   4                      // write data from temp to mmc
 1123   4                      if(mmc_write_block_int(51+i,temp) != 0)
 1124   4                      {
 1125   5                          return 0; // write fail return 0
 1126   5                      }
 1127   4                  }
 1128   3                  // if RFID card not has data then add zero data to temp
 1129   3                  else
 1130   3                  {
 1131   4                      temp[0] = 0;
 1132   4      
 1133   4                      // write data from temp to mmc
 1134   4                      if(mmc_write_block_int(51+i,temp) != 0)
 1135   4                      {
 1136   5                          return 0; // write fail return 0
 1137   5                      }
 1138   4                  }
 1139   3              }
 1140   2      
 1141   2              // add global variable to temp
 1142   2              temp[0] = lMemTem;
 1143   2              temp[1] = lMemRFID;
 1144   2              temp[2] = lPasswordUser;
 1145   2              temp[3] = lPasswordUserTime;
 1146   2      
 1147   2              // write data from temp to mmc
 1148   2              if(mmc_write_block_int(201,temp) != 0)
 1149   2              {
 1150   3                  return 0; // write fail return 0
 1151   3              }
 1152   2      
 1153   2              return 1; // write complete return 1
 1154   2          }
 1155   1          else if(number == 3) // number = 3 is for RFID card open door time
 1156   1          {
 1157   2              for(i = 0;i < MAX_RFID_CARD;i++)
 1158   2              {
 1159   3                  // if rfid card open door time has data then add rfid card open door time data to temp
 1160   3                  if(memoryTem[i].datarfid != 0)
 1161   3                  {
 1162   4                      temp[0] = memoryTem[i].datarfid;
 1163   4                      temp[1] = memoryTem[i].day;
 1164   4                      temp[2] = memoryTem[i].month;
 1165   4                      temp[3] = memoryTem[i].year;
 1166   4                      temp[4] = memoryTem[i].hour;
 1167   4                      temp[5] = memoryTem[i].minute;
 1168   4                      temp[6] = memoryTem[i].sec;
 1169   4                  
 1170   4                      // write data from temp to mmc
 1171   4                      if(mmc_write_block_int(101+i,temp) != 0)
 1172   4                      {
 1173   5                          return 0; // write fail return 0
 1174   5                      }
 1175   4                  }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 19  

 1176   3                  // if rfid card open door time not has data then add zero data to temp
 1177   3                  else
 1178   3                  {
 1179   4                      temp[0] = 0;
 1180   4      
 1181   4                      // write data from temp to mmc
 1182   4                      if(mmc_write_block_int(101+i,temp) != 0)
 1183   4                      {
 1184   5                          return 0; // write fail return 0
 1185   5                      }
 1186   4                  }
 1187   3              }
 1188   2      
 1189   2              // add global variable to temp
 1190   2              temp[0] = lMemTem;
 1191   2              temp[1] = lMemRFID;
 1192   2              temp[2] = lPasswordUser;
 1193   2              temp[3] = lPasswordUserTime;
 1194   2      
 1195   2              // write data from temp to mmc
 1196   2              if(mmc_write_block_int(201,temp) != 0)
 1197   2              {
 1198   3                  return 0; // write fail return 0
 1199   3              }
 1200   2      
 1201   2              return 1; // write complete return 1
 1202   2          }
 1203   1          else if(number == 4) // number = 4 is for password user open door time
 1204   1          {
 1205   2              for(i = 0;i < MAX_NUMBER_USER;i++)
 1206   2              {
 1207   3                  // if password user open door time has data then add password user open door time data to temp
 1208   3                  if(PassUserTime[i].passwordUser[0] != '\0')
 1209   3                  {
 1210   4                      for(j = 0;j < MAX_PASSWORD_USER;j++)
 1211   4                      {
 1212   5                          temp[j] = PassUserTime[i].passwordUser[j];
 1213   5                      }
 1214   4                      temp[MAX_PASSWORD_USER] = PassUserTime[i].day;
 1215   4                      temp[MAX_PASSWORD_USER+1] = PassUserTime[i].month;
 1216   4                      temp[MAX_PASSWORD_USER+2] = PassUserTime[i].year;
 1217   4                      temp[MAX_PASSWORD_USER+3] = PassUserTime[i].hour;
 1218   4                      temp[MAX_PASSWORD_USER+4] = PassUserTime[i].minute;
 1219   4                      temp[MAX_PASSWORD_USER+5] = PassUserTime[i].sec;
 1220   4      
 1221   4                      // write data from temp to mmc
 1222   4                      if(mmc_write_block_int(151+i,temp) != 0)
 1223   4                      {
 1224   5                          return 0; // write fail return 0
 1225   5                      }
 1226   4                  }
 1227   3                  // if password user open door time not has data then add no data to temp
 1228   3                  else
 1229   3                  {
 1230   4                      temp[0] = '\0';
 1231   4      
 1232   4                      // write data from temp to mmc
 1233   4                      if(mmc_write_block_int(151+i,temp) != 0)
 1234   4                      {
 1235   5                          return 0; // write fail return 0
 1236   5                      }
 1237   4                  }
 1238   3              }
 1239   2              
 1240   2              // add global variable to temp
 1241   2              temp[0] = lMemTem;
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 20  

 1242   2              temp[1] = lMemRFID;
 1243   2              temp[2] = lPasswordUser;
 1244   2              temp[3] = lPasswordUserTime;
 1245   2      
 1246   2              // write data from temp to mmc
 1247   2              if(mmc_write_block_int(201,temp) != 0)
 1248   2              {
 1249   3                  return 0; // write fail return 0
 1250   3              }
 1251   2      
 1252   2              return 1; // write complete return 1
 1253   2          }
 1254   1      
 1255   1          return 0; // write fail return 0
 1256   1      }
 1257          
 1258          // this function use for clear data of sd/mmc
 1259          int cleardata_mmc()
 1260          {
 1261   1          int i = 0,j = 0;
 1262   1          int temp[MMC_DATA_SIZE/4];
 1263   1          
 1264   1          // add no data to temp
 1265   1          for(i = 0;i < MAX_NUMBER_USER;i++)
 1266   1          {
 1267   2              for(j = 0;j < MAX_PASSWORD_USER;j++)
 1268   2              {
 1269   3                  temp[j] = '\0';
 1270   3              }
 1271   2      
 1272   2              // write data from temp to mmc
 1273   2              if(mmc_write_block_int(1+i,temp) != 0)
 1274   2              {
 1275   3                  return 0; // write fail return 0
 1276   3              }
 1277   2          }
 1278   1      
 1279   1          // add zero data to temp
 1280   1          for(i = 0;i < MAX_RFID_CARD;i++)
 1281   1          {
 1282   2              temp[0] = 0;
 1283   2              temp[1] = 0;
 1284   2              temp[2] = 0;
 1285   2              temp[3] = 0;
 1286   2              temp[4] = 0;
 1287   2              temp[5] = 0;
 1288   2              temp[6] = 0;
 1289   2              
 1290   2              // write data from temp to mmc
 1291   2              if(mmc_write_block_int(51+i,temp) != 0)
 1292   2              {
 1293   3                  return 0; // write fail return 0
 1294   3              }
 1295   2          }
 1296   1      
 1297   1          // add zero data to temp
 1298   1          for(i = 0;i < MAX_RFID_CARD;i++)
 1299   1          {
 1300   2              temp[0] = 0;
 1301   2              temp[1] = 0;
 1302   2              temp[2] = 0;
 1303   2              temp[3] = 0;
 1304   2              temp[4] = 0;
 1305   2              temp[5] = 0;
 1306   2              temp[6] = 0;
 1307   2              
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 21  

 1308   2              // write data from temp to mmc  
 1309   2              if(mmc_write_block_int(101+i,temp) != 0)
 1310   2              {
 1311   3                  return 0; // write fail return 0
 1312   3              }
 1313   2          }
 1314   1      
 1315   1          // add no data to temp
 1316   1          for(i = 0;i < MAX_NUMBER_USER;i++)
 1317   1          {
 1318   2              for(j = 0;j < MAX_PASSWORD_USER;j++)
 1319   2              {
 1320   3                  temp[j] = '\0';
 1321   3              }
 1322   2      
 1323   2              // write data from temp to mmc
 1324   2              if(mmc_write_block_int(151+i,temp) != 0)
 1325   2              {
 1326   3                  return 0; // write fail return 0
 1327   3              }
 1328   2          }
 1329   1      
 1330   1          // add zero data to temp
 1331   1          temp[1] = 0;
 1332   1          temp[2] = 0;
 1333   1          temp[3] = 0;
 1334   1          temp[4] = 0;
 1335   1      
 1336   1          // write data from temp to mmc
 1337   1          if(mmc_write_block_int(201,temp) != 0)
 1338   1          {
 1339   2              return 0; // write fail return 0
 1340   2          }
 1341   1      
 1342   1          return 1; // write complete return 1
 1343   1      }
 1344          
 1345          // this function use for load picture from sd/mmc
 1346          void loadpic_mmc(int blocknum)
 1347          {
 1348   1          int i =0;
 1349   1          char temp[MMC_DATA_SIZE] = { '\0' };
 1350   1      
 1351   1          // load data to temp
 1352   1          mmc_read_block_char(blocknum,temp);
 1353   1          
 1354   1          // copy from temp to temp picture
 1355   1          for(i = 0;i < 504;i++)
 1356   1          {
 1357   2              temppic[i] = temp[i];
 1358   2          }
 1359   1      }
 1360          
 1361          // this function use for set date and time
 1362          void settime(void)
 1363          {
 1364   1          int minutenew = 0,hournew = 0,daynew = 0,monthnew = 0,yearnew = 0,daymod = 0;
 1365   1      
 1366   1          //------ date zone ------
 1367   1      
 1368   1          loadpic_mmc(422); // load picture from sd/mmc
 1369   1          lcd_fill_picture(temppic); // show picture on lcd
 1370   1          receive_keypad(6); // receive data from keypad
 1371   1      
 1372   1          // check if all tempkey has data
 1373   1          if((tempkey[0] != '\0') && (tempkey[1] != '\0') && (tempkey[2] != '\0') && (tempkey[3] != '\0')
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 22  

 1374   1          &&(tempkey[4] != '\0') && (tempkey[5] != '\0') && (tempkey[6] != '\0') && (tempkey[7] != '\0'))
 1375   1          {
 1376   2              // convert tempkey to year
 1377   2              yearnew = (((tempkey[4]-48)*1000)+((tempkey[5]-48)*100)+((tempkey[6]-48)*10)+(tempkey[7]-48));
 1378   2      
 1379   2              // convert tempkey to month
 1380   2              monthnew = (((tempkey[2]-48)*10)+(tempkey[3]-48))%13;
 1381   2              if(monthnew == 0)
 1382   2                  monthnew++;
 1383   2          
 1384   2              // set day of month
 1385   2              if(monthnew == 1)
 1386   2              {
 1387   3                  daymod = 32;
 1388   3              }
 1389   2              else if(monthnew == 2)
 1390   2              {
 1391   3                  if((yearnew%4) == 0)
 1392   3                  {
 1393   4                      daymod = 30;
 1394   4                  }
 1395   3                  else
 1396   3                  {
 1397   4                      daymod = 29;
 1398   4                  }               
 1399   3              }
 1400   2              else if(monthnew == 3)
 1401   2              {
 1402   3                  daymod = 32;
 1403   3              }
 1404   2              else if(monthnew == 4)
 1405   2              {
 1406   3                  daymod = 31;
 1407   3              }
 1408   2              else if(monthnew == 5)
 1409   2              {
 1410   3                  daymod = 32;
 1411   3              }
 1412   2              else if(monthnew == 6)
 1413   2              {
 1414   3                  daymod = 31;
 1415   3              }
 1416   2              else if(monthnew == 7)
 1417   2              {
 1418   3                  daymod = 32;
 1419   3              }
 1420   2              else if(monthnew == 8)
 1421   2              {
 1422   3                  daymod = 32;
 1423   3              }
 1424   2              else if(monthnew == 9)
 1425   2              {
 1426   3                  daymod = 31;
 1427   3              }
 1428   2              else if(monthnew == 10)
 1429   2              {
 1430   3                  daymod = 32;
 1431   3              }
 1432   2              else if(monthnew == 11)
 1433   2              {
 1434   3                  daymod = 31;
 1435   3              }
 1436   2              else if(monthnew == 12)
 1437   2              {
 1438   3                  daymod = 32;
 1439   3              }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 23  

 1440   2              
 1441   2              // convert tempkey to day               
 1442   2              daynew = (((tempkey[0]-48)*10)+(tempkey[1]-48))%daymod;
 1443   2              if(daynew == 0)
 1444   2                  daynew++;
 1445   2           }
 1446   1      
 1447   1           setyear(yearnew); // set year = new year
 1448   1           setmonth(monthnew); // set month = new month
 1449   1           setday(daynew); // set day = new day
 1450   1      
 1451   1           //------ time zone ------
 1452   1      
 1453   1           printf("Enter time (hhmm) :");
 1454   1           loadpic_mmc(423); // load picture from sd/mmc
 1455   1           lcd_fill_picture(temppic); // show picture on lcd
 1456   1           receive_keypad(7); // receive data from keypad
 1457   1      
 1458   1           // check if all tempkey has data
 1459   1           if((tempkey[0] != '\0') && (tempkey[1] != '\0') && (tempkey[2] != '\0') && (tempkey[3] != '\0'))
 1460   1           {
 1461   2                  minutenew = (((tempkey[2]-48)*10)+(tempkey[3]-48))%60; // convert tempkey to minute
 1462   2                  hournew = (((tempkey[0]-48)*10)+(tempkey[1]-48))%24; // convert tempkey to hour
 1463   2           }
 1464   1      
 1465   1           setminute(minutenew); // set minute = new minute
 1466   1           sethour(hournew); // set hour = new hour
 1467   1           setsec(0); // set sec = 0
 1468   1      
 1469   1           printf("\n%d/%d/%d\n%d:%d:%d\n",day(),month(),year(),hour(),minute(),sec());
 1470   1      }
 1471          
 1472          
 1473          // main program
 1474          void main(void)
 1475          {    
 1476   1          char ch;
 1477   1          int value;
 1478   1          int j;
 1479   1      
 1480   1          init_serial0(); // initial serial port 0
 1481   1          init_keypad(); // initial keypad
 1482   1          
 1483   1          initTime(); // initial date and time
 1484   1          init_RFID(); // initial RFID Reader
 1485   1          SPI_Init(); // initial SPI1
 1486   1          lcd_initial(); // initial LCD                                           
 1487   1          lcd_clear_screen(); // clear LCD screen
 1488   1          if( mmc_init() != 0 ) // initial sd/mmc fail
 1489   1          {
 1490   2              printf("\nMMC init fail");
 1491   2          }
 1492   1          else // initial sd/mmc success
 1493   1          {
 1494   2              // load data from mmc
 1495   2              // if this a new program then load will fail and will clear data and save new check message to sd/mmc   
 1496   2              if(loaddata_mmc() == 0) // load fail
 1497   2              { 
 1498   3                  printf("Load fail\n");
 1499   3                  cleardata_mmc(); // clear data in sd/mmc
 1500   3                  if (savedata_mmc(0) == 0) // save fail
 1501   3                  {
 1502   4                      printf("Save fail\n");
 1503   4                  }
 1504   3                  else // save success
 1505   3                  {
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 24  

 1506   4                      printf("Save complete");
 1507   4                  }
 1508   3              }
 1509   2              // if this a old program then program will load data from sd/mmc
 1510   2              else // load success
 1511   2              {
 1512   3                  printf("Load complete");
 1513   3              }
 1514   2          }
 1515   1          
 1516   1          // change state to compare to ready for use
 1517   1          setStateCompare();
 1518   1      
 1519   1          printf("\n%d/%d/%d\n%d:%d:%d\n",day(),month(),year(),hour(),minute(),sec());
 1520   1      
 1521   1          // infinity loop 
 1522   1          while(1)
 1523   1          {
 1524   2              value = readRFID(); // get ID of RFID card
 1525   2              ch = keypad(); // get pressing key of keypad
 1526   2              
 1527   2              // if card has been stamp value will not be 0
 1528   2              // so in this if will be state that !!require stamp card to !!operate
 1529   2              if(value != 0) 
 1530   2              {
 1531   3                  // when state is compare, program will check ID of RFID card (value) to open door
 1532   3                  if(state == COMPARE)
 1533   3                  {
 1534   4                      // if has ID of RFID card in system then door will open and save door open time
 1535   4                      if(CheckRFIDCard(value) == 1) // check ID of RFID card (value) success (has ID of RFID card in system
             -)
 1536   4                      {
 1537   5                          inputMemTem(value); // save door open time by RFID card
 1538   5                          savedata_mmc(3); // save door open time to sd/mmc
 1539   5                          printf("Door Open\n");
 1540   5                          opendoor(); // open door
 1541   5                          printf("Door Close\n"); 
 1542   5                      }
 1543   4                      else //check ID of RFID card (value) fail (not has ID of RFID card in system)
 1544   4                      {
 1545   5                          printf("Wrong Card\n");
 1546   5                          loadpic_mmc(415); // load picture from sd/mmc
 1547   5                          lcd_fill_picture(temppic); // show picture on lcd
 1548   5                          delay_ms(1000);
 1549   5                          loadpic_mmc(401); // load picture from sd/mmc
 1550   5                          lcd_fill_picture(temppic); // show picture on lcd
 1551   5                      }
 1552   4                  }
 1553   3                  // when state is save, program will save ID of RFID card (value) to system
 1554   3                  else if(state == SAVE)
 1555   3                  {
 1556   4                      // if save ID of RFID card (value) success then program will save current ID of RFID card to sd/mmc t
             -oo
 1557   4                      if(inputMemRFID(value) == 1) // save ID of RFID card (value) success
 1558   4                      {
 1559   5                          savedata_mmc(2); // save current ID of RFID card to sd/mmc
 1560   5                          printf("ID card = %d\n",value);
 1561   5                          loadpic_mmc(416); // load picture from sd/mmc
 1562   5                          lcd_fill_picture(temppic); // show picture on lcd
 1563   5                          printf("Save RFID card OK!\n");
 1564   5                          delay_ms(1000);
 1565   5                      }
 1566   4                      else // save ID of RFID card (value) fail
 1567   4                      {
 1568   5                          loadpic_mmc(417); // load picture from sd/mmc
 1569   5                          lcd_fill_picture(temppic); // show picture on lcd
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 25  

 1570   5                          printf("This card already has been save\n");
 1571   5                          delay_ms(1000);
 1572   5                      }
 1573   4                      setStateConfig(); // back to menu
 1574   4                  }
 1575   3                  // when state is delete, program will delete ID of RFID card (value) from system
 1576   3                  else if( state == DELETE)
 1577   3                  {
 1578   4                      // if delete ID of RFID card (value) success then program will save current ID of RFID card to sd/mmc
             - too
 1579   4                      if(deleteMemRFID(value) == 1) // delete ID of RFID card (value) success
 1580   4                      {
 1581   5                          savedata_mmc(2); // save current ID of RFID card to sd/mmc
 1582   5                          loadpic_mmc(420); // load picture from sd/mmc
 1583   5                          lcd_fill_picture(temppic); // show picture on lcd
 1584   5                          printf("Delete RFID card OK!\n");
 1585   5                          delay_ms(1000);
 1586   5                      }
 1587   4                      else // delete ID of RFID card (value) fail
 1588   4                      {
 1589   5                          loadpic_mmc(421); // load picture from sd/mmc
 1590   5                          lcd_fill_picture(temppic); // show picture on lcd
 1591   5                          printf("Not found\n");
 1592   5                          delay_ms(1000);
 1593   5                      }
 1594   4                      setStateConfig(); // back to menu
 1595   4                  }
 1596   3              }
 1597   2              // when state is change password, program will receive and change password to enter menu
 1598   2              // and save new password to sd/mmc
 1599   2              else if (state == CHANGEPASS)
 1600   2              {
 1601   3                  loadpic_mmc(419); // load picture from sd/mmc
 1602   3                  lcd_fill_picture(temppic); // show picture on lcd
 1603   3                  receive_keypad(1); // receive data from keypad
 1604   3                  change_password(); // change password
 1605   3                  savedata_mmc(0); // save new password to sd/mmc
 1606   3                  loadpic_mmc(416); // load picture from sd/mmc
 1607   3                  lcd_fill_picture(temppic); // show picture on lcd
 1608   3                  delay_ms(1000);
 1609   3                  setStateConfig(); // back to menu
 1610   3              }
 1611   2              // when state is set time, program will receive and change date and time
 1612   2              else if(state == SETTIME)
 1613   2              {
 1614   3                   settime(); // receive and change date and time
 1615   3                   loadpic_mmc(416); // load picture from sd/mmc
 1616   3                   lcd_fill_picture(temppic); // show picture on lcd
 1617   3                   delay_ms(1000);
 1618   3                   setStateConfig(); // back to menu
 1619   3              }
 1620   2              // when state is add password, program will receive and add password user and save current password use
             -r to sd/mmc
 1621   2              else if(state == ADDPASSWORD)
 1622   2              {
 1623   3                   if(receive_keypad(3) != 0) // receive data from keypad success
 1624   3                   {
 1625   4                      if(addPasswordUser() == 1) // add password user success
 1626   4                      {
 1627   5                          savedata_mmc(1); // save current password user to sd/mmc
 1628   5                          loadpic_mmc(416); // load picture from sd/mmc
 1629   5                          lcd_fill_picture(temppic); // show picture on lcd
 1630   5                          printf("Save Password User OK!\n");
 1631   5                          delay_ms(1000);
 1632   5                      }
 1633   4                      else // add password user fail
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 26  

 1634   4                      {
 1635   5                          loadpic_mmc(417); // load picture from sd/mmc
 1636   5                          lcd_fill_picture(temppic); // show picture on lcd
 1637   5                          printf("This user already has been save\n");
 1638   5                          delay_ms(1000);
 1639   5                      }
 1640   4                   }
 1641   3                   else // receive data from keypad fail
 1642   3                   {
 1643   4                      printf("\nSave Password User Fail!\n");
 1644   4                   }
 1645   3                   setStateConfig(); // back to menu
 1646   3              }
 1647   2              // when state is delete password, program will receive and delete password user
 1648   2              // and save current password user to sd/mmc
 1649   2              else if(state == DELETEPASSWORD)
 1650   2              {
 1651   3                   if(receive_keypad(3) != 0) // receive data from keypad success
 1652   3                   {
 1653   4                      if(deletePasswordUser() == 1) // delete password user success
 1654   4                      {
 1655   5                          savedata_mmc(1); // save current password user to sd/mmc
 1656   5                          loadpic_mmc(420); // load picture from sd/mmc
 1657   5                          lcd_fill_picture(temppic); // show picture on lcd
 1658   5                          printf("Delete Password User OK!\n");
 1659   5                          delay_ms(1000);
 1660   5                      }
 1661   4                      else // delete password user fail
 1662   4                      {
 1663   5                          loadpic_mmc(421); // load picture from sd/mmc
 1664   5                          lcd_fill_picture(temppic); // show picture on lcd
 1665   5                          printf("Not Found\n");
 1666   5                          delay_ms(1000);
 1667   5                      }
 1668   4                   }
 1669   3                   else // receive data from keypad fail
 1670   3                   {
 1671   4                      printf("\nDelete Password User Fail!\n");
 1672   4                   }
 1673   3                   setStateConfig(); // back to menu
 1674   3              }
 1675   2              // program will check password user to open door
 1676   2              else if((ch != '$')&&(ch != '*')&&(ch != '#')&&(state == COMPARE))
 1677   2              {
 1678   3                  cleardata(); // clear tempkey
 1679   3                  tempkey[0] = ch;
 1680   3                  printf("%c",ch);
 1681   3                  if(receive_keypad(2) == 1) // receive data from keypad success
 1682   3                  {
 1683   4                      printf("\n");
 1684   4                      if(check_password(1) == 1) // check password user success (has password user in system)
 1685   4                      {
 1686   5                          addPasswordUserTime(); // save door open time by password user
 1687   5                          savedata_mmc(4);
 1688   5                          printf("Door Open\n");
 1689   5                          opendoor();
 1690   5                          printf("Door Close\n"); 
 1691   5                      }
 1692   4                      else // check password user fail (not has password user in system)
 1693   4                      {
 1694   5                          printf("Wrong Password User\n");
 1695   5                          delay_ms(1000);
 1696   5                          loadpic_mmc(415); // load picture from sd/mmc
 1697   5                          lcd_fill_picture(temppic); // show picture on lcd
 1698   5                          delay_ms(1000);
 1699   5                          loadpic_mmc(401); // load picture from sd/mmc
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 27  

 1700   5                          lcd_fill_picture(temppic); // show picture on lcd
 1701   5                      }
 1702   4                  }
 1703   3              }
 1704   2              // this is menu section can go by two way
 1705   2              // 1) key * has been press in state compare
 1706   2              // 2) back from other state
 1707   2              else if((ch == '*' && state != SAVE && state !=DELETE)||(state == CONFIG))
 1708   2              {
 1709   3                  // if back from other state then auto enter password
 1710   3                  if(state == CONFIG)
 1711   3                  {
 1712   4                      cleardata(); // clear tempkey
 1713   4                      for(j = 0;j < MAX_PASSWORD-1;j++) // auto enter password
 1714   4                          tempkey[j] = password[j];
 1715   4                  }
 1716   3                  // if come by key * then program will receive and check password
 1717   3                  else
 1718   3                  {
 1719   4                      printf("Enter Password :");
 1720   4                      loadpic_mmc(402); // load picture from sd/mmc
 1721   4                      lcd_fill_picture(temppic); // show picture on lcd
 1722   4                      receive_keypad(5);  // receive data from keypad
 1723   4                  }
 1724   3              
 1725   3                  if(check_password(2) == 1) // check password success (password right)
 1726   3                  {
 1727   4                      // if state is not a config then change state to config
 1728   4                      if(state != CONFIG)
 1729   4                      {
 1730   5                          setStateConfig();
 1731   5                      }
 1732   4                     
 1733   4                      if(receive_keypad(4) == 1) // receive menu success
 1734   4                      {
 1735   5                          if(tempkey[0] == '1' && tempkey[1] =='\0') // if select menu 1 then go to state change password
 1736   5                          {
 1737   6                              setStateChangepass(); // go to state change password
 1738   6                          }
 1739   5                          else if(tempkey[0] == '2' && tempkey[1] =='\0') // if select menu 2 then go to state set time
 1740   5                          {
 1741   6                              setStateSettime(); // go to state set time
 1742   6                          }
 1743   5                          else if(tempkey[0] == '3' && tempkey[1] =='\0') // if select menu 3 then go to state save
 1744   5                          {   
 1745   6                              setStateSave(); // go to state save
 1746   6                              timestate = (sec()+59)%60; // set time out
 1747   6                          }
 1748   5                          else if(tempkey[0] == '4' && tempkey[1] =='\0') // if select menu 4 then go to state delete
 1749   5                          {
 1750   6                              setStateDelete(); // go to state delete
 1751   6                              timestate = (sec()+59)%60; // set time out
 1752   6                          }
 1753   5                          else if(tempkey[0] == '5' && tempkey[1] =='\0') // if select menu 5 then go to state add password
 1754   5                          {
 1755   6                              setStateAddPassword(); // go to state add password                           
 1756   6                          }       
 1757   5                          else if(tempkey[0] == '6' && tempkey[1] =='\0') // if select menu 6 then go to state delete password
 1758   5                          {
 1759   6                              setStateDeletePassword(); // go to state delete password
 1760   6                          }
 1761   5                          else if(tempkey[0] == '7' && tempkey[1] =='\0') // if select menu 7 then show ID of RFID card
 1762   5                                                                          // and save time
 1763   5                          {
 1764   6                              for(j = 0;j < MAX_RFID_CARD;j++) // show all ID of RFID card and save time
 1765   6                              {
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 28  

 1766   7                                  if(memoryRFID[j].datarfid != 0)
 1767   7                                      printf("%d save at %d/%d/%d %d:%d:%d\n",memoryRFID[j].datarfid,memoryRFID[j].day
 1768   7                                          ,memoryRFID[j].month,memoryRFID[j].year,memoryRFID[j].hour
 1769   7                                          ,memoryRFID[j].minute,memoryRFID[j].sec);
 1770   7                              }
 1771   6                              
 1772   6                              setStateConfig(); // back to menu
 1773   6                          }
 1774   5                          else if(tempkey[0] == '8' && tempkey[1] == '\0') // if select menu 8 then show password user
 1775   5                                                                           // and save time
 1776   5                          {       
 1777   6                              for(j = 0;j < MAX_NUMBER_USER;j++) // show all password user and save time
 1778   6                              {
 1779   7                                  if(PassUser[j].passwordUser[0] != '\0')
 1780   7                                      printf("%s save at %d/%d/%d %d:%d:%d\n",PassUser[j].passwordUser,PassUser[j].day
 1781   7                                          ,PassUser[j].month,PassUser[j].year,PassUser[j].hour
 1782   7                                          ,PassUser[j].minute,PassUser[j].sec);
 1783   7                              }
 1784   6                              setStateConfig(); // back to menu
 1785   6                          }
 1786   5                          else if(tempkey[0] == '9' && tempkey[1] =='\0') // if select menu 9 then show door open time
 1787   5                                                                          // by RFID card and password user 
 1788   5                          {
 1789   6                              for(j = 0;j < MAX_RFID_CARD;j++) // show door open time by RFID card 
 1790   6                              {
 1791   7                                  if(memoryTem[j].datarfid != 0)
 1792   7                                      printf("%d stamp at %d/%d/%d %d:%d:%d\n",memoryTem[j].datarfid,memoryTem[j].day
 1793   7                                          ,memoryTem[j].month,memoryTem[j].year,memoryTem[j].hour
 1794   7                                          ,memoryTem[j].minute,memoryTem[j].sec);
 1795   7                              }
 1796   6              
 1797   6                              for(j = 0;j < MAX_NUMBER_USER;j++) // show door open time by password user
 1798   6                              {
 1799   7                                  if(PassUserTime[j].passwordUser[0] != '\0')
 1800   7                                      printf("%s use at %d/%d/%d %d:%d:%d\n",PassUserTime[j].passwordUser,PassUserTime[j].day
 1801   7                                          ,PassUserTime[j].month,PassUserTime[j].year,PassUserTime[j].hour
 1802   7                                          ,PassUserTime[j].minute,PassUserTime[j].sec);
 1803   7                              }
 1804   6                          
 1805   6                              setStateConfig(); // back to menu
 1806   6                          }
 1807   5                          else if(tempkey[0] == '0' && tempkey[1] =='\0') // if select menu 0 then show date and time
 1808   5                          {
 1809   6                              printf("\n%d/%d/%d\n%d:%d:%d\n",day(),month(),year(),hour(),minute(),sec());
 1810   6                              setStateConfig(); // back to menu
 1811   6                          }
 1812   5                          else
 1813   5                          {
 1814   6                              setStateConfig(); // back to menu
 1815   6                          }
 1816   5                      }
 1817   4                      else // receive menu fail
 1818   4                      {
 1819   5                          setStateCompare(); // go to state compare   
 1820   5                      }
 1821   4                  }
 1822   3                  else  // check password fail (password wrong)
 1823   3                  {
 1824   4                      printf("Wrong Password\n");
 1825   4                      setStateCompare(); // go to state compare   
 1826   4                  }
 1827   3              }
 1828   2              // check time out of state save and delete
 1829   2              else if(state == SAVE || state == DELETE)
 1830   2              {
 1831   3                  // if time out then go back to menu
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 29  

 1832   3                  if(sec()- timestate == 0)
 1833   3                  {
 1834   4                      setStateConfig(); // back to menu
 1835   4                  }
 1836   3              }       
 1837   2          }
 1838   1      }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 30  

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN CODE16 (printf?T)
 EXTERN CODE16 (init_RFID?T)
 EXTERN CODE16 (readRFID?T)
 EXTERN CODE16 (initTime?T)
 EXTERN CODE16 (sec?T)
 EXTERN CODE16 (minute?T)
 EXTERN CODE16 (hour?T)
 EXTERN CODE16 (setminute?T)
 EXTERN CODE16 (sethour?T)
 EXTERN CODE16 (setsec?T)
 EXTERN CODE16 (day?T)
 EXTERN CODE16 (month?T)
 EXTERN CODE16 (year?T)
 EXTERN CODE16 (setday?T)
 EXTERN CODE16 (setmonth?T)
 EXTERN CODE16 (setyear?T)
 EXTERN CODE16 (init_keypad?T)
 EXTERN CODE16 (delay_ms?T)
 EXTERN CODE16 (keypad?T)
 EXTERN CODE16 (init_serial0?T)
 EXTERN CODE16 (SPI_Init?T)
 EXTERN CODE16 (mmc_init?T)
 EXTERN CODE16 (mmc_read_block_int?T)
 EXTERN CODE16 (mmc_read_block_char?T)
 EXTERN CODE16 (mmc_write_block_int?T)
 EXTERN CODE16 (lcd_initial?T)
 EXTERN CODE16 (lcd_clear_screen?T)
 EXTERN CODE16 (lcd_fill_picture?T)
 EXTERN CODE16 (lcd_gotoxy?T)
 EXTERN CODE16 (lcd_put_char?T)
 EXTERN CODE16 (?C?SDIV?T)
 EXTERN NUMBER (__startup)



*** PUBLICS:
 PUBLIC         receive_keypad?T
 PUBLIC         check_password?T
 PUBLIC         change_password?T
 PUBLIC         loadpic_mmc?T
 PUBLIC         cleardata?T
 PUBLIC         setStateCompare?T
 PUBLIC         setStateConfig?T
 PUBLIC         setStateChangepass?T
 PUBLIC         setStateSettime?T
 PUBLIC         setStateSave?T
 PUBLIC         setStateDelete?T
 PUBLIC         setStateAddPassword?T
 PUBLIC         setStateDeletePassword?T
 PUBLIC         CheckRFIDCard?T
 PUBLIC         inputMemTem?T
 PUBLIC         inputMemRFID?T
 PUBLIC         deleteMemRFID?T
 PUBLIC         addPasswordUser?T
 PUBLIC         addPasswordUserTime?T
 PUBLIC         deletePasswordUser?T
 PUBLIC         opendoor?T
 PUBLIC         loaddata_mmc?T
 PUBLIC         savedata_mmc?T
 PUBLIC         cleardata_mmc?T
 PUBLIC         settime?T
 PUBLIC         main
 PUBLIC         timestate
 PUBLIC         state
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 31  

 PUBLIC         lMemTem
 PUBLIC         lMemRFID
 PUBLIC         lPasswordUser
 PUBLIC         lPasswordUserTime
 PUBLIC         menuold
 PUBLIC         tempkey
 PUBLIC         password
 PUBLIC         temppic
 PUBLIC         ckmsg
 PUBLIC         memoryTem
 PUBLIC         memoryRFID
 PUBLIC         PassUserTime
 PUBLIC         PassUser



*** DATA SEGMENT '?CON?main':
 00000000          ??S_66:
 00000000            DB          'Wrong Password',0x0A,0x00
 00000010          ??S_65:
 00000010            DB          '%s use at %d/%d/%d %d:%d:%d',0x0A,0x00
 0000002D          ??S_64:
 0000002D            DB          '%d stamp at %d/%d/%d %d:%d:%d',0x0A,0x00
 0000004C          ??S_63:
 0000004C            DB          '%s save at %d/%d/%d %d:%d:%d',0x0A,0x00
 0000006A          ??S_62:
 0000006A            DB          '%d save at %d/%d/%d %d:%d:%d',0x0A,0x00
 00000088          ??S_61:
 00000088            DB          'Enter Password :',0x00
 00000099          ??S_60:
 00000099            DB          'Wrong Password User',0x0A,0x00
 000000AE          ??S_59:
 000000AE            DB          0x0A,'Delete Password User Fail!',0x0A
 000000CA            DB          0x00
 000000CB          ??S_58:
 000000CB            DB          'Not Found',0x0A,0x00
 000000D6          ??S_57:
 000000D6            DB          'Delete Password User OK!',0x0A,0x00
 000000F0          ??S_56:
 000000F0            DB          0x0A,'Save Password User Fail!',0x0A,0x00
 0000010B          ??S_55:
 0000010B            DB          'This user already has been save',0x0A
 0000012B            DB          0x00
 0000012C          ??S_54:
 0000012C            DB          'Save Password User OK!',0x0A,0x00
 00000144          ??S_53:
 00000144            DB          'Not found',0x0A,0x00
 0000014F          ??S_52:
 0000014F            DB          'Delete RFID card OK!',0x0A,0x00
 00000165          ??S_51:
 00000165            DB          'This card already has been save',0x0A
 00000185            DB          0x00
 00000186          ??S_50:
 00000186            DB          'Save RFID card OK!',0x0A,0x00
 0000019A          ??S_49:
 0000019A            DB          'ID card = %d',0x0A,0x00
 000001A8          ??S_48:
 000001A8            DB          'Wrong Card',0x0A,0x00
 000001B4          ??S_47:
 000001B4            DB          'Door Close',0x0A,0x00
 000001C0          ??S_46:
 000001C0            DB          'Door Open',0x0A,0x00
 000001CB          ??S_45:
 000001CB            DB          'Load complete',0x00
 000001D9          ??S_44:
 000001D9            DB          'Save complete',0x00
 000001E7          ??S_43:
 000001E7            DB          'Save fail',0x0A,0x00
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 32  

 000001F2          ??S_42:
 000001F2            DB          'Load fail',0x0A,0x00
 000001FD          ??S_41:
 000001FD            DB          0x0A,'MMC init fail',0x00
 0000020C          ??S_40:
 0000020C            DB          0x0A,'%d/%d/%d',0x0A,'%d:%d:%d',0x0A,0x00
 00000220          ??S_39:
 00000220            DB          'Enter time (hhmm) :',0x00
 00000234          ??S_38:
 00000234            DB          '* State Delete Password *',0x0A,0x00
 0000024F          ??S_37:
 0000024F            DB          'Enter Password User :',0x00
 00000265          ??S_36:
 00000265            DB          '* State Add Password *',0x0A,0x00
 0000027D          ??S_35:
 0000027D            DB          '**********************',0x0A,0x00
 00000295          ??S_34:
 00000295            DB          '* State Delete *',0x0A,0x00
 000002A7          ??S_33:
 000002A7            DB          'Please Stamp Card in 1 minute',0x0A,0x00
 000002C6          ??S_32:
 000002C6            DB          '* State Save *',0x0A,0x00
 000002D6          ??S_31:
 000002D6            DB          '**************',0x0A,0x00
 000002E6          ??S_30:
 000002E6            DB          'Enter Time (ddmmyyyy) :',0x00
 000002FE          ??S_29:
 000002FE            DB          '* State Set Time *',0x0A,0x00
 00000312          ??S_28:
 00000312            DB          '******************',0x0A,0x00
 00000326          ??S_27:
 00000326            DB          'Enter New Password :',0x00
 0000033B          ??S_26:
 0000033B            DB          '* State Change Password *',0x0A,0x00
 00000356          ??S_25:
 00000356            DB          '*************************',0x0A,0x00
 00000371          ??S_24:
 00000371            DB          'Select Menu :',0x00
 0000037F          ??S_23:
 0000037F            DB          '[0] Show time',0x0A,0x00
 0000038E          ??S_22:
 0000038E            DB          '[9] Show Stamp time',0x0A,0x00
 000003A3          ??S_21:
 000003A3            DB          '[8] Show password user save time',0x0A
 000003C4            DB          0x00
 000003C5          ??S_20:
 000003C5            DB          '[7] Show RFID card save time',0x0A,0x00
 000003E3          ??S_19:
 000003E3            DB          '[6] Delete password user',0x0A,0x00
 000003FD          ??S_18:
 000003FD            DB          '[5] Add password user',0x0A,0x00
 00000414          ??S_17:
 00000414            DB          '[4] Delete RFID card',0x0A,0x00
 0000042A          ??S_16:
 0000042A            DB          '[3] Save RFID card',0x0A,0x00
 0000043E          ??S_15:
 0000043E            DB          '[2] Set time',0x0A,0x00
 0000044C          ??S_14:
 0000044C            DB          '[1] Change password',0x0A,0x00
 00000461          ??S_13:
 00000461            DB          '****************',0x0A,0x00
 00000473          ??S_12:
 00000473            DB          '* State Config *',0x0A,0x00
 00000485          ??S_11:
 00000485            DB          0x0A,'****************',0x0A,0x00
 00000498          ??S_10:
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 33  

 00000498            DB          '*****************',0x0A,0x00
 000004AB          ??S_9:
 000004AB            DB          '* State Compare *',0x0A,0x00
 000004BE          ??S_8:
 000004BE            DB          0x0A,'*****************',0x0A,0x00
 000004D2          ??S_7:
 000004D2            DB          0x08,'%c',0x00
 000004D6          ??S_6:
 000004D6            DB          ' ',0x00
 000004D8          ??S_5:
 000004D8            DB          '%c',0x00
 000004DB          ??S_4:
 000004DB            DB          0x08,' ',0x08,0x00
 000004DF          ??S_3:
 000004DF            DB          0x0A,0x00
 000004E1            ALIGN       4
 000004E4          ?tpl?0001:
 000004E4           BEGIN_INIT
 000004E4  00        DB          0x0
 000004E5            SPACE       511
 000006E4           END_INIT

*** DATA SEGMENT '?DT0?main':
 00000000          timestate:
 00000000           BEGIN_INIT
 00000000  00000000  DD          0x0
 00000004           END_INIT
 00000004          state:
 00000004            DS          4
 00000008          lMemTem:
 00000008           BEGIN_INIT
 00000008  00000000  DD          0x0
 0000000C           END_INIT
 0000000C          lMemRFID:
 0000000C           BEGIN_INIT
 0000000C  00000000  DD          0x0
 00000010           END_INIT
 00000010          lPasswordUser:
 00000010           BEGIN_INIT
 00000010  00000000  DD          0x0
 00000014           END_INIT
 00000014          lPasswordUserTime:
 00000014           BEGIN_INIT
 00000014  00000000  DD          0x0
 00000018           END_INIT
 00000018          memoryTem:
 00000018            DS          1400
 00000590          memoryRFID:
 00000590            DS          1400
 00000B08          PassUserTime:
 00000B08            DS          1600
 00001148          PassUser:
 00001148            DS          1600
 00001788          menuold:
 00001788           BEGIN_INIT
 00001788  31        DB          0x31
 00001789           END_INIT
 00001789          tempkey:
 00001789            DS          9
 00001792          password:
 00001792           BEGIN_INIT
 00001792            DB          '111',0x00
 00001796            SPACE       5
 0000179B           END_INIT
 0000179B          temppic:
 0000179B            DS          504
 00001993          ckmsg:
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 34  

 00001993           BEGIN_INIT
 00001993            DB          'E-block Check 9',0x00
 000019A3           END_INIT



*** CODE SEGMENT '?PR?cleardata?T?main':
   84: void cleardata(){
 00000000            ; SCOPE-START
   87:     for(i = 0;i < MAX_PASSWORD;i++)
 00000000  2000      MOV         R0,#0x0
 00000002  ---- Variable 'i' assigned to Register 'R0' ----
 00000002          L_4:
   89:          tempkey[i] = '\0';
 00000002  2100      MOV         R1,#0x0
 00000004  1C03      MOV         R3,R0 ; i
 00000006  4800      LDR         R2,=tempkey ; tempkey
 00000008  54D1      STRB        R1,[R2,R3]
   90:     }
 0000000A  3001      ADD         R0,#0x1
 0000000C  1C01      MOV         R1,R0 ; i
 0000000E  2909      CMP         R1,#0x9 ; i
 00000010  DBF7      BLT         L_4  ; T=0x00000002
 00000012            ; SCOPE-END
   91: }
 00000012  4770      BX          R14
 00000014          ENDP ; 'cleardata?T'


*** CODE SEGMENT '?PR?receive_keypad?T?main':
   94: int receive_keypad(int mode)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C07      MOV         R7,R0 ; mode
 00000004  ---- Variable 'mode' assigned to Register 'R7' ----
 00000004  B081      SUB         R13,#0x4
   95: {
 00000006            ; SCOPE-START
   96:     char key = '$';
 00000006  2624      MOV         R6,#0x24
 00000008  ---- Variable 'key' assigned to Register 'R6' ----
   97:     int i = 0,initial;
 00000008  2500      MOV         R5,#0x0
 0000000A  ---- Variable 'i' assigned to Register 'R5' ----
   99:     sec_starts = (sec()+30)%60; // set time out 30 second
 0000000A  F7FF      BL          sec?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          sec?T  ; T=0x0001  (2)
 0000000E  301E      ADD         R0,#0x1E
 00000010  213C      MOV         R1,#0x3C
 00000012  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000014  FFF5      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000016  1C01      MOV         R1,R0
 00000018  1C0C      MOV         R4,R1
 0000001A  ---- Variable 'sec_starts' assigned to Register 'R4' ----
  103:     if(mode == 1)// mode 1 is use for change password
 0000001A  1C38      MOV         R0,R7 ; mode
 0000001C  2801      CMP         R0,#0x1 ; mode
 0000001E  D15B      BNE         L_6  ; T=0x000000D8
  105:         cleardata(); // clear tempkey
 00000020  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 00000022  FFEE      BL          cleardata?T  ; T=0x0001  (2)
  106:         do
 00000024          L_7:
  108:             key = keypad(); // receivce charecter from keypad
 00000024  F7FF      BL          keypad?T  ; T=0x0001  (1)
 00000026  FFEC      BL          keypad?T  ; T=0x0001  (2)
 00000028  1C06      MOV         R6,R0 ; key
  109:             if(key != '$') // keypad sent $ if no key has been press so ignore it
 0000002A  0600      LSL         R0,R0,#0x18 ; key
 0000002C  0E00      LSR         R0,R0,#0x18
 0000002E  2824      CMP         R0,#0x24
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 35  

 00000030  D042      BEQ         L_11  ; T=0x000000B8
  111:                 if(key == '*') // end receive when key * has been press
 00000032  282A      CMP         R0,#0x2A
 00000034  D108      BNE         L_12  ; T=0x00000048
  113:                     tempkey[i] = '\0';
 00000036  2000      MOV         R0,#0x0
 00000038  1C2A      MOV         R2,R5 ; i
 0000003A  4800      LDR         R1,=tempkey ; tempkey
 0000003C  5488      STRB        R0,[R1,R2]
  114:                     key = '*';
 0000003E  262A      MOV         R6,#0x2A
  115:                     printf("\n");
 00000040  4800      LDR         R0,=??S_3 ; ??S_3
 00000042  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000044  FFDD      BL          printf?T  ; T=0x0001  (2)
  116:                 }
 00000046  E037      B           L_11  ; T=0x000000B8
 00000048          L_12:
  117:                 else if(key == '#') // delete data when key # has been press
 00000048  1C30      MOV         R0,R6 ; key
 0000004A  0600      LSL         R0,R0,#0x18 ; key
 0000004C  0E00      LSR         R0,R0,#0x18
 0000004E  2823      CMP         R0,#0x23
 00000050  D115      BNE         L_14  ; T=0x0000007E
  119:                     if(i > 0)
 00000052  1C28      MOV         R0,R5 ; i
 00000054  2800      CMP         R0,#0x0 ; i
 00000056  DD2F      BLE         L_11  ; T=0x000000B8
  121:                         lcd_gotoxy(10+(4*(i-1))+(5*(i-1)),3); // set position for lcd
 00000058  1C29      MOV         R1,R5 ; i
 0000005A  3901      SUB         R1,#0x1
 0000005C  2005      MOV         R0,#0x5
 0000005E  4341      MUL         R1,R0
 00000060  1C28      MOV         R0,R5 ; i
 00000062  0080      LSL         R0,R0,#0x2 ; i
 00000064  3006      ADD         R0,#0x6
 00000066  1840      ADD         R0,R1
 00000068  2103      MOV         R1,#0x3
 0000006A  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 0000006C  FFC9      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  122:                         lcd_put_char(' '); // put charecter to lcd
 0000006E  2020      MOV         R0,#0x20
 00000070  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 00000072  FFC6      BL          lcd_put_char?T  ; T=0x0001  (2)
  123:                         i--;
 00000074  3D01      SUB         R5,#0x1
  124:                         printf("\b \b");
 00000076  4800      LDR         R0,=??S_4 ; ??S_4
 00000078  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000007A  FFC2      BL          printf?T  ; T=0x0001  (2)
  126:                 }
 0000007C  E01C      B           L_11  ; T=0x000000B8
 0000007E          L_14:
  127:                 else if(i == MAX_PASSWORD-1) // if reach last charecter then not do anything
 0000007E  1C28      MOV         R0,R5 ; i
 00000080  2808      CMP         R0,#0x8 ; i
 00000082  D019      BEQ         L_11  ; T=0x000000B8
  133:                     printf("%c",key);
 00000084  1C30      MOV         R0,R6 ; key
 00000086  0601      LSL         R1,R0,#0x18 ; key
 00000088  0E09      LSR         R1,R1,#0x18
 0000008A  4800      LDR         R0,=??S_5 ; ??S_5
 0000008C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000008E  FFB8      BL          printf?T  ; T=0x0001  (2)
  134:                     lcd_gotoxy(10+(4*i)+(5*i),3); // set position for lcd
 00000090  1C28      MOV         R0,R5 ; i
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 36  

 00000092  0080      LSL         R0,R0,#0x2 ; i
 00000094  300A      ADD         R0,#0xA
 00000096  1C29      MOV         R1,R5 ; i
 00000098  2205      MOV         R2,#0x5
 0000009A  4351      MUL         R1,R2
 0000009C  1840      ADD         R0,R1
 0000009E  2103      MOV         R1,#0x3
 000000A0  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 000000A2  FFAE      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  135:                     lcd_put_char(key); // put charecter to lcd
 000000A4  1C30      MOV         R0,R6 ; key
 000000A6  0600      LSL         R0,R0,#0x18 ; key
 000000A8  0E00      LSR         R0,R0,#0x18
 000000AA  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 000000AC  FFA9      BL          lcd_put_char?T  ; T=0x0001  (2)
  136:                     tempkey[i] = key;
 000000AE  1C30      MOV         R0,R6 ; key
 000000B0  1C2A      MOV         R2,R5 ; i
 000000B2  4800      LDR         R1,=tempkey ; tempkey
 000000B4  5488      STRB        R0,[R1,R2]
  137:                     i++;
 000000B6  3501      ADD         R5,#0x1
  139:             }
 000000B8          L_11:
  140:             if((sec()- sec_starts) == 0) // check time out
 000000B8  F7FF      BL          sec?T  ; T=0x0001  (1)
 000000BA  FFA2      BL          sec?T  ; T=0x0001  (2)
 000000BC  1C21      MOV         R1,R4 ; sec_starts
 000000BE  1A40      SUB         R0,R1 ; sec_starts
 000000C0  2800      CMP         R0,#0x0
 000000C2  D103      BNE         L_9  ; T=0x000000CC
  142:                 cleardata(); // clear tempkey
 000000C4  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 000000C6  FF9C      BL          cleardata?T  ; T=0x0001  (2)
  143:                 return 0; // if receive fail then return 0
 000000C8  2000      MOV         R0,#0x0
 000000CA  E32F      B           L_20  ; T=0x0000072C
  145:         }while(key != '*'); // exit loop when key * has been press
 000000CC          L_9:
 000000CC  1C30      MOV         R0,R6 ; key
 000000CE  0600      LSL         R0,R0,#0x18 ; key
 000000D0  0E00      LSR         R0,R0,#0x18
 000000D2  282A      CMP         R0,#0x2A
 000000D4  D1A6      BNE         L_7  ; T=0x00000024
  146:     }
 000000D6  E328      B           L_21  ; T=0x0000072A
 000000D8          L_6:
  147:     else if(mode == 2) // mode 2 use for check password user to open door
 000000D8  1C38      MOV         R0,R7 ; mode
 000000DA  2802      CMP         R0,#0x2 ; mode
 000000DC  D167      BNE         L_22  ; T=0x000001AE
  149:         i = 1; // start at second charecter since first charecter as been collect before
 000000DE  2501      MOV         R5,#0x1
  150:         lcd_gotoxy(8,4); // set position for lcd
 000000E0  2008      MOV         R0,#0x8
 000000E2  2104      MOV         R1,#0x4
 000000E4  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 000000E6  FF8C      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  151:         lcd_put_char('*'); // put charecter to lcd
 000000E8  202A      MOV         R0,#0x2A
 000000EA  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 000000EC  FF89      BL          lcd_put_char?T  ; T=0x0001  (2)
  152:         do
 000000EE          L_23:
  154:             key = keypad(); // receivce charecter from keypad
 000000EE  F7FF      BL          keypad?T  ; T=0x0001  (1)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 37  

 000000F0  FF87      BL          keypad?T  ; T=0x0001  (2)
 000000F2  1C06      MOV         R6,R0 ; key
  155:              if(key != '$') // keypad sent $ if no key has been press so ignore it
 000000F4  0600      LSL         R0,R0,#0x18 ; key
 000000F6  0E00      LSR         R0,R0,#0x18
 000000F8  2824      CMP         R0,#0x24
 000000FA  D04A      BEQ         L_27  ; T=0x00000192
  157:                 if(i == (MAX_PASSWORD_USER-1)) // auto end receive when reach last charecter
 000000FC  1C28      MOV         R0,R5 ; i
 000000FE  2804      CMP         R0,#0x4 ; i
 00000100  D107      BNE         L_28  ; T=0x00000112
  159:                     tempkey[i] = '\0';
 00000102  2000      MOV         R0,#0x0
 00000104  1C2A      MOV         R2,R5 ; i
 00000106  4800      LDR         R1,=tempkey ; tempkey
 00000108  5488      STRB        R0,[R1,R2]
  160:                     printf("\n");
 0000010A  4800      LDR         R0,=??S_3 ; ??S_3
 0000010C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000010E  FF78      BL          printf?T  ; T=0x0001  (2)
  161:                 }
 00000110  E03F      B           L_27  ; T=0x00000192
 00000112          L_28:
  162:                 else if(key == '#') // delete data when key # has been press
 00000112  1C30      MOV         R0,R6 ; key
 00000114  0600      LSL         R0,R0,#0x18 ; key
 00000116  0E00      LSR         R0,R0,#0x18
 00000118  2823      CMP         R0,#0x23
 0000011A  D11D      BNE         L_30  ; T=0x00000158
  164:                     if(i > 0)
 0000011C  1C28      MOV         R0,R5 ; i
 0000011E  2800      CMP         R0,#0x0 ; i
 00000120  DD37      BLE         L_27  ; T=0x00000192
  166:                         lcd_gotoxy(8+(4*(i-1))+(5*(i-1)),4); // set position for lcd
 00000122  1C29      MOV         R1,R5 ; i
 00000124  3901      SUB         R1,#0x1
 00000126  2005      MOV         R0,#0x5
 00000128  4341      MUL         R1,R0
 0000012A  1C28      MOV         R0,R5 ; i
 0000012C  0080      LSL         R0,R0,#0x2 ; i
 0000012E  3004      ADD         R0,#0x4
 00000130  1840      ADD         R0,R1
 00000132  2104      MOV         R1,#0x4
 00000134  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 00000136  FF64      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  167:                         lcd_put_char(' '); // put charecter to lcd
 00000138  2020      MOV         R0,#0x20
 0000013A  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 0000013C  FF61      BL          lcd_put_char?T  ; T=0x0001  (2)
  168:                         i--;
 0000013E  3D01      SUB         R5,#0x1
  169:                         printf("\b \b");
 00000140  4800      LDR         R0,=??S_4 ; ??S_4
 00000142  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000144  FF5D      BL          printf?T  ; T=0x0001  (2)
  170:                         if(i == 0) // exit and wait receive first charecter
 00000146  1C28      MOV         R0,R5 ; i
 00000148  2800      CMP         R0,#0x0 ; i
 0000014A  D122      BNE         L_27  ; T=0x00000192
  172:                             tempkey[i] = '\0';
 0000014C  2000      MOV         R0,#0x0
 0000014E  1C2A      MOV         R2,R5 ; i
 00000150  4800      LDR         R1,=tempkey ; tempkey
 00000152  5488      STRB        R0,[R1,R2]
  173:                             return 0; // if receive fail then return 0
 00000154  2000      MOV         R0,#0x0
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 38  

 00000156  E2E9      B           L_20  ; T=0x0000072C
  176:                 }
 00000158          L_30:
  177:                 else if(key != '*')// if charecter is not * and # then put to string tempkey
 00000158  1C30      MOV         R0,R6 ; key
 0000015A  0600      LSL         R0,R0,#0x18 ; key
 0000015C  0E00      LSR         R0,R0,#0x18
 0000015E  282A      CMP         R0,#0x2A
 00000160  D017      BEQ         L_27  ; T=0x00000192
  179:                     printf("%c",key);
 00000162  1C30      MOV         R0,R6 ; key
 00000164  0601      LSL         R1,R0,#0x18 ; key
 00000166  0E09      LSR         R1,R1,#0x18
 00000168  4800      LDR         R0,=??S_5 ; ??S_5
 0000016A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000016C  FF49      BL          printf?T  ; T=0x0001  (2)
  180:                     lcd_gotoxy(8+(4*i)+(5*i),4); // set position for lcd
 0000016E  1C28      MOV         R0,R5 ; i
 00000170  0080      LSL         R0,R0,#0x2 ; i
 00000172  3008      ADD         R0,#0x8
 00000174  1C29      MOV         R1,R5 ; i
 00000176  2205      MOV         R2,#0x5
 00000178  4351      MUL         R1,R2
 0000017A  1840      ADD         R0,R1
 0000017C  2104      MOV         R1,#0x4
 0000017E  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 00000180  FF3F      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  181:                     lcd_put_char('*'); // put charecter to lcd
 00000182  202A      MOV         R0,#0x2A
 00000184  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 00000186  FF3C      BL          lcd_put_char?T  ; T=0x0001  (2)
  182:                     tempkey[i] = key;
 00000188  1C30      MOV         R0,R6 ; key
 0000018A  1C2A      MOV         R2,R5 ; i
 0000018C  4800      LDR         R1,=tempkey ; tempkey
 0000018E  5488      STRB        R0,[R1,R2]
  183:                     i++;
 00000190  3501      ADD         R5,#0x1
  185:             }       
 00000192          L_27:
  186:             if((sec()- sec_starts) == 0) // check time out
 00000192  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000194  FF35      BL          sec?T  ; T=0x0001  (2)
 00000196  1C21      MOV         R1,R4 ; sec_starts
 00000198  1A40      SUB         R0,R1 ; sec_starts
 0000019A  2800      CMP         R0,#0x0
 0000019C  D103      BNE         L_25  ; T=0x000001A6
  188:                 cleardata(); // clear tempkey
 0000019E  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 000001A0  FF2F      BL          cleardata?T  ; T=0x0001  (2)
  189:                 return 0; // if receive fail then return 0
 000001A2  2000      MOV         R0,#0x0
 000001A4  E2C2      B           L_20  ; T=0x0000072C
  191:         }while(i != (MAX_PASSWORD_USER-1)); // exit loop when reach last charecter
 000001A6          L_25:
 000001A6  1C28      MOV         R0,R5 ; i
 000001A8  2804      CMP         R0,#0x4 ; i
 000001AA  D1A0      BNE         L_23  ; T=0x000000EE
  192:     }
 000001AC  E2BD      B           L_21  ; T=0x0000072A
 000001AE          L_22:
  193:      else if(mode == 3) // mode 3 use for add and delete password user
 000001AE  1C38      MOV         R0,R7 ; mode
 000001B0  2803      CMP         R0,#0x3 ; mode
 000001B2  D166      BNE         L_37  ; T=0x00000282
  195:         cleardata(); // clear tempkey
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 39  

 000001B4  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 000001B6  FF24      BL          cleardata?T  ; T=0x0001  (2)
  196:         do
 000001B8          L_38:
  198:             key = keypad(); // receivce charecter from keypad
 000001B8  F7FF      BL          keypad?T  ; T=0x0001  (1)
 000001BA  FF22      BL          keypad?T  ; T=0x0001  (2)
 000001BC  1C06      MOV         R6,R0 ; key
  199:              if(key != '$') // keypad sent $ if no key has been press so ignore it
 000001BE  0600      LSL         R0,R0,#0x18 ; key
 000001C0  0E00      LSR         R0,R0,#0x18
 000001C2  2824      CMP         R0,#0x24
 000001C4  D04A      BEQ         L_42  ; T=0x0000025C
  202:                 if((key == '*')&&(i == MAX_PASSWORD_USER-1)) // end receive when key * has been press and reach last charecte
             -r
 000001C6  282A      CMP         R0,#0x2A
 000001C8  D10B      BNE         L_43  ; T=0x000001E2
 000001CA  1C28      MOV         R0,R5 ; i
 000001CC  2804      CMP         R0,#0x4 ; i
 000001CE  D108      BNE         L_43  ; T=0x000001E2
  204:                     tempkey[i] = '\0';
 000001D0  2000      MOV         R0,#0x0
 000001D2  1C2A      MOV         R2,R5 ; i
 000001D4  4800      LDR         R1,=tempkey ; tempkey
 000001D6  5488      STRB        R0,[R1,R2]
  205:                     key = '*';
 000001D8  262A      MOV         R6,#0x2A
  206:                     printf("\n");
 000001DA  4800      LDR         R0,=??S_3 ; ??S_3
 000001DC  F7FF      BL          printf?T  ; T=0x0001  (1)
 000001DE  FF10      BL          printf?T  ; T=0x0001  (2)
  207:                 }
 000001E0  E03C      B           L_42  ; T=0x0000025C
 000001E2          L_43:
  208:                 else if(key == '#') // delete data when key # has been press
 000001E2  1C30      MOV         R0,R6 ; key
 000001E4  0600      LSL         R0,R0,#0x18 ; key
 000001E6  0E00      LSR         R0,R0,#0x18
 000001E8  2823      CMP         R0,#0x23
 000001EA  D115      BNE         L_45  ; T=0x00000218
  210:                     if(i > 0)
 000001EC  1C28      MOV         R0,R5 ; i
 000001EE  2800      CMP         R0,#0x0 ; i
 000001F0  DD34      BLE         L_42  ; T=0x0000025C
  212:                         lcd_gotoxy(24+(4*(i-1))+(5*(i-1)),3); // set position for lcd
 000001F2  1C29      MOV         R1,R5 ; i
 000001F4  3901      SUB         R1,#0x1
 000001F6  2005      MOV         R0,#0x5
 000001F8  4341      MUL         R1,R0
 000001FA  1C28      MOV         R0,R5 ; i
 000001FC  0080      LSL         R0,R0,#0x2 ; i
 000001FE  3014      ADD         R0,#0x14
 00000200  1840      ADD         R0,R1
 00000202  2103      MOV         R1,#0x3
 00000204  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 00000206  FEFC      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  213:                         lcd_put_char(' '); // put charecter to lcd
 00000208  2020      MOV         R0,#0x20
 0000020A  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 0000020C  FEF9      BL          lcd_put_char?T  ; T=0x0001  (2)
  214:                         i--;
 0000020E  3D01      SUB         R5,#0x1
  215:                         printf("\b \b");
 00000210  4800      LDR         R0,=??S_4 ; ??S_4
 00000212  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000214  FEF5      BL          printf?T  ; T=0x0001  (2)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 40  

  217:                 }
 00000216  E021      B           L_42  ; T=0x0000025C
 00000218          L_45:
  218:                 else if(i == MAX_PASSWORD_USER-1) // if reach last charecter then not do anything
 00000218  1C28      MOV         R0,R5 ; i
 0000021A  2804      CMP         R0,#0x4 ; i
 0000021C  D01E      BEQ         L_42  ; T=0x0000025C
  222:                 else if(key != '*') // if charecter is not * and # then put to string tempkey
 0000021E  1C30      MOV         R0,R6 ; key
 00000220  0600      LSL         R0,R0,#0x18 ; key
 00000222  0E00      LSR         R0,R0,#0x18
 00000224  282A      CMP         R0,#0x2A
 00000226  D019      BEQ         L_42  ; T=0x0000025C
  224:                     printf("%c",key);
 00000228  1C30      MOV         R0,R6 ; key
 0000022A  0601      LSL         R1,R0,#0x18 ; key
 0000022C  0E09      LSR         R1,R1,#0x18
 0000022E  4800      LDR         R0,=??S_5 ; ??S_5
 00000230  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000232  FEE6      BL          printf?T  ; T=0x0001  (2)
  225:                     lcd_gotoxy(24+(4*i)+(5*i),3); // set position for lcd
 00000234  1C28      MOV         R0,R5 ; i
 00000236  0080      LSL         R0,R0,#0x2 ; i
 00000238  3018      ADD         R0,#0x18
 0000023A  1C29      MOV         R1,R5 ; i
 0000023C  2205      MOV         R2,#0x5
 0000023E  4351      MUL         R1,R2
 00000240  1840      ADD         R0,R1
 00000242  2103      MOV         R1,#0x3
 00000244  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 00000246  FEDC      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  226:                     lcd_put_char(key); // put charecter to lcd
 00000248  1C30      MOV         R0,R6 ; key
 0000024A  0600      LSL         R0,R0,#0x18 ; key
 0000024C  0E00      LSR         R0,R0,#0x18
 0000024E  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 00000250  FED7      BL          lcd_put_char?T  ; T=0x0001  (2)
  227:                     tempkey[i] = key;
 00000252  1C30      MOV         R0,R6 ; key
 00000254  1C2A      MOV         R2,R5 ; i
 00000256  4800      LDR         R1,=tempkey ; tempkey
 00000258  5488      STRB        R0,[R1,R2]
  228:                     i++;
 0000025A  3501      ADD         R5,#0x1
  230:             }       
 0000025C          L_42:
  231:             if((sec()- sec_starts) == 0) // check time out
 0000025C  F7FF      BL          sec?T  ; T=0x0001  (1)
 0000025E  FED0      BL          sec?T  ; T=0x0001  (2)
 00000260  1C21      MOV         R1,R4 ; sec_starts
 00000262  1A40      SUB         R0,R1 ; sec_starts
 00000264  2800      CMP         R0,#0x0
 00000266  D103      BNE         L_40  ; T=0x00000270
  233:                 cleardata(); // clear tempkey
 00000268  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 0000026A  FECA      BL          cleardata?T  ; T=0x0001  (2)
  234:                 return 0; // if receive fail then return 0
 0000026C  2000      MOV         R0,#0x0
 0000026E  E25D      B           L_20  ; T=0x0000072C
  236:         }while((key != '*')||(i != (MAX_PASSWORD_USER-1))); // exit loop when key * has been press and reach last chare
             -cter
 00000270          L_40:
 00000270  1C30      MOV         R0,R6 ; key
 00000272  0600      LSL         R0,R0,#0x18 ; key
 00000274  0E00      LSR         R0,R0,#0x18
 00000276  282A      CMP         R0,#0x2A
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 41  

 00000278  D19E      BNE         L_38  ; T=0x000001B8
 0000027A  1C28      MOV         R0,R5 ; i
 0000027C  2804      CMP         R0,#0x4 ; i
 0000027E  D19B      BNE         L_38  ; T=0x000001B8
  237:     }
 00000280  E253      B           L_21  ; T=0x0000072A
 00000282          L_37:
  238:     else if(mode == 4) // mode 4 use for select menu (state config)
 00000282  1C38      MOV         R0,R7 ; mode
 00000284  2804      CMP         R0,#0x4 ; mode
 00000286  D000      BNE         $+4
 00000288  E120      B           L_53  ; T=0x000004CC
  240:         cleardata(); // clear tempkey
 0000028C  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 0000028E  FEB8      BL          cleardata?T  ; T=0x0001  (2)
  241:         printf(" ");
 00000290  4800      LDR         R0,=??S_6 ; ??S_6
 00000292  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000294  FEB5      BL          printf?T  ; T=0x0001  (2)
  242:         initial = 1;
 00000296  2001      MOV         R0,#0x1
 00000298  9000      STR         R0,[R13,#0x0] ; initial
  243:         do
 0000029A          L_54:
  245:             key = keypad(); // receivce charecter from keypad
 0000029A  F7FF      BL          keypad?T  ; T=0x0001  (1)
 0000029C  FEB1      BL          keypad?T  ; T=0x0001  (2)
 0000029E  1C06      MOV         R6,R0 ; key
  246:             if(initial == 1) // auto select one menu when open menu
 000002A0  9800      LDR         R0,[R13,#0x0] ; initial
 000002A2  2801      CMP         R0,#0x1
 000002A4  D103      BNE         L_58  ; T=0x000002AE
  248:                 key = menuold;
 000002A6  4800      LDR         R0,=menuold ; menuold
 000002A8  7806      LDRB        R6,[R0,#0x0] ; menuold
  249:                 initial = 0;
 000002AA  2000      MOV         R0,#0x0
 000002AC  9000      STR         R0,[R13,#0x0] ; initial
  250:             }
 000002AE  E005      B           L_59  ; T=0x000002BC
 000002B0          L_58:
  251:             else if(tempkey[0] != '\0') // when exit from function, that fuction menu will be select
 000002B0  4800      LDR         R0,=tempkey ; tempkey
 000002B2  7801      LDRB        R1,[R0,#0x0] ; tempkey
 000002B4  1C08      MOV         R0,R1
 000002B6  2800      CMP         R0,#0x0
 000002B8  D000      BEQ         L_59  ; T=0x000002BC
  253:                 menuold = tempkey[0];
 000002BA  4800      LDR         R0,=menuold ; menuold
 000002BC  7001      STRB        R1,[R0,#0x0] ; menuold
  254:             }
 000002BE          L_59:
  257:             if(key != '$') // keypad sent $ if no key has been press so ignore it
 000002BE  1C30      MOV         R0,R6 ; key
 000002C0  0600      LSL         R0,R0,#0x18 ; key
 000002C2  0E00      LSR         R0,R0,#0x18
 000002C4  2824      CMP         R0,#0x24
 000002C6  D100      BEQ         $+4
 000002C8  E0E9      B           L_61  ; T=0x0000049E
  260:                 if(key == '*') // end receive (confirm select) when key * has been press
 000002CC  282A      CMP         R0,#0x2A
 000002CE  D105      BNE         L_62  ; T=0x000002DC
  262:                     tempkey[1] = '\0';
 000002D0  2100      MOV         R1,#0x0
 000002D2  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 000002D4  7001      STRB        R1,[R0,#0x0] ; tempkey+1
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 42  

  263:                     key = '*';
 000002D6  262A      MOV         R6,#0x2A
  264:                     printf("\n");
 000002D8  4800      LDR         R0,=??S_3 ; ??S_3
 000002DA  F7FF      BL          printf?T  ; T=0x0001  (1)
 000002DC  FE91      BL          printf?T  ; T=0x0001  (2)
  265:                 }
 000002DE  E0DE      B           L_61  ; T=0x0000049E
 000002E0          L_62:
  266:                 else if(key == '#') // exit menu when key # has been press
 000002E0  1C30      MOV         R0,R6 ; key
 000002E2  0600      LSL         R0,R0,#0x18 ; key
 000002E4  0E00      LSR         R0,R0,#0x18
 000002E6  2823      CMP         R0,#0x23
 000002E8  D108      BNE         L_64  ; T=0x000002FC
  268:                     tempkey[0] = '\0';
 000002EA  2100      MOV         R1,#0x0
 000002EC  4800      LDR         R0,=tempkey ; tempkey
 000002EE  7001      STRB        R1,[R0,#0x0] ; tempkey
  269:                     menuold = '1';
 000002F0  2131      MOV         R1,#0x31
 000002F2  4800      LDR         R0,=menuold ; menuold
 000002F4  7001      STRB        R1,[R0,#0x0] ; menuold
  270:                     printf("\n");
 000002F6  4800      LDR         R0,=??S_3 ; ??S_3
 000002F8  F7FF      BL          printf?T  ; T=0x0001  (1)
 000002FA  FE82      BL          printf?T  ; T=0x0001  (2)
  271:                     return 0; // if receive fail then return 0
 000002FC  2000      MOV         R0,#0x0
 000002FE  E215      B           L_20  ; T=0x0000072C
  272:                 }
 00000300          L_64:
  273:                 else if(key == '1') // select menu 1 change password when key 1 has been press
 00000300  1C30      MOV         R0,R6 ; key
 00000302  0600      LSL         R0,R0,#0x18 ; key
 00000304  0E00      LSR         R0,R0,#0x18
 00000306  2831      CMP         R0,#0x31
 00000308  D10D      BNE         L_66  ; T=0x00000326
  275:                     printf("\b%c",key);
 0000030A  1C30      MOV         R0,R6 ; key
 0000030C  0601      LSL         R1,R0,#0x18 ; key
 0000030E  0E09      LSR         R1,R1,#0x18
 00000310  4800      LDR         R0,=??S_7 ; ??S_7
 00000312  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000314  FE75      BL          printf?T  ; T=0x0001  (2)
  276:                     tempkey[0] = key;
 00000316  1C31      MOV         R1,R6 ; key
 00000318  4800      LDR         R0,=tempkey ; tempkey
 0000031A  7001      STRB        R1,[R0,#0x0] ; tempkey
  277:                     loadpic_mmc(403); // load picture from sd/mmc
 0000031C  4800      LDR         R0,=0x193
 0000031E  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000320  FE6F      BL          loadpic_mmc?T  ; T=0x0001  (2)
  278:                     lcd_fill_picture(temppic); // show picture on lcd
 00000322  4800      LDR         R0,=temppic ; temppic
 00000324  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000326  FE6C      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  279:                 }
 00000328  E0B9      B           L_61  ; T=0x0000049E
 0000032A          L_66:
  280:                 else if(key == '2') // select menu 2 set date time when key 2 has been press
 0000032A  1C30      MOV         R0,R6 ; key
 0000032C  0600      LSL         R0,R0,#0x18 ; key
 0000032E  0E00      LSR         R0,R0,#0x18
 00000330  2832      CMP         R0,#0x32
 00000332  D10D      BNE         L_68  ; T=0x00000350
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 43  

  282:                     printf("\b%c",key);
 00000334  1C30      MOV         R0,R6 ; key
 00000336  0601      LSL         R1,R0,#0x18 ; key
 00000338  0E09      LSR         R1,R1,#0x18
 0000033A  4800      LDR         R0,=??S_7 ; ??S_7
 0000033C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000033E  FE60      BL          printf?T  ; T=0x0001  (2)
  283:                     tempkey[0] = key;
 00000340  1C31      MOV         R1,R6 ; key
 00000342  4800      LDR         R0,=tempkey ; tempkey
 00000344  7001      STRB        R1,[R0,#0x0] ; tempkey
  284:                     loadpic_mmc(404); // load picture from sd/mmc
 00000346  4865      LDR         R0,=0x194
 00000348  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000034A  FE5A      BL          loadpic_mmc?T  ; T=0x0001  (2)
  285:                     lcd_fill_picture(temppic); // show picture on lcd
 0000034C  4800      LDR         R0,=temppic ; temppic
 0000034E  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000350  FE57      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  286:                 }
 00000352  E0A4      B           L_61  ; T=0x0000049E
 00000354          L_68:
  287:                 else if(key == '3') // select menu 3 save rfid card when key 3 has been press
 00000354  1C30      MOV         R0,R6 ; key
 00000356  0600      LSL         R0,R0,#0x18 ; key
 00000358  0E00      LSR         R0,R0,#0x18
 0000035A  2833      CMP         R0,#0x33
 0000035C  D10D      BNE         L_70  ; T=0x0000037A
  289:                     printf("\b%c",key);
 0000035E  1C30      MOV         R0,R6 ; key
 00000360  0601      LSL         R1,R0,#0x18 ; key
 00000362  0E09      LSR         R1,R1,#0x18
 00000364  4800      LDR         R0,=??S_7 ; ??S_7
 00000366  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000368  FE4B      BL          printf?T  ; T=0x0001  (2)
  290:                     tempkey[0] = key;
 0000036A  1C31      MOV         R1,R6 ; key
 0000036C  4800      LDR         R0,=tempkey ; tempkey
 0000036E  7001      STRB        R1,[R0,#0x0] ; tempkey
  291:                     loadpic_mmc(405); // load picture from sd/mmc
 00000370  4800      LDR         R0,=0x195
 00000372  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000374  FE45      BL          loadpic_mmc?T  ; T=0x0001  (2)
  292:                     lcd_fill_picture(temppic); // show picture on lcd
 00000376  4800      LDR         R0,=temppic ; temppic
 00000378  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000037A  FE42      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  293:                 }
 0000037C  E08F      B           L_61  ; T=0x0000049E
 0000037E          L_70:
  294:                 else if(key == '4') // select menu 4 delete rfid card when key 4 has been press
 0000037E  1C30      MOV         R0,R6 ; key
 00000380  0600      LSL         R0,R0,#0x18 ; key
 00000382  0E00      LSR         R0,R0,#0x18
 00000384  2834      CMP         R0,#0x34
 00000386  D10D      BNE         L_72  ; T=0x000003A4
  296:                     printf("\b%c",key);
 00000388  1C30      MOV         R0,R6 ; key
 0000038A  0601      LSL         R1,R0,#0x18 ; key
 0000038C  0E09      LSR         R1,R1,#0x18
 0000038E  4800      LDR         R0,=??S_7 ; ??S_7
 00000390  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000392  FE36      BL          printf?T  ; T=0x0001  (2)
  297:                     tempkey[0] = key;
 00000394  1C31      MOV         R1,R6 ; key
 00000396  4800      LDR         R0,=tempkey ; tempkey
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 44  

 00000398  7001      STRB        R1,[R0,#0x0] ; tempkey
  298:                     loadpic_mmc(406); // load picture from sd/mmc
 0000039A  4800      LDR         R0,=0x196
 0000039C  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000039E  FE30      BL          loadpic_mmc?T  ; T=0x0001  (2)
  299:                     lcd_fill_picture(temppic); // show picture on lcd
 000003A0  4800      LDR         R0,=temppic ; temppic
 000003A2  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000003A4  FE2D      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  300:                 }
 000003A6  E07A      B           L_61  ; T=0x0000049E
 000003A8          L_72:
  301:                 else if(key == '5') // select menu 5 add password user when key 5 has been press
 000003A8  1C30      MOV         R0,R6 ; key
 000003AA  0600      LSL         R0,R0,#0x18 ; key
 000003AC  0E00      LSR         R0,R0,#0x18
 000003AE  2835      CMP         R0,#0x35
 000003B0  D10D      BNE         L_74  ; T=0x000003CE
  303:                     printf("\b%c",key);
 000003B2  1C30      MOV         R0,R6 ; key
 000003B4  0601      LSL         R1,R0,#0x18 ; key
 000003B6  0E09      LSR         R1,R1,#0x18
 000003B8  4800      LDR         R0,=??S_7 ; ??S_7
 000003BA  F7FF      BL          printf?T  ; T=0x0001  (1)
 000003BC  FE21      BL          printf?T  ; T=0x0001  (2)
  304:                     tempkey[0] = key;
 000003BE  1C31      MOV         R1,R6 ; key
 000003C0  4800      LDR         R0,=tempkey ; tempkey
 000003C2  7001      STRB        R1,[R0,#0x0] ; tempkey
  305:                     loadpic_mmc(407); // load picture from sd/mmc
 000003C4  4800      LDR         R0,=0x197
 000003C6  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 000003C8  FE1B      BL          loadpic_mmc?T  ; T=0x0001  (2)
  306:                     lcd_fill_picture(temppic); // show picture on lcd
 000003CA  4800      LDR         R0,=temppic ; temppic
 000003CC  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000003CE  FE18      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  307:                 }
 000003D0  E065      B           L_61  ; T=0x0000049E
 000003D2          L_74:
  308:                 else if(key == '6') // select menu 6 delete password user when key 6 has been press
 000003D2  1C30      MOV         R0,R6 ; key
 000003D4  0600      LSL         R0,R0,#0x18 ; key
 000003D6  0E00      LSR         R0,R0,#0x18
 000003D8  2836      CMP         R0,#0x36
 000003DA  D10D      BNE         L_76  ; T=0x000003F8
  310:                     printf("\b%c",key);
 000003DC  1C30      MOV         R0,R6 ; key
 000003DE  0601      LSL         R1,R0,#0x18 ; key
 000003E0  0E09      LSR         R1,R1,#0x18
 000003E2  4800      LDR         R0,=??S_7 ; ??S_7
 000003E4  F7FF      BL          printf?T  ; T=0x0001  (1)
 000003E6  FE0C      BL          printf?T  ; T=0x0001  (2)
  311:                     tempkey[0] = key;
 000003E8  1C31      MOV         R1,R6 ; key
 000003EA  4800      LDR         R0,=tempkey ; tempkey
 000003EC  7001      STRB        R1,[R0,#0x0] ; tempkey
  312:                     loadpic_mmc(408); // load picture from sd/mmc
 000003EE  4866      LDR         R0,=0x198
 000003F0  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 000003F2  FE06      BL          loadpic_mmc?T  ; T=0x0001  (2)
  313:                     lcd_fill_picture(temppic); // show picture on lcd
 000003F4  4800      LDR         R0,=temppic ; temppic
 000003F6  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000003F8  FE03      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  314:                 }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 45  

 000003FA  E050      B           L_61  ; T=0x0000049E
 000003FC          L_76:
  315:                 else if(key == '7') // select menu 7 show information of rfid card when key 7 has been press
 000003FC  1C30      MOV         R0,R6 ; key
 000003FE  0600      LSL         R0,R0,#0x18 ; key
 00000400  0E00      LSR         R0,R0,#0x18
 00000402  2837      CMP         R0,#0x37
 00000404  D10D      BNE         L_78  ; T=0x00000422
  317:                     printf("\b%c",key);
 00000406  1C30      MOV         R0,R6 ; key
 00000408  0601      LSL         R1,R0,#0x18 ; key
 0000040A  0E09      LSR         R1,R1,#0x18
 0000040C  4800      LDR         R0,=??S_7 ; ??S_7
 0000040E  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000410  FDF7      BL          printf?T  ; T=0x0001  (2)
  318:                     tempkey[0] = key;
 00000412  1C31      MOV         R1,R6 ; key
 00000414  4800      LDR         R0,=tempkey ; tempkey
 00000416  7001      STRB        R1,[R0,#0x0] ; tempkey
  319:                     loadpic_mmc(409); // load picture from sd/mmc
 00000418  4800      LDR         R0,=0x199
 0000041A  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000041C  FDF1      BL          loadpic_mmc?T  ; T=0x0001  (2)
  320:                     lcd_fill_picture(temppic); // show picture on lcd
 0000041E  4800      LDR         R0,=temppic ; temppic
 00000420  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000422  FDEE      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  321:                 }
 00000424  E03B      B           L_61  ; T=0x0000049E
 00000426          L_78:
  322:                 else if(key == '8') // select menu 8 show information of password user when key 8 has been press
 00000426  1C30      MOV         R0,R6 ; key
 00000428  0600      LSL         R0,R0,#0x18 ; key
 0000042A  0E00      LSR         R0,R0,#0x18
 0000042C  2838      CMP         R0,#0x38
 0000042E  D10D      BNE         L_80  ; T=0x0000044C
  324:                     printf("\b%c",key);
 00000430  1C30      MOV         R0,R6 ; key
 00000432  0601      LSL         R1,R0,#0x18 ; key
 00000434  0E09      LSR         R1,R1,#0x18
 00000436  4800      LDR         R0,=??S_7 ; ??S_7
 00000438  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000043A  FDE2      BL          printf?T  ; T=0x0001  (2)
  325:                     tempkey[0] = key;
 0000043C  1C31      MOV         R1,R6 ; key
 0000043E  4800      LDR         R0,=tempkey ; tempkey
 00000440  7001      STRB        R1,[R0,#0x0] ; tempkey
  326:                     loadpic_mmc(410); // load picture from sd/mmc
 00000442  4800      LDR         R0,=0x19A
 00000444  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000446  FDDC      BL          loadpic_mmc?T  ; T=0x0001  (2)
  327:                     lcd_fill_picture(temppic); // show picture on lcd
 00000448  4800      LDR         R0,=temppic ; temppic
 0000044A  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000044C  FDD9      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  328:                 }
 0000044E  E026      B           L_61  ; T=0x0000049E
 00000450          L_80:
  329:                 else if(key == '9') // select menu 9 show date time and card or password that use to open door when key 9 has
             - been press
 00000450  1C30      MOV         R0,R6 ; key
 00000452  0600      LSL         R0,R0,#0x18 ; key
 00000454  0E00      LSR         R0,R0,#0x18
 00000456  2839      CMP         R0,#0x39
 00000458  D10D      BNE         L_82  ; T=0x00000476
  331:                     printf("\b%c",key);
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 46  

 0000045A  1C30      MOV         R0,R6 ; key
 0000045C  0601      LSL         R1,R0,#0x18 ; key
 0000045E  0E09      LSR         R1,R1,#0x18
 00000460  4800      LDR         R0,=??S_7 ; ??S_7
 00000462  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000464  FDCD      BL          printf?T  ; T=0x0001  (2)
  332:                     tempkey[0] = key;
 00000466  1C31      MOV         R1,R6 ; key
 00000468  4800      LDR         R0,=tempkey ; tempkey
 0000046A  7001      STRB        R1,[R0,#0x0] ; tempkey
  333:                     loadpic_mmc(411); // load picture from sd/mmc
 0000046C  4800      LDR         R0,=0x19B
 0000046E  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000470  FDC7      BL          loadpic_mmc?T  ; T=0x0001  (2)
  334:                     lcd_fill_picture(temppic); // show picture on lcd
 00000472  4800      LDR         R0,=temppic ; temppic
 00000474  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000476  FDC4      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  335:                 }
 00000478  E011      B           L_61  ; T=0x0000049E
 0000047A          L_82:
  336:                 else if(key == '0') // select menu 0 show date and time when key 0 has been press
 0000047A  1C30      MOV         R0,R6 ; key
 0000047C  0600      LSL         R0,R0,#0x18 ; key
 0000047E  0E00      LSR         R0,R0,#0x18
 00000480  2830      CMP         R0,#0x30
 00000482  D10C      BNE         L_61  ; T=0x0000049E
  338:                     printf("\b%c",key);
 00000484  1C30      MOV         R0,R6 ; key
 00000486  0601      LSL         R1,R0,#0x18 ; key
 00000488  0E09      LSR         R1,R1,#0x18
 0000048A  4800      LDR         R0,=??S_7 ; ??S_7
 0000048C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000048E  FDB8      BL          printf?T  ; T=0x0001  (2)
  339:                     tempkey[0] = key;
 00000490  1C31      MOV         R1,R6 ; key
 00000492  4800      LDR         R0,=tempkey ; tempkey
 00000494  7001      STRB        R1,[R0,#0x0] ; tempkey
  340:                     loadpic_mmc(412); // load picture from sd/mmc
 00000496  4867      LDR         R0,=0x19C
 00000498  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000049A  FDB2      BL          loadpic_mmc?T  ; T=0x0001  (2)
  341:                     lcd_fill_picture(temppic); // show picture on lcd
 0000049C  4800      LDR         R0,=temppic ; temppic
 0000049E  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000004A0  FDAF      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  343:             }
 000004A2          L_61:
  344:             if((sec()- sec_starts) == 0) // check time out
 000004A2  F7FF      BL          sec?T  ; T=0x0001  (1)
 000004A4  FDAD      BL          sec?T  ; T=0x0001  (2)
 000004A6  1C21      MOV         R1,R4 ; sec_starts
 000004A8  1A40      SUB         R0,R1 ; sec_starts
 000004AA  2800      CMP         R0,#0x0
 000004AC  D104      BNE         L_56  ; T=0x000004B8
  346:                 cleardata(); // clear tempkey
 000004AE  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 000004B0  FDA7      BL          cleardata?T  ; T=0x0001  (2)
  347:                 menuold = '1';
 000004B2  2131      MOV         R1,#0x31
 000004B4  4800      LDR         R0,=menuold ; menuold
 000004B6  7001      STRB        R1,[R0,#0x0] ; menuold
  348:                 return 0; // if receive fail then return 0
 000004B8  2000      MOV         R0,#0x0
 000004BA  E137      B           L_20  ; T=0x0000072C
  350:         }while((key != '*')&&(key != '#'));// exit loop key * or # has been press
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 47  

 000004BC          L_56:
 000004BC  1C30      MOV         R0,R6 ; key
 000004BE  0600      LSL         R0,R0,#0x18 ; key
 000004C0  0E00      LSR         R0,R0,#0x18
 000004C2  282A      CMP         R0,#0x2A
 000004C4  D100      BEQ         $+4
 000004C6  E130      B           L_21  ; T=0x0000072A
 000004CA  2823      CMP         R0,#0x23
 000004CC  D000      BNE         $+4
 000004CE  E6E4      B           L_54  ; T=0x0000029A
  351:     }
 000004D2  E12A      B           L_21  ; T=0x0000072A
 000004D4          L_53:
  352:     else if(mode == 5)// mode 5 for password enter menu
 000004D4  1C38      MOV         R0,R7 ; mode
 000004D6  2805      CMP         R0,#0x5 ; mode
 000004D8  D155      BNE         L_88  ; T=0x00000586
  354:         cleardata(); // clear tempkey
 000004DA  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 000004DC  FD91      BL          cleardata?T  ; T=0x0001  (2)
  355:         do
 000004DE          L_89:
  357:             key = keypad(); // receivce charecter from keypad
 000004DE  F7FF      BL          keypad?T  ; T=0x0001  (1)
 000004E0  FD8F      BL          keypad?T  ; T=0x0001  (2)
 000004E2  1C06      MOV         R6,R0 ; key
  358:             if(key != '$') // keypad sent $ if no key has been press so ignore it
 000004E4  0600      LSL         R0,R0,#0x18 ; key
 000004E6  0E00      LSR         R0,R0,#0x18
 000004E8  2824      CMP         R0,#0x24
 000004EA  D03C      BEQ         L_93  ; T=0x00000566
  361:                 if(key == '*') // end receive when key * has been press
 000004EC  282A      CMP         R0,#0x2A
 000004EE  D104      BNE         L_94  ; T=0x000004FA
  363:                     tempkey[i] = '\0';
 000004F0  2000      MOV         R0,#0x0
 000004F2  1C2A      MOV         R2,R5 ; i
 000004F4  4800      LDR         R1,=tempkey ; tempkey
 000004F6  5488      STRB        R0,[R1,R2]
  364:                     key = '*';
 000004F8  262A      MOV         R6,#0x2A
  365:                     printf("\n");
 000004FA  4800      LDR         R0,=??S_3 ; ??S_3
 000004FC  F7FF      BL          printf?T  ; T=0x0001  (1)
 000004FE  FD80      BL          printf?T  ; T=0x0001  (2)
  366:                 }
 00000500  E031      B           L_93  ; T=0x00000566
 00000502          L_94:
  367:                 else if(key == '#') // delete data when key # has been press
 00000502  1C30      MOV         R0,R6 ; key
 00000504  0600      LSL         R0,R0,#0x18 ; key
 00000506  0E00      LSR         R0,R0,#0x18
 00000508  2823      CMP         R0,#0x23
 0000050A  D111      BNE         L_96  ; T=0x00000530
  369:                     if(i > 0)
 0000050C  1C28      MOV         R0,R5 ; i
 0000050E  2800      CMP         R0,#0x0 ; i
 00000510  DD29      BLE         L_93  ; T=0x00000566
  371:                         lcd_gotoxy(8+(2*(i-1))+(5*(i-1)),4); // set position for lcd
 00000512  1C29      MOV         R1,R5 ; i
 00000514  3901      SUB         R1,#0x1
 00000516  2005      MOV         R0,#0x5
 00000518  4341      MUL         R1,R0
 0000051A  1C28      MOV         R0,R5 ; i
 0000051C  0040      LSL         R0,R0,#0x1 ; i
 0000051E  3006      ADD         R0,#0x6
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 48  

 00000520  1840      ADD         R0,R1
 00000522  2104      MOV         R1,#0x4
 00000524  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 00000526  FD6C      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  372:                         lcd_put_char(' '); // put charecter to lcd
 00000528  2020      MOV         R0,#0x20
 0000052A  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 0000052C  FD69      BL          lcd_put_char?T  ; T=0x0001  (2)
  373:                         i--;
 0000052E  3D01      SUB         R5,#0x1
  374:                         printf("\b \b");
 00000530  4800      LDR         R0,=??S_4 ; ??S_4
 00000532  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000534  FD65      BL          printf?T  ; T=0x0001  (2)
  376:                 }
 00000536  E016      B           L_93  ; T=0x00000566
 00000538          L_96:
  377:                 else if(i == MAX_PASSWORD-1) // if reach last charecter then not do anything
 00000538  1C28      MOV         R0,R5 ; i
 0000053A  2808      CMP         R0,#0x8 ; i
 0000053C  D013      BEQ         L_93  ; T=0x00000566
  383:                     lcd_gotoxy(8+(2*i)+(5*i),4); // set position for lcd
 0000053E  1C28      MOV         R0,R5 ; i
 00000540  0040      LSL         R0,R0,#0x1 ; i
 00000542  3008      ADD         R0,#0x8
 00000544  1C29      MOV         R1,R5 ; i
 00000546  2205      MOV         R2,#0x5
 00000548  4351      MUL         R1,R2
 0000054A  1840      ADD         R0,R1
 0000054C  2104      MOV         R1,#0x4
 0000054E  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 00000550  FD57      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  384:                     lcd_put_char('*'); // put charecter to lcd
 00000552  202A      MOV         R0,#0x2A
 00000554  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 00000556  FD54      BL          lcd_put_char?T  ; T=0x0001  (2)
  385:                     printf("%c",key);
 00000558  1C30      MOV         R0,R6 ; key
 0000055A  0601      LSL         R1,R0,#0x18 ; key
 0000055C  0E09      LSR         R1,R1,#0x18
 0000055E  4800      LDR         R0,=??S_5 ; ??S_5
 00000560  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000562  FD4E      BL          printf?T  ; T=0x0001  (2)
  386:                     tempkey[i] = key;
 00000564  1C30      MOV         R0,R6 ; key
 00000566  1C2A      MOV         R2,R5 ; i
 00000568  4800      LDR         R1,=tempkey ; tempkey
 0000056A  5488      STRB        R0,[R1,R2]
  387:                     i++;
 0000056C  3501      ADD         R5,#0x1
  389:             }
 0000056E          L_93:
  390:             if((sec()- sec_starts) == 0) // check time out
 0000056E  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000570  FD47      BL          sec?T  ; T=0x0001  (2)
 00000572  1C21      MOV         R1,R4 ; sec_starts
 00000574  1A40      SUB         R0,R1 ; sec_starts
 00000576  2800      CMP         R0,#0x0
 00000578  D1FF      BNE         L_91  ; T=0x0000057A
  392:                 cleardata(); // clear tempkey
 0000057A  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 0000057C  FD41      BL          cleardata?T  ; T=0x0001  (2)
  393:                 return 0; // if receive fail then return 0
 0000057E  2000      MOV         R0,#0x0
 00000580  E0D4      B           L_20  ; T=0x0000072C
  395:         }while(key != '*'); // exit loop when key * has been press
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 49  

 00000582          L_91:
 00000582  1C30      MOV         R0,R6 ; key
 00000584  0600      LSL         R0,R0,#0x18 ; key
 00000586  0E00      LSR         R0,R0,#0x18
 00000588  282A      CMP         R0,#0x2A
 0000058A  D1A8      BNE         L_89  ; T=0x000004DE
  396:     }
 0000058C  E0CD      B           L_21  ; T=0x0000072A
 0000058E          L_88:
  397:     else if(mode == 6) // mode 6 for enter day, month and year
 0000058E  1C38      MOV         R0,R7 ; mode
 00000590  2806      CMP         R0,#0x6 ; mode
 00000592  D000      BNE         $+4
 00000594  E062      B           L_103  ; T=0x0000065C
  399:         cleardata(); // clear tempkey
 00000598  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 0000059A  FD32      BL          cleardata?T  ; T=0x0001  (2)
  400:         do
 0000059C          L_104:
  402:             key = keypad(); // receivce charecter from keypad
 0000059C  F7FF      BL          keypad?T  ; T=0x0001  (1)
 0000059E  FD30      BL          keypad?T  ; T=0x0001  (2)
 000005A0  1C06      MOV         R6,R0 ; key
  403:              if(key != '$') // keypad sent $ if no key has been press so ignore it
 000005A2  0600      LSL         R0,R0,#0x18 ; key
 000005A4  0E00      LSR         R0,R0,#0x18
 000005A6  2824      CMP         R0,#0x24
 000005A8  D045      BEQ         L_108  ; T=0x00000636
  406:                 if((key == '*')&&(i == 8)) // end receive when key * has been press and reach last charecter
 000005AA  282A      CMP         R0,#0x2A
 000005AC  D106      BNE         L_109  ; T=0x000005BC
 000005AE  1C28      MOV         R0,R5 ; i
 000005B0  2808      CMP         R0,#0x8 ; i
 000005B2  D103      BNE         L_109  ; T=0x000005BC
  408:                     tempkey[i] = '\0';
 000005B4  2000      MOV         R0,#0x0
 000005B6  1C2A      MOV         R2,R5 ; i
 000005B8  4800      LDR         R1,=tempkey ; tempkey
 000005BA  5488      STRB        R0,[R1,R2]
  409:                     key = '*';
 000005BC  262A      MOV         R6,#0x2A
  410:                     printf("\n");
 000005BE  4800      LDR         R0,=??S_3 ; ??S_3
 000005C0  F7FF      BL          printf?T  ; T=0x0001  (1)
 000005C2  FD1E      BL          printf?T  ; T=0x0001  (2)
  411:                 }
 000005C4  E037      B           L_108  ; T=0x00000636
 000005C6          L_109:
  412:                 else if(key == '#') // delete data when key # has been press
 000005C6  1C30      MOV         R0,R6 ; key
 000005C8  0600      LSL         R0,R0,#0x18 ; key
 000005CA  0E00      LSR         R0,R0,#0x18
 000005CC  2823      CMP         R0,#0x23
 000005CE  D110      BNE         L_111  ; T=0x000005F2
  414:                     if(i > 0)
 000005D0  1C28      MOV         R0,R5 ; i
 000005D2  2800      CMP         R0,#0x0 ; i
 000005D4  DD2F      BLE         L_108  ; T=0x00000636
  416:                         lcd_gotoxy(8+(4*(i-1))+(5*(i-1)),3); // set position for lcd
 000005D6  1C29      MOV         R1,R5 ; i
 000005D8  3901      SUB         R1,#0x1
 000005DA  2005      MOV         R0,#0x5
 000005DC  4341      MUL         R1,R0
 000005DE  1C28      MOV         R0,R5 ; i
 000005E0  0080      LSL         R0,R0,#0x2 ; i
 000005E2  3004      ADD         R0,#0x4
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 50  

 000005E4  1840      ADD         R0,R1
 000005E6  2103      MOV         R1,#0x3
 000005E8  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 000005EA  FD0A      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  417:                         lcd_put_char(' '); // put charecter to lcd
 000005EC  2020      MOV         R0,#0x20
 000005EE  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 000005F0  FD07      BL          lcd_put_char?T  ; T=0x0001  (2)
  418:                         i--;
 000005F2  3D01      SUB         R5,#0x1
  419:                         printf("\b \b");
 000005F4  4800      LDR         R0,=??S_4 ; ??S_4
 000005F6  F7FF      BL          printf?T  ; T=0x0001  (1)
 000005F8  FD03      BL          printf?T  ; T=0x0001  (2)
  421:                 }
 000005FA  E01C      B           L_108  ; T=0x00000636
 000005FC          L_111:
  422:                 else if(i == 8) // if reach last charecter then not do anything
 000005FC  1C28      MOV         R0,R5 ; i
 000005FE  2808      CMP         R0,#0x8 ; i
 00000600  D019      BEQ         L_108  ; T=0x00000636
  426:                 else if(key != '*') // if charecter is not * and # then put to string tempkey
 00000602  1C30      MOV         R0,R6 ; key
 00000604  0600      LSL         R0,R0,#0x18 ; key
 00000606  0E00      LSR         R0,R0,#0x18
 00000608  282A      CMP         R0,#0x2A
 0000060A  D014      BEQ         L_108  ; T=0x00000636
  428:                     lcd_gotoxy(8+(4*i)+(5*i),3); // set position for lcd
 0000060C  1C28      MOV         R0,R5 ; i
 0000060E  0080      LSL         R0,R0,#0x2 ; i
 00000610  3008      ADD         R0,#0x8
 00000612  1C29      MOV         R1,R5 ; i
 00000614  2205      MOV         R2,#0x5
 00000616  4351      MUL         R1,R2
 00000618  1840      ADD         R0,R1
 0000061A  2103      MOV         R1,#0x3
 0000061C  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 0000061E  FCF0      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  429:                     lcd_put_char(key); // put charecter to lcd
 00000620  1C30      MOV         R0,R6 ; key
 00000622  0600      LSL         R0,R0,#0x18 ; key
 00000624  0E00      LSR         R0,R0,#0x18
 00000626  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 00000628  FCEB      BL          lcd_put_char?T  ; T=0x0001  (2)
  430:                     printf("%c",key);
 0000062A  1C30      MOV         R0,R6 ; key
 0000062C  0601      LSL         R1,R0,#0x18 ; key
 0000062E  0E09      LSR         R1,R1,#0x18
 00000630  4800      LDR         R0,=??S_5 ; ??S_5
 00000632  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000634  FCE5      BL          printf?T  ; T=0x0001  (2)
  431:                     tempkey[i] = key;
 00000636  1C30      MOV         R0,R6 ; key
 00000638  1C2A      MOV         R2,R5 ; i
 0000063A  4800      LDR         R1,=tempkey ; tempkey
 0000063C  5488      STRB        R0,[R1,R2]
  432:                     i++;
 0000063E  3501      ADD         R5,#0x1
  434:             }       
 00000640          L_108:
  435:             if((sec()- sec_starts) == 0) // check time out
 00000640  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000642  FCDE      BL          sec?T  ; T=0x0001  (2)
 00000644  1C21      MOV         R1,R4 ; sec_starts
 00000646  1A40      SUB         R0,R1 ; sec_starts
 00000648  2800      CMP         R0,#0x0
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 51  

 0000064A  D1FE      BNE         L_106  ; T=0x0000064A
  437:                 cleardata(); // clear tempkey
 0000064C  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 0000064E  FCD8      BL          cleardata?T  ; T=0x0001  (2)
  438:                 return 0; // if receive fail then return 0
 00000650  2000      MOV         R0,#0x0
 00000652  E06B      B           L_20  ; T=0x0000072C
  440:         }while((key != '*')||(i != 8)); // exit loop when key * has been press and reach last charecter
 00000654          L_106:
 00000654  1C30      MOV         R0,R6 ; key
 00000656  0600      LSL         R0,R0,#0x18 ; key
 00000658  0E00      LSR         R0,R0,#0x18
 0000065A  282A      CMP         R0,#0x2A
 0000065C  D19E      BNE         L_104  ; T=0x0000059C
 0000065E  1C28      MOV         R0,R5 ; i
 00000660  2808      CMP         R0,#0x8 ; i
 00000662  D19B      BNE         L_104  ; T=0x0000059C
  441:     }
 00000664  E061      B           L_21  ; T=0x0000072A
 00000666          L_103:
  442:     else if(mode == 7) // mode 7 for enter hour and minute
 00000666  1C38      MOV         R0,R7 ; mode
 00000668  2807      CMP         R0,#0x7 ; mode
 0000066A  D000      BNE         $+4
 0000066C  E05D      B           L_21  ; T=0x0000072A
  444:         cleardata(); // clear tempkey
 00000670  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 00000672  FCC6      BL          cleardata?T  ; T=0x0001  (2)
  445:         do
 00000674          L_120:
  447:             key = keypad(); // receivce charecter from keypad
 00000674  F7FF      BL          keypad?T  ; T=0x0001  (1)
 00000676  FCC4      BL          keypad?T  ; T=0x0001  (2)
 00000678  1C06      MOV         R6,R0 ; key
  448:              if(key != '$') // keypad sent $ if no key has been press so ignore it
 0000067A  0607      LSL         R7,R0,#0x18 ; key
 0000067C  0E3F      LSR         R7,R7,#0x18
 0000067E  2F24      CMP         R7,#0x24
 00000680  D041      BEQ         L_124  ; T=0x00000706
  451:                 if((key == '*')&&(i == 4)) // end receive when key * has been press and reach last charecter
 00000682  2F2A      CMP         R7,#0x2A
 00000684  D105      BNE         L_125  ; T=0x00000692
 00000686  1C28      MOV         R0,R5 ; i
 00000688  2804      CMP         R0,#0x4 ; i
 0000068A  D102      BNE         L_125  ; T=0x00000692
  453:                     tempkey[i] = '\0';
 0000068C  2000      MOV         R0,#0x0
 0000068E  1C2A      MOV         R2,R5 ; i
 00000690  4800      LDR         R1,=tempkey ; tempkey
 00000692  5488      STRB        R0,[R1,R2]
  454:                     key = '*';
 00000694  262A      MOV         R6,#0x2A
  455:                     printf("\n");
 00000696  4800      LDR         R0,=??S_3 ; ??S_3
 00000698  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000069A  FCB2      BL          printf?T  ; T=0x0001  (2)
  456:                 }
 0000069C  E033      B           L_124  ; T=0x00000706
 0000069E          L_125:
  457:                 else if(key == '#') // delete data when key # has been press
 0000069E  2F23      CMP         R7,#0x23
 000006A0  D10F      BNE         L_127  ; T=0x000006C2
  459:                     if(i > 0)
 000006A2  1C28      MOV         R0,R5 ; i
 000006A4  2800      CMP         R0,#0x0 ; i
 000006A6  DD2E      BLE         L_124  ; T=0x00000706
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 52  

  461:                         lcd_gotoxy(20+(4*(i-1))+(5*(i-1)),3); // set position for lcd
 000006A8  1C29      MOV         R1,R5 ; i
 000006AA  3901      SUB         R1,#0x1
 000006AC  2005      MOV         R0,#0x5
 000006AE  4341      MUL         R1,R0
 000006B0  1C28      MOV         R0,R5 ; i
 000006B2  0080      LSL         R0,R0,#0x2 ; i
 000006B4  3010      ADD         R0,#0x10
 000006B6  1840      ADD         R0,R1
 000006B8  2103      MOV         R1,#0x3
 000006BA  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 000006BC  FCA1      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  462:                         lcd_put_char(' '); // put charecter to lcd
 000006BE  2020      MOV         R0,#0x20
 000006C0  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 000006C2  FC9E      BL          lcd_put_char?T  ; T=0x0001  (2)
  463:                         i--;
 000006C4  3D01      SUB         R5,#0x1
  464:                         printf("\b \b");
 000006C6  4800      LDR         R0,=??S_4 ; ??S_4
 000006C8  F7FF      BL          printf?T  ; T=0x0001  (1)
 000006CA  FC9A      BL          printf?T  ; T=0x0001  (2)
  466:                 }
 000006CC  E01B      B           L_124  ; T=0x00000706
 000006CE          L_127:
  467:                 else if(i == 4) // if reach last charecter then not do anything
 000006CE  1C28      MOV         R0,R5 ; i
 000006D0  2804      CMP         R0,#0x4 ; i
 000006D2  D018      BEQ         L_124  ; T=0x00000706
  471:                 else if(key != '*') // if charecter is not * and # then put to string tempkey
 000006D4  1C30      MOV         R0,R6 ; key
 000006D6  0600      LSL         R0,R0,#0x18 ; key
 000006D8  0E00      LSR         R0,R0,#0x18
 000006DA  282A      CMP         R0,#0x2A
 000006DC  D013      BEQ         L_124  ; T=0x00000706
  473:                     printf("%c",key);
 000006DE  1C30      MOV         R0,R6 ; key
 000006E0  0601      LSL         R1,R0,#0x18 ; key
 000006E2  0E09      LSR         R1,R1,#0x18
 000006E4  4800      LDR         R0,=??S_5 ; ??S_5
 000006E6  F7FF      BL          printf?T  ; T=0x0001  (1)
 000006E8  FC8B      BL          printf?T  ; T=0x0001  (2)
  474:                     lcd_gotoxy(20+(4*i)+(5*i),3); // set position for lcd
 000006EA  1C28      MOV         R0,R5 ; i
 000006EC  0080      LSL         R0,R0,#0x2 ; i
 000006EE  3014      ADD         R0,#0x14
 000006F0  1C29      MOV         R1,R5 ; i
 000006F2  2205      MOV         R2,#0x5
 000006F4  4351      MUL         R1,R2
 000006F6  1840      ADD         R0,R1
 000006F8  2103      MOV         R1,#0x3
 000006FA  F7FF      BL          lcd_gotoxy?T  ; T=0x0001  (1)
 000006FC  FC81      BL          lcd_gotoxy?T  ; T=0x0001  (2)
  475:                     lcd_put_char(key); // put charecter to lcd
 000006FE  1C30      MOV         R0,R6 ; key
 00000700  0600      LSL         R0,R0,#0x18 ; key
 00000702  0E00      LSR         R0,R0,#0x18
 00000704  F7FF      BL          lcd_put_char?T  ; T=0x0001  (1)
 00000706  FC7C      BL          lcd_put_char?T  ; T=0x0001  (2)
  476:                     tempkey[i] = key;
 00000708  1C30      MOV         R0,R6 ; key
 0000070A  1C2A      MOV         R2,R5 ; i
 0000070C  4800      LDR         R1,=tempkey ; tempkey
 0000070E  5488      STRB        R0,[R1,R2]
  477:                     i++;
 00000710  3501      ADD         R5,#0x1
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 53  

  479:             }       
 00000712          L_124:
  480:             if((sec()- sec_starts) == 0) // check time out
 00000712  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000714  FC75      BL          sec?T  ; T=0x0001  (2)
 00000716  1C21      MOV         R1,R4 ; sec_starts
 00000718  1A40      SUB         R0,R1 ; sec_starts
 0000071A  2800      CMP         R0,#0x0
 0000071C  D1FD      BNE         L_122  ; T=0x0000071A
  482:                 cleardata(); // clear tempkey
 0000071E  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 00000720  FC6F      BL          cleardata?T  ; T=0x0001  (2)
  483:                 return 0; // if receive fail then return 0
 00000722  2000      MOV         R0,#0x0
 00000724  E002      B           L_20  ; T=0x0000072C
  485:         }while((key != '*')||(i != 4)); // exit loop when key * has been press and reach last charecter
 00000726          L_122:
 00000726  1C30      MOV         R0,R6 ; key
 00000728  0600      LSL         R0,R0,#0x18 ; key
 0000072A  0E00      LSR         R0,R0,#0x18
 0000072C  282A      CMP         R0,#0x2A
 0000072E  D1A1      BNE         L_120  ; T=0x00000674
 00000730  1C28      MOV         R0,R5 ; i
 00000732  2804      CMP         R0,#0x4 ; i
 00000734  D19E      BNE         L_120  ; T=0x00000674
  486:     }
 00000736          L_21:
  488:     return 1; // if receive complete then return 1
 00000736  2001      MOV         R0,#0x1
 00000738            ; SCOPE-END
  489: }
 00000738          L_20:
 00000738  B001      ADD         R13,#0x4
 0000073A  BCF0      POP         {R4-R7}
 0000073C  BC08      POP         {R3}
 0000073E  4718      BX          R3
 00000740          ENDP ; 'receive_keypad?T'


*** CODE SEGMENT '?PR?check_password?T?main':
  494: int check_password(int sel)
 00000000  B4F0      PUSH        {R4-R7}
 00000002  1C02      MOV         R2,R0 ; sel
 00000004  ---- Variable 'sel' assigned to Register 'R2' ----
 00000004  ---- Variable 'i' assigned to Register 'R1' ----
  495: {
 00000004            ; SCOPE-START
  496:     int i,j,wrong_pass = 0;
 00000004  2300      MOV         R3,#0x0
 00000006  ---- Variable 'wrong_pass' assigned to Register 'R3' ----
  497:     if(sel == 1) // enter mode check password user
 00000006  1C10      MOV         R0,R2 ; sel
 00000008  2801      CMP         R0,#0x1 ; sel
 0000000A  D12C      BNE         L_134  ; T=0x00000066
  499:         for(i = 0;i< MAX_NUMBER_USER;i++) // loop for check all password user
 0000000C  2100      MOV         R1,#0x0
 0000000E          L_138:
  501:             wrong_pass = 1; 
 0000000E  2301      MOV         R3,#0x1
  502:            for(j = 0;j < MAX_PASSWORD_USER;j++) // loop compare password user with that password receive from user
 00000010  2000      MOV         R0,#0x0
 00000012  ---- Variable 'j' assigned to Register 'R0' ----
 00000012          L_143:
  504:                 if(tempkey[j] != PassUser[i].passwordUser[j]) // if has different set wrong_pass to 0
 00000012  1C0D      MOV         R5,R1 ; i
 00000014  016D      LSL         R5,R5,#0x5 ; i
 00000016  1C06      MOV         R6,R0 ; j
 00000018  19AE      ADD         R6,R5,R6 ; j
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 54  

 0000001A  4800      LDR         R4,=PassUser ; PassUser
 0000001C  5DA4      LDRB        R4,[R4,R6]
 0000001E  1C27      MOV         R7,R4
 00000020  1C06      MOV         R6,R0 ; j
 00000022  4800      LDR         R4,=tempkey ; tempkey
 00000024  5DA4      LDRB        R4,[R4,R6]
 00000026  1C26      MOV         R6,R4
 00000028  42BE      CMP         R6,R7
 0000002A  D000      BEQ         L_145  ; T=0x0000002E
  506:                    wrong_pass = 0;
 0000002C  2300      MOV         R3,#0x0
  507:                 }
 0000002E          L_145:
  510:                 if((tempkey[j] == '\0') && (PassUser[i].passwordUser[j] == '\0'))
 0000002E  2C00      CMP         R4,#0x0
 00000030  D10A      BNE         L_140  ; T=0x00000048
 00000032  1C04      MOV         R4,R0 ; j
 00000034  192D      ADD         R5,R4 ; j
 00000036  4800      LDR         R4,=PassUser ; PassUser
 00000038  5D64      LDRB        R4,[R4,R5]
 0000003A  2C00      CMP         R4,#0x0
 0000003C  D104      BNE         L_140  ; T=0x00000048
  512:                     if(j == 0)// if no data in password receive from user then set wrong_pass to 0
 0000003E  1C04      MOV         R4,R0 ; j
 00000040  2C00      CMP         R4,#0x0 ; j
 00000042  D100      BNE         L_147  ; T=0x00000046
  513:                         wrong_pass = 0;
 00000044  2300      MOV         R3,#0x0
 00000046          L_147:
  514:                     j = MAX_PASSWORD_USER;
 00000046  2005      MOV         R0,#0x5
  516:            }
 00000048          L_140:
 00000048  3001      ADD         R0,#0x1
 0000004A  1C04      MOV         R4,R0 ; j
 0000004C  2C05      CMP         R4,#0x5 ; j
 0000004E  DBE0      BLT         L_143  ; T=0x00000012
  517:            if(wrong_pass) // if wrong_pass is 1 then password user is correct and return 1
 00000050  1C18      MOV         R0,R3 ; wrong_pass
 00000052  2800      CMP         R0,#0x0 ; wrong_pass
 00000054  D001      BEQ         L_135  ; T=0x0000005A
  518:                 return 1;
 00000056  2001      MOV         R0,#0x1
 00000058  E023      B           L_149  ; T=0x000000A2
  519:         }
 0000005A          L_135:
 0000005A  3101      ADD         R1,#0x1
 0000005C  1C08      MOV         R0,R1 ; i
 0000005E  2832      CMP         R0,#0x32 ; i
 00000060  DBD5      BLT         L_138  ; T=0x0000000E
  520:         return 0; // password user not correct and return 0
 00000062  2000      MOV         R0,#0x0
 00000064  E01D      B           L_149  ; T=0x000000A2
  521:     }
 00000066          L_134:
  522:     else if(sel == 2) // enter mode check password to enter menu
 00000066  1C10      MOV         R0,R2 ; sel
 00000068  2802      CMP         R0,#0x2 ; sel
 0000006A  D119      BNE         L_151  ; T=0x000000A0
  524:          for(i = 0;i < MAX_PASSWORD;i++)
 0000006C  2100      MOV         R1,#0x0
 0000006E          L_155:
  527:             if(tempkey[i] != password[i])
 0000006E  1C0A      MOV         R2,R1 ; i
 00000070  4800      LDR         R0,=password ; password
 00000072  5C82      LDRB        R2,[R0,R2]
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 55  

 00000074  1C14      MOV         R4,R2
 00000076  1C0B      MOV         R3,R1 ; i
 00000078  4800      LDR         R0,=tempkey ; tempkey
 0000007A  5CC3      LDRB        R3,[R0,R3]
 0000007C  1C18      MOV         R0,R3
 0000007E  42A0      CMP         R0,R4
 00000080  D001      BEQ         L_157  ; T=0x00000086
  528:                 return 0;
 00000082  2000      MOV         R0,#0x0
 00000084  E00D      B           L_149  ; T=0x000000A2
 00000086          L_157:
  531:             if((tempkey[i] == '\0') && (password[i] == '\0'))
 00000086  1C18      MOV         R0,R3
 00000088  2800      CMP         R0,#0x0
 0000008A  D103      BNE         L_152  ; T=0x00000094
 0000008C  1C10      MOV         R0,R2
 0000008E  2800      CMP         R0,#0x0
 00000090  D100      BNE         L_152  ; T=0x00000094
  533:                 i = MAX_PASSWORD;
 00000092  2109      MOV         R1,#0x9
  535:         }
 00000094          L_152:
 00000094  3101      ADD         R1,#0x1
 00000096  1C08      MOV         R0,R1 ; i
 00000098  2809      CMP         R0,#0x9 ; i
 0000009A  DBE8      BLT         L_155  ; T=0x0000006E
  537:         return 1; // password is correct and return 1
 0000009C  2001      MOV         R0,#0x1
 0000009E  E000      B           L_149  ; T=0x000000A2
  538:     }
 000000A0          L_151:
  540:         return 0;
 000000A0  2000      MOV         R0,#0x0
 000000A2            ; SCOPE-END
  541: }
 000000A2          L_149:
 000000A2  BCF0      POP         {R4-R7}
 000000A4  4770      BX          R14
 000000A6          ENDP ; 'check_password?T'


*** CODE SEGMENT '?PR?change_password?T?main':
  545: {
 00000000            ; SCOPE-START
  547:     if(tempkey[0] == '\0') // if no data then exit
 00000000  4800      LDR         R0,=tempkey ; tempkey
 00000002  7800      LDRB        R0,[R0,#0x0] ; tempkey
 00000004  2800      CMP         R0,#0x0
 00000006  D00A      BEQ         L_161  ; T=0x0000001E
  551:     for(i = 0;i < MAX_PASSWORD;i++) // set new password 
 00000008  2000      MOV         R0,#0x0
 0000000A  ---- Variable 'i' assigned to Register 'R0' ----
 0000000A          L_165:
  553:          password[i] = tempkey[i];
 0000000A  1C02      MOV         R2,R0 ; i
 0000000C  4800      LDR         R1,=tempkey ; tempkey
 0000000E  5C89      LDRB        R1,[R1,R2]
 00000010  1C03      MOV         R3,R0 ; i
 00000012  4800      LDR         R2,=password ; password
 00000014  54D1      STRB        R1,[R2,R3]
  554:     }
 00000016  3001      ADD         R0,#0x1
 00000018  1C01      MOV         R1,R0 ; i
 0000001A  2909      CMP         R1,#0x9 ; i
 0000001C  DBF5      BLT         L_165  ; T=0x0000000A
 0000001E            ; SCOPE-END
  555: }
 0000001E          L_161:
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 56  

 0000001E  4770      BX          R14
 00000020          ENDP ; 'change_password?T'


*** CODE SEGMENT '?PR?setStateCompare?T?main':
  558: void setStateCompare(void){
 00000000  B500      PUSH        {LR}
  559:     printf("\n*****************\n");
 00000002  4800      LDR         R0,=??S_8 ; ??S_8
 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  560:     printf("* State Compare *\n");
 00000008  4800      LDR         R0,=??S_9 ; ??S_9
 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  561:     printf("*****************\n");
 0000000E  4800      LDR         R0,=??S_10 ; ??S_10
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  562:     state = COMPARE;
 00000014  2100      MOV         R1,#0x0
 00000016  4800      LDR         R0,=state ; state
 00000018  6001      STR         R1,[R0,#0x0] ; state
  563:     loadpic_mmc(401); // load picture from sd/mmc
 0000001A  4800      LDR         R0,=0x191
 0000001C  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          loadpic_mmc?T  ; T=0x0001  (2)
  564:     lcd_fill_picture(temppic); // show picture on lcd
 00000020  4800      LDR         R0,=temppic ; temppic
 00000022  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000024  FFED      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  565: }
 00000026  BC08      POP         {R3}
 00000028  4718      BX          R3
 0000002A          ENDP ; 'setStateCompare?T'


*** CODE SEGMENT '?PR?setStateConfig?T?main':
  568: void setStateConfig(void){
 00000000  B500      PUSH        {LR}
  569:     printf("\n****************\n");
 00000002  4800      LDR         R0,=??S_11 ; ??S_11
 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  570:     printf("* State Config *\n");
 00000008  4800      LDR         R0,=??S_12 ; ??S_12
 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  571:     printf("****************\n");
 0000000E  4800      LDR         R0,=??S_13 ; ??S_13
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  572:     printf("[1] Change password\n");
 00000014  4800      LDR         R0,=??S_14 ; ??S_14
 00000016  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          printf?T  ; T=0x0001  (2)
  573:     printf("[2] Set time\n");
 0000001A  4800      LDR         R0,=??S_15 ; ??S_15
 0000001C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          printf?T  ; T=0x0001  (2)
  574:     printf("[3] Save RFID card\n");
 00000020  4800      LDR         R0,=??S_16 ; ??S_16
 00000022  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000024  FFED      BL          printf?T  ; T=0x0001  (2)
  575:     printf("[4] Delete RFID card\n");
 00000026  4800      LDR         R0,=??S_17 ; ??S_17
 00000028  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000002A  FFEA      BL          printf?T  ; T=0x0001  (2)
  576:     printf("[5] Add password user\n");
 0000002C  4800      LDR         R0,=??S_18 ; ??S_18
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 57  

 0000002E  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000030  FFE7      BL          printf?T  ; T=0x0001  (2)
  577:     printf("[6] Delete password user\n");
 00000032  4800      LDR         R0,=??S_19 ; ??S_19
 00000034  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000036  FFE4      BL          printf?T  ; T=0x0001  (2)
  578:     printf("[7] Show RFID card save time\n");
 00000038  4800      LDR         R0,=??S_20 ; ??S_20
 0000003A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000003C  FFE1      BL          printf?T  ; T=0x0001  (2)
  579:     printf("[8] Show password user save time\n");
 0000003E  4800      LDR         R0,=??S_21 ; ??S_21
 00000040  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000042  FFDE      BL          printf?T  ; T=0x0001  (2)
  580:     printf("[9] Show Stamp time\n");
 00000044  4800      LDR         R0,=??S_22 ; ??S_22
 00000046  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000048  FFDB      BL          printf?T  ; T=0x0001  (2)
  581:     printf("[0] Show time\n");
 0000004A  4800      LDR         R0,=??S_23 ; ??S_23
 0000004C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000004E  FFD8      BL          printf?T  ; T=0x0001  (2)
  582:     printf("Select Menu :");
 00000050  4800      LDR         R0,=??S_24 ; ??S_24
 00000052  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000054  FFD5      BL          printf?T  ; T=0x0001  (2)
  583:     state = CONFIG; 
 00000056  210A      MOV         R1,#0xA
 00000058  4800      LDR         R0,=state ; state
 0000005A  6001      STR         R1,[R0,#0x0] ; state
  584: }
 0000005C  BC08      POP         {R3}
 0000005E  4718      BX          R3
 00000060          ENDP ; 'setStateConfig?T'


*** CODE SEGMENT '?PR?setStateChangepass?T?main':
  587: void setStateChangepass(void){
 00000000  B500      PUSH        {LR}
  588:     printf("*************************\n");
 00000002  4800      LDR         R0,=??S_25 ; ??S_25
 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  589:     printf("* State Change Password *\n");
 00000008  4800      LDR         R0,=??S_26 ; ??S_26
 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  590:     printf("*************************\n");
 0000000E  4800      LDR         R0,=??S_25 ; ??S_25
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  591:     printf("Enter New Password :");
 00000014  4800      LDR         R0,=??S_27 ; ??S_27
 00000016  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          printf?T  ; T=0x0001  (2)
  592:     state = CHANGEPASS;
 0000001A  2101      MOV         R1,#0x1
 0000001C  4800      LDR         R0,=state ; state
 0000001E  6001      STR         R1,[R0,#0x0] ; state
  593: }
 00000020  BC08      POP         {R3}
 00000022  4718      BX          R3
 00000024          ENDP ; 'setStateChangepass?T'


*** CODE SEGMENT '?PR?setStateSettime?T?main':
  596: void setStateSettime(void){
 00000000  B500      PUSH        {LR}
  597:     printf("******************\n");
 00000002  4800      LDR         R0,=??S_28 ; ??S_28
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 58  

 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  598:     printf("* State Set Time *\n");
 00000008  4800      LDR         R0,=??S_29 ; ??S_29
 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  599:     printf("******************\n");
 0000000E  4800      LDR         R0,=??S_28 ; ??S_28
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  600:     printf("Enter Time (ddmmyyyy) :");
 00000014  4800      LDR         R0,=??S_30 ; ??S_30
 00000016  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          printf?T  ; T=0x0001  (2)
  601:     state = SETTIME;
 0000001A  2102      MOV         R1,#0x2
 0000001C  4800      LDR         R0,=state ; state
 0000001E  6001      STR         R1,[R0,#0x0] ; state
  602: }
 00000020  BC08      POP         {R3}
 00000022  4718      BX          R3
 00000024          ENDP ; 'setStateSettime?T'


*** CODE SEGMENT '?PR?setStateSave?T?main':
  605: void setStateSave(void){
 00000000  B500      PUSH        {LR}
  606:     printf("**************\n");
 00000002  4800      LDR         R0,=??S_31 ; ??S_31
 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  607:     printf("* State Save *\n");
 00000008  4800      LDR         R0,=??S_32 ; ??S_32
 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  608:     printf("**************\n");
 0000000E  4800      LDR         R0,=??S_31 ; ??S_31
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  609:     printf("Please Stamp Card in 1 minute\n");
 00000014  4800      LDR         R0,=??S_33 ; ??S_33
 00000016  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          printf?T  ; T=0x0001  (2)
  610:     loadpic_mmc(418); // load picture from sd/mmc
 0000001A  4800      LDR         R0,=0x1A2
 0000001C  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          loadpic_mmc?T  ; T=0x0001  (2)
  611:     lcd_fill_picture(temppic); // show picture on lcd
 00000020  4800      LDR         R0,=temppic ; temppic
 00000022  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000024  FFED      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  612:     state = SAVE; 
 00000026  2103      MOV         R1,#0x3
 00000028  4800      LDR         R0,=state ; state
 0000002A  6001      STR         R1,[R0,#0x0] ; state
  613: }
 0000002C  BC08      POP         {R3}
 0000002E  4718      BX          R3
 00000030          ENDP ; 'setStateSave?T'


*** CODE SEGMENT '?PR?setStateDelete?T?main':
  616: void setStateDelete(void){
 00000000  B500      PUSH        {LR}
  617:     printf("****************\n");
 00000002  4800      LDR         R0,=??S_13 ; ??S_13
 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  618:     printf("* State Delete *\n");
 00000008  4800      LDR         R0,=??S_34 ; ??S_34
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 59  

 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  619:     printf("****************\n");
 0000000E  4800      LDR         R0,=??S_13 ; ??S_13
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  620:     printf("Please Stamp Card in 1 minute\n");
 00000014  4800      LDR         R0,=??S_33 ; ??S_33
 00000016  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          printf?T  ; T=0x0001  (2)
  621:     loadpic_mmc(418); // load picture from sd/mmc
 0000001A  4800      LDR         R0,=0x1A2
 0000001C  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          loadpic_mmc?T  ; T=0x0001  (2)
  622:     lcd_fill_picture(temppic); // show picture on lcd
 00000020  4800      LDR         R0,=temppic ; temppic
 00000022  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000024  FFED      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  623:     state = DELETE; 
 00000026  2104      MOV         R1,#0x4
 00000028  4800      LDR         R0,=state ; state
 0000002A  6001      STR         R1,[R0,#0x0] ; state
  624: }
 0000002C  BC08      POP         {R3}
 0000002E  4718      BX          R3
 00000030          ENDP ; 'setStateDelete?T'


*** CODE SEGMENT '?PR?setStateAddPassword?T?main':
  627: void setStateAddPassword(void){
 00000000  B500      PUSH        {LR}
  628:     printf("**********************\n");
 00000002  4800      LDR         R0,=??S_35 ; ??S_35
 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  629:     printf("* State Add Password *\n");
 00000008  4800      LDR         R0,=??S_36 ; ??S_36
 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  630:     printf("**********************\n");
 0000000E  4800      LDR         R0,=??S_35 ; ??S_35
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  631:     printf("Enter Password User :");
 00000014  4800      LDR         R0,=??S_37 ; ??S_37
 00000016  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          printf?T  ; T=0x0001  (2)
  632:     loadpic_mmc(419); // load picture from sd/mmc
 0000001A  4800      LDR         R0,=0x1A3
 0000001C  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          loadpic_mmc?T  ; T=0x0001  (2)
  633:     lcd_fill_picture(temppic); // show picture on lcd
 00000020  4800      LDR         R0,=temppic ; temppic
 00000022  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000024  FFED      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  634:     state = ADDPASSWORD; 
 00000026  2105      MOV         R1,#0x5
 00000028  4800      LDR         R0,=state ; state
 0000002A  6001      STR         R1,[R0,#0x0] ; state
  635: }
 0000002C  BC08      POP         {R3}
 0000002E  4718      BX          R3
 00000030          ENDP ; 'setStateAddPassword?T'


*** CODE SEGMENT '?PR?setStateDeletePassword?T?main':
  638: void setStateDeletePassword(void){
 00000000  B500      PUSH        {LR}
  639:     printf("*************************\n");
 00000002  4800      LDR         R0,=??S_25 ; ??S_25
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 60  

 00000004  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000006  FFFC      BL          printf?T  ; T=0x0001  (2)
  640:     printf("* State Delete Password *\n");
 00000008  4800      LDR         R0,=??S_38 ; ??S_38
 0000000A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          printf?T  ; T=0x0001  (2)
  641:     printf("*************************\n");
 0000000E  4800      LDR         R0,=??S_25 ; ??S_25
 00000010  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000012  FFF6      BL          printf?T  ; T=0x0001  (2)
  642:     printf("Enter Password User :");
 00000014  4800      LDR         R0,=??S_37 ; ??S_37
 00000016  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          printf?T  ; T=0x0001  (2)
  643:     loadpic_mmc(419); // load picture from sd/mmc
 0000001A  4800      LDR         R0,=0x1A3
 0000001C  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          loadpic_mmc?T  ; T=0x0001  (2)
  644:     lcd_fill_picture(temppic); // show picture on lcd
 00000020  4800      LDR         R0,=temppic ; temppic
 00000022  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000024  FFED      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  645:     state = DELETEPASSWORD; 
 00000026  2106      MOV         R1,#0x6
 00000028  4800      LDR         R0,=state ; state
 0000002A  6001      STR         R1,[R0,#0x0] ; state
  646: }
 0000002C  BC08      POP         {R3}
 0000002E  4718      BX          R3
 00000030          ENDP ; 'setStateDeletePassword?T'


*** CODE SEGMENT '?PR?CheckRFIDCard?T?main':
  649: int CheckRFIDCard(int rfid)
 00000000  1C02      MOV         R2,R0 ; rfid
 00000002  ---- Variable 'rfid' assigned to Register 'R2' ----
  650: {
 00000002            ; SCOPE-START
  652:      for(i=0;i<MAX_RFID_CARD;i++) // loop for check all card
 00000002  2100      MOV         R1,#0x0
 00000004  ---- Variable 'i' assigned to Register 'R1' ----
 00000004          L_170:
  654:          if( memoryRFID[i].datarfid == rfid) // if ID of RFID card that stamp and ID of RFID card in system
 00000004  1C0B      MOV         R3,R1 ; i
 00000006  201C      MOV         R0,#0x1C
 00000008  4343      MUL         R3,R0
 0000000A  4800      LDR         R0,=memoryRFID ; memoryRFID
 0000000C  58C3      LDR         R3,[R0,R3]
 0000000E  1C10      MOV         R0,R2 ; rfid
 00000010  4283      CMP         R3,R0 ; rfid
 00000012  D101      BNE         L_167  ; T=0x00000018
  657:              return 1;
 00000014  2001      MOV         R0,#0x1
 00000016  E004      B           L_173  ; T=0x00000022
  659:      }
 00000018          L_167:
 00000018  3101      ADD         R1,#0x1
 0000001A  1C08      MOV         R0,R1 ; i
 0000001C  2832      CMP         R0,#0x32 ; i
 0000001E  DBF1      BLT         L_170  ; T=0x00000004
  660:      return 0; // not found match ID of card then return 0
 00000020  2000      MOV         R0,#0x0
 00000022            ; SCOPE-END
  662: }
 00000022          L_173:
 00000022  4770      BX          R14
 00000024          ENDP ; 'CheckRFIDCard?T'


*** CODE SEGMENT '?PR?inputMemTem?T?main':
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 61  

  665: void inputMemTem(int datarfid)
 00000000  B500      PUSH        {LR}
 00000002  1C03      MOV         R3,R0 ; datarfid
 00000004  ---- Variable 'datarfid' assigned to Register 'R3' ----
  668:       memoryTem[lMemTem].datarfid = datarfid;
 00000004  1C18      MOV         R0,R3 ; datarfid
 00000006  4800      LDR         R1,=lMemTem ; lMemTem
 00000008  680A      LDR         R2,[R1,#0x0] ; lMemTem
 0000000A  211C      MOV         R1,#0x1C
 0000000C  434A      MUL         R2,R1
 0000000E  4800      LDR         R1,=memoryTem ; memoryTem
 00000010  5088      STR         R0,[R1,R2]
  669:       memoryTem[lMemTem].day = day();
 00000012  F7FF      BL          day?T  ; T=0x0001  (1)
 00000014  FFF5      BL          day?T  ; T=0x0001  (2)
 00000016  4800      LDR         R1,=lMemTem ; lMemTem
 00000018  680A      LDR         R2,[R1,#0x0] ; lMemTem
 0000001A  211C      MOV         R1,#0x1C
 0000001C  434A      MUL         R2,R1
 0000001E  4800      LDR         R1,=memoryTem + 0x4 ; memoryTem+4
 00000020  5088      STR         R0,[R1,R2]
  670:       memoryTem[lMemTem].month = month();
 00000022  F7FF      BL          month?T  ; T=0x0001  (1)
 00000024  FFED      BL          month?T  ; T=0x0001  (2)
 00000026  4800      LDR         R1,=lMemTem ; lMemTem
 00000028  680A      LDR         R2,[R1,#0x0] ; lMemTem
 0000002A  211C      MOV         R1,#0x1C
 0000002C  434A      MUL         R2,R1
 0000002E  4800      LDR         R1,=memoryTem + 0x8 ; memoryTem+8
 00000030  5088      STR         R0,[R1,R2]
  671:       memoryTem[lMemTem].year = year();
 00000032  F7FF      BL          year?T  ; T=0x0001  (1)
 00000034  FFE5      BL          year?T  ; T=0x0001  (2)
 00000036  4800      LDR         R1,=lMemTem ; lMemTem
 00000038  680A      LDR         R2,[R1,#0x0] ; lMemTem
 0000003A  211C      MOV         R1,#0x1C
 0000003C  434A      MUL         R2,R1
 0000003E  4800      LDR         R1,=memoryTem + 0xC ; memoryTem+12
 00000040  5088      STR         R0,[R1,R2]
  672:       memoryTem[lMemTem].hour = hour();
 00000042  F7FF      BL          hour?T  ; T=0x0001  (1)
 00000044  FFDD      BL          hour?T  ; T=0x0001  (2)
 00000046  4800      LDR         R1,=lMemTem ; lMemTem
 00000048  680A      LDR         R2,[R1,#0x0] ; lMemTem
 0000004A  211C      MOV         R1,#0x1C
 0000004C  434A      MUL         R2,R1
 0000004E  4800      LDR         R1,=memoryTem + 0x10 ; memoryTem+16
 00000050  5088      STR         R0,[R1,R2]
  673:       memoryTem[lMemTem].minute = minute();
 00000052  F7FF      BL          minute?T  ; T=0x0001  (1)
 00000054  FFD5      BL          minute?T  ; T=0x0001  (2)
 00000056  4800      LDR         R1,=lMemTem ; lMemTem
 00000058  680A      LDR         R2,[R1,#0x0] ; lMemTem
 0000005A  211C      MOV         R1,#0x1C
 0000005C  434A      MUL         R2,R1
 0000005E  4800      LDR         R1,=memoryTem + 0x14 ; memoryTem+20
 00000060  5088      STR         R0,[R1,R2]
  674:       memoryTem[lMemTem].sec = sec();
 00000062  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000064  FFCD      BL          sec?T  ; T=0x0001  (2)
 00000066  4800      LDR         R1,=lMemTem ; lMemTem
 00000068  6809      LDR         R1,[R1,#0x0] ; lMemTem
 0000006A  231C      MOV         R3,#0x1C
 0000006C  434B      MUL         R3,R1
 0000006E  4800      LDR         R2,=memoryTem + 0x18 ; memoryTem+24
 00000070  50D0      STR         R0,[R2,R3]
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 62  

  675:       lMemTem++; // increase number of card that use to open door
 00000072  4800      LDR         R0,=lMemTem ; lMemTem
 00000074  3101      ADD         R1,#0x1
 00000076  6001      STR         R1,[R0,#0x0] ; lMemTem
  676:       if( lMemTem == MAX_RFID_CARD) // if number of card reach to maximun then reset number of card to 0
 00000078  4800      LDR         R0,=lMemTem ; lMemTem
 0000007A  6800      LDR         R0,[R0,#0x0] ; lMemTem
 0000007C  2832      CMP         R0,#0x32
 0000007E  D102      BNE         L_174  ; T=0x00000086
  678:           lMemTem = 0;
 00000080  2100      MOV         R1,#0x0
 00000082  4800      LDR         R0,=lMemTem ; lMemTem
 00000084  6001      STR         R1,[R0,#0x0] ; lMemTem
  679:       }
 00000086          L_174:
  680: }
 00000086  BC08      POP         {R3}
 00000088  4718      BX          R3
 0000008A          ENDP ; 'inputMemTem?T'


*** CODE SEGMENT '?PR?inputMemRFID?T?main':
  683: int inputMemRFID(int inrfid)
 00000000  B510      PUSH        {R4,LR}
 00000002  1C03      MOV         R3,R0 ; inrfid
 00000004  ---- Variable 'inrfid' assigned to Register 'R3' ----
  684: {
 00000004            ; SCOPE-START
  686:       if( lMemRFID == MAX_RFID_CARD) // if number of card is full then return 0
 00000004  4800      LDR         R0,=lMemRFID ; lMemRFID
 00000006  6802      LDR         R2,[R0,#0x0] ; lMemRFID
 00000008  2A32      CMP         R2,#0x32
 0000000A  D101      BNE         L_181  ; T=0x00000010
  688:           return 0;
 0000000C  2000      MOV         R0,#0x0
 0000000E  E047      B           L_176  ; T=0x000000A0
  690:       for(i=0;i<MAX_RFID_CARD;i++) // if card already save then return 0
 00000010          L_181:
 00000010  2100      MOV         R1,#0x0
 00000012  ---- Variable 'i' assigned to Register 'R1' ----
 00000012          L_180:
  692:          if( memoryRFID[i].datarfid == inrfid)
 00000012  1C0C      MOV         R4,R1 ; i
 00000014  201C      MOV         R0,#0x1C
 00000016  4344      MUL         R4,R0
 00000018  4800      LDR         R0,=memoryRFID ; memoryRFID
 0000001A  5904      LDR         R4,[R0,R4]
 0000001C  1C18      MOV         R0,R3 ; inrfid
 0000001E  4284      CMP         R4,R0 ; inrfid
 00000020  D101      BNE         L_177  ; T=0x00000026
  694:              return 0;
 00000022  2000      MOV         R0,#0x0
 00000024  E03C      B           L_176  ; T=0x000000A0
  696:       }
 00000026          L_177:
 00000026  3101      ADD         R1,#0x1
 00000028  1C08      MOV         R0,R1 ; i
 0000002A  2832      CMP         R0,#0x32 ; i
 0000002C  DBF1      BLT         L_180  ; T=0x00000012
  699:       memoryRFID[lMemRFID].datarfid = inrfid;
 0000002E  1C18      MOV         R0,R3 ; inrfid
 00000030  211C      MOV         R1,#0x1C
 00000032  434A      MUL         R2,R1
 00000034  4800      LDR         R1,=memoryRFID ; memoryRFID
 00000036  5088      STR         R0,[R1,R2]
  700:       memoryRFID[lMemRFID].day = day();
 00000038  F7FF      BL          day?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          day?T  ; T=0x0001  (2)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 63  

 0000003C  4800      LDR         R1,=lMemRFID ; lMemRFID
 0000003E  680A      LDR         R2,[R1,#0x0] ; lMemRFID
 00000040  211C      MOV         R1,#0x1C
 00000042  434A      MUL         R2,R1
 00000044  4800      LDR         R1,=memoryRFID + 0x4 ; memoryRFID+4
 00000046  5088      STR         R0,[R1,R2]
  701:       memoryRFID[lMemRFID].month = month();
 00000048  F7FF      BL          month?T  ; T=0x0001  (1)
 0000004A  FFDA      BL          month?T  ; T=0x0001  (2)
 0000004C  4800      LDR         R1,=lMemRFID ; lMemRFID
 0000004E  680A      LDR         R2,[R1,#0x0] ; lMemRFID
 00000050  211C      MOV         R1,#0x1C
 00000052  434A      MUL         R2,R1
 00000054  4800      LDR         R1,=memoryRFID + 0x8 ; memoryRFID+8
 00000056  5088      STR         R0,[R1,R2]
  702:       memoryRFID[lMemRFID].year = year();
 00000058  F7FF      BL          year?T  ; T=0x0001  (1)
 0000005A  FFD2      BL          year?T  ; T=0x0001  (2)
 0000005C  4800      LDR         R1,=lMemRFID ; lMemRFID
 0000005E  680A      LDR         R2,[R1,#0x0] ; lMemRFID
 00000060  211C      MOV         R1,#0x1C
 00000062  434A      MUL         R2,R1
 00000064  4800      LDR         R1,=memoryRFID + 0xC ; memoryRFID+12
 00000066  5088      STR         R0,[R1,R2]
  703:       memoryRFID[lMemRFID].hour = hour();
 00000068  F7FF      BL          hour?T  ; T=0x0001  (1)
 0000006A  FFCA      BL          hour?T  ; T=0x0001  (2)
 0000006C  4800      LDR         R1,=lMemRFID ; lMemRFID
 0000006E  680A      LDR         R2,[R1,#0x0] ; lMemRFID
 00000070  211C      MOV         R1,#0x1C
 00000072  434A      MUL         R2,R1
 00000074  4800      LDR         R1,=memoryRFID + 0x10 ; memoryRFID+16
 00000076  5088      STR         R0,[R1,R2]
  704:       memoryRFID[lMemRFID].minute = minute();
 00000078  F7FF      BL          minute?T  ; T=0x0001  (1)
 0000007A  FFC2      BL          minute?T  ; T=0x0001  (2)
 0000007C  4800      LDR         R1,=lMemRFID ; lMemRFID
 0000007E  680A      LDR         R2,[R1,#0x0] ; lMemRFID
 00000080  211C      MOV         R1,#0x1C
 00000082  434A      MUL         R2,R1
 00000084  4800      LDR         R1,=memoryRFID + 0x14 ; memoryRFID+20
 00000086  5088      STR         R0,[R1,R2]
  705:       memoryRFID[lMemRFID].sec = sec();
 00000088  F7FF      BL          sec?T  ; T=0x0001  (1)
 0000008A  FFBA      BL          sec?T  ; T=0x0001  (2)
 0000008C  4800      LDR         R1,=lMemRFID ; lMemRFID
 0000008E  6809      LDR         R1,[R1,#0x0] ; lMemRFID
 00000090  231C      MOV         R3,#0x1C
 00000092  434B      MUL         R3,R1
 00000094  4800      LDR         R2,=memoryRFID + 0x18 ; memoryRFID+24
 00000096  50D0      STR         R0,[R2,R3]
  706:       lMemRFID++; // increase number of card in system
 00000098  4800      LDR         R0,=lMemRFID ; lMemRFID
 0000009A  3101      ADD         R1,#0x1
 0000009C  6001      STR         R1,[R0,#0x0] ; lMemRFID
  707:       return 1; // return 1 when add card is done
 0000009E  2001      MOV         R0,#0x1
 000000A0            ; SCOPE-END
  708: }
 000000A0          L_176:
 000000A0  BC10      POP         {R4}
 000000A2  BC08      POP         {R3}
 000000A4  4718      BX          R3
 000000A6          ENDP ; 'inputMemRFID?T'


*** CODE SEGMENT '?PR?deleteMemRFID?T?main':
  711: int deleteMemRFID(int inrfid)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 64  

 00000000  B430      PUSH        {R4-R5}
 00000002  1C05      MOV         R5,R0 ; inrfid
 00000004  ---- Variable 'inrfid' assigned to Register 'R5' ----
  712: {
 00000004            ; SCOPE-START
  714:      for(i=0;i<MAX_RFID_CARD;i++)
 00000004  2400      MOV         R4,#0x0
 00000006  ---- Variable 'i' assigned to Register 'R4' ----
 00000006          L_186:
  716:          if( memoryRFID[i].datarfid == inrfid) // if ID of card that stamp and ID of card in system is match then de
             -lete 
 00000006  1C22      MOV         R2,R4 ; i
 00000008  201C      MOV         R0,#0x1C
 0000000A  4342      MUL         R2,R0
 0000000C  4800      LDR         R0,=memoryRFID ; memoryRFID
 0000000E  5881      LDR         R1,[R0,R2]
 00000010  1C28      MOV         R0,R5 ; inrfid
 00000012  4281      CMP         R1,R0 ; inrfid
 00000014  D117      BNE         L_183  ; T=0x00000046
  718:              memoryRFID[i] = memoryRFID[--lMemRFID]; // copy data of last card to data of match card
 00000016  4800      LDR         R1,=lMemRFID ; lMemRFID
 00000018  6808      LDR         R0,[R1,#0x0] ; lMemRFID
 0000001A  3801      SUB         R0,#0x1
 0000001C  6008      STR         R0,[R1,#0x0] ; lMemRFID
 0000001E  211C      MOV         R1,#0x1C
 00000020  4348      MUL         R0,R1
 00000022  4800      LDR         R1,=memoryRFID ; memoryRFID
 00000024  1809      ADD         R1,R0 ; memoryRFID
 00000026  4800      LDR         R0,=memoryRFID ; memoryRFID
 00000028  1880      ADD         R0,R2 ; memoryRFID
 0000002A  2207      MOV         R2,#0x7
 0000002C          L_526:
 0000002C  C908      LDMIA       R1!,{R3}
 0000002E  C008      STMIA       R0!,{R3}
 00000030  1E52      SUB         R2,R2,#0x1
 00000032  D1FB      BNE         L_526  ; T=0x0000002C
  720:              memoryRFID[lMemRFID].datarfid = 0; // remove data of last card
 00000034  2000      MOV         R0,#0x0
 00000036  4800      LDR         R1,=lMemRFID ; lMemRFID
 00000038  680A      LDR         R2,[R1,#0x0] ; lMemRFID
 0000003A  211C      MOV         R1,#0x1C
 0000003C  434A      MUL         R2,R1
 0000003E  4800      LDR         R1,=memoryRFID ; memoryRFID
 00000040  5088      STR         R0,[R1,R2]
  721:              return 1; // return 1 when done
 00000042  2001      MOV         R0,#0x1
 00000044  E004      B           L_189  ; T=0x00000050
  723:      }
 00000046          L_183:
 00000046  3401      ADD         R4,#0x1
 00000048  1C20      MOV         R0,R4 ; i
 0000004A  2832      CMP         R0,#0x32 ; i
 0000004C  DBDB      BLT         L_186  ; T=0x00000006
  724:      return 0; // not found ID of card then return 0
 0000004E  2000      MOV         R0,#0x0
 00000050            ; SCOPE-END
  725: }
 00000050          L_189:
 00000050  BC30      POP         {R4-R5}
 00000052  4770      BX          R14
 00000054          ENDP ; 'deleteMemRFID?T'


*** CODE SEGMENT '?PR?addPasswordUser?T?main':
  728: int addPasswordUser()
 00000000  B500      PUSH        {LR}
  729: {
 00000002            ; SCOPE-START
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 65  

  731:     if(lPasswordUser == MAX_NUMBER_USER) // if number of password user is full then return 0
 00000002  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 00000004  6800      LDR         R0,[R0,#0x0] ; lPasswordUser
 00000006  2832      CMP         R0,#0x32
 00000008  D101      BNE         L_190  ; T=0x0000000E
  733:         return 0;
 0000000A  2000      MOV         R0,#0x0
 0000000C  E043      B           L_191  ; T=0x00000096
  734:     }
 0000000E          L_190:
  735:     else if(check_password(1) == 1) // if password user already save then return 0
 0000000E  2001      MOV         R0,#0x1
 00000010  F7FF      BL          check_password?T  ; T=0x0001  (1)
 00000012  FFF6      BL          check_password?T  ; T=0x0001  (2)
 00000014  2801      CMP         R0,#0x1 ; check_password?T
 00000016  D101      BNE         L_199  ; T=0x0000001C
  737:         return 0;
 00000018  2000      MOV         R0,#0x0
 0000001A  E03C      B           L_191  ; T=0x00000096
  741:         for(i = 0;i < MAX_PASSWORD_USER;i++)
 0000001C          L_199:
 0000001C  2000      MOV         R0,#0x0
 0000001E  ---- Variable 'i' assigned to Register 'R0' ----
 0000001E          L_198:
  743:             PassUser[lPasswordUser].passwordUser[i] = tempkey[i];
 0000001E  1C02      MOV         R2,R0 ; i
 00000020  4800      LDR         R1,=tempkey ; tempkey
 00000022  5C89      LDRB        R1,[R1,R2]
 00000024  4800      LDR         R2,=lPasswordUser ; lPasswordUser
 00000026  6813      LDR         R3,[R2,#0x0] ; lPasswordUser
 00000028  015B      LSL         R3,R3,#0x5
 0000002A  1C02      MOV         R2,R0 ; i
 0000002C  189B      ADD         R3,R2 ; i
 0000002E  4800      LDR         R2,=PassUser ; PassUser
 00000030  54D1      STRB        R1,[R2,R3]
  744:         }
 00000032  3001      ADD         R0,#0x1
 00000034  1C01      MOV         R1,R0 ; i
 00000036  2905      CMP         R1,#0x5 ; i
 00000038  DBF1      BLT         L_198  ; T=0x0000001E
  745:         PassUser[lPasswordUser].day = day();
 0000003A  F7FF      BL          day?T  ; T=0x0001  (1)
 0000003C  FFE1      BL          day?T  ; T=0x0001  (2)
 0000003E  4800      LDR         R1,=lPasswordUser ; lPasswordUser
 00000040  680A      LDR         R2,[R1,#0x0] ; lPasswordUser
 00000042  0152      LSL         R2,R2,#0x5
 00000044  4800      LDR         R1,=PassUser + 0x8 ; PassUser+8
 00000046  5088      STR         R0,[R1,R2]
  746:         PassUser[lPasswordUser].month = month();
 00000048  F7FF      BL          month?T  ; T=0x0001  (1)
 0000004A  FFDA      BL          month?T  ; T=0x0001  (2)
 0000004C  4800      LDR         R1,=lPasswordUser ; lPasswordUser
 0000004E  680A      LDR         R2,[R1,#0x0] ; lPasswordUser
 00000050  0152      LSL         R2,R2,#0x5
 00000052  4800      LDR         R1,=PassUser + 0xC ; PassUser+12
 00000054  5088      STR         R0,[R1,R2]
  747:         PassUser[lPasswordUser].year = year();
 00000056  F7FF      BL          year?T  ; T=0x0001  (1)
 00000058  FFD3      BL          year?T  ; T=0x0001  (2)
 0000005A  4800      LDR         R1,=lPasswordUser ; lPasswordUser
 0000005C  680A      LDR         R2,[R1,#0x0] ; lPasswordUser
 0000005E  0152      LSL         R2,R2,#0x5
 00000060  4800      LDR         R1,=PassUser + 0x10 ; PassUser+16
 00000062  5088      STR         R0,[R1,R2]
  748:         PassUser[lPasswordUser].hour = hour();
 00000064  F7FF      BL          hour?T  ; T=0x0001  (1)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 66  

 00000066  FFCC      BL          hour?T  ; T=0x0001  (2)
 00000068  4800      LDR         R1,=lPasswordUser ; lPasswordUser
 0000006A  680A      LDR         R2,[R1,#0x0] ; lPasswordUser
 0000006C  0152      LSL         R2,R2,#0x5
 0000006E  4800      LDR         R1,=PassUser + 0x14 ; PassUser+20
 00000070  5088      STR         R0,[R1,R2]
  749:         PassUser[lPasswordUser].minute = minute();
 00000072  F7FF      BL          minute?T  ; T=0x0001  (1)
 00000074  FFC5      BL          minute?T  ; T=0x0001  (2)
 00000076  4800      LDR         R1,=lPasswordUser ; lPasswordUser
 00000078  680A      LDR         R2,[R1,#0x0] ; lPasswordUser
 0000007A  0152      LSL         R2,R2,#0x5
 0000007C  4800      LDR         R1,=PassUser + 0x18 ; PassUser+24
 0000007E  5088      STR         R0,[R1,R2]
  750:         PassUser[lPasswordUser].sec = sec();
 00000080  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000082  FFBE      BL          sec?T  ; T=0x0001  (2)
 00000084  4800      LDR         R1,=lPasswordUser ; lPasswordUser
 00000086  6809      LDR         R1,[R1,#0x0] ; lPasswordUser
 00000088  014B      LSL         R3,R1,#0x5
 0000008A  4800      LDR         R2,=PassUser + 0x1C ; PassUser+28
 0000008C  50D0      STR         R0,[R2,R3]
  751:         lPasswordUser++; // increase number of password user in system 
 0000008E  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 00000090  3101      ADD         R1,#0x1
 00000092  6001      STR         R1,[R0,#0x0] ; lPasswordUser
  753:     return 1; // add passord user complete then return 1
 00000094  2001      MOV         R0,#0x1
 00000096            ; SCOPE-END
  754: }
 00000096          L_191:
 00000096  BC08      POP         {R3}
 00000098  4718      BX          R3
 0000009A          ENDP ; 'addPasswordUser?T'


*** CODE SEGMENT '?PR?addPasswordUserTime?T?main':
  757: void addPasswordUserTime()
 00000000  B500      PUSH        {LR}
  758: {
 00000002            ; SCOPE-START
  761:      for(i = 0;i < MAX_PASSWORD_USER;i++)
 00000002  2000      MOV         R0,#0x0
 00000004  ---- Variable 'i' assigned to Register 'R0' ----
 00000004          L_203:
  763:         PassUserTime[lPasswordUserTime].passwordUser[i] = tempkey[i];
 00000004  1C02      MOV         R2,R0 ; i
 00000006  4800      LDR         R1,=tempkey ; tempkey
 00000008  5C89      LDRB        R1,[R1,R2]
 0000000A  4800      LDR         R2,=lPasswordUserTime ; lPasswordUserTime
 0000000C  6813      LDR         R3,[R2,#0x0] ; lPasswordUserTime
 0000000E  015B      LSL         R3,R3,#0x5
 00000010  1C02      MOV         R2,R0 ; i
 00000012  189B      ADD         R3,R2 ; i
 00000014  4800      LDR         R2,=PassUserTime ; PassUserTime
 00000016  54D1      STRB        R1,[R2,R3]
  764:     }
 00000018  3001      ADD         R0,#0x1
 0000001A  1C01      MOV         R1,R0 ; i
 0000001C  2905      CMP         R1,#0x5 ; i
 0000001E  DBF1      BLT         L_203  ; T=0x00000004
  765:     PassUserTime[lPasswordUserTime].day = day();
 00000020  F7FF      BL          day?T  ; T=0x0001  (1)
 00000022  FFEE      BL          day?T  ; T=0x0001  (2)
 00000024  4800      LDR         R1,=lPasswordUserTime ; lPasswordUserTime
 00000026  680A      LDR         R2,[R1,#0x0] ; lPasswordUserTime
 00000028  0152      LSL         R2,R2,#0x5
 0000002A  4800      LDR         R1,=PassUserTime + 0x8 ; PassUserTime+8
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 67  

 0000002C  5088      STR         R0,[R1,R2]
  766:     PassUserTime[lPasswordUserTime].month = month();
 0000002E  F7FF      BL          month?T  ; T=0x0001  (1)
 00000030  FFE7      BL          month?T  ; T=0x0001  (2)
 00000032  4800      LDR         R1,=lPasswordUserTime ; lPasswordUserTime
 00000034  680A      LDR         R2,[R1,#0x0] ; lPasswordUserTime
 00000036  0152      LSL         R2,R2,#0x5
 00000038  4800      LDR         R1,=PassUserTime + 0xC ; PassUserTime+12
 0000003A  5088      STR         R0,[R1,R2]
  767:     PassUserTime[lPasswordUserTime].year = year();
 0000003C  F7FF      BL          year?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          year?T  ; T=0x0001  (2)
 00000040  4800      LDR         R1,=lPasswordUserTime ; lPasswordUserTime
 00000042  680A      LDR         R2,[R1,#0x0] ; lPasswordUserTime
 00000044  0152      LSL         R2,R2,#0x5
 00000046  4800      LDR         R1,=PassUserTime + 0x10 ; PassUserTime+16
 00000048  5088      STR         R0,[R1,R2]
  768:     PassUserTime[lPasswordUserTime].hour = hour();
 0000004A  F7FF      BL          hour?T  ; T=0x0001  (1)
 0000004C  FFD9      BL          hour?T  ; T=0x0001  (2)
 0000004E  4800      LDR         R1,=lPasswordUserTime ; lPasswordUserTime
 00000050  680A      LDR         R2,[R1,#0x0] ; lPasswordUserTime
 00000052  0152      LSL         R2,R2,#0x5
 00000054  4800      LDR         R1,=PassUserTime + 0x14 ; PassUserTime+20
 00000056  5088      STR         R0,[R1,R2]
  769:     PassUserTime[lPasswordUserTime].minute = minute();
 00000058  F7FF      BL          minute?T  ; T=0x0001  (1)
 0000005A  FFD2      BL          minute?T  ; T=0x0001  (2)
 0000005C  4800      LDR         R1,=lPasswordUserTime ; lPasswordUserTime
 0000005E  680A      LDR         R2,[R1,#0x0] ; lPasswordUserTime
 00000060  0152      LSL         R2,R2,#0x5
 00000062  4800      LDR         R1,=PassUserTime + 0x18 ; PassUserTime+24
 00000064  5088      STR         R0,[R1,R2]
  770:     PassUserTime[lPasswordUserTime].sec = sec();
 00000066  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000068  FFCB      BL          sec?T  ; T=0x0001  (2)
 0000006A  4800      LDR         R1,=lPasswordUserTime ; lPasswordUserTime
 0000006C  6809      LDR         R1,[R1,#0x0] ; lPasswordUserTime
 0000006E  014B      LSL         R3,R1,#0x5
 00000070  4800      LDR         R2,=PassUserTime + 0x1C ; PassUserTime+28
 00000072  50D0      STR         R0,[R2,R3]
  771:     lPasswordUserTime++; // increase number of password user that use to open door
 00000074  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 00000076  3101      ADD         R1,#0x1
 00000078  6001      STR         R1,[R0,#0x0] ; lPasswordUserTime
  772:     if( lPasswordUserTime == MAX_NUMBER_USER)  // if number of password user reach to maximun then reset number of c
             -ard to 0
 0000007A  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 0000007C  6800      LDR         R0,[R0,#0x0] ; lPasswordUserTime
 0000007E  2832      CMP         R0,#0x32
 00000080  D102      BNE         L_205  ; T=0x00000088
  774:         lPasswordUserTime = 0;
 00000082  2100      MOV         R1,#0x0
 00000084  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 00000086  6001      STR         R1,[R0,#0x0] ; lPasswordUserTime
  775:     }    
 00000088          L_205:
 00000088            ; SCOPE-END
  776: }
 00000088  BC08      POP         {R3}
 0000008A  4718      BX          R3
 0000008C          ENDP ; 'addPasswordUserTime?T'


*** CODE SEGMENT '?PR?deletePasswordUser?T?main':
  779: int deletePasswordUser()
 00000000  B570      PUSH        {R4-R6,LR}
  780: {
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 68  

 00000002            ; SCOPE-START
  781:     int i,j,check_correct = 0;
 00000002  2500      MOV         R5,#0x0
 00000004  ---- Variable 'check_correct' assigned to Register 'R5' ----
  782:       if(check_password(1) == 1) // if has password user same as password that receive from user then delete
 00000004  2001      MOV         R0,#0x1
 00000006  F7FF      BL          check_password?T  ; T=0x0001  (1)
 00000008  FFFB      BL          check_password?T  ; T=0x0001  (2)
 0000000A  2801      CMP         R0,#0x1 ; check_password?T
 0000000C  D138      BNE         L_206  ; T=0x00000080
  784:          for(i = 0;i < MAX_NUMBER_USER;i++)
 0000000E  2400      MOV         R4,#0x0
 00000010  ---- Variable 'i' assigned to Register 'R4' ----
 00000010          L_210:
  786:             check_correct = 1;
 00000010  2501      MOV         R5,#0x1
  787:             for(j = 0;j < MAX_PASSWORD_USER;j++)
 00000012  2600      MOV         R6,#0x0
 00000014  ---- Variable 'j' assigned to Register 'R6' ----
 00000014          L_215:
  791:                 if(tempkey[j] != PassUser[i].passwordUser[j])
 00000014  1C21      MOV         R1,R4 ; i
 00000016  0149      LSL         R1,R1,#0x5 ; i
 00000018  1C30      MOV         R0,R6 ; j
 0000001A  1809      ADD         R1,R0 ; j
 0000001C  4800      LDR         R0,=PassUser ; PassUser
 0000001E  5C40      LDRB        R0,[R0,R1]
 00000020  1C01      MOV         R1,R0
 00000022  1C32      MOV         R2,R6 ; j
 00000024  4800      LDR         R0,=tempkey ; tempkey
 00000026  5C80      LDRB        R0,[R0,R2]
 00000028  4288      CMP         R0,R1
 0000002A  D000      BEQ         L_212  ; T=0x0000002E
  793:                     check_correct = 0;
 0000002C  2500      MOV         R5,#0x0
  795:             }
 0000002E          L_212:
 0000002E  3601      ADD         R6,#0x1
 00000030  1C30      MOV         R0,R6 ; j
 00000032  2805      CMP         R0,#0x5 ; j
 00000034  DBEE      BLT         L_215  ; T=0x00000014
  796:             if(check_correct == 1) // if check_correct is 1 then delete current password user
 00000036  1C28      MOV         R0,R5 ; check_correct
 00000038  2801      CMP         R0,#0x1 ; check_correct
 0000003A  D11C      BNE         L_207  ; T=0x00000076
  798:                 lPasswordUser--; // decrease number of password user
 0000003C  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 0000003E  6801      LDR         R1,[R0,#0x0] ; lPasswordUser
 00000040  3901      SUB         R1,#0x1
 00000042  6001      STR         R1,[R0,#0x0] ; lPasswordUser
  799:                 for(j = 0;j < MAX_PASSWORD_USER;j++)
 00000044  2600      MOV         R6,#0x0
 00000046          L_222:
  802:                     PassUser[i] = PassUser[lPasswordUser];
 00000046  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 00000048  6800      LDR         R0,[R0,#0x0] ; lPasswordUser
 0000004A  0140      LSL         R0,R0,#0x5
 0000004C  4800      LDR         R1,=PassUser ; PassUser
 0000004E  1809      ADD         R1,R0 ; PassUser
 00000050  1C22      MOV         R2,R4 ; i
 00000052  0152      LSL         R2,R2,#0x5 ; i
 00000054  4800      LDR         R0,=PassUser ; PassUser
 00000056  1880      ADD         R0,R2 ; PassUser
 00000058  2208      MOV         R2,#0x8
 0000005A          L_528:
 0000005A  C908      LDMIA       R1!,{R3}
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 69  

 0000005C  C008      STMIA       R0!,{R3}
 0000005E  1E52      SUB         R2,R2,#0x1
 00000060  D1FB      BNE         L_528  ; T=0x0000005A
  803:                 }
 00000062  3601      ADD         R6,#0x1
 00000064  1C30      MOV         R0,R6 ; j
 00000066  2805      CMP         R0,#0x5 ; j
 00000068  DBED      BLT         L_222  ; T=0x00000046
  804:                 PassUser[lPasswordUser].passwordUser[0] = '\0'; // clear data of last password user
 0000006A  2000      MOV         R0,#0x0
 0000006C  4800      LDR         R1,=lPasswordUser ; lPasswordUser
 0000006E  680A      LDR         R2,[R1,#0x0] ; lPasswordUser
 00000070  0152      LSL         R2,R2,#0x5
 00000072  4800      LDR         R1,=PassUser ; PassUser
 00000074  5488      STRB        R0,[R1,R2]
  806:         }
 00000076          L_207:
 00000076  3401      ADD         R4,#0x1
 00000078  1C20      MOV         R0,R4 ; i
 0000007A  2832      CMP         R0,#0x32 ; i
 0000007C  DBC8      BLT         L_210  ; T=0x00000010
  807:     }
 0000007E  E001      B           L_224  ; T=0x00000084
 00000080          L_206:
  810:            return 0;
 00000080  2000      MOV         R0,#0x0
 00000082  E000      B           L_225  ; T=0x00000086
  811:       }
 00000084          L_224:
  812:     return 1; // if delete complete then return 1
 00000084  2001      MOV         R0,#0x1
 00000086            ; SCOPE-END
  813: }
 00000086          L_225:
 00000086  BC70      POP         {R4-R6}
 00000088  BC08      POP         {R3}
 0000008A  4718      BX          R3
 0000008C          ENDP ; 'deletePasswordUser?T'


*** CODE SEGMENT '?PR?opendoor?T?main':
  816: void opendoor()
 00000000  B500      PUSH        {LR}
  821:     loadpic_mmc(413); // load picture from sd/mmc
 00000002  4800      LDR         R0,=0x19D
 00000004  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000006  FFFC      BL          loadpic_mmc?T  ; T=0x0001  (2)
  822:     lcd_fill_picture(temppic); // show picture on lcd
 00000008  4800      LDR         R0,=temppic ; temppic
 0000000A  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  823:     delay_ms(500);
 0000000E  487D      LDR         R0,=0x1F4
 00000010  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000012  FFF6      BL          delay_ms?T  ; T=0x0001  (2)
  824:     loadpic_mmc(414); // load picture from sd/mmc
 00000014  4800      LDR         R0,=0x19E
 00000016  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000018  FFF3      BL          loadpic_mmc?T  ; T=0x0001  (2)
  825:     lcd_fill_picture(temppic); // show picture on lcd
 0000001A  4800      LDR         R0,=temppic ; temppic
 0000001C  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  827:     delay_ms(5000);
 00000020  4800      LDR         R0,=0x1388
 00000022  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000024  FFED      BL          delay_ms?T  ; T=0x0001  (2)
  829:     loadpic_mmc(413); // load picture from sd/mmc
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 70  

 00000026  4800      LDR         R0,=0x19D
 00000028  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000002A  FFEA      BL          loadpic_mmc?T  ; T=0x0001  (2)
  830:     lcd_fill_picture(temppic); // show picture on lcd
 0000002C  4800      LDR         R0,=temppic ; temppic
 0000002E  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000030  FFE7      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  831:     delay_ms(1000);
 00000032  48FA      LDR         R0,=0x3E8
 00000034  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000036  FFE4      BL          delay_ms?T  ; T=0x0001  (2)
  832:     loadpic_mmc(401); // load picture from sd/mmc
 00000038  4800      LDR         R0,=0x191
 0000003A  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000003C  FFE1      BL          loadpic_mmc?T  ; T=0x0001  (2)
  833:     lcd_fill_picture(temppic); // show picture on lcd
 0000003E  4800      LDR         R0,=temppic ; temppic
 00000040  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000042  FFDE      BL          lcd_fill_picture?T  ; T=0x0001  (2)
  835: }
 00000044  BC08      POP         {R3}
 00000046  4718      BX          R3
 00000048          ENDP ; 'opendoor?T'


*** CODE SEGMENT '?PR?loaddata_mmc?T?main':
  838: int loaddata_mmc()
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  4800      LDR         R0,=0xFFFFFE00
 00000004  4485      ADD         R13,R13,R0
  839: {
 00000006            ; SCOPE-START
  873:     int i = 0,j = 0;
 00000006  2500      MOV         R5,#0x0
 00000008  ---- Variable 'i' assigned to Register 'R5' ----
 00000008  2400      MOV         R4,#0x0
 0000000A  ---- Variable 'j' assigned to Register 'R4' ----
  878:     mmc_read_block_int(0,temp); // load data to temp
 0000000A  A900      ADD         R1,R13,#0x0
 0000000C  2000      MOV         R0,#0x0
 0000000E  F7FF      BL          mmc_read_block_int?T  ; T=0x0001  (1)
 00000010  FFF7      BL          mmc_read_block_int?T  ; T=0x0001  (2)
  881:     for(i = 0;i < sizeof(ckmsg);i++)
 00000012  2500      MOV         R5,#0x0
 00000014          L_229:
  883:          if(temp[i] != ckmsg[i])
 00000014  1C29      MOV         R1,R5 ; i
 00000016  0089      LSL         R1,R1,#0x2 ; i
 00000018  A800      ADD         R0,R13,#0x0
 0000001A  5840      LDR         R0,[R0,R1]
 0000001C  1C2A      MOV         R2,R5 ; i
 0000001E  4800      LDR         R1,=ckmsg ; ckmsg
 00000020  5C89      LDRB        R1,[R1,R2]
 00000022  4288      CMP         R0,R1
 00000024  D001      BEQ         L_226  ; T=0x0000002A
  884:             return 0;
 00000026  2000      MOV         R0,#0x0
 00000028  E0DB      B           L_232  ; T=0x000001E2
  885:     }
 0000002A          L_226:
 0000002A  3501      ADD         R5,#0x1
 0000002C  1C28      MOV         R0,R5 ; i
 0000002E  2810      CMP         R0,#0x10 ; i
 00000030  DBF0      BLT         L_229  ; T=0x00000014
  886:     printf("\n");
 00000032  4800      LDR         R0,=??S_3 ; ??S_3
 00000034  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000036  FFE4      BL          printf?T  ; T=0x0001  (2)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 71  

  887:     for(j = 0;j < i;j++)
 00000038  2400      MOV         R4,#0x0
 0000003A  E007      B           L_235  ; T=0x0000004C
 0000003C          L_236:
  889:          printf("%c",temp[j]);
 0000003C  1C21      MOV         R1,R4 ; j
 0000003E  0089      LSL         R1,R1,#0x2 ; j
 00000040  A800      ADD         R0,R13,#0x0
 00000042  5841      LDR         R1,[R0,R1]
 00000044  4800      LDR         R0,=??S_5 ; ??S_5
 00000046  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000048  FFDB      BL          printf?T  ; T=0x0001  (2)
  890:     }
 0000004A  3401      ADD         R4,#0x1
 0000004C          L_235:
 0000004C  1C29      MOV         R1,R5 ; i
 0000004E  1C20      MOV         R0,R4 ; j
 00000050  4288      CMP         R0,R1 ; j
 00000052  DBF3      BLT         L_236  ; T=0x0000003C
  891:     printf("\n");
 00000054  4800      LDR         R0,=??S_3 ; ??S_3
 00000056  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000058  FFD3      BL          printf?T  ; T=0x0001  (2)
  894:     for(j = 0;j < MAX_PASSWORD;j++)
 0000005A  2400      MOV         R4,#0x0
 0000005C          L_241:
  896:          password[j] = temp[i];
 0000005C  1C29      MOV         R1,R5 ; i
 0000005E  0089      LSL         R1,R1,#0x2 ; i
 00000060  A800      ADD         R0,R13,#0x0
 00000062  5840      LDR         R0,[R0,R1]
 00000064  1C22      MOV         R2,R4 ; j
 00000066  4800      LDR         R1,=password ; password
 00000068  5488      STRB        R0,[R1,R2]
  897:         i++; 
 0000006A  3501      ADD         R5,#0x1
  898:     }
 0000006C  3401      ADD         R4,#0x1
 0000006E  1C20      MOV         R0,R4 ; j
 00000070  2809      CMP         R0,#0x9 ; j
 00000072  DBF3      BLT         L_241  ; T=0x0000005C
  901:     for(i = 0;i < MAX_NUMBER_USER;i++)
 00000074  2500      MOV         R5,#0x0
 00000076          L_246:
  903:         mmc_read_block_int(1+i,temp); // load data to temp
 00000076  1C28      MOV         R0,R5 ; i
 00000078  3001      ADD         R0,#0x1
 0000007A  A900      ADD         R1,R13,#0x0
 0000007C  F7FF      BL          mmc_read_block_int?T  ; T=0x0001  (1)
 0000007E  FFC0      BL          mmc_read_block_int?T  ; T=0x0001  (2)
  906:         if(temp[0] != '\0')
 00000080  9800      LDR         R0,[R13,#0x0] ; temp
 00000082  2800      CMP         R0,#0x0
 00000084  D020      BEQ         L_243  ; T=0x000000C8
  908:              for(j = 0;j < MAX_PASSWORD_USER;j++)
 00000086  2400      MOV         R4,#0x0
 00000088          L_252:
  910:                 PassUser[i].passwordUser[j] = temp[j];
 00000088  1C21      MOV         R1,R4 ; j
 0000008A  0089      LSL         R1,R1,#0x2 ; j
 0000008C  A800      ADD         R0,R13,#0x0
 0000008E  5840      LDR         R0,[R0,R1]
 00000090  1C2A      MOV         R2,R5 ; i
 00000092  0152      LSL         R2,R2,#0x5 ; i
 00000094  1C23      MOV         R3,R4 ; j
 00000096  18D3      ADD         R3,R2,R3 ; j
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 72  

 00000098  4800      LDR         R1,=PassUser ; PassUser
 0000009A  54C8      STRB        R0,[R1,R3]
  911:             }
 0000009C  3401      ADD         R4,#0x1
 0000009E  1C20      MOV         R0,R4 ; j
 000000A0  2805      CMP         R0,#0x5 ; j
 000000A2  DBF1      BLT         L_252  ; T=0x00000088
  912:             PassUser[i].day = temp[MAX_PASSWORD_USER];
 000000A4  9805      LDR         R0,[R13,#0x14] ; temp
 000000A6  4800      LDR         R1,=PassUser + 0x8 ; PassUser+8
 000000A8  5088      STR         R0,[R1,R2]
  913:             PassUser[i].month = temp[MAX_PASSWORD_USER+1];
 000000AA  9806      LDR         R0,[R13,#0x18] ; temp
 000000AC  4800      LDR         R1,=PassUser + 0xC ; PassUser+12
 000000AE  5088      STR         R0,[R1,R2]
  914:             PassUser[i].year = temp[MAX_PASSWORD_USER+2];
 000000B0  9807      LDR         R0,[R13,#0x1C] ; temp
 000000B2  4800      LDR         R1,=PassUser + 0x10 ; PassUser+16
 000000B4  5088      STR         R0,[R1,R2]
  915:             PassUser[i].hour = temp[MAX_PASSWORD_USER+3];
 000000B6  9808      LDR         R0,[R13,#0x20] ; temp
 000000B8  4800      LDR         R1,=PassUser + 0x14 ; PassUser+20
 000000BA  5088      STR         R0,[R1,R2]
  916:             PassUser[i].minute = temp[MAX_PASSWORD_USER+4];
 000000BC  9809      LDR         R0,[R13,#0x24] ; temp
 000000BE  4800      LDR         R1,=PassUser + 0x18 ; PassUser+24
 000000C0  5088      STR         R0,[R1,R2]
  917:             PassUser[i].sec = temp[MAX_PASSWORD_USER+5];
 000000C2  980A      LDR         R0,[R13,#0x28] ; temp
 000000C4  4800      LDR         R1,=PassUser + 0x1C ; PassUser+28
 000000C6  5088      STR         R0,[R1,R2]
  919:     }
 000000C8          L_243:
 000000C8  3501      ADD         R5,#0x1
 000000CA  1C28      MOV         R0,R5 ; i
 000000CC  2832      CMP         R0,#0x32 ; i
 000000CE  DBD2      BLT         L_246  ; T=0x00000076
  922:     for(i = 0;i < MAX_RFID_CARD;i++)
 000000D0  2500      MOV         R5,#0x0
 000000D2          L_257:
  924:         mmc_read_block_int(51+i,temp); // load data to temp
 000000D2  1C28      MOV         R0,R5 ; i
 000000D4  3033      ADD         R0,#0x33
 000000D6  A900      ADD         R1,R13,#0x0
 000000D8  F7FF      BL          mmc_read_block_int?T  ; T=0x0001  (1)
 000000DA  FF92      BL          mmc_read_block_int?T  ; T=0x0001  (2)
  927:         if(temp[0] != 0)
 000000DC  9800      LDR         R0,[R13,#0x0] ; temp
 000000DE  2800      CMP         R0,#0x0
 000000E0  D017      BEQ         L_254  ; T=0x00000112
  929:             memoryRFID[i].datarfid = temp[0];
 000000E2  9800      LDR         R0,[R13,#0x0] ; temp
 000000E4  1C2A      MOV         R2,R5 ; i
 000000E6  211C      MOV         R1,#0x1C
 000000E8  434A      MUL         R2,R1
 000000EA  4800      LDR         R1,=memoryRFID ; memoryRFID
 000000EC  5088      STR         R0,[R1,R2]
  930:             memoryRFID[i].day = temp[1];
 000000EE  9801      LDR         R0,[R13,#0x4] ; temp
 000000F0  4800      LDR         R1,=memoryRFID + 0x4 ; memoryRFID+4
 000000F2  5088      STR         R0,[R1,R2]
  931:             memoryRFID[i].month = temp[2];
 000000F4  9802      LDR         R0,[R13,#0x8] ; temp
 000000F6  4800      LDR         R1,=memoryRFID + 0x8 ; memoryRFID+8
 000000F8  5088      STR         R0,[R1,R2]
  932:             memoryRFID[i].year = temp[3];
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 73  

 000000FA  9803      LDR         R0,[R13,#0xC] ; temp
 000000FC  4800      LDR         R1,=memoryRFID + 0xC ; memoryRFID+12
 000000FE  5088      STR         R0,[R1,R2]
  933:             memoryRFID[i].hour = temp[4];
 00000100  9804      LDR         R0,[R13,#0x10] ; temp
 00000102  4800      LDR         R1,=memoryRFID + 0x10 ; memoryRFID+16
 00000104  5088      STR         R0,[R1,R2]
  934:             memoryRFID[i].minute = temp[5];
 00000106  9805      LDR         R0,[R13,#0x14] ; temp
 00000108  4800      LDR         R1,=memoryRFID + 0x14 ; memoryRFID+20
 0000010A  5088      STR         R0,[R1,R2]
  935:             memoryRFID[i].sec = temp[6];
 0000010C  9806      LDR         R0,[R13,#0x18] ; temp
 0000010E  4800      LDR         R1,=memoryRFID + 0x18 ; memoryRFID+24
 00000110  5088      STR         R0,[R1,R2]
  937:     }
 00000112          L_254:
 00000112  3501      ADD         R5,#0x1
 00000114  1C28      MOV         R0,R5 ; i
 00000116  2832      CMP         R0,#0x32 ; i
 00000118  DBDB      BLT         L_257  ; T=0x000000D2
  940:     for(i = 0;i < MAX_RFID_CARD;i++)
 0000011A  2500      MOV         R5,#0x0
 0000011C          L_263:
  942:         mmc_read_block_int(101+i,temp); // load data to temp
 0000011C  1C28      MOV         R0,R5 ; i
 0000011E  3065      ADD         R0,#0x65
 00000120  A900      ADD         R1,R13,#0x0
 00000122  F7FF      BL          mmc_read_block_int?T  ; T=0x0001  (1)
 00000124  FF6D      BL          mmc_read_block_int?T  ; T=0x0001  (2)
  945:         if(temp[0] != 0)
 00000126  9800      LDR         R0,[R13,#0x0] ; temp
 00000128  2800      CMP         R0,#0x0
 0000012A  D017      BEQ         L_260  ; T=0x0000015C
  947:             memoryTem[i].datarfid = temp[0];
 0000012C  9800      LDR         R0,[R13,#0x0] ; temp
 0000012E  1C2A      MOV         R2,R5 ; i
 00000130  211C      MOV         R1,#0x1C
 00000132  434A      MUL         R2,R1
 00000134  4800      LDR         R1,=memoryTem ; memoryTem
 00000136  5088      STR         R0,[R1,R2]
  948:             memoryTem[i].day = temp[1];
 00000138  9801      LDR         R0,[R13,#0x4] ; temp
 0000013A  4800      LDR         R1,=memoryTem + 0x4 ; memoryTem+4
 0000013C  5088      STR         R0,[R1,R2]
  949:             memoryTem[i].month = temp[2];
 0000013E  9802      LDR         R0,[R13,#0x8] ; temp
 00000140  4800      LDR         R1,=memoryTem + 0x8 ; memoryTem+8
 00000142  5088      STR         R0,[R1,R2]
  950:             memoryTem[i].year = temp[3];
 00000144  9803      LDR         R0,[R13,#0xC] ; temp
 00000146  4800      LDR         R1,=memoryTem + 0xC ; memoryTem+12
 00000148  5088      STR         R0,[R1,R2]
  951:             memoryTem[i].hour = temp[4];
 0000014A  9804      LDR         R0,[R13,#0x10] ; temp
 0000014C  4800      LDR         R1,=memoryTem + 0x10 ; memoryTem+16
 0000014E  5088      STR         R0,[R1,R2]
  952:             memoryTem[i].minute = temp[5];
 00000150  9805      LDR         R0,[R13,#0x14] ; temp
 00000152  4800      LDR         R1,=memoryTem + 0x14 ; memoryTem+20
 00000154  5088      STR         R0,[R1,R2]
  953:             memoryTem[i].sec = temp[6];
 00000156  9806      LDR         R0,[R13,#0x18] ; temp
 00000158  4800      LDR         R1,=memoryTem + 0x18 ; memoryTem+24
 0000015A  5088      STR         R0,[R1,R2]
  955:     } 
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 74  

 0000015C          L_260:
 0000015C  3501      ADD         R5,#0x1
 0000015E  1C28      MOV         R0,R5 ; i
 00000160  2832      CMP         R0,#0x32 ; i
 00000162  DBDB      BLT         L_263  ; T=0x0000011C
  958:     for(i = 0;i < MAX_NUMBER_USER;i++)
 00000164  2500      MOV         R5,#0x0
 00000166          L_269:
  960:         mmc_read_block_int(151+i,temp); // load data to temp
 00000166  1C28      MOV         R0,R5 ; i
 00000168  3097      ADD         R0,#0x97
 0000016A  A900      ADD         R1,R13,#0x0
 0000016C  F7FF      BL          mmc_read_block_int?T  ; T=0x0001  (1)
 0000016E  FF48      BL          mmc_read_block_int?T  ; T=0x0001  (2)
  963:         if(temp[0] != '\0')
 00000170  9800      LDR         R0,[R13,#0x0] ; temp
 00000172  2800      CMP         R0,#0x0
 00000174  D020      BEQ         L_266  ; T=0x000001B8
  965:              for(j = 0;j < MAX_PASSWORD_USER;j++)
 00000176  2400      MOV         R4,#0x0
 00000178          L_275:
  967:                 PassUserTime[i].passwordUser[j] = temp[j];
 00000178  1C21      MOV         R1,R4 ; j
 0000017A  0089      LSL         R1,R1,#0x2 ; j
 0000017C  A800      ADD         R0,R13,#0x0
 0000017E  5840      LDR         R0,[R0,R1]
 00000180  1C2A      MOV         R2,R5 ; i
 00000182  0152      LSL         R2,R2,#0x5 ; i
 00000184  1C23      MOV         R3,R4 ; j
 00000186  18D3      ADD         R3,R2,R3 ; j
 00000188  4800      LDR         R1,=PassUserTime ; PassUserTime
 0000018A  54C8      STRB        R0,[R1,R3]
  968:             }
 0000018C  3401      ADD         R4,#0x1
 0000018E  1C20      MOV         R0,R4 ; j
 00000190  2805      CMP         R0,#0x5 ; j
 00000192  DBF1      BLT         L_275  ; T=0x00000178
  969:             PassUserTime[i].day = temp[MAX_PASSWORD_USER];
 00000194  9805      LDR         R0,[R13,#0x14] ; temp
 00000196  4800      LDR         R1,=PassUserTime + 0x8 ; PassUserTime+8
 00000198  5088      STR         R0,[R1,R2]
  970:             PassUserTime[i].month = temp[MAX_PASSWORD_USER+1];
 0000019A  9806      LDR         R0,[R13,#0x18] ; temp
 0000019C  4800      LDR         R1,=PassUserTime + 0xC ; PassUserTime+12
 0000019E  5088      STR         R0,[R1,R2]
  971:             PassUserTime[i].year = temp[MAX_PASSWORD_USER+2];
 000001A0  9807      LDR         R0,[R13,#0x1C] ; temp
 000001A2  4800      LDR         R1,=PassUserTime + 0x10 ; PassUserTime+16
 000001A4  5088      STR         R0,[R1,R2]
  972:             PassUserTime[i].hour = temp[MAX_PASSWORD_USER+3];
 000001A6  9808      LDR         R0,[R13,#0x20] ; temp
 000001A8  4800      LDR         R1,=PassUserTime + 0x14 ; PassUserTime+20
 000001AA  5088      STR         R0,[R1,R2]
  973:             PassUserTime[i].minute = temp[MAX_PASSWORD_USER+4];
 000001AC  9809      LDR         R0,[R13,#0x24] ; temp
 000001AE  4800      LDR         R1,=PassUserTime + 0x18 ; PassUserTime+24
 000001B0  5088      STR         R0,[R1,R2]
  974:             PassUserTime[i].sec = temp[MAX_PASSWORD_USER+5];
 000001B2  980A      LDR         R0,[R13,#0x28] ; temp
 000001B4  4800      LDR         R1,=PassUserTime + 0x1C ; PassUserTime+28
 000001B6  5088      STR         R0,[R1,R2]
  976:     }
 000001B8          L_266:
 000001B8  3501      ADD         R5,#0x1
 000001BA  1C28      MOV         R0,R5 ; i
 000001BC  2832      CMP         R0,#0x32 ; i
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 75  

 000001BE  DBD2      BLT         L_269  ; T=0x00000166
  979:     mmc_read_block_int(201,temp); // load data to temp
 000001C0  A900      ADD         R1,R13,#0x0
 000001C2  20C9      MOV         R0,#0xC9
 000001C4  F7FF      BL          mmc_read_block_int?T  ; T=0x0001  (1)
 000001C6  FF1C      BL          mmc_read_block_int?T  ; T=0x0001  (2)
  982:     lMemTem = temp[0];
 000001C8  9900      LDR         R1,[R13,#0x0] ; temp
 000001CA  4800      LDR         R0,=lMemTem ; lMemTem
 000001CC  6001      STR         R1,[R0,#0x0] ; lMemTem
  983:     lMemRFID = temp[1];
 000001CE  9901      LDR         R1,[R13,#0x4] ; temp
 000001D0  4800      LDR         R0,=lMemRFID ; lMemRFID
 000001D2  6001      STR         R1,[R0,#0x0] ; lMemRFID
  984:     lPasswordUser = temp[2]; 
 000001D4  9902      LDR         R1,[R13,#0x8] ; temp
 000001D6  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 000001D8  6001      STR         R1,[R0,#0x0] ; lPasswordUser
  985:     lPasswordUserTime = temp[3];
 000001DA  9903      LDR         R1,[R13,#0xC] ; temp
 000001DC  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 000001DE  6001      STR         R1,[R0,#0x0] ; lPasswordUserTime
  987:     return 1; // if load complete then return 1
 000001E0  2001      MOV         R0,#0x1
 000001E2            ; SCOPE-END
  988: }
 000001E2          L_232:
 000001E2  4980      LDR         R1,=0x200
 000001E4  448D      ADD         R13,R13,R1
 000001E6  BC30      POP         {R4-R5}
 000001E8  BC08      POP         {R3}
 000001EA  4718      BX          R3
 000001EC          ENDP ; 'loaddata_mmc?T'


*** CODE SEGMENT '?PR?savedata_mmc?T?main':
  996: int savedata_mmc(int number)
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C06      MOV         R6,R0 ; number
 00000004  ---- Variable 'number' assigned to Register 'R6' ----
 00000004  4800      LDR         R0,=0xFFFFFE00
 00000006  4485      ADD         R13,R13,R0
  997: {
 00000008            ; SCOPE-START
 1031:      int i = 0,j = 0;
 00000008  2500      MOV         R5,#0x0
 0000000A  ---- Variable 'i' assigned to Register 'R5' ----
 0000000A  2400      MOV         R4,#0x0
 0000000C  ---- Variable 'j' assigned to Register 'R4' ----
 1034:     if(number == 0) // number = 0 is for check message and password
 0000000C  1C30      MOV         R0,R6 ; number
 0000000E  2800      CMP         R0,#0x0 ; number
 00000010  D122      BNE         L_277  ; T=0x00000058
 1037:         for(i = 0;i < sizeof(ckmsg);i++)
 00000012  2500      MOV         R5,#0x0
 00000014          L_281:
 1039:             temp[i] = ckmsg[i];
 00000014  1C29      MOV         R1,R5 ; i
 00000016  4800      LDR         R0,=ckmsg ; ckmsg
 00000018  5C40      LDRB        R0,[R0,R1]
 0000001A  1C2A      MOV         R2,R5 ; i
 0000001C  0092      LSL         R2,R2,#0x2 ; i
 0000001E  A900      ADD         R1,R13,#0x0
 00000020  5088      STR         R0,[R1,R2]
 1040:         }
 00000022  3501      ADD         R5,#0x1
 00000024  1C28      MOV         R0,R5 ; i
 00000026  2810      CMP         R0,#0x10 ; i
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 76  

 00000028  DBF4      BLT         L_281  ; T=0x00000014
 1043:         for(j = 0;j < MAX_PASSWORD;j++)
 0000002A  2400      MOV         R4,#0x0
 0000002C          L_286:
 1045:              temp[i] = password[j];
 0000002C  1C21      MOV         R1,R4 ; j
 0000002E  4800      LDR         R0,=password ; password
 00000030  5C40      LDRB        R0,[R0,R1]
 00000032  1C2A      MOV         R2,R5 ; i
 00000034  0092      LSL         R2,R2,#0x2 ; i
 00000036  A900      ADD         R1,R13,#0x0
 00000038  5088      STR         R0,[R1,R2]
 1046:             i++; 
 0000003A  3501      ADD         R5,#0x1
 1047:         }
 0000003C  3401      ADD         R4,#0x1
 0000003E  1C20      MOV         R0,R4 ; j
 00000040  2809      CMP         R0,#0x9 ; j
 00000042  DBF3      BLT         L_286  ; T=0x0000002C
 1050:         if(mmc_write_block_int(0,temp) != 0)
 00000044  A900      ADD         R1,R13,#0x0
 00000046  2000      MOV         R0,#0x0
 00000048  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 0000004A  FFDA      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 0000004C  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 0000004E  D001      BEQ         L_288  ; T=0x00000054
 1052:             return 0; // write fail return 0
 00000050  2000      MOV         R0,#0x0
 00000052  E188      B           L_289  ; T=0x00000366
 1053:         }
 00000054          L_288:
 1054:         return 1;   
 00000054  2001      MOV         R0,#0x1
 00000056  E186      B           L_289  ; T=0x00000366
 1055:     }
 00000058          L_277:
 1056:     else if(number == 1) // number = 1 is for password user
 00000058  1C30      MOV         R0,R6 ; number
 0000005A  2801      CMP         R0,#0x1 ; number
 0000005C  D161      BNE         L_291  ; T=0x00000122
 1058:           for(i = 0;i < MAX_NUMBER_USER;i++)
 0000005E  2500      MOV         R5,#0x0
 00000060          L_295:
 1061:             if(PassUser[i].passwordUser[0] != '\0')
 00000060  1C29      MOV         R1,R5 ; i
 00000062  0149      LSL         R1,R1,#0x5 ; i
 00000064  4800      LDR         R0,=PassUser ; PassUser
 00000066  5C40      LDRB        R0,[R0,R1]
 00000068  2800      CMP         R0,#0x0
 0000006A  D035      BEQ         L_297  ; T=0x000000D8
 1063:                 for(j = 0;j < MAX_PASSWORD_USER;j++)
 0000006C  2400      MOV         R4,#0x0
 0000006E          L_301:
 1065:                     temp[j] = PassUser[i].passwordUser[j];
 0000006E  1C29      MOV         R1,R5 ; i
 00000070  0149      LSL         R1,R1,#0x5 ; i
 00000072  1C20      MOV         R0,R4 ; j
 00000074  1809      ADD         R1,R0 ; j
 00000076  4800      LDR         R0,=PassUser ; PassUser
 00000078  5C40      LDRB        R0,[R0,R1]
 0000007A  1C22      MOV         R2,R4 ; j
 0000007C  0092      LSL         R2,R2,#0x2 ; j
 0000007E  A900      ADD         R1,R13,#0x0
 00000080  5088      STR         R0,[R1,R2]
 1066:                 }
 00000082  3401      ADD         R4,#0x1
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 77  

 00000084  1C20      MOV         R0,R4 ; j
 00000086  2805      CMP         R0,#0x5 ; j
 00000088  DBF1      BLT         L_301  ; T=0x0000006E
 1067:                 temp[MAX_PASSWORD_USER] = PassUser[i].day;
 0000008A  1C29      MOV         R1,R5 ; i
 0000008C  0149      LSL         R1,R1,#0x5 ; i
 0000008E  4800      LDR         R0,=PassUser + 0x8 ; PassUser+8
 00000090  5840      LDR         R0,[R0,R1]
 00000092  9005      STR         R0,[R13,#0x14] ; temp
 1068:                 temp[MAX_PASSWORD_USER+1] = PassUser[i].month;
 00000094  1C29      MOV         R1,R5 ; i
 00000096  0149      LSL         R1,R1,#0x5 ; i
 00000098  4800      LDR         R0,=PassUser + 0xC ; PassUser+12
 0000009A  5840      LDR         R0,[R0,R1]
 0000009C  9006      STR         R0,[R13,#0x18] ; temp
 1069:                 temp[MAX_PASSWORD_USER+2] = PassUser[i].year;
 0000009E  1C29      MOV         R1,R5 ; i
 000000A0  0149      LSL         R1,R1,#0x5 ; i
 000000A2  4800      LDR         R0,=PassUser + 0x10 ; PassUser+16
 000000A4  5840      LDR         R0,[R0,R1]
 000000A6  9007      STR         R0,[R13,#0x1C] ; temp
 1070:                 temp[MAX_PASSWORD_USER+3] = PassUser[i].hour;
 000000A8  1C29      MOV         R1,R5 ; i
 000000AA  0149      LSL         R1,R1,#0x5 ; i
 000000AC  4800      LDR         R0,=PassUser + 0x14 ; PassUser+20
 000000AE  5840      LDR         R0,[R0,R1]
 000000B0  9008      STR         R0,[R13,#0x20] ; temp
 1071:                 temp[MAX_PASSWORD_USER+4] = PassUser[i].minute;
 000000B2  1C29      MOV         R1,R5 ; i
 000000B4  0149      LSL         R1,R1,#0x5 ; i
 000000B6  4800      LDR         R0,=PassUser + 0x18 ; PassUser+24
 000000B8  5840      LDR         R0,[R0,R1]
 000000BA  9009      STR         R0,[R13,#0x24] ; temp
 1072:                 temp[MAX_PASSWORD_USER+5] = PassUser[i].sec;
 000000BC  1C29      MOV         R1,R5 ; i
 000000BE  0149      LSL         R1,R1,#0x5 ; i
 000000C0  4800      LDR         R0,=PassUser + 0x1C ; PassUser+28
 000000C2  5840      LDR         R0,[R0,R1]
 000000C4  900A      STR         R0,[R13,#0x28] ; temp
 1075:                 if(mmc_write_block_int(1+i,temp) != 0)
 000000C6  1C28      MOV         R0,R5 ; i
 000000C8  3001      ADD         R0,#0x1
 000000CA  A900      ADD         R1,R13,#0x0
 000000CC  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 000000CE  FF98      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 000000D0  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 000000D2  D00C      BEQ         L_292  ; T=0x000000EE
 1077:                     return 0; // write fail return 0
 000000D4  2000      MOV         R0,#0x0
 000000D6  E146      B           L_289  ; T=0x00000366
 1079:             }
 000000D8          L_297:
 1083:                 temp[0] = '\0';
 000000D8  2000      MOV         R0,#0x0
 000000DA  9000      STR         R0,[R13,#0x0] ; temp
 1086:                 if(mmc_write_block_int(1+i,temp) != 0)
 000000DC  1C28      MOV         R0,R5 ; i
 000000DE  3001      ADD         R0,#0x1
 000000E0  A900      ADD         R1,R13,#0x0
 000000E2  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 000000E4  FF8D      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 000000E6  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 000000E8  D001      BEQ         L_292  ; T=0x000000EE
 1088:                     return 0; // write fail return 0
 000000EA  2000      MOV         R0,#0x0
 000000EC  E13B      B           L_289  ; T=0x00000366
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 78  

 1091:         }
 000000EE          L_292:
 000000EE  3501      ADD         R5,#0x1
 000000F0  1C28      MOV         R0,R5 ; i
 000000F2  2832      CMP         R0,#0x32 ; i
 000000F4  DBB4      BLT         L_295  ; T=0x00000060
 1094:         temp[0] = lMemTem;
 000000F6  4800      LDR         R0,=lMemTem ; lMemTem
 000000F8  6800      LDR         R0,[R0,#0x0] ; lMemTem
 000000FA  9000      STR         R0,[R13,#0x0] ; temp
 1095:         temp[1] = lMemRFID;
 000000FC  4800      LDR         R0,=lMemRFID ; lMemRFID
 000000FE  6800      LDR         R0,[R0,#0x0] ; lMemRFID
 00000100  9001      STR         R0,[R13,#0x4] ; temp
 1096:         temp[2] = lPasswordUser;
 00000102  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 00000104  6800      LDR         R0,[R0,#0x0] ; lPasswordUser
 00000106  9002      STR         R0,[R13,#0x8] ; temp
 1097:         temp[3] = lPasswordUserTime;
 00000108  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 0000010A  6800      LDR         R0,[R0,#0x0] ; lPasswordUserTime
 0000010C  9003      STR         R0,[R13,#0xC] ; temp
 1100:         if(mmc_write_block_int(201,temp) != 0)
 0000010E  A900      ADD         R1,R13,#0x0
 00000110  20C9      MOV         R0,#0xC9
 00000112  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000114  FF75      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 00000116  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 00000118  D001      BEQ         L_306  ; T=0x0000011E
 1102:             return 0; // write fail return 0
 0000011A  2000      MOV         R0,#0x0
 0000011C  E123      B           L_289  ; T=0x00000366
 1103:         }
 0000011E          L_306:
 1105:         return 1; // write complete return 1
 0000011E  2001      MOV         R0,#0x1
 00000120  E121      B           L_289  ; T=0x00000366
 1106:     }
 00000122          L_291:
 1107:     else if(number == 2) // number = 2 is for RFID Card data
 00000122  1C30      MOV         R0,R6 ; number
 00000124  2802      CMP         R0,#0x2 ; number
 00000126  D15A      BNE         L_308  ; T=0x000001DE
 1109:         for(i = 0;i < MAX_RFID_CARD;i++)
 00000128  2500      MOV         R5,#0x0
 0000012A          L_312:
 1112:             if(memoryRFID[i].datarfid != 0)
 0000012A  1C29      MOV         R1,R5 ; i
 0000012C  201C      MOV         R0,#0x1C
 0000012E  4341      MUL         R1,R0
 00000130  4800      LDR         R0,=memoryRFID ; memoryRFID
 00000132  5840      LDR         R0,[R0,R1]
 00000134  2800      CMP         R0,#0x0
 00000136  D02D      BEQ         L_314  ; T=0x00000194
 1114:                 temp[0] = memoryRFID[i].datarfid;
 00000138  9000      STR         R0,[R13,#0x0] ; temp
 1115:                 temp[1] = memoryRFID[i].day;
 0000013A  1C29      MOV         R1,R5 ; i
 0000013C  201C      MOV         R0,#0x1C
 0000013E  4341      MUL         R1,R0
 00000140  4800      LDR         R0,=memoryRFID + 0x4 ; memoryRFID+4
 00000142  5840      LDR         R0,[R0,R1]
 00000144  9001      STR         R0,[R13,#0x4] ; temp
 1116:                 temp[2] = memoryRFID[i].month;
 00000146  1C29      MOV         R1,R5 ; i
 00000148  201C      MOV         R0,#0x1C
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 79  

 0000014A  4341      MUL         R1,R0
 0000014C  4800      LDR         R0,=memoryRFID + 0x8 ; memoryRFID+8
 0000014E  5840      LDR         R0,[R0,R1]
 00000150  9002      STR         R0,[R13,#0x8] ; temp
 1117:                 temp[3] = memoryRFID[i].year;
 00000152  1C29      MOV         R1,R5 ; i
 00000154  201C      MOV         R0,#0x1C
 00000156  4341      MUL         R1,R0
 00000158  4800      LDR         R0,=memoryRFID + 0xC ; memoryRFID+12
 0000015A  5840      LDR         R0,[R0,R1]
 0000015C  9003      STR         R0,[R13,#0xC] ; temp
 1118:                 temp[4] = memoryRFID[i].hour;
 0000015E  1C29      MOV         R1,R5 ; i
 00000160  201C      MOV         R0,#0x1C
 00000162  4341      MUL         R1,R0
 00000164  4800      LDR         R0,=memoryRFID + 0x10 ; memoryRFID+16
 00000166  5840      LDR         R0,[R0,R1]
 00000168  9004      STR         R0,[R13,#0x10] ; temp
 1119:                 temp[5] = memoryRFID[i].minute;
 0000016A  1C29      MOV         R1,R5 ; i
 0000016C  201C      MOV         R0,#0x1C
 0000016E  4341      MUL         R1,R0
 00000170  4800      LDR         R0,=memoryRFID + 0x14 ; memoryRFID+20
 00000172  5840      LDR         R0,[R0,R1]
 00000174  9005      STR         R0,[R13,#0x14] ; temp
 1120:                 temp[6] = memoryRFID[i].sec;
 00000176  1C29      MOV         R1,R5 ; i
 00000178  201C      MOV         R0,#0x1C
 0000017A  4341      MUL         R1,R0
 0000017C  4800      LDR         R0,=memoryRFID + 0x18 ; memoryRFID+24
 0000017E  5840      LDR         R0,[R0,R1]
 00000180  9006      STR         R0,[R13,#0x18] ; temp
 1123:                 if(mmc_write_block_int(51+i,temp) != 0)
 00000182  1C28      MOV         R0,R5 ; i
 00000184  3033      ADD         R0,#0x33
 00000186  A900      ADD         R1,R13,#0x0
 00000188  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 0000018A  FF3A      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 0000018C  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 0000018E  D00C      BEQ         L_309  ; T=0x000001AA
 1125:                     return 0; // write fail return 0
 00000190  2000      MOV         R0,#0x0
 00000192  E0E8      B           L_289  ; T=0x00000366
 1127:             }
 00000194          L_314:
 1131:                 temp[0] = 0;
 00000194  2000      MOV         R0,#0x0
 00000196  9000      STR         R0,[R13,#0x0] ; temp
 1134:                 if(mmc_write_block_int(51+i,temp) != 0)
 00000198  1C28      MOV         R0,R5 ; i
 0000019A  3033      ADD         R0,#0x33
 0000019C  A900      ADD         R1,R13,#0x0
 0000019E  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 000001A0  FF2F      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 000001A2  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 000001A4  D001      BEQ         L_309  ; T=0x000001AA
 1136:                     return 0; // write fail return 0
 000001A6  2000      MOV         R0,#0x0
 000001A8  E0DD      B           L_289  ; T=0x00000366
 1139:         }
 000001AA          L_309:
 000001AA  3501      ADD         R5,#0x1
 000001AC  1C28      MOV         R0,R5 ; i
 000001AE  2832      CMP         R0,#0x32 ; i
 000001B0  DBBB      BLT         L_312  ; T=0x0000012A
 1142:         temp[0] = lMemTem;
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 80  

 000001B2  4800      LDR         R0,=lMemTem ; lMemTem
 000001B4  6800      LDR         R0,[R0,#0x0] ; lMemTem
 000001B6  9000      STR         R0,[R13,#0x0] ; temp
 1143:         temp[1] = lMemRFID;
 000001B8  4800      LDR         R0,=lMemRFID ; lMemRFID
 000001BA  6800      LDR         R0,[R0,#0x0] ; lMemRFID
 000001BC  9001      STR         R0,[R13,#0x4] ; temp
 1144:         temp[2] = lPasswordUser;
 000001BE  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 000001C0  6800      LDR         R0,[R0,#0x0] ; lPasswordUser
 000001C2  9002      STR         R0,[R13,#0x8] ; temp
 1145:         temp[3] = lPasswordUserTime;
 000001C4  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 000001C6  6800      LDR         R0,[R0,#0x0] ; lPasswordUserTime
 000001C8  9003      STR         R0,[R13,#0xC] ; temp
 1148:         if(mmc_write_block_int(201,temp) != 0)
 000001CA  A900      ADD         R1,R13,#0x0
 000001CC  20C9      MOV         R0,#0xC9
 000001CE  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 000001D0  FF17      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 000001D2  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 000001D4  D001      BEQ         L_318  ; T=0x000001DA
 1150:             return 0; // write fail return 0
 000001D6  2000      MOV         R0,#0x0
 000001D8  E0C5      B           L_289  ; T=0x00000366
 1151:         }
 000001DA          L_318:
 1153:           return 1; // write complete return 1
 000001DA  2001      MOV         R0,#0x1
 000001DC  E0C3      B           L_289  ; T=0x00000366
 1154:     }
 000001DE          L_308:
 1155:     else if(number == 3) // number = 3 is for RFID card open door time
 000001DE  1C30      MOV         R0,R6 ; number
 000001E0  2803      CMP         R0,#0x3 ; number
 000001E2  D15A      BNE         L_320  ; T=0x0000029A
 1157:         for(i = 0;i < MAX_RFID_CARD;i++)
 000001E4  2500      MOV         R5,#0x0
 000001E6          L_324:
 1160:             if(memoryTem[i].datarfid != 0)
 000001E6  1C29      MOV         R1,R5 ; i
 000001E8  201C      MOV         R0,#0x1C
 000001EA  4341      MUL         R1,R0
 000001EC  4800      LDR         R0,=memoryTem ; memoryTem
 000001EE  5840      LDR         R0,[R0,R1]
 000001F0  2800      CMP         R0,#0x0
 000001F2  D02D      BEQ         L_326  ; T=0x00000250
 1162:                 temp[0] = memoryTem[i].datarfid;
 000001F4  9000      STR         R0,[R13,#0x0] ; temp
 1163:                 temp[1] = memoryTem[i].day;
 000001F6  1C29      MOV         R1,R5 ; i
 000001F8  201C      MOV         R0,#0x1C
 000001FA  4341      MUL         R1,R0
 000001FC  4800      LDR         R0,=memoryTem + 0x4 ; memoryTem+4
 000001FE  5840      LDR         R0,[R0,R1]
 00000200  9001      STR         R0,[R13,#0x4] ; temp
 1164:                 temp[2] = memoryTem[i].month;
 00000202  1C29      MOV         R1,R5 ; i
 00000204  201C      MOV         R0,#0x1C
 00000206  4341      MUL         R1,R0
 00000208  4800      LDR         R0,=memoryTem + 0x8 ; memoryTem+8
 0000020A  5840      LDR         R0,[R0,R1]
 0000020C  9002      STR         R0,[R13,#0x8] ; temp
 1165:                 temp[3] = memoryTem[i].year;
 0000020E  1C29      MOV         R1,R5 ; i
 00000210  201C      MOV         R0,#0x1C
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 81  

 00000212  4341      MUL         R1,R0
 00000214  4800      LDR         R0,=memoryTem + 0xC ; memoryTem+12
 00000216  5840      LDR         R0,[R0,R1]
 00000218  9003      STR         R0,[R13,#0xC] ; temp
 1166:                 temp[4] = memoryTem[i].hour;
 0000021A  1C29      MOV         R1,R5 ; i
 0000021C  201C      MOV         R0,#0x1C
 0000021E  4341      MUL         R1,R0
 00000220  4800      LDR         R0,=memoryTem + 0x10 ; memoryTem+16
 00000222  5840      LDR         R0,[R0,R1]
 00000224  9004      STR         R0,[R13,#0x10] ; temp
 1167:                 temp[5] = memoryTem[i].minute;
 00000226  1C29      MOV         R1,R5 ; i
 00000228  201C      MOV         R0,#0x1C
 0000022A  4341      MUL         R1,R0
 0000022C  4800      LDR         R0,=memoryTem + 0x14 ; memoryTem+20
 0000022E  5840      LDR         R0,[R0,R1]
 00000230  9005      STR         R0,[R13,#0x14] ; temp
 1168:                 temp[6] = memoryTem[i].sec;
 00000232  1C29      MOV         R1,R5 ; i
 00000234  201C      MOV         R0,#0x1C
 00000236  4341      MUL         R1,R0
 00000238  4800      LDR         R0,=memoryTem + 0x18 ; memoryTem+24
 0000023A  5840      LDR         R0,[R0,R1]
 0000023C  9006      STR         R0,[R13,#0x18] ; temp
 1171:                 if(mmc_write_block_int(101+i,temp) != 0)
 0000023E  1C28      MOV         R0,R5 ; i
 00000240  3065      ADD         R0,#0x65
 00000242  A900      ADD         R1,R13,#0x0
 00000244  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000246  FEDC      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 00000248  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 0000024A  D00C      BEQ         L_321  ; T=0x00000266
 1173:                     return 0; // write fail return 0
 0000024C  2000      MOV         R0,#0x0
 0000024E  E08A      B           L_289  ; T=0x00000366
 1175:             }
 00000250          L_326:
 1179:                 temp[0] = 0;
 00000250  2000      MOV         R0,#0x0
 00000252  9000      STR         R0,[R13,#0x0] ; temp
 1182:                 if(mmc_write_block_int(101+i,temp) != 0)
 00000254  1C28      MOV         R0,R5 ; i
 00000256  3065      ADD         R0,#0x65
 00000258  A900      ADD         R1,R13,#0x0
 0000025A  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 0000025C  FED1      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 0000025E  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 00000260  D001      BEQ         L_321  ; T=0x00000266
 1184:                     return 0; // write fail return 0
 00000262  2000      MOV         R0,#0x0
 00000264  E07F      B           L_289  ; T=0x00000366
 1187:         }
 00000266          L_321:
 00000266  3501      ADD         R5,#0x1
 00000268  1C28      MOV         R0,R5 ; i
 0000026A  2832      CMP         R0,#0x32 ; i
 0000026C  DBBB      BLT         L_324  ; T=0x000001E6
 1190:         temp[0] = lMemTem;
 0000026E  4800      LDR         R0,=lMemTem ; lMemTem
 00000270  6800      LDR         R0,[R0,#0x0] ; lMemTem
 00000272  9000      STR         R0,[R13,#0x0] ; temp
 1191:         temp[1] = lMemRFID;
 00000274  4800      LDR         R0,=lMemRFID ; lMemRFID
 00000276  6800      LDR         R0,[R0,#0x0] ; lMemRFID
 00000278  9001      STR         R0,[R13,#0x4] ; temp
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 82  

 1192:         temp[2] = lPasswordUser;
 0000027A  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 0000027C  6800      LDR         R0,[R0,#0x0] ; lPasswordUser
 0000027E  9002      STR         R0,[R13,#0x8] ; temp
 1193:         temp[3] = lPasswordUserTime;
 00000280  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 00000282  6800      LDR         R0,[R0,#0x0] ; lPasswordUserTime
 00000284  9003      STR         R0,[R13,#0xC] ; temp
 1196:         if(mmc_write_block_int(201,temp) != 0)
 00000286  A900      ADD         R1,R13,#0x0
 00000288  20C9      MOV         R0,#0xC9
 0000028A  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 0000028C  FEB9      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 0000028E  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 00000290  D001      BEQ         L_330  ; T=0x00000296
 1198:             return 0; // write fail return 0
 00000292  2000      MOV         R0,#0x0
 00000294  E067      B           L_289  ; T=0x00000366
 1199:         }
 00000296          L_330:
 1201:           return 1; // write complete return 1
 00000296  2001      MOV         R0,#0x1
 00000298  E065      B           L_289  ; T=0x00000366
 1202:     }
 0000029A          L_320:
 1203:     else if(number == 4) // number = 4 is for password user open door time
 0000029A  1C30      MOV         R0,R6 ; number
 0000029C  2804      CMP         R0,#0x4 ; number
 0000029E  D161      BNE         L_290  ; T=0x00000364
 1205:            for(i = 0;i < MAX_NUMBER_USER;i++)
 000002A0  2500      MOV         R5,#0x0
 000002A2          L_336:
 1208:             if(PassUserTime[i].passwordUser[0] != '\0')
 000002A2  1C29      MOV         R1,R5 ; i
 000002A4  0149      LSL         R1,R1,#0x5 ; i
 000002A6  4800      LDR         R0,=PassUserTime ; PassUserTime
 000002A8  5C40      LDRB        R0,[R0,R1]
 000002AA  2800      CMP         R0,#0x0
 000002AC  D035      BEQ         L_338  ; T=0x0000031A
 1210:                 for(j = 0;j < MAX_PASSWORD_USER;j++)
 000002AE  2400      MOV         R4,#0x0
 000002B0          L_342:
 1212:                     temp[j] = PassUserTime[i].passwordUser[j];
 000002B0  1C29      MOV         R1,R5 ; i
 000002B2  0149      LSL         R1,R1,#0x5 ; i
 000002B4  1C20      MOV         R0,R4 ; j
 000002B6  1809      ADD         R1,R0 ; j
 000002B8  4800      LDR         R0,=PassUserTime ; PassUserTime
 000002BA  5C40      LDRB        R0,[R0,R1]
 000002BC  1C22      MOV         R2,R4 ; j
 000002BE  0092      LSL         R2,R2,#0x2 ; j
 000002C0  A900      ADD         R1,R13,#0x0
 000002C2  5088      STR         R0,[R1,R2]
 1213:                 }
 000002C4  3401      ADD         R4,#0x1
 000002C6  1C20      MOV         R0,R4 ; j
 000002C8  2805      CMP         R0,#0x5 ; j
 000002CA  DBF1      BLT         L_342  ; T=0x000002B0
 1214:                 temp[MAX_PASSWORD_USER] = PassUserTime[i].day;
 000002CC  1C29      MOV         R1,R5 ; i
 000002CE  0149      LSL         R1,R1,#0x5 ; i
 000002D0  4800      LDR         R0,=PassUserTime + 0x8 ; PassUserTime+8
 000002D2  5840      LDR         R0,[R0,R1]
 000002D4  9005      STR         R0,[R13,#0x14] ; temp
 1215:                 temp[MAX_PASSWORD_USER+1] = PassUserTime[i].month;
 000002D6  1C29      MOV         R1,R5 ; i
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 83  

 000002D8  0149      LSL         R1,R1,#0x5 ; i
 000002DA  4800      LDR         R0,=PassUserTime + 0xC ; PassUserTime+12
 000002DC  5840      LDR         R0,[R0,R1]
 000002DE  9006      STR         R0,[R13,#0x18] ; temp
 1216:                 temp[MAX_PASSWORD_USER+2] = PassUserTime[i].year;
 000002E0  1C29      MOV         R1,R5 ; i
 000002E2  0149      LSL         R1,R1,#0x5 ; i
 000002E4  4800      LDR         R0,=PassUserTime + 0x10 ; PassUserTime+16
 000002E6  5840      LDR         R0,[R0,R1]
 000002E8  9007      STR         R0,[R13,#0x1C] ; temp
 1217:                 temp[MAX_PASSWORD_USER+3] = PassUserTime[i].hour;
 000002EA  1C29      MOV         R1,R5 ; i
 000002EC  0149      LSL         R1,R1,#0x5 ; i
 000002EE  4800      LDR         R0,=PassUserTime + 0x14 ; PassUserTime+20
 000002F0  5840      LDR         R0,[R0,R1]
 000002F2  9008      STR         R0,[R13,#0x20] ; temp
 1218:                 temp[MAX_PASSWORD_USER+4] = PassUserTime[i].minute;
 000002F4  1C29      MOV         R1,R5 ; i
 000002F6  0149      LSL         R1,R1,#0x5 ; i
 000002F8  4800      LDR         R0,=PassUserTime + 0x18 ; PassUserTime+24
 000002FA  5840      LDR         R0,[R0,R1]
 000002FC  9009      STR         R0,[R13,#0x24] ; temp
 1219:                 temp[MAX_PASSWORD_USER+5] = PassUserTime[i].sec;
 000002FE  1C29      MOV         R1,R5 ; i
 00000300  0149      LSL         R1,R1,#0x5 ; i
 00000302  4800      LDR         R0,=PassUserTime + 0x1C ; PassUserTime+28
 00000304  5840      LDR         R0,[R0,R1]
 00000306  900A      STR         R0,[R13,#0x28] ; temp
 1222:                 if(mmc_write_block_int(151+i,temp) != 0)
 00000308  1C28      MOV         R0,R5 ; i
 0000030A  3097      ADD         R0,#0x97
 0000030C  A900      ADD         R1,R13,#0x0
 0000030E  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000310  FE77      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 00000312  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 00000314  D00C      BEQ         L_333  ; T=0x00000330
 1224:                     return 0; // write fail return 0
 00000316  2000      MOV         R0,#0x0
 00000318  E025      B           L_289  ; T=0x00000366
 1226:             }
 0000031A          L_338:
 1230:                 temp[0] = '\0';
 0000031A  2000      MOV         R0,#0x0
 0000031C  9000      STR         R0,[R13,#0x0] ; temp
 1233:                 if(mmc_write_block_int(151+i,temp) != 0)
 0000031E  1C28      MOV         R0,R5 ; i
 00000320  3097      ADD         R0,#0x97
 00000322  A900      ADD         R1,R13,#0x0
 00000324  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000326  FE6C      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 00000328  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 0000032A  D001      BEQ         L_333  ; T=0x00000330
 1235:                     return 0; // write fail return 0
 0000032C  2000      MOV         R0,#0x0
 0000032E  E01A      B           L_289  ; T=0x00000366
 1238:         }
 00000330          L_333:
 00000330  3501      ADD         R5,#0x1
 00000332  1C28      MOV         R0,R5 ; i
 00000334  2832      CMP         R0,#0x32 ; i
 00000336  DBB4      BLT         L_336  ; T=0x000002A2
 1241:         temp[0] = lMemTem;
 00000338  4800      LDR         R0,=lMemTem ; lMemTem
 0000033A  6800      LDR         R0,[R0,#0x0] ; lMemTem
 0000033C  9000      STR         R0,[R13,#0x0] ; temp
 1242:         temp[1] = lMemRFID;
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 84  

 0000033E  4800      LDR         R0,=lMemRFID ; lMemRFID
 00000340  6800      LDR         R0,[R0,#0x0] ; lMemRFID
 00000342  9001      STR         R0,[R13,#0x4] ; temp
 1243:         temp[2] = lPasswordUser;
 00000344  4800      LDR         R0,=lPasswordUser ; lPasswordUser
 00000346  6800      LDR         R0,[R0,#0x0] ; lPasswordUser
 00000348  9002      STR         R0,[R13,#0x8] ; temp
 1244:         temp[3] = lPasswordUserTime;
 0000034A  4800      LDR         R0,=lPasswordUserTime ; lPasswordUserTime
 0000034C  6800      LDR         R0,[R0,#0x0] ; lPasswordUserTime
 0000034E  9003      STR         R0,[R13,#0xC] ; temp
 1247:         if(mmc_write_block_int(201,temp) != 0)
 00000350  A900      ADD         R1,R13,#0x0
 00000352  20C9      MOV         R0,#0xC9
 00000354  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000356  FE54      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 00000358  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 0000035A  D001      BEQ         L_347  ; T=0x00000360
 1249:             return 0; // write fail return 0
 0000035C  2000      MOV         R0,#0x0
 0000035E  E002      B           L_289  ; T=0x00000366
 1250:         }
 00000360          L_347:
 1252:         return 1; // write complete return 1
 00000360  2001      MOV         R0,#0x1
 00000362  E000      B           L_289  ; T=0x00000366
 1253:     }
 00000364          L_290:
 1255:     return 0; // write fail return 0
 00000364  2000      MOV         R0,#0x0
 00000366            ; SCOPE-END
 1256: }
 00000366          L_289:
 00000366  4980      LDR         R1,=0x200
 00000368  448D      ADD         R13,R13,R1
 0000036A  BC70      POP         {R4-R6}
 0000036C  BC08      POP         {R3}
 0000036E  4718      BX          R3
 00000370          ENDP ; 'savedata_mmc?T'


*** CODE SEGMENT '?PR?cleardata_mmc?T?main':
 1259: int cleardata_mmc()
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  4800      LDR         R0,=0xFFFFFE00
 00000004  4485      ADD         R13,R13,R0
 1260: {
 00000006            ; SCOPE-START
 1261:      int i = 0,j = 0;
 00000006  2500      MOV         R5,#0x0
 00000008  ---- Variable 'i' assigned to Register 'R5' ----
 00000008  2400      MOV         R4,#0x0
 0000000A  ---- Variable 'j' assigned to Register 'R4' ----
 1265:     for(i = 0;i < MAX_NUMBER_USER;i++)
 0000000A  2500      MOV         R5,#0x0
 1267:         for(j = 0;j < MAX_PASSWORD_USER;j++)
 0000000C          L_357:
 0000000C  2400      MOV         R4,#0x0
 0000000E          L_356:
 1269:             temp[j] = '\0';
 0000000E  2000      MOV         R0,#0x0
 00000010  1C22      MOV         R2,R4 ; j
 00000012  0092      LSL         R2,R2,#0x2 ; j
 00000014  A900      ADD         R1,R13,#0x0
 00000016  5088      STR         R0,[R1,R2]
 1270:         }
 00000018  3401      ADD         R4,#0x1
 0000001A  1C20      MOV         R0,R4 ; j
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 85  

 0000001C  2805      CMP         R0,#0x5 ; j
 0000001E  DBF6      BLT         L_356  ; T=0x0000000E
 1273:         if(mmc_write_block_int(1+i,temp) != 0)
 00000020  1C28      MOV         R0,R5 ; i
 00000022  3001      ADD         R0,#0x1
 00000024  A900      ADD         R1,R13,#0x0
 00000026  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000028  FFEB      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 0000002A  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 0000002C  D001      BEQ         L_348  ; T=0x00000032
 1275:              return 0; // write fail return 0
 0000002E  2000      MOV         R0,#0x0
 00000030  E064      B           L_359  ; T=0x000000FC
 1277:     }
 00000032          L_348:
 00000032  3501      ADD         R5,#0x1
 00000034  1C28      MOV         R0,R5 ; i
 00000036  2832      CMP         R0,#0x32 ; i
 00000038  DBE8      BLT         L_357  ; T=0x0000000C
 1280:     for(i = 0;i < MAX_RFID_CARD;i++)
 0000003A  2500      MOV         R5,#0x0
 0000003C          L_363:
 1282:         temp[0] = 0;
 0000003C  2000      MOV         R0,#0x0
 0000003E  9000      STR         R0,[R13,#0x0] ; temp
 1283:         temp[1] = 0;
 00000040  2000      MOV         R0,#0x0
 00000042  9001      STR         R0,[R13,#0x4] ; temp
 1284:         temp[2] = 0;
 00000044  2000      MOV         R0,#0x0
 00000046  9002      STR         R0,[R13,#0x8] ; temp
 1285:         temp[3] = 0;
 00000048  2000      MOV         R0,#0x0
 0000004A  9003      STR         R0,[R13,#0xC] ; temp
 1286:         temp[4] = 0;
 0000004C  2000      MOV         R0,#0x0
 0000004E  9004      STR         R0,[R13,#0x10] ; temp
 1287:         temp[5] = 0;
 00000050  2000      MOV         R0,#0x0
 00000052  9005      STR         R0,[R13,#0x14] ; temp
 1288:         temp[6] = 0;
 00000054  2000      MOV         R0,#0x0
 00000056  9006      STR         R0,[R13,#0x18] ; temp
 1291:          if(mmc_write_block_int(51+i,temp) != 0)
 00000058  1C28      MOV         R0,R5 ; i
 0000005A  3033      ADD         R0,#0x33
 0000005C  A900      ADD         R1,R13,#0x0
 0000005E  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000060  FFCF      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 00000062  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 00000064  D001      BEQ         L_360  ; T=0x0000006A
 1293:             return 0; // write fail return 0
 00000066  2000      MOV         R0,#0x0
 00000068  E048      B           L_359  ; T=0x000000FC
 1295:     }
 0000006A          L_360:
 0000006A  3501      ADD         R5,#0x1
 0000006C  1C28      MOV         R0,R5 ; i
 0000006E  2832      CMP         R0,#0x32 ; i
 00000070  DBE4      BLT         L_363  ; T=0x0000003C
 1298:     for(i = 0;i < MAX_RFID_CARD;i++)
 00000072  2500      MOV         R5,#0x0
 00000074          L_369:
 1300:         temp[0] = 0;
 00000074  2000      MOV         R0,#0x0
 00000076  9000      STR         R0,[R13,#0x0] ; temp
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 86  

 1301:         temp[1] = 0;
 00000078  2000      MOV         R0,#0x0
 0000007A  9001      STR         R0,[R13,#0x4] ; temp
 1302:         temp[2] = 0;
 0000007C  2000      MOV         R0,#0x0
 0000007E  9002      STR         R0,[R13,#0x8] ; temp
 1303:         temp[3] = 0;
 00000080  2000      MOV         R0,#0x0
 00000082  9003      STR         R0,[R13,#0xC] ; temp
 1304:         temp[4] = 0;
 00000084  2000      MOV         R0,#0x0
 00000086  9004      STR         R0,[R13,#0x10] ; temp
 1305:         temp[5] = 0;
 00000088  2000      MOV         R0,#0x0
 0000008A  9005      STR         R0,[R13,#0x14] ; temp
 1306:         temp[6] = 0;
 0000008C  2000      MOV         R0,#0x0
 0000008E  9006      STR         R0,[R13,#0x18] ; temp
 1309:         if(mmc_write_block_int(101+i,temp) != 0)
 00000090  1C28      MOV         R0,R5 ; i
 00000092  3065      ADD         R0,#0x65
 00000094  A900      ADD         R1,R13,#0x0
 00000096  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 00000098  FFB3      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 0000009A  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 0000009C  D001      BEQ         L_366  ; T=0x000000A2
 1311:             return 0; // write fail return 0
 0000009E  2000      MOV         R0,#0x0
 000000A0  E02C      B           L_359  ; T=0x000000FC
 1313:     }
 000000A2          L_366:
 000000A2  3501      ADD         R5,#0x1
 000000A4  1C28      MOV         R0,R5 ; i
 000000A6  2832      CMP         R0,#0x32 ; i
 000000A8  DBE4      BLT         L_369  ; T=0x00000074
 1316:     for(i = 0;i < MAX_NUMBER_USER;i++)
 000000AA  2500      MOV         R5,#0x0
 1318:         for(j = 0;j < MAX_PASSWORD_USER;j++)
 000000AC          L_381:
 000000AC  2400      MOV         R4,#0x0
 000000AE          L_380:
 1320:             temp[j] = '\0';
 000000AE  2000      MOV         R0,#0x0
 000000B0  1C22      MOV         R2,R4 ; j
 000000B2  0092      LSL         R2,R2,#0x2 ; j
 000000B4  A900      ADD         R1,R13,#0x0
 000000B6  5088      STR         R0,[R1,R2]
 1321:         }
 000000B8  3401      ADD         R4,#0x1
 000000BA  1C20      MOV         R0,R4 ; j
 000000BC  2805      CMP         R0,#0x5 ; j
 000000BE  DBF6      BLT         L_380  ; T=0x000000AE
 1324:         if(mmc_write_block_int(151+i,temp) != 0)
 000000C0  1C28      MOV         R0,R5 ; i
 000000C2  3097      ADD         R0,#0x97
 000000C4  A900      ADD         R1,R13,#0x0
 000000C6  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 000000C8  FF9B      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 000000CA  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 000000CC  D001      BEQ         L_372  ; T=0x000000D2
 1326:              return 0; // write fail return 0
 000000CE  2000      MOV         R0,#0x0
 000000D0  E014      B           L_359  ; T=0x000000FC
 1328:     }
 000000D2          L_372:
 000000D2  3501      ADD         R5,#0x1
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 87  

 000000D4  1C28      MOV         R0,R5 ; i
 000000D6  2832      CMP         R0,#0x32 ; i
 000000D8  DBE8      BLT         L_381  ; T=0x000000AC
 1331:     temp[1] = 0;
 000000DA  2000      MOV         R0,#0x0
 000000DC  9001      STR         R0,[R13,#0x4] ; temp
 1332:     temp[2] = 0;
 000000DE  2000      MOV         R0,#0x0
 000000E0  9002      STR         R0,[R13,#0x8] ; temp
 1333:     temp[3] = 0;
 000000E2  2000      MOV         R0,#0x0
 000000E4  9003      STR         R0,[R13,#0xC] ; temp
 1334:     temp[4] = 0;
 000000E6  2000      MOV         R0,#0x0
 000000E8  9004      STR         R0,[R13,#0x10] ; temp
 1337:     if(mmc_write_block_int(201,temp) != 0)
 000000EA  A900      ADD         R1,R13,#0x0
 000000EC  20C9      MOV         R0,#0xC9
 000000EE  F7FF      BL          mmc_write_block_int?T  ; T=0x0001  (1)
 000000F0  FF87      BL          mmc_write_block_int?T  ; T=0x0001  (2)
 000000F2  2800      CMP         R0,#0x0 ; mmc_write_block_int?T
 000000F4  D001      BEQ         L_383  ; T=0x000000FA
 1339:         return 0; // write fail return 0
 000000F6  2000      MOV         R0,#0x0
 000000F8  E000      B           L_359  ; T=0x000000FC
 1340:     }
 000000FA          L_383:
 1342:     return 1; // write complete return 1
 000000FA  2001      MOV         R0,#0x1
 000000FC            ; SCOPE-END
 1343: }
 000000FC          L_359:
 000000FC  4980      LDR         R1,=0x200
 000000FE  448D      ADD         R13,R13,R1
 00000100  BC30      POP         {R4-R5}
 00000102  BC08      POP         {R3}
 00000104  4718      BX          R3
 00000106          ENDP ; 'cleardata_mmc?T'


*** CODE SEGMENT '?PR?loadpic_mmc?T?main':
 1346: void loadpic_mmc(int blocknum)
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  1C05      MOV         R5,R0 ; blocknum
 00000004  ---- Variable 'blocknum' assigned to Register 'R5' ----
 00000004  4800      LDR         R0,=0xFFFFFE00
 00000006  4485      ADD         R13,R13,R0
 1347: {
 00000008            ; SCOPE-START
 1348:     int i =0;
 00000008  2400      MOV         R4,#0x0
 0000000A  ---- Variable 'i' assigned to Register 'R4' ----
 1349:     char temp[MMC_DATA_SIZE] = { '\0' };
 0000000A  4800      LDR         R1,=?tpl?0001 ; ?tpl?0001
 0000000C  A800      ADD         R0,R13,#0x0
 0000000E  4A80      LDR         R2,=0x200
 00000010          L_530:
 00000010  780B      LDRB        R3,[R1,#0x0]
 00000012  7003      STRB        R3,[R0,#0x0]
 00000014  1C49      ADD         R1,R1,#0x1
 00000016  1C40      ADD         R0,R0,#0x1
 00000018  1E52      SUB         R2,R2,#0x1
 0000001A  D1F9      BNE         L_530  ; T=0x00000010
 1352:      mmc_read_block_char(blocknum,temp);
 0000001C  1C28      MOV         R0,R5 ; blocknum
 0000001E  A900      ADD         R1,R13,#0x0
 00000020  F7FF      BL          mmc_read_block_char?T  ; T=0x0001  (1)
 00000022  FFEE      BL          mmc_read_block_char?T  ; T=0x0001  (2)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 88  

 1355:     for(i = 0;i < 504;i++)
 00000024  2400      MOV         R4,#0x0
 00000026          L_387:
 1357:         temppic[i] = temp[i];
 00000026  1C21      MOV         R1,R4 ; i
 00000028  A800      ADD         R0,R13,#0x0
 0000002A  5C40      LDRB        R0,[R0,R1]
 0000002C  1C22      MOV         R2,R4 ; i
 0000002E  4800      LDR         R1,=temppic ; temppic
 00000030  5488      STRB        R0,[R1,R2]
 1358:     }
 00000032  3401      ADD         R4,#0x1
 00000034  1C20      MOV         R0,R4 ; i
 00000036  497E      LDR         R1,=0x1F8
 00000038  4288      CMP         R0,R1 ; i
 0000003A  DBF4      BLT         L_387  ; T=0x00000026
 0000003C            ; SCOPE-END
 1359: }
 0000003C  4880      LDR         R0,=0x200
 0000003E  4485      ADD         R13,R13,R0
 00000040  BC30      POP         {R4-R5}
 00000042  BC08      POP         {R3}
 00000044  4718      BX          R3
 00000046          ENDP ; 'loadpic_mmc?T'


*** CODE SEGMENT '?PR?settime?T?main':
 1362: void settime(void)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  B082      SUB         R13,#0x8
 1363: {
 00000004            ; SCOPE-START
 1364:     int minutenew = 0,hournew = 0,daynew = 0,monthnew = 0,yearnew = 0,daymod = 0;
 00000004  2000      MOV         R0,#0x0
 00000006  9000      STR         R0,[R13,#0x0] ; minutenew
 00000008  2000      MOV         R0,#0x0
 0000000A  9001      STR         R0,[R13,#0x4] ; hournew
 0000000C  2400      MOV         R4,#0x0
 0000000E  ---- Variable 'daynew' assigned to Register 'R4' ----
 0000000E  2500      MOV         R5,#0x0
 00000010  ---- Variable 'monthnew' assigned to Register 'R5' ----
 00000010  2600      MOV         R6,#0x0
 00000012  ---- Variable 'yearnew' assigned to Register 'R6' ----
 00000012  2700      MOV         R7,#0x0
 00000014  ---- Variable 'daymod' assigned to Register 'R7' ----
 1368:     loadpic_mmc(422); // load picture from sd/mmc
 00000014  4800      LDR         R0,=0x1A6
 00000016  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000018  FFF3      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1369:     lcd_fill_picture(temppic); // show picture on lcd
 0000001A  4800      LDR         R0,=temppic ; temppic
 0000001C  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1370:     receive_keypad(6); // receive data from keypad
 00000020  2006      MOV         R0,#0x6
 00000022  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 00000024  FFED      BL          receive_keypad?T  ; T=0x0001  (2)
 1373:     if((tempkey[0] != '\0') && (tempkey[1] != '\0') && (tempkey[2] != '\0') && (tempkey[3] != '\0')
 00000026  4800      LDR         R0,=tempkey ; tempkey
 00000028  7800      LDRB        R0,[R0,#0x0] ; tempkey
 0000002A  2800      CMP         R0,#0x0
 0000002C  D100      BEQ         $+4
 0000002E  E09B      B           L_389  ; T=0x00000168
 00000032  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 00000034  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 00000036  2800      CMP         R0,#0x0
 00000038  D100      BEQ         $+4
 0000003A  E095      B           L_389  ; T=0x00000168
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 89  

 0000003E  4800      LDR         R0,=tempkey + 0x2 ; tempkey+2
 00000040  7800      LDRB        R0,[R0,#0x0] ; tempkey+2
 00000042  2800      CMP         R0,#0x0
 00000044  D100      BEQ         $+4
 00000046  E08F      B           L_389  ; T=0x00000168
 0000004A  4800      LDR         R0,=tempkey + 0x3 ; tempkey+3
 0000004C  7800      LDRB        R0,[R0,#0x0] ; tempkey+3
 0000004E  2800      CMP         R0,#0x0
 00000050  D100      BEQ         $+4
 00000052  E089      B           L_389  ; T=0x00000168
 00000056  4800      LDR         R0,=tempkey + 0x4 ; tempkey+4
 00000058  7801      LDRB        R1,[R0,#0x0] ; tempkey+4
 0000005A  1C08      MOV         R0,R1
 0000005C  2800      CMP         R0,#0x0
 0000005E  D100      BEQ         $+4
 00000060  E082      B           L_389  ; T=0x00000168
 00000064  4800      LDR         R0,=tempkey + 0x5 ; tempkey+5
 00000066  7800      LDRB        R0,[R0,#0x0] ; tempkey+5
 00000068  2800      CMP         R0,#0x0
 0000006A  D100      BEQ         $+4
 0000006C  E07C      B           L_389  ; T=0x00000168
 00000070  4800      LDR         R2,=tempkey + 0x6 ; tempkey+6
 00000072  7812      LDRB        R2,[R2,#0x0] ; tempkey+6
 00000074  2A00      CMP         R2,#0x0
 00000076  D077      BEQ         L_389  ; T=0x00000168
 00000078  4800      LDR         R2,=tempkey + 0x7 ; tempkey+7
 0000007A  7812      LDRB        R2,[R2,#0x0] ; tempkey+7
 0000007C  2A00      CMP         R2,#0x0
 0000007E  D073      BEQ         L_389  ; T=0x00000168
 1377:         yearnew = (((tempkey[4]-48)*1000)+((tempkey[5]-48)*100)+((tempkey[6]-48)*10)+(tempkey[7]-48));
 00000080  3830      SUB         R0,#0x30
 00000082  2264      MOV         R2,#0x64
 00000084  4350      MUL         R0,R2
 00000086  1C0E      MOV         R6,R1
 00000088  3E30      SUB         R6,#0x30
 0000008A  49FA      LDR         R1,=0x3E8
 0000008C  434E      MUL         R6,R1
 0000008E  1836      ADD         R6,R0
 00000090  4800      LDR         R0,=tempkey + 0x6 ; tempkey+6
 00000092  7800      LDRB        R0,[R0,#0x0] ; tempkey+6
 00000094  3830      SUB         R0,#0x30
 00000096  210A      MOV         R1,#0xA
 00000098  4348      MUL         R0,R1
 0000009A  1836      ADD         R6,R0
 0000009C  4800      LDR         R0,=tempkey + 0x7 ; tempkey+7
 0000009E  7800      LDRB        R0,[R0,#0x0] ; tempkey+7
 000000A0  3830      SUB         R0,#0x30
 000000A2  1836      ADD         R6,R0
 1380:         monthnew = (((tempkey[2]-48)*10)+(tempkey[3]-48))%13;
 000000A4  4800      LDR         R0,=tempkey + 0x2 ; tempkey+2
 000000A6  7800      LDRB        R0,[R0,#0x0] ; tempkey+2
 000000A8  3830      SUB         R0,#0x30
 000000AA  210A      MOV         R1,#0xA
 000000AC  4348      MUL         R0,R1
 000000AE  4800      LDR         R1,=tempkey + 0x3 ; tempkey+3
 000000B0  7809      LDRB        R1,[R1,#0x0] ; tempkey+3
 000000B2  3930      SUB         R1,#0x30
 000000B4  1840      ADD         R0,R1
 000000B6  210D      MOV         R1,#0xD
 000000B8  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 000000BA  FFA2      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 000000BC  1C01      MOV         R1,R0
 000000BE  1C0D      MOV         R5,R1 ; monthnew
 1381:         if(monthnew == 0)
 000000C0  1C28      MOV         R0,R5 ; monthnew
 000000C2  2800      CMP         R0,#0x0 ; monthnew
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 90  

 000000C4  D1FA      BNE         L_390  ; T=0x000000BC
 1382:             monthnew++;
 000000C6  3501      ADD         R5,#0x1
 000000C8          L_390:
 1385:         if(monthnew == 1)
 000000C8  1C28      MOV         R0,R5 ; monthnew
 000000CA  2801      CMP         R0,#0x1 ; monthnew
 000000CC  D1FB      BNE         L_391  ; T=0x000000C6
 1387:             daymod = 32;
 000000CE  2720      MOV         R7,#0x20
 1388:         }
 000000D0  E038      B           L_392  ; T=0x00000144
 000000D2          L_391:
 1389:         else if(monthnew == 2)
 000000D2  1C28      MOV         R0,R5 ; monthnew
 000000D4  2802      CMP         R0,#0x2 ; monthnew
 000000D6  D104      BNE         L_393  ; T=0x000000E2
 1391:             if((yearnew%4) == 0)
 000000D8  1C30      MOV         R0,R6 ; yearnew
 000000DA  2104      MOV         R1,#0x4
 000000DC  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 000000DE  FF90      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 000000E0  1C01      MOV         R1,R0
 000000E2  2900      CMP         R1,#0x0
 000000E4  D1FB      BNE         L_394  ; T=0x000000DE
 1393:                 daymod = 30;
 000000E6  271E      MOV         R7,#0x1E
 1394:             }
 000000E8  E02C      B           L_392  ; T=0x00000144
 000000EA          L_394:
 1397:                 daymod = 29;
 000000EA  271D      MOV         R7,#0x1D
 1399:         }
 000000EC  E02A      B           L_392  ; T=0x00000144
 000000EE          L_393:
 1400:         else if(monthnew == 3)
 000000EE  1C28      MOV         R0,R5 ; monthnew
 000000F0  2803      CMP         R0,#0x3 ; monthnew
 000000F2  D1FB      BNE         L_397  ; T=0x000000EC
 1402:             daymod = 32;
 000000F4  2720      MOV         R7,#0x20
 1403:         }
 000000F6  E025      B           L_392  ; T=0x00000144
 000000F8          L_397:
 1404:         else if(monthnew == 4)
 000000F8  1C28      MOV         R0,R5 ; monthnew
 000000FA  2804      CMP         R0,#0x4 ; monthnew
 000000FC  D1FB      BNE         L_399  ; T=0x000000F6
 1406:             daymod = 31;
 000000FE  271F      MOV         R7,#0x1F
 1407:         }
 00000100  E020      B           L_392  ; T=0x00000144
 00000102          L_399:
 1408:         else if(monthnew == 5)
 00000102  1C28      MOV         R0,R5 ; monthnew
 00000104  2805      CMP         R0,#0x5 ; monthnew
 00000106  D1FB      BNE         L_401  ; T=0x00000100
 1410:             daymod = 32;
 00000108  2720      MOV         R7,#0x20
 1411:         }
 0000010A  E01B      B           L_392  ; T=0x00000144
 0000010C          L_401:
 1412:         else if(monthnew == 6)
 0000010C  1C28      MOV         R0,R5 ; monthnew
 0000010E  2806      CMP         R0,#0x6 ; monthnew
 00000110  D1FB      BNE         L_403  ; T=0x0000010A
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 91  

 1414:             daymod = 31;
 00000112  271F      MOV         R7,#0x1F
 1415:         }
 00000114  E016      B           L_392  ; T=0x00000144
 00000116          L_403:
 1416:         else if(monthnew == 7)
 00000116  1C28      MOV         R0,R5 ; monthnew
 00000118  2807      CMP         R0,#0x7 ; monthnew
 0000011A  D1FB      BNE         L_405  ; T=0x00000114
 1418:             daymod = 32;
 0000011C  2720      MOV         R7,#0x20
 1419:         }
 0000011E  E011      B           L_392  ; T=0x00000144
 00000120          L_405:
 1420:         else if(monthnew == 8)
 00000120  1C28      MOV         R0,R5 ; monthnew
 00000122  2808      CMP         R0,#0x8 ; monthnew
 00000124  D1FB      BNE         L_407  ; T=0x0000011E
 1422:             daymod = 32;
 00000126  2720      MOV         R7,#0x20
 1423:         }
 00000128  E00C      B           L_392  ; T=0x00000144
 0000012A          L_407:
 1424:         else if(monthnew == 9)
 0000012A  1C28      MOV         R0,R5 ; monthnew
 0000012C  2809      CMP         R0,#0x9 ; monthnew
 0000012E  D1FB      BNE         L_409  ; T=0x00000128
 1426:             daymod = 31;
 00000130  271F      MOV         R7,#0x1F
 1427:         }
 00000132  E007      B           L_392  ; T=0x00000144
 00000134          L_409:
 1428:         else if(monthnew == 10)
 00000134  1C28      MOV         R0,R5 ; monthnew
 00000136  280A      CMP         R0,#0xA ; monthnew
 00000138  D1FB      BNE         L_411  ; T=0x00000132
 1430:             daymod = 32;
 0000013A  2720      MOV         R7,#0x20
 1431:         }
 0000013C  E002      B           L_392  ; T=0x00000144
 0000013E          L_411:
 1432:         else if(monthnew == 11)
 0000013E  1C28      MOV         R0,R5 ; monthnew
 00000140  280B      CMP         R0,#0xB ; monthnew
 00000142  D1FB      BNE         L_413  ; T=0x0000013C
 1434:             daymod = 31;
 00000144  271F      MOV         R7,#0x1F
 1435:         }
 00000146  E7FD      B           L_392  ; T=0x00000144
 00000148          L_413:
 1436:         else if(monthnew == 12)
 00000148  1C28      MOV         R0,R5 ; monthnew
 0000014A  280C      CMP         R0,#0xC ; monthnew
 0000014C  D1FA      BNE         L_392  ; T=0x00000144
 1438:             daymod = 32;
 0000014E  2720      MOV         R7,#0x20
 1439:         }
 00000150          L_392:
 1442:         daynew = (((tempkey[0]-48)*10)+(tempkey[1]-48))%daymod;
 00000150  4800      LDR         R0,=tempkey ; tempkey
 00000152  7800      LDRB        R0,[R0,#0x0] ; tempkey
 00000154  3830      SUB         R0,#0x30
 00000156  210A      MOV         R1,#0xA
 00000158  4348      MUL         R0,R1
 0000015A  4800      LDR         R1,=tempkey + 0x1 ; tempkey+1
 0000015C  7809      LDRB        R1,[R1,#0x0] ; tempkey+1
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 92  

 0000015E  3930      SUB         R1,#0x30
 00000160  1840      ADD         R0,R1
 00000162  1C39      MOV         R1,R7 ; daymod
 00000164  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000166  FF4C      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000168  1C01      MOV         R1,R0
 0000016A  1C0C      MOV         R4,R1 ; daynew
 1443:         if(daynew == 0)
 0000016C  1C20      MOV         R0,R4 ; daynew
 0000016E  2800      CMP         R0,#0x0 ; daynew
 00000170  D1FA      BNE         L_389  ; T=0x00000168
 1444:             daynew++;
 00000172  3401      ADD         R4,#0x1
 1445:      }
 00000174          L_389:
 1447:      setyear(yearnew); // set year = new year
 00000174  1C30      MOV         R0,R6 ; yearnew
 00000176  F7FF      BL          setyear?T  ; T=0x0001  (1)
 00000178  FF43      BL          setyear?T  ; T=0x0001  (2)
 1448:      setmonth(monthnew); // set month = new month
 0000017A  1C28      MOV         R0,R5 ; monthnew
 0000017C  F7FF      BL          setmonth?T  ; T=0x0001  (1)
 0000017E  FF40      BL          setmonth?T  ; T=0x0001  (2)
 1449:      setday(daynew); // set day = new day
 00000180  1C20      MOV         R0,R4 ; daynew
 00000182  F7FF      BL          setday?T  ; T=0x0001  (1)
 00000184  FF3D      BL          setday?T  ; T=0x0001  (2)
 1453:      printf("Enter time (hhmm) :");
 00000186  4800      LDR         R0,=??S_39 ; ??S_39
 00000188  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000018A  FF3A      BL          printf?T  ; T=0x0001  (2)
 1454:      loadpic_mmc(423); // load picture from sd/mmc
 0000018C  4800      LDR         R0,=0x1A7
 0000018E  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000190  FF37      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1455:      lcd_fill_picture(temppic); // show picture on lcd
 00000192  4800      LDR         R0,=temppic ; temppic
 00000194  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000196  FF34      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1456:      receive_keypad(7); // receive data from keypad
 00000198  2007      MOV         R0,#0x7
 0000019A  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 0000019C  FF31      BL          receive_keypad?T  ; T=0x0001  (2)
 1459:      if((tempkey[0] != '\0') && (tempkey[1] != '\0') && (tempkey[2] != '\0') && (tempkey[3] != '\0'))
 0000019E  4800      LDR         R0,=tempkey ; tempkey
 000001A0  7800      LDRB        R0,[R0,#0x0] ; tempkey
 000001A2  1C03      MOV         R3,R0
 000001A4  2B00      CMP         R3,#0x0
 000001A6  D01C      BEQ         L_417  ; T=0x000001E2
 000001A8  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 000001AA  7802      LDRB        R2,[R0,#0x0] ; tempkey+1
 000001AC  1C10      MOV         R0,R2
 000001AE  2800      CMP         R0,#0x0
 000001B0  D017      BEQ         L_417  ; T=0x000001E2
 000001B2  4800      LDR         R0,=tempkey + 0x2 ; tempkey+2
 000001B4  7800      LDRB        R0,[R0,#0x0] ; tempkey+2
 000001B6  2800      CMP         R0,#0x0
 000001B8  D013      BEQ         L_417  ; T=0x000001E2
 000001BA  4800      LDR         R1,=tempkey + 0x3 ; tempkey+3
 000001BC  7809      LDRB        R1,[R1,#0x0] ; tempkey+3
 000001BE  2900      CMP         R1,#0x0
 000001C0  D00F      BEQ         L_417  ; T=0x000001E2
 1461:             minutenew = (((tempkey[2]-48)*10)+(tempkey[3]-48))%60; // convert tempkey to minute
 000001C2  3830      SUB         R0,#0x30
 000001C4  240A      MOV         R4,#0xA
 000001C6  4360      MUL         R0,R4
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 93  

 000001C8  3930      SUB         R1,#0x30
 000001CA  1840      ADD         R0,R1
 000001CC  213C      MOV         R1,#0x3C
 000001CE  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 000001D0  FF17      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 000001D2  1C01      MOV         R1,R0
 000001D4  9100      STR         R1,[R13,#0x0] ; minutenew
 1462:             hournew = (((tempkey[0]-48)*10)+(tempkey[1]-48))%24; // convert tempkey to hour
 000001D6  1C18      MOV         R0,R3
 000001D8  3830      SUB         R0,#0x30
 000001DA  210A      MOV         R1,#0xA
 000001DC  4348      MUL         R0,R1
 000001DE  1C11      MOV         R1,R2
 000001E0  3930      SUB         R1,#0x30
 000001E2  1840      ADD         R0,R1
 000001E4  2118      MOV         R1,#0x18
 000001E6  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 000001E8  FF0B      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 000001EA  1C01      MOV         R1,R0
 000001EC  9101      STR         R1,[R13,#0x4] ; hournew
 1463:      }
 000001EE          L_417:
 1465:      setminute(minutenew); // set minute = new minute
 000001EE  9800      LDR         R0,[R13,#0x0] ; minutenew
 000001F0  F7FF      BL          setminute?T  ; T=0x0001  (1)
 000001F2  FF06      BL          setminute?T  ; T=0x0001  (2)
 1466:      sethour(hournew); // set hour = new hour
 000001F4  9801      LDR         R0,[R13,#0x4] ; hournew
 000001F6  F7FF      BL          sethour?T  ; T=0x0001  (1)
 000001F8  FF03      BL          sethour?T  ; T=0x0001  (2)
 1467:      setsec(0); // set sec = 0
 000001FA  2000      MOV         R0,#0x0
 000001FC  F7FF      BL          setsec?T  ; T=0x0001  (1)
 000001FE  FF00      BL          setsec?T  ; T=0x0001  (2)
 1469:      printf("\n%d/%d/%d\n%d:%d:%d\n",day(),month(),year(),hour(),minute(),sec());
 00000200  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000202  FEFE      BL          sec?T  ; T=0x0001  (2)
 00000204  B401      PUSH        {R0}
 00000206  F7FF      BL          minute?T  ; T=0x0001  (1)
 00000208  FEFB      BL          minute?T  ; T=0x0001  (2)
 0000020A  B401      PUSH        {R0}
 0000020C  F7FF      BL          hour?T  ; T=0x0001  (1)
 0000020E  FEF8      BL          hour?T  ; T=0x0001  (2)
 00000210  B401      PUSH        {R0}
 00000212  F7FF      BL          day?T  ; T=0x0001  (1)
 00000214  FEF5      BL          day?T  ; T=0x0001  (2)
 00000216  B401      PUSH        {R0}
 00000218  F7FF      BL          month?T  ; T=0x0001  (1)
 0000021A  FEF2      BL          month?T  ; T=0x0001  (2)
 0000021C  B401      PUSH        {R0}
 0000021E  F7FF      BL          year?T  ; T=0x0001  (1)
 00000220  FEEF      BL          year?T  ; T=0x0001  (2)
 00000222  1C03      MOV         R3,R0
 00000224  4800      LDR         R0,=??S_40 ; ??S_40
 00000226  BC04      POP         {R2}
 00000228  BC02      POP         {R1}
 0000022A  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000022C  FEE9      BL          printf?T  ; T=0x0001  (2)
 0000022E  B003      ADD         R13,#0xC
 00000230            ; SCOPE-END
 1470: }
 00000230  B002      ADD         R13,#0x8
 00000232  BCF0      POP         {R4-R7}
 00000234  BC08      POP         {R3}
 00000236  4718      BX          R3
 00000238          ENDP ; 'settime?T'

ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 94  


*** CODE SEGMENT '?PR?main?main':
 1474: void main(void)
 00000000  B500      PUSH        {LR}
 00000002  ---- Variable 'j' assigned to Register 'R4' ----
 1475: {    
 00000002            ; SCOPE-START
 1480:     init_serial0(); // initial serial port 0
 00000002  F7FF      BL          init_serial0?T  ; T=0x0001  (1)
 00000004  FFFD      BL          init_serial0?T  ; T=0x0001  (2)
 1481:     init_keypad(); // initial keypad
 00000006  F7FF      BL          init_keypad?T  ; T=0x0001  (1)
 00000008  FFFB      BL          init_keypad?T  ; T=0x0001  (2)
 1483:     initTime(); // initial date and time
 0000000A  F7FF      BL          initTime?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          initTime?T  ; T=0x0001  (2)
 1484:     init_RFID(); // initial RFID Reader
 0000000E  F7FF      BL          init_RFID?T  ; T=0x0001  (1)
 00000010  FFF7      BL          init_RFID?T  ; T=0x0001  (2)
 1485:     SPI_Init(); // initial SPI1
 00000012  F7FF      BL          SPI_Init?T  ; T=0x0001  (1)
 00000014  FFF5      BL          SPI_Init?T  ; T=0x0001  (2)
 1486:     lcd_initial(); // initial LCD                                           
 00000016  F7FF      BL          lcd_initial?T  ; T=0x0001  (1)
 00000018  FFF3      BL          lcd_initial?T  ; T=0x0001  (2)
 1487:       lcd_clear_screen(); // clear LCD screen
 0000001A  F7FF      BL          lcd_clear_screen?T  ; T=0x0001  (1)
 0000001C  FFF1      BL          lcd_clear_screen?T  ; T=0x0001  (2)
 1488:     if( mmc_init() != 0 ) // initial sd/mmc fail
 0000001E  F7FF      BL          mmc_init?T  ; T=0x0001  (1)
 00000020  FFEF      BL          mmc_init?T  ; T=0x0001  (2)
 00000022  2800      CMP         R0,#0x0 ; mmc_init?T
 00000024  D003      BEQ         L_418  ; T=0x0000002E
 1490:         printf("\nMMC init fail");
 00000026  4800      LDR         R0,=??S_41 ; ??S_41
 00000028  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000002A  FFEA      BL          printf?T  ; T=0x0001  (2)
 1491:     }
 0000002C  E018      B           L_419  ; T=0x00000060
 0000002E          L_418:
 1496:          if(loaddata_mmc() == 0) // load fail
 0000002E  F7FF      BL          loaddata_mmc?T  ; T=0x0001  (1)
 00000030  FFE7      BL          loaddata_mmc?T  ; T=0x0001  (2)
 00000032  2800      CMP         R0,#0x0 ; loaddata_mmc?T
 00000034  D111      BNE         L_420  ; T=0x0000005A
 1498:             printf("Load fail\n");
 00000036  4800      LDR         R0,=??S_42 ; ??S_42
 00000038  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          printf?T  ; T=0x0001  (2)
 1499:             cleardata_mmc(); // clear data in sd/mmc
 0000003C  F7FF      BL          cleardata_mmc?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          cleardata_mmc?T  ; T=0x0001  (2)
 1500:             if (savedata_mmc(0) == 0) // save fail
 00000040  2000      MOV         R0,#0x0
 00000042  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 00000044  FFDD      BL          savedata_mmc?T  ; T=0x0001  (2)
 00000046  2800      CMP         R0,#0x0 ; savedata_mmc?T
 00000048  D103      BNE         L_421  ; T=0x00000052
 1502:                 printf("Save fail\n");
 0000004A  4800      LDR         R0,=??S_43 ; ??S_43
 0000004C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000004E  FFD8      BL          printf?T  ; T=0x0001  (2)
 1503:             }
 00000050  E006      B           L_419  ; T=0x00000060
 00000052          L_421:
 1506:                 printf("Save complete");
 00000052  4800      LDR         R0,=??S_44 ; ??S_44
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 95  

 00000054  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000056  FFD4      BL          printf?T  ; T=0x0001  (2)
 1508:         }
 00000058  E002      B           L_419  ; T=0x00000060
 0000005A          L_420:
 1512:             printf("Load complete");
 0000005A  4800      LDR         R0,=??S_45 ; ??S_45
 0000005C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000005E  FFD0      BL          printf?T  ; T=0x0001  (2)
 1514:     }
 00000060          L_419:
 1517:     setStateCompare();
 00000060  F7FF      BL          setStateCompare?T  ; T=0x0001  (1)
 00000062  FFCE      BL          setStateCompare?T  ; T=0x0001  (2)
 1519:     printf("\n%d/%d/%d\n%d:%d:%d\n",day(),month(),year(),hour(),minute(),sec());
 00000064  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000066  FFCC      BL          sec?T  ; T=0x0001  (2)
 00000068  B401      PUSH        {R0}
 0000006A  F7FF      BL          minute?T  ; T=0x0001  (1)
 0000006C  FFC9      BL          minute?T  ; T=0x0001  (2)
 0000006E  B401      PUSH        {R0}
 00000070  F7FF      BL          hour?T  ; T=0x0001  (1)
 00000072  FFC6      BL          hour?T  ; T=0x0001  (2)
 00000074  B401      PUSH        {R0}
 00000076  F7FF      BL          day?T  ; T=0x0001  (1)
 00000078  FFC3      BL          day?T  ; T=0x0001  (2)
 0000007A  B401      PUSH        {R0}
 0000007C  F7FF      BL          month?T  ; T=0x0001  (1)
 0000007E  FFC0      BL          month?T  ; T=0x0001  (2)
 00000080  B401      PUSH        {R0}
 00000082  F7FF      BL          year?T  ; T=0x0001  (1)
 00000084  FFBD      BL          year?T  ; T=0x0001  (2)
 00000086  1C03      MOV         R3,R0
 00000088  4800      LDR         R0,=??S_40 ; ??S_40
 0000008A  BC04      POP         {R2}
 0000008C  BC02      POP         {R1}
 0000008E  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000090  FFB7      BL          printf?T  ; T=0x0001  (2)
 00000092  B003      ADD         R13,#0xC
 1522:     while(1)
 00000094          L_426:
 1524:            value = readRFID(); // get ID of RFID card
 00000094  F7FF      BL          readRFID?T  ; T=0x0001  (1)
 00000096  FFB4      BL          readRFID?T  ; T=0x0001  (2)
 00000098  1C06      MOV         R6,R0 ; value
 0000009A  ---- Variable 'value' assigned to Register 'R6' ----
 1525:            ch = keypad(); // get pressing key of keypad
 0000009A  F7FF      BL          keypad?T  ; T=0x0001  (1)
 0000009C  FFB1      BL          keypad?T  ; T=0x0001  (2)
 0000009E  1C05      MOV         R5,R0 ; ch
 000000A0  ---- Variable 'ch' assigned to Register 'R5' ----
 1529:         if(value != 0) 
 000000A0  1C30      MOV         R0,R6 ; value
 000000A2  2800      CMP         R0,#0x0 ; value
 000000A4  D07C      BEQ         L_428  ; T=0x000001A0
 1532:             if(state == COMPARE)
 000000A6  4800      LDR         R0,=state ; state
 000000A8  6807      LDR         R7,[R0,#0x0] ; state
 000000AA  2F00      CMP         R7,#0x0
 000000AC  D126      BNE         L_429  ; T=0x000000FC
 1535:                 if(CheckRFIDCard(value) == 1) // check ID of RFID card (value) success (has ID of RFID card in system)
 000000AE  1C30      MOV         R0,R6 ; value
 000000B0  F7FF      BL          CheckRFIDCard?T  ; T=0x0001  (1)
 000000B2  FFA6      BL          CheckRFIDCard?T  ; T=0x0001  (2)
 000000B4  2801      CMP         R0,#0x1 ; CheckRFIDCard?T
 000000B6  D10E      BNE         L_430  ; T=0x000000D6
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 96  

 1537:                     inputMemTem(value); // save door open time by RFID card
 000000B8  1C30      MOV         R0,R6 ; value
 000000BA  F7FF      BL          inputMemTem?T  ; T=0x0001  (1)
 000000BC  FFA1      BL          inputMemTem?T  ; T=0x0001  (2)
 1538:                     savedata_mmc(3); // save door open time to sd/mmc
 000000BE  2003      MOV         R0,#0x3
 000000C0  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 000000C2  FF9E      BL          savedata_mmc?T  ; T=0x0001  (2)
 1539:                     printf("Door Open\n");
 000000C4  4800      LDR         R0,=??S_46 ; ??S_46
 000000C6  F7FF      BL          printf?T  ; T=0x0001  (1)
 000000C8  FF9B      BL          printf?T  ; T=0x0001  (2)
 1540:                     opendoor(); // open door
 000000CA  F7FF      BL          opendoor?T  ; T=0x0001  (1)
 000000CC  FF99      BL          opendoor?T  ; T=0x0001  (2)
 1541:                     printf("Door Close\n"); 
 000000CE  4800      LDR         R0,=??S_47 ; ??S_47
 000000D0  F7FF      BL          printf?T  ; T=0x0001  (1)
 000000D2  FF96      BL          printf?T  ; T=0x0001  (2)
 1542:                 }
 000000D4  E7DE      B           L_426  ; T=0x00000094
 000000D6          L_430:
 1545:                     printf("Wrong Card\n");
 000000D6  4800      LDR         R0,=??S_48 ; ??S_48
 000000D8  F7FF      BL          printf?T  ; T=0x0001  (1)
 000000DA  FF92      BL          printf?T  ; T=0x0001  (2)
 1546:                     loadpic_mmc(415); // load picture from sd/mmc
 000000DC  4800      LDR         R0,=0x19F
 000000DE  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 000000E0  FF8F      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1547:                     lcd_fill_picture(temppic); // show picture on lcd
 000000E2  4800      LDR         R0,=temppic ; temppic
 000000E4  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000000E6  FF8C      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1548:                     delay_ms(1000);
 000000E8  48FA      LDR         R0,=0x3E8
 000000EA  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 000000EC  FF89      BL          delay_ms?T  ; T=0x0001  (2)
 1549:                     loadpic_mmc(401); // load picture from sd/mmc
 000000EE  4800      LDR         R0,=0x191
 000000F0  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 000000F2  FF86      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1550:                     lcd_fill_picture(temppic); // show picture on lcd
 000000F4  4800      LDR         R0,=temppic ; temppic
 000000F6  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000000F8  FF83      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1552:             }
 000000FA  E7CB      B           L_426  ; T=0x00000094
 000000FC          L_429:
 1554:             else if(state == SAVE)
 000000FC  2F03      CMP         R7,#0x3
 000000FE  D127      BNE         L_433  ; T=0x00000150
 1557:                 if(inputMemRFID(value) == 1) // save ID of RFID card (value) success
 00000100  1C30      MOV         R0,R6 ; value
 00000102  F7FF      BL          inputMemRFID?T  ; T=0x0001  (1)
 00000104  FF7D      BL          inputMemRFID?T  ; T=0x0001  (2)
 00000106  2801      CMP         R0,#0x1 ; inputMemRFID?T
 00000108  D113      BNE         L_434  ; T=0x00000132
 1559:                     savedata_mmc(2); // save current ID of RFID card to sd/mmc
 0000010A  2002      MOV         R0,#0x2
 0000010C  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 0000010E  FF78      BL          savedata_mmc?T  ; T=0x0001  (2)
 1560:                     printf("ID card = %d\n",value);
 00000110  4800      LDR         R0,=??S_49 ; ??S_49
 00000112  1C31      MOV         R1,R6 ; value
 00000114  F7FF      BL          printf?T  ; T=0x0001  (1)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 97  

 00000116  FF74      BL          printf?T  ; T=0x0001  (2)
 1561:                     loadpic_mmc(416); // load picture from sd/mmc
 00000118  4868      LDR         R0,=0x1A0
 0000011A  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000011C  FF71      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1562:                     lcd_fill_picture(temppic); // show picture on lcd
 0000011E  4800      LDR         R0,=temppic ; temppic
 00000120  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000122  FF6E      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1563:                     printf("Save RFID card OK!\n");
 00000124  4800      LDR         R0,=??S_50 ; ??S_50
 00000126  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000128  FF6B      BL          printf?T  ; T=0x0001  (2)
 1564:                     delay_ms(1000);
 0000012A  48FA      LDR         R0,=0x3E8
 0000012C  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 0000012E  FF68      BL          delay_ms?T  ; T=0x0001  (2)
 1565:                 }
 00000130  E00B      B           L_435  ; T=0x0000014A
 00000132          L_434:
 1568:                     loadpic_mmc(417); // load picture from sd/mmc
 00000132  4800      LDR         R0,=0x1A1
 00000134  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000136  FF64      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1569:                     lcd_fill_picture(temppic); // show picture on lcd
 00000138  4800      LDR         R0,=temppic ; temppic
 0000013A  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000013C  FF61      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1570:                     printf("This card already has been save\n");
 0000013E  4800      LDR         R0,=??S_51 ; ??S_51
 00000140  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000142  FF5E      BL          printf?T  ; T=0x0001  (2)
 1571:                     delay_ms(1000);
 00000144  48FA      LDR         R0,=0x3E8
 00000146  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000148  FF5B      BL          delay_ms?T  ; T=0x0001  (2)
 1572:                 }
 0000014A          L_435:
 1573:                 setStateConfig(); // back to menu
 0000014A  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 0000014C  FF59      BL          setStateConfig?T  ; T=0x0001  (2)
 1574:             }
 0000014E  E7A1      B           L_426  ; T=0x00000094
 00000150          L_433:
 1576:             else if( state == DELETE)
 00000150  4800      LDR         R0,=state ; state
 00000152  6800      LDR         R0,[R0,#0x0] ; state
 00000154  2804      CMP         R0,#0x4
 00000156  D19D      BNE         L_426  ; T=0x00000094
 1579:                 if(deleteMemRFID(value) == 1) // delete ID of RFID card (value) success
 00000158  1C30      MOV         R0,R6 ; value
 0000015A  F7FF      BL          deleteMemRFID?T  ; T=0x0001  (1)
 0000015C  FF51      BL          deleteMemRFID?T  ; T=0x0001  (2)
 0000015E  2801      CMP         R0,#0x1 ; deleteMemRFID?T
 00000160  D10F      BNE         L_438  ; T=0x00000182
 1581:                     savedata_mmc(2); // save current ID of RFID card to sd/mmc
 00000162  2002      MOV         R0,#0x2
 00000164  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 00000166  FF4C      BL          savedata_mmc?T  ; T=0x0001  (2)
 1582:                     loadpic_mmc(420); // load picture from sd/mmc
 00000168  4869      LDR         R0,=0x1A4
 0000016A  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000016C  FF49      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1583:                     lcd_fill_picture(temppic); // show picture on lcd
 0000016E  4800      LDR         R0,=temppic ; temppic
 00000170  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 98  

 00000172  FF46      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1584:                     printf("Delete RFID card OK!\n");
 00000174  4800      LDR         R0,=??S_52 ; ??S_52
 00000176  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000178  FF43      BL          printf?T  ; T=0x0001  (2)
 1585:                     delay_ms(1000);
 0000017A  48FA      LDR         R0,=0x3E8
 0000017C  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 0000017E  FF40      BL          delay_ms?T  ; T=0x0001  (2)
 1586:                 }
 00000180  E00B      B           L_439  ; T=0x0000019A
 00000182          L_438:
 1589:                     loadpic_mmc(421); // load picture from sd/mmc
 00000182  4800      LDR         R0,=0x1A5
 00000184  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000186  FF3C      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1590:                     lcd_fill_picture(temppic); // show picture on lcd
 00000188  4800      LDR         R0,=temppic ; temppic
 0000018A  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000018C  FF39      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1591:                     printf("Not found\n");
 0000018E  4800      LDR         R0,=??S_53 ; ??S_53
 00000190  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000192  FF36      BL          printf?T  ; T=0x0001  (2)
 1592:                     delay_ms(1000);
 00000194  48FA      LDR         R0,=0x3E8
 00000196  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000198  FF33      BL          delay_ms?T  ; T=0x0001  (2)
 1593:                 }
 0000019A          L_439:
 1594:                 setStateConfig(); // back to menu
 0000019A  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 0000019C  FF31      BL          setStateConfig?T  ; T=0x0001  (2)
 1596:            }
 0000019E  E779      B           L_426  ; T=0x00000094
 000001A0          L_428:
 1599:            else if (state == CHANGEPASS)
 000001A0  4800      LDR         R0,=state ; state
 000001A2  6807      LDR         R7,[R0,#0x0] ; state
 000001A4  2F01      CMP         R7,#0x1
 000001A6  D119      BNE         L_441  ; T=0x000001DC
 1601:             loadpic_mmc(419); // load picture from sd/mmc
 000001A8  4800      LDR         R0,=0x1A3
 000001AA  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 000001AC  FF29      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1602:             lcd_fill_picture(temppic); // show picture on lcd
 000001AE  4800      LDR         R0,=temppic ; temppic
 000001B0  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000001B2  FF26      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1603:             receive_keypad(1); // receive data from keypad
 000001B4  2001      MOV         R0,#0x1
 000001B6  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 000001B8  FF23      BL          receive_keypad?T  ; T=0x0001  (2)
 1604:             change_password(); // change password
 000001BA  F7FF      BL          change_password?T  ; T=0x0001  (1)
 000001BC  FF21      BL          change_password?T  ; T=0x0001  (2)
 1605:             savedata_mmc(0); // save new password to sd/mmc
 000001BE  2000      MOV         R0,#0x0
 000001C0  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 000001C2  FF1E      BL          savedata_mmc?T  ; T=0x0001  (2)
 1606:             loadpic_mmc(416); // load picture from sd/mmc
 000001C4  4868      LDR         R0,=0x1A0
 000001C6  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 000001C8  FF1B      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1607:             lcd_fill_picture(temppic); // show picture on lcd
 000001CA  4800      LDR         R0,=temppic ; temppic
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 99  

 000001CC  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000001CE  FF18      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1608:             delay_ms(1000);
 000001D0  48FA      LDR         R0,=0x3E8
 000001D2  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 000001D4  FF15      BL          delay_ms?T  ; T=0x0001  (2)
 1609:             setStateConfig(); // back to menu
 000001D6  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000001D8  FF13      BL          setStateConfig?T  ; T=0x0001  (2)
 1610:         }
 000001DA  E75B      B           L_426  ; T=0x00000094
 000001DC          L_441:
 1612:         else if(state == SETTIME)
 000001DC  2F02      CMP         R7,#0x2
 000001DE  D10D      BNE         L_443  ; T=0x000001FC
 1614:              settime(); // receive and change date and time
 000001E0  F7FF      BL          settime?T  ; T=0x0001  (1)
 000001E2  FF0E      BL          settime?T  ; T=0x0001  (2)
 1615:              loadpic_mmc(416); // load picture from sd/mmc
 000001E4  4868      LDR         R0,=0x1A0
 000001E6  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 000001E8  FF0B      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1616:              lcd_fill_picture(temppic); // show picture on lcd
 000001EA  4800      LDR         R0,=temppic ; temppic
 000001EC  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 000001EE  FF08      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1617:              delay_ms(1000);
 000001F0  48FA      LDR         R0,=0x3E8
 000001F2  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 000001F4  FF05      BL          delay_ms?T  ; T=0x0001  (2)
 1618:              setStateConfig(); // back to menu
 000001F6  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000001F8  FF03      BL          setStateConfig?T  ; T=0x0001  (2)
 1619:         }
 000001FA  E74B      B           L_426  ; T=0x00000094
 000001FC          L_443:
 1621:         else if(state == ADDPASSWORD)
 000001FC  2F05      CMP         R7,#0x5
 000001FE  D12B      BNE         L_445  ; T=0x00000258
 1623:              if(receive_keypad(3) != 0) // receive data from keypad success
 00000200  2003      MOV         R0,#0x3
 00000202  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 00000204  FEFD      BL          receive_keypad?T  ; T=0x0001  (2)
 00000206  2800      CMP         R0,#0x0 ; receive_keypad?T
 00000208  D020      BEQ         L_446  ; T=0x0000024C
 1625:                 if(addPasswordUser() == 1) // add password user success
 0000020A  F7FF      BL          addPasswordUser?T  ; T=0x0001  (1)
 0000020C  FEF9      BL          addPasswordUser?T  ; T=0x0001  (2)
 0000020E  2801      CMP         R0,#0x1 ; addPasswordUser?T
 00000210  D10F      BNE         L_447  ; T=0x00000232
 1627:                     savedata_mmc(1); // save current password user to sd/mmc
 00000212  2001      MOV         R0,#0x1
 00000214  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 00000216  FEF4      BL          savedata_mmc?T  ; T=0x0001  (2)
 1628:                     loadpic_mmc(416); // load picture from sd/mmc
 00000218  4868      LDR         R0,=0x1A0
 0000021A  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 0000021C  FEF1      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1629:                     lcd_fill_picture(temppic); // show picture on lcd
 0000021E  4800      LDR         R0,=temppic ; temppic
 00000220  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000222  FEEE      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1630:                     printf("Save Password User OK!\n");
 00000224  4800      LDR         R0,=??S_54 ; ??S_54
 00000226  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000228  FEEB      BL          printf?T  ; T=0x0001  (2)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 100 

 1631:                     delay_ms(1000);
 0000022A  48FA      LDR         R0,=0x3E8
 0000022C  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 0000022E  FEE8      BL          delay_ms?T  ; T=0x0001  (2)
 1632:                 }
 00000230  E00F      B           L_449  ; T=0x00000252
 00000232          L_447:
 1635:                     loadpic_mmc(417); // load picture from sd/mmc
 00000232  4800      LDR         R0,=0x1A1
 00000234  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000236  FEE4      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1636:                     lcd_fill_picture(temppic); // show picture on lcd
 00000238  4800      LDR         R0,=temppic ; temppic
 0000023A  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000023C  FEE1      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1637:                     printf("This user already has been save\n");
 0000023E  4800      LDR         R0,=??S_55 ; ??S_55
 00000240  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000242  FEDE      BL          printf?T  ; T=0x0001  (2)
 1638:                     delay_ms(1000);
 00000244  48FA      LDR         R0,=0x3E8
 00000246  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000248  FEDB      BL          delay_ms?T  ; T=0x0001  (2)
 1640:              }
 0000024A  E002      B           L_449  ; T=0x00000252
 0000024C          L_446:
 1643:                 printf("\nSave Password User Fail!\n");
 0000024C  4800      LDR         R0,=??S_56 ; ??S_56
 0000024E  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000250  FED7      BL          printf?T  ; T=0x0001  (2)
 1644:              }
 00000252          L_449:
 1645:              setStateConfig(); // back to menu
 00000252  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 00000254  FED5      BL          setStateConfig?T  ; T=0x0001  (2)
 1646:           }
 00000256  E71D      B           L_426  ; T=0x00000094
 00000258          L_445:
 1649:         else if(state == DELETEPASSWORD)
 00000258  2F06      CMP         R7,#0x6
 0000025A  D12B      BNE         L_451  ; T=0x000002B4
 1651:              if(receive_keypad(3) != 0) // receive data from keypad success
 0000025C  2003      MOV         R0,#0x3
 0000025E  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 00000260  FECF      BL          receive_keypad?T  ; T=0x0001  (2)
 00000262  2800      CMP         R0,#0x0 ; receive_keypad?T
 00000264  D020      BEQ         L_452  ; T=0x000002A8
 1653:                 if(deletePasswordUser() == 1) // delete password user success
 00000266  F7FF      BL          deletePasswordUser?T  ; T=0x0001  (1)
 00000268  FECB      BL          deletePasswordUser?T  ; T=0x0001  (2)
 0000026A  2801      CMP         R0,#0x1 ; deletePasswordUser?T
 0000026C  D10F      BNE         L_453  ; T=0x0000028E
 1655:                     savedata_mmc(1); // save current password user to sd/mmc
 0000026E  2001      MOV         R0,#0x1
 00000270  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 00000272  FEC6      BL          savedata_mmc?T  ; T=0x0001  (2)
 1656:                     loadpic_mmc(420); // load picture from sd/mmc
 00000274  4869      LDR         R0,=0x1A4
 00000276  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000278  FEC3      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1657:                     lcd_fill_picture(temppic); // show picture on lcd
 0000027A  4800      LDR         R0,=temppic ; temppic
 0000027C  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000027E  FEC0      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1658:                     printf("Delete Password User OK!\n");
 00000280  4800      LDR         R0,=??S_57 ; ??S_57
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 101 

 00000282  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000284  FEBD      BL          printf?T  ; T=0x0001  (2)
 1659:                     delay_ms(1000);
 00000286  48FA      LDR         R0,=0x3E8
 00000288  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 0000028A  FEBA      BL          delay_ms?T  ; T=0x0001  (2)
 1660:                 }
 0000028C  E00F      B           L_455  ; T=0x000002AE
 0000028E          L_453:
 1663:                     loadpic_mmc(421); // load picture from sd/mmc
 0000028E  4800      LDR         R0,=0x1A5
 00000290  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000292  FEB6      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1664:                     lcd_fill_picture(temppic); // show picture on lcd
 00000294  4800      LDR         R0,=temppic ; temppic
 00000296  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 00000298  FEB3      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1665:                     printf("Not Found\n");
 0000029A  4800      LDR         R0,=??S_58 ; ??S_58
 0000029C  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000029E  FEB0      BL          printf?T  ; T=0x0001  (2)
 1666:                     delay_ms(1000);
 000002A0  48FA      LDR         R0,=0x3E8
 000002A2  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 000002A4  FEAD      BL          delay_ms?T  ; T=0x0001  (2)
 1668:              }
 000002A6  E002      B           L_455  ; T=0x000002AE
 000002A8          L_452:
 1671:                 printf("\nDelete Password User Fail!\n");
 000002A8  4800      LDR         R0,=??S_59 ; ??S_59
 000002AA  F7FF      BL          printf?T  ; T=0x0001  (1)
 000002AC  FEA9      BL          printf?T  ; T=0x0001  (2)
 1672:              }
 000002AE          L_455:
 1673:              setStateConfig(); // back to menu
 000002AE  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000002B0  FEA7      BL          setStateConfig?T  ; T=0x0001  (2)
 1674:           }
 000002B2  E6EF      B           L_426  ; T=0x00000094
 000002B4          L_451:
 1676:         else if((ch != '$')&&(ch != '*')&&(ch != '#')&&(state == COMPARE))
 000002B4  1C28      MOV         R0,R5 ; ch
 000002B6  0606      LSL         R6,R0,#0x18 ; ch
 000002B8  0E36      LSR         R6,R6,#0x18
 000002BA  2E24      CMP         R6,#0x24
 000002BC  D040      BEQ         L_457  ; T=0x00000340
 000002BE  2E2A      CMP         R6,#0x2A
 000002C0  D03E      BEQ         L_457  ; T=0x00000340
 000002C2  2E23      CMP         R6,#0x23
 000002C4  D03C      BEQ         L_457  ; T=0x00000340
 000002C6  2F00      CMP         R7,#0x0
 000002C8  D13A      BNE         L_457  ; T=0x00000340
 1678:                cleardata(); // clear tempkey
 000002CA  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 000002CC  FE99      BL          cleardata?T  ; T=0x0001  (2)
 1679:             tempkey[0] = ch;
 000002CE  1C29      MOV         R1,R5 ; ch
 000002D0  4800      LDR         R0,=tempkey ; tempkey
 000002D2  7001      STRB        R1,[R0,#0x0] ; tempkey
 1680:             printf("%c",ch);
 000002D4  1C31      MOV         R1,R6
 000002D6  4800      LDR         R0,=??S_5 ; ??S_5
 000002D8  F7FF      BL          printf?T  ; T=0x0001  (1)
 000002DA  FE92      BL          printf?T  ; T=0x0001  (2)
 1681:             if(receive_keypad(2) == 1) // receive data from keypad success
 000002DC  2002      MOV         R0,#0x2
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 102 

 000002DE  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 000002E0  FE8F      BL          receive_keypad?T  ; T=0x0001  (2)
 000002E2  2801      CMP         R0,#0x1 ; receive_keypad?T
 000002E4  D000      BNE         $+4
 000002E6  E6D5      B           L_426  ; T=0x00000094
 1683:                 printf("\n");
 000002EA  4800      LDR         R0,=??S_3 ; ??S_3
 000002EC  F7FF      BL          printf?T  ; T=0x0001  (1)
 000002EE  FE88      BL          printf?T  ; T=0x0001  (2)
 1684:                 if(check_password(1) == 1) // check password user success (has password user in system)
 000002F0  2001      MOV         R0,#0x1
 000002F2  F7FF      BL          check_password?T  ; T=0x0001  (1)
 000002F4  FE85      BL          check_password?T  ; T=0x0001  (2)
 000002F6  2801      CMP         R0,#0x1 ; check_password?T
 000002F8  D10C      BNE         L_459  ; T=0x00000314
 1686:                     addPasswordUserTime(); // save door open time by password user
 000002FA  F7FF      BL          addPasswordUserTime?T  ; T=0x0001  (1)
 000002FC  FE81      BL          addPasswordUserTime?T  ; T=0x0001  (2)
 1687:                     savedata_mmc(4);
 000002FE  2004      MOV         R0,#0x4
 00000300  F7FF      BL          savedata_mmc?T  ; T=0x0001  (1)
 00000302  FE7E      BL          savedata_mmc?T  ; T=0x0001  (2)
 1688:                     printf("Door Open\n");
 00000304  4800      LDR         R0,=??S_46 ; ??S_46
 00000306  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000308  FE7B      BL          printf?T  ; T=0x0001  (2)
 1689:                     opendoor();
 0000030A  F7FF      BL          opendoor?T  ; T=0x0001  (1)
 0000030C  FE79      BL          opendoor?T  ; T=0x0001  (2)
 1690:                     printf("Door Close\n"); 
 0000030E  4800      LDR         R0,=??S_47 ; ??S_47
 00000310  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000312  FE76      BL          printf?T  ; T=0x0001  (2)
 1691:                 }
 00000314  E6BE      B           L_426  ; T=0x00000094
 00000316          L_459:
 1694:                     printf("Wrong Password User\n");
 00000316  4800      LDR         R0,=??S_60 ; ??S_60
 00000318  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000031A  FE72      BL          printf?T  ; T=0x0001  (2)
 1695:                     delay_ms(1000);
 0000031C  48FA      LDR         R0,=0x3E8
 0000031E  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000320  FE6F      BL          delay_ms?T  ; T=0x0001  (2)
 1696:                     loadpic_mmc(415); // load picture from sd/mmc
 00000322  4800      LDR         R0,=0x19F
 00000324  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000326  FE6C      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1697:                     lcd_fill_picture(temppic); // show picture on lcd
 00000328  4800      LDR         R0,=temppic ; temppic
 0000032A  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000032C  FE69      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1698:                     delay_ms(1000);
 0000032E  48FA      LDR         R0,=0x3E8
 00000330  F7FF      BL          delay_ms?T  ; T=0x0001  (1)
 00000332  FE66      BL          delay_ms?T  ; T=0x0001  (2)
 1699:                     loadpic_mmc(401); // load picture from sd/mmc
 00000334  4800      LDR         R0,=0x191
 00000336  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000338  FE63      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1700:                     lcd_fill_picture(temppic); // show picture on lcd
 0000033A  4800      LDR         R0,=temppic ; temppic
 0000033C  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000033E  FE60      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1703:            }
 00000340  E6A8      B           L_426  ; T=0x00000094
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 103 

 00000342          L_457:
 1707:         else if((ch == '*' && state != SAVE && state !=DELETE)||(state == CONFIG))
 00000342  1C28      MOV         R0,R5 ; ch
 00000344  0600      LSL         R0,R0,#0x18 ; ch
 00000346  0E00      LSR         R0,R0,#0x18
 00000348  282A      CMP         R0,#0x2A
 0000034A  D106      BNE         L_464  ; T=0x0000035A
 0000034C  4800      LDR         R0,=state ; state
 0000034E  6800      LDR         R0,[R0,#0x0] ; state
 00000350  2803      CMP         R0,#0x3
 00000352  D002      BEQ         L_464  ; T=0x0000035A
 00000354  4800      LDR         R0,=state ; state
 00000356  6800      LDR         R0,[R0,#0x0] ; state
 00000358  2804      CMP         R0,#0x4
 0000035A  D103      BNE         L_463  ; T=0x00000364
 0000035C          L_464:
 0000035C  4800      LDR         R0,=state ; state
 0000035E  6800      LDR         R0,[R0,#0x0] ; state
 00000360  280A      CMP         R0,#0xA
 00000362  D000      BNE         $+4
 00000364  E14D      B           L_462  ; T=0x00000602
 00000368          L_463:
 1710:             if(state == CONFIG)
 00000368  4800      LDR         R0,=state ; state
 0000036A  6800      LDR         R0,[R0,#0x0] ; state
 0000036C  280A      CMP         R0,#0xA
 0000036E  D10C      BNE         L_465  ; T=0x0000038A
 1712:                 cleardata(); // clear tempkey
 00000370  F7FF      BL          cleardata?T  ; T=0x0001  (1)
 00000372  FE46      BL          cleardata?T  ; T=0x0001  (2)
 1713:                 for(j = 0;j < MAX_PASSWORD-1;j++) // auto enter password
 00000374  2400      MOV         R4,#0x0
 00000376  E004      B           L_468  ; T=0x00000382
 00000378          L_469:
 1714:                     tempkey[j] = password[j];
 00000378  1C21      MOV         R1,R4 ; j
 0000037A  4800      LDR         R0,=password ; password
 0000037C  5C40      LDRB        R0,[R0,R1]
 0000037E  1C22      MOV         R2,R4 ; j
 00000380  4800      LDR         R1,=tempkey ; tempkey
 00000382  5488      STRB        R0,[R1,R2]
 00000384  3401      ADD         R4,#0x1
 00000386          L_468:
 00000386  1C20      MOV         R0,R4 ; j
 00000388  2808      CMP         R0,#0x8 ; j
 0000038A  DBF5      BLT         L_469  ; T=0x00000378
 1715:             }
 0000038C  E009      B           L_471  ; T=0x000003A2
 0000038E          L_465:
 1719:                 printf("Enter Password :");
 0000038E  4800      LDR         R0,=??S_61 ; ??S_61
 00000390  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000392  FE36      BL          printf?T  ; T=0x0001  (2)
 1720:                 loadpic_mmc(402); // load picture from sd/mmc
 00000394  4800      LDR         R0,=0x192
 00000396  F7FF      BL          loadpic_mmc?T  ; T=0x0001  (1)
 00000398  FE33      BL          loadpic_mmc?T  ; T=0x0001  (2)
 1721:                 lcd_fill_picture(temppic); // show picture on lcd
 0000039A  4800      LDR         R0,=temppic ; temppic
 0000039C  F7FF      BL          lcd_fill_picture?T  ; T=0x0001  (1)
 0000039E  FE30      BL          lcd_fill_picture?T  ; T=0x0001  (2)
 1722:                 receive_keypad(5);  // receive data from keypad
 000003A0  2005      MOV         R0,#0x5
 000003A2  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 000003A4  FE2D      BL          receive_keypad?T  ; T=0x0001  (2)
 1723:             }
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 104 

 000003A6          L_471:
 1725:             if(check_password(2) == 1) // check password success (password right)
 000003A6  2002      MOV         R0,#0x2
 000003A8  F7FF      BL          check_password?T  ; T=0x0001  (1)
 000003AA  FE2A      BL          check_password?T  ; T=0x0001  (2)
 000003AC  2801      CMP         R0,#0x1 ; check_password?T
 000003AE  D000      BNE         $+4
 000003B0  E121      B           L_472  ; T=0x000005F6
 1728:                 if(state != CONFIG)
 000003B4  4800      LDR         R0,=state ; state
 000003B6  6800      LDR         R0,[R0,#0x0] ; state
 000003B8  280A      CMP         R0,#0xA
 000003BA  D0FE      BEQ         L_473  ; T=0x000003BA
 1730:                     setStateConfig();
 000003BC  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000003BE  FE20      BL          setStateConfig?T  ; T=0x0001  (2)
 1731:                 }
 000003C0          L_473:
 1733:                 if(receive_keypad(4) == 1) // receive menu success
 000003C0  2004      MOV         R0,#0x4
 000003C2  F7FF      BL          receive_keypad?T  ; T=0x0001  (1)
 000003C4  FE1D      BL          receive_keypad?T  ; T=0x0001  (2)
 000003C6  2801      CMP         R0,#0x1 ; receive_keypad?T
 000003C8  D000      BNE         $+4
 000003CA  E111      B           L_474  ; T=0x000005F0
 1735:                     if(tempkey[0] == '1' && tempkey[1] =='\0') // if select menu 1 then go to state change password
 000003CE  4800      LDR         R0,=tempkey ; tempkey
 000003D0  7805      LDRB        R5,[R0,#0x0] ; tempkey
 000003D2  1C2E      MOV         R6,R5
 000003D4  2E31      CMP         R6,#0x31
 000003D6  D102      BNE         L_475  ; T=0x000003DE
 000003D8  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 000003DA  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 000003DC  2800      CMP         R0,#0x0
 000003DE  D1FE      BNE         L_475  ; T=0x000003DE
 1737:                         setStateChangepass(); // go to state change password
 000003E0  F7FF      BL          setStateChangepass?T  ; T=0x0001  (1)
 000003E2  FE0E      BL          setStateChangepass?T  ; T=0x0001  (2)
 1738:                     }
 000003E4  E656      B           L_426  ; T=0x00000094
 000003E6          L_475:
 1739:                     else if(tempkey[0] == '2' && tempkey[1] =='\0') // if select menu 2 then go to state set time
 000003E6  2E32      CMP         R6,#0x32
 000003E8  D102      BNE         L_477  ; T=0x000003F0
 000003EA  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 000003EC  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 000003EE  2800      CMP         R0,#0x0
 000003F0  D1FE      BNE         L_477  ; T=0x000003F0
 1741:                         setStateSettime(); // go to state set time
 000003F2  F7FF      BL          setStateSettime?T  ; T=0x0001  (1)
 000003F4  FE05      BL          setStateSettime?T  ; T=0x0001  (2)
 1742:                     }
 000003F6  E64D      B           L_426  ; T=0x00000094
 000003F8          L_477:
 1743:                     else if(tempkey[0] == '3' && tempkey[1] =='\0') // if select menu 3 then go to state save
 000003F8  2E33      CMP         R6,#0x33
 000003FA  D10B      BNE         L_479  ; T=0x00000414
 000003FC  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 000003FE  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 00000400  2800      CMP         R0,#0x0
 00000402  D107      BNE         L_479  ; T=0x00000414
 1745:                         setStateSave(); // go to state save
 00000404  F7FF      BL          setStateSave?T  ; T=0x0001  (1)
 00000406  FDFC      BL          setStateSave?T  ; T=0x0001  (2)
 1746:                         timestate = (sec()+59)%60; // set time out
 00000408  F7FF      BL          sec?T  ; T=0x0001  (1)
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 105 

 0000040A  FDFA      BL          sec?T  ; T=0x0001  (2)
 0000040C  303B      ADD         R0,#0x3B
 0000040E  213C      MOV         R1,#0x3C
 00000410  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000412  FDF6      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000414  1C01      MOV         R1,R0
 00000416  4800      LDR         R0,=timestate ; timestate
 00000418  6001      STR         R1,[R0,#0x0] ; timestate
 1747:                     }
 0000041A  E63B      B           L_426  ; T=0x00000094
 0000041C          L_479:
 1748:                     else if(tempkey[0] == '4' && tempkey[1] =='\0') // if select menu 4 then go to state delete
 0000041C  2E34      CMP         R6,#0x34
 0000041E  D10B      BNE         L_481  ; T=0x00000438
 00000420  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 00000422  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 00000424  2800      CMP         R0,#0x0
 00000426  D107      BNE         L_481  ; T=0x00000438
 1750:                         setStateDelete(); // go to state delete
 00000428  F7FF      BL          setStateDelete?T  ; T=0x0001  (1)
 0000042A  FDEA      BL          setStateDelete?T  ; T=0x0001  (2)
 1751:                         timestate = (sec()+59)%60; // set time out
 0000042C  F7FF      BL          sec?T  ; T=0x0001  (1)
 0000042E  FDE8      BL          sec?T  ; T=0x0001  (2)
 00000430  303B      ADD         R0,#0x3B
 00000432  213C      MOV         R1,#0x3C
 00000434  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000436  FDE4      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000438  1C01      MOV         R1,R0
 0000043A  4800      LDR         R0,=timestate ; timestate
 0000043C  6001      STR         R1,[R0,#0x0] ; timestate
 1752:                     }
 0000043E  E629      B           L_426  ; T=0x00000094
 00000440          L_481:
 1753:                     else if(tempkey[0] == '5' && tempkey[1] =='\0') // if select menu 5 then go to state add password
 00000440  2E35      CMP         R6,#0x35
 00000442  D102      BNE         L_483  ; T=0x0000044A
 00000444  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 00000446  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 00000448  2800      CMP         R0,#0x0
 0000044A  D1FE      BNE         L_483  ; T=0x0000044A
 1755:                         setStateAddPassword(); // go to state add password                           
 0000044C  F7FF      BL          setStateAddPassword?T  ; T=0x0001  (1)
 0000044E  FDD8      BL          setStateAddPassword?T  ; T=0x0001  (2)
 1756:                     }       
 00000450  E620      B           L_426  ; T=0x00000094
 00000452          L_483:
 1757:                     else if(tempkey[0] == '6' && tempkey[1] =='\0') // if select menu 6 then go to state delete password
 00000452  2E36      CMP         R6,#0x36
 00000454  D102      BNE         L_485  ; T=0x0000045C
 00000456  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 00000458  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 0000045A  2800      CMP         R0,#0x0
 0000045C  D1FE      BNE         L_485  ; T=0x0000045C
 1759:                         setStateDeletePassword(); // go to state delete password
 0000045E  F7FF      BL          setStateDeletePassword?T  ; T=0x0001  (1)
 00000460  FDCF      BL          setStateDeletePassword?T  ; T=0x0001  (2)
 1760:                     }
 00000462  E617      B           L_426  ; T=0x00000094
 00000464          L_485:
 1761:                     else if(tempkey[0] == '7' && tempkey[1] =='\0') // if select menu 7 then show ID of RFID card
 00000464  2E37      CMP         R6,#0x37
 00000466  D123      BNE         L_487  ; T=0x000004B0
 00000468  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 0000046A  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 0000046C  2800      CMP         R0,#0x0
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 106 

 0000046E  D11F      BNE         L_487  ; T=0x000004B0
 1764:                         for(j = 0;j < MAX_RFID_CARD;j++) // show all ID of RFID card and save time
 00000470  2400      MOV         R4,#0x0
 00000472  E017      B           L_490  ; T=0x000004A4
 00000474          L_491:
 1766:                             if(memoryRFID[j].datarfid != 0)
 00000474  1C23      MOV         R3,R4 ; j
 00000476  201C      MOV         R0,#0x1C
 00000478  4343      MUL         R3,R0
 0000047A  4800      LDR         R0,=memoryRFID ; memoryRFID
 0000047C  58C1      LDR         R1,[R0,R3]
 0000047E  2900      CMP         R1,#0x0
 00000480  D00F      BEQ         L_488  ; T=0x000004A2
 1767:                                 printf("%d save at %d/%d/%d %d:%d:%d\n",memoryRFID[j].datarfid,memoryRFID[j].day
 00000482  4800      LDR         R0,=memoryRFID + 0x18 ; memoryRFID+24
 00000484  58C0      LDR         R0,[R0,R3]
 00000486  B401      PUSH        {R0}
 00000488  4800      LDR         R0,=memoryRFID + 0x14 ; memoryRFID+20
 0000048A  58C0      LDR         R0,[R0,R3]
 0000048C  B401      PUSH        {R0}
 0000048E  4800      LDR         R0,=memoryRFID + 0x10 ; memoryRFID+16
 00000490  58C0      LDR         R0,[R0,R3]
 00000492  B401      PUSH        {R0}
 00000494  4800      LDR         R0,=memoryRFID + 0xC ; memoryRFID+12
 00000496  58C0      LDR         R0,[R0,R3]
 00000498  B401      PUSH        {R0}
 0000049A  4800      LDR         R0,=memoryRFID + 0x4 ; memoryRFID+4
 0000049C  58C2      LDR         R2,[R0,R3]
 0000049E  4800      LDR         R0,=memoryRFID + 0x8 ; memoryRFID+8
 000004A0  58C3      LDR         R3,[R0,R3]
 000004A2  4800      LDR         R0,=??S_62 ; ??S_62
 000004A4  F7FF      BL          printf?T  ; T=0x0001  (1)
 000004A6  FDAC      BL          printf?T  ; T=0x0001  (2)
 000004A8  B004      ADD         R13,#0x10
 1770:                         }
 000004AA          L_488:
 000004AA  3401      ADD         R4,#0x1
 000004AC          L_490:
 000004AC  1C20      MOV         R0,R4 ; j
 000004AE  2832      CMP         R0,#0x32 ; j
 000004B0  DBE0      BLT         L_491  ; T=0x00000474
 1772:                         setStateConfig(); // back to menu
 000004B2  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000004B4  FDA5      BL          setStateConfig?T  ; T=0x0001  (2)
 1773:                     }
 000004B6  E5ED      B           L_426  ; T=0x00000094
 000004B8          L_487:
 1774:                     else if(tempkey[0] == '8' && tempkey[1] == '\0') // if select menu 8 then show password user
 000004B8  1C28      MOV         R0,R5
 000004BA  2838      CMP         R0,#0x38
 000004BC  D124      BNE         L_495  ; T=0x00000508
 000004BE  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 000004C0  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 000004C2  2800      CMP         R0,#0x0
 000004C4  D120      BNE         L_495  ; T=0x00000508
 1777:                         for(j = 0;j < MAX_NUMBER_USER;j++) // show all password user and save time
 000004C6  2400      MOV         R4,#0x0
 000004C8  E018      B           L_498  ; T=0x000004FC
 000004CA          L_499:
 1779:                             if(PassUser[j].passwordUser[0] != '\0')
 000004CA  1C20      MOV         R0,R4 ; j
 000004CC  0140      LSL         R0,R0,#0x5 ; j
 000004CE  4800      LDR         R1,=PassUser ; PassUser
 000004D0  5C09      LDRB        R1,[R1,R0]
 000004D2  2900      CMP         R1,#0x0
 000004D4  D011      BEQ         L_496  ; T=0x000004FA
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 107 

 1780:                                 printf("%s save at %d/%d/%d %d:%d:%d\n",PassUser[j].passwordUser,PassUser[j].day
 000004D6  4800      LDR         R1,=PassUser + 0x1C ; PassUser+28
 000004D8  5809      LDR         R1,[R1,R0]
 000004DA  B402      PUSH        {R1}
 000004DC  4800      LDR         R1,=PassUser + 0x18 ; PassUser+24
 000004DE  5809      LDR         R1,[R1,R0]
 000004E0  B402      PUSH        {R1}
 000004E2  4800      LDR         R1,=PassUser + 0x14 ; PassUser+20
 000004E4  5809      LDR         R1,[R1,R0]
 000004E6  B402      PUSH        {R1}
 000004E8  4800      LDR         R1,=PassUser + 0x10 ; PassUser+16
 000004EA  5809      LDR         R1,[R1,R0]
 000004EC  B402      PUSH        {R1}
 000004EE  4800      LDR         R1,=PassUser + 0x8 ; PassUser+8
 000004F0  580A      LDR         R2,[R1,R0]
 000004F2  4800      LDR         R1,=PassUser + 0xC ; PassUser+12
 000004F4  580B      LDR         R3,[R1,R0]
 000004F6  4800      LDR         R1,=PassUser ; PassUser
 000004F8  1809      ADD         R1,R0 ; PassUser
 000004FA  4800      LDR         R0,=??S_63 ; ??S_63
 000004FC  F7FF      BL          printf?T  ; T=0x0001  (1)
 000004FE  FD80      BL          printf?T  ; T=0x0001  (2)
 00000500  B004      ADD         R13,#0x10
 1783:                         }
 00000502          L_496:
 00000502  3401      ADD         R4,#0x1
 00000504          L_498:
 00000504  1C20      MOV         R0,R4 ; j
 00000506  2832      CMP         R0,#0x32 ; j
 00000508  DBDF      BLT         L_499  ; T=0x000004CA
 1784:                         setStateConfig(); // back to menu
 0000050A  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 0000050C  FD79      BL          setStateConfig?T  ; T=0x0001  (2)
 1785:                     }
 0000050E  E5C1      B           L_426  ; T=0x00000094
 00000510          L_495:
 1786:                     else if(tempkey[0] == '9' && tempkey[1] =='\0') // if select menu 9 then show door open time
 00000510  4800      LDR         R0,=tempkey ; tempkey
 00000512  7800      LDRB        R0,[R0,#0x0] ; tempkey
 00000514  2839      CMP         R0,#0x39
 00000516  D145      BNE         L_503  ; T=0x000005A4
 00000518  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 0000051A  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 0000051C  2800      CMP         R0,#0x0
 0000051E  D141      BNE         L_503  ; T=0x000005A4
 1789:                         for(j = 0;j < MAX_RFID_CARD;j++) // show door open time by RFID card 
 00000520  2400      MOV         R4,#0x0
 00000522  E017      B           L_506  ; T=0x00000554
 00000524          L_507:
 1791:                             if(memoryTem[j].datarfid != 0)
 00000524  1C23      MOV         R3,R4 ; j
 00000526  201C      MOV         R0,#0x1C
 00000528  4343      MUL         R3,R0
 0000052A  4800      LDR         R0,=memoryTem ; memoryTem
 0000052C  58C1      LDR         R1,[R0,R3]
 0000052E  2900      CMP         R1,#0x0
 00000530  D00F      BEQ         L_504  ; T=0x00000552
 1792:                                 printf("%d stamp at %d/%d/%d %d:%d:%d\n",memoryTem[j].datarfid,memoryTem[j].day
 00000532  4800      LDR         R0,=memoryTem + 0x18 ; memoryTem+24
 00000534  58C0      LDR         R0,[R0,R3]
 00000536  B401      PUSH        {R0}
 00000538  4800      LDR         R0,=memoryTem + 0x14 ; memoryTem+20
 0000053A  58C0      LDR         R0,[R0,R3]
 0000053C  B401      PUSH        {R0}
 0000053E  4800      LDR         R0,=memoryTem + 0x10 ; memoryTem+16
 00000540  58C0      LDR         R0,[R0,R3]
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 108 

 00000542  B401      PUSH        {R0}
 00000544  4800      LDR         R0,=memoryTem + 0xC ; memoryTem+12
 00000546  58C0      LDR         R0,[R0,R3]
 00000548  B401      PUSH        {R0}
 0000054A  4800      LDR         R0,=memoryTem + 0x4 ; memoryTem+4
 0000054C  58C2      LDR         R2,[R0,R3]
 0000054E  4800      LDR         R0,=memoryTem + 0x8 ; memoryTem+8
 00000550  58C3      LDR         R3,[R0,R3]
 00000552  4800      LDR         R0,=??S_64 ; ??S_64
 00000554  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000556  FD54      BL          printf?T  ; T=0x0001  (2)
 00000558  B004      ADD         R13,#0x10
 1795:                         }
 0000055A          L_504:
 0000055A  3401      ADD         R4,#0x1
 0000055C          L_506:
 0000055C  1C20      MOV         R0,R4 ; j
 0000055E  2832      CMP         R0,#0x32 ; j
 00000560  DBE0      BLT         L_507  ; T=0x00000524
 1797:                         for(j = 0;j < MAX_NUMBER_USER;j++) // show door open time by password user
 00000562  2400      MOV         R4,#0x0
 00000564  E018      B           L_512  ; T=0x00000598
 00000566          L_513:
 1799:                             if(PassUserTime[j].passwordUser[0] != '\0')
 00000566  1C20      MOV         R0,R4 ; j
 00000568  0140      LSL         R0,R0,#0x5 ; j
 0000056A  4800      LDR         R1,=PassUserTime ; PassUserTime
 0000056C  5C09      LDRB        R1,[R1,R0]
 0000056E  2900      CMP         R1,#0x0
 00000570  D011      BEQ         L_510  ; T=0x00000596
 1800:                                 printf("%s use at %d/%d/%d %d:%d:%d\n",PassUserTime[j].passwordUser,PassUserTime[j].day
 00000572  4800      LDR         R1,=PassUserTime + 0x1C ; PassUserTime+28
 00000574  5809      LDR         R1,[R1,R0]
 00000576  B402      PUSH        {R1}
 00000578  4800      LDR         R1,=PassUserTime + 0x18 ; PassUserTime+24
 0000057A  5809      LDR         R1,[R1,R0]
 0000057C  B402      PUSH        {R1}
 0000057E  4800      LDR         R1,=PassUserTime + 0x14 ; PassUserTime+20
 00000580  5809      LDR         R1,[R1,R0]
 00000582  B402      PUSH        {R1}
 00000584  4800      LDR         R1,=PassUserTime + 0x10 ; PassUserTime+16
 00000586  5809      LDR         R1,[R1,R0]
 00000588  B402      PUSH        {R1}
 0000058A  4800      LDR         R1,=PassUserTime + 0x8 ; PassUserTime+8
 0000058C  580A      LDR         R2,[R1,R0]
 0000058E  4800      LDR         R1,=PassUserTime + 0xC ; PassUserTime+12
 00000590  580B      LDR         R3,[R1,R0]
 00000592  4800      LDR         R1,=PassUserTime ; PassUserTime
 00000594  1809      ADD         R1,R0 ; PassUserTime
 00000596  4800      LDR         R0,=??S_65 ; ??S_65
 00000598  F7FF      BL          printf?T  ; T=0x0001  (1)
 0000059A  FD32      BL          printf?T  ; T=0x0001  (2)
 0000059C  B004      ADD         R13,#0x10
 1803:                         }
 0000059E          L_510:
 0000059E  3401      ADD         R4,#0x1
 000005A0          L_512:
 000005A0  1C20      MOV         R0,R4 ; j
 000005A2  2832      CMP         R0,#0x32 ; j
 000005A4  DBDF      BLT         L_513  ; T=0x00000566
 1805:                         setStateConfig(); // back to menu
 000005A6  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000005A8  FD2B      BL          setStateConfig?T  ; T=0x0001  (2)
 1806:                     }
 000005AA  E573      B           L_426  ; T=0x00000094
 000005AC          L_503:
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 109 

 1807:                     else if(tempkey[0] == '0' && tempkey[1] =='\0') // if select menu 0 then show date and time
 000005AC  4800      LDR         R0,=tempkey ; tempkey
 000005AE  7800      LDRB        R0,[R0,#0x0] ; tempkey
 000005B0  2830      CMP         R0,#0x30
 000005B2  D11A      BNE         L_517  ; T=0x000005EA
 000005B4  4800      LDR         R0,=tempkey + 0x1 ; tempkey+1
 000005B6  7800      LDRB        R0,[R0,#0x0] ; tempkey+1
 000005B8  2800      CMP         R0,#0x0
 000005BA  D116      BNE         L_517  ; T=0x000005EA
 1809:                         printf("\n%d/%d/%d\n%d:%d:%d\n",day(),month(),year(),hour(),minute(),sec());
 000005BC  F7FF      BL          sec?T  ; T=0x0001  (1)
 000005BE  FD20      BL          sec?T  ; T=0x0001  (2)
 000005C0  B401      PUSH        {R0}
 000005C2  F7FF      BL          minute?T  ; T=0x0001  (1)
 000005C4  FD1D      BL          minute?T  ; T=0x0001  (2)
 000005C6  B401      PUSH        {R0}
 000005C8  F7FF      BL          hour?T  ; T=0x0001  (1)
 000005CA  FD1A      BL          hour?T  ; T=0x0001  (2)
 000005CC  B401      PUSH        {R0}
 000005CE  F7FF      BL          day?T  ; T=0x0001  (1)
 000005D0  FD17      BL          day?T  ; T=0x0001  (2)
 000005D2  B401      PUSH        {R0}
 000005D4  F7FF      BL          month?T  ; T=0x0001  (1)
 000005D6  FD14      BL          month?T  ; T=0x0001  (2)
 000005D8  B401      PUSH        {R0}
 000005DA  F7FF      BL          year?T  ; T=0x0001  (1)
 000005DC  FD11      BL          year?T  ; T=0x0001  (2)
 000005DE  1C03      MOV         R3,R0
 000005E0  4800      LDR         R0,=??S_40 ; ??S_40
 000005E2  BC04      POP         {R2}
 000005E4  BC02      POP         {R1}
 000005E6  F7FF      BL          printf?T  ; T=0x0001  (1)
 000005E8  FD0B      BL          printf?T  ; T=0x0001  (2)
 000005EA  B003      ADD         R13,#0xC
 1810:                         setStateConfig(); // back to menu
 000005EC  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000005EE  FD08      BL          setStateConfig?T  ; T=0x0001  (2)
 1811:                     }
 000005F0  E550      B           L_426  ; T=0x00000094
 000005F2          L_517:
 1814:                         setStateConfig(); // back to menu
 000005F2  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 000005F4  FD05      BL          setStateConfig?T  ; T=0x0001  (2)
 1816:                 }
 000005F6  E54D      B           L_426  ; T=0x00000094
 000005F8          L_474:
 1819:                     setStateCompare(); // go to state compare   
 000005F8  F7FF      BL          setStateCompare?T  ; T=0x0001  (1)
 000005FA  FD02      BL          setStateCompare?T  ; T=0x0001  (2)
 1821:             }
 000005FC  E54A      B           L_426  ; T=0x00000094
 000005FE          L_472:
 1824:                 printf("Wrong Password\n");
 000005FE  4800      LDR         R0,=??S_66 ; ??S_66
 00000600  F7FF      BL          printf?T  ; T=0x0001  (1)
 00000602  FCFE      BL          printf?T  ; T=0x0001  (2)
 1825:                 setStateCompare(); // go to state compare   
 00000604  F7FF      BL          setStateCompare?T  ; T=0x0001  (1)
 00000606  FCFC      BL          setStateCompare?T  ; T=0x0001  (2)
 1827:         }
 00000608  E544      B           L_426  ; T=0x00000094
 0000060A          L_462:
 1829:         else if(state == SAVE || state == DELETE)
 0000060A  4800      LDR         R0,=state ; state
 0000060C  6800      LDR         R0,[R0,#0x0] ; state
 0000060E  2803      CMP         R0,#0x3
ARM COMPILER V2.32a,  main                                                                 18/05/08  02:36:12  PAGE 110 

 00000610  D000      BEQ         L_523  ; T=0x00000614
 00000612  4800      LDR         R0,=state ; state
 00000614  6800      LDR         R0,[R0,#0x0] ; state
 00000616  2804      CMP         R0,#0x4
 00000618  D000      BNE         $+4
 0000061A  E53B      B           L_426  ; T=0x00000094
 0000061E          L_523:
 1832:             if(sec()- timestate == 0)
 0000061E  F7FF      BL          sec?T  ; T=0x0001  (1)
 00000620  FCEF      BL          sec?T  ; T=0x0001  (2)
 00000622  4800      LDR         R1,=timestate ; timestate
 00000624  6809      LDR         R1,[R1,#0x0] ; timestate
 00000626  1A40      SUB         R0,R1
 00000628  2800      CMP         R0,#0x0
 0000062A  D000      BNE         $+4
 0000062C  E532      B           L_426  ; T=0x00000094
 1834:                 setStateConfig(); // back to menu
 00000630  F7FF      BL          setStateConfig?T  ; T=0x0001  (1)
 00000632  FCE6      BL          setStateConfig?T  ; T=0x0001  (2)
 1837:     }
 00000634  E52E      B           L_426  ; T=0x00000094
 00000636            ; SCOPE-END
 1838: }
 00000636  BC08      POP         {R3}
 00000638  4718      BX          R3
 0000063A          ENDP ; 'main'



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =      6563
  const size           =      1764
End of Module Information.


ARM COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
