ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 1   


ARM COMPILER V2.32a, COMPILATION OF MODULE mmc
OBJECT MODULE PLACED IN mmc.OBJ
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe mmc.c THUMB TABS(4) 

stmt  level    source

    1          #include <LPC213X.H> /* LPC214x definitions */
    2          
    3          #include "type.h"
    4          #include "mmc.h"
    5          #include "spi.h"
    6          
    7          BYTE MMCCmd[MMC_CMD_SIZE];
    8          BYTE MMCStatus = 0;
    9          
   10          /************************** MMC Init *********************************/
   11          /*
   12          * Initialises the MMC into SPI mode and sets block size(512), returns
   13          * 0 on success
   14          *
   15          */
   16          int mmc_init()
   17          {
   18   1          DWORD i;
   19   1          BYTE MMCRDData[10];
   20   1      
   21   1          MMCStatus = 0;
   22   1          
   23   1      
   24   1          PINSEL1 &= 0xFFFFFCFF;
   25   1          IODIR0 |= SPI_SEL; /* SSEL is output */
   26   1          IOSET0 |= SPI_SEL; /* set SSEL to high */
   27   1      
   28   1          /* initialise the MMC card into SPI mode by sending 80 clks on */
   29   1          for(i=0; i<10; i++)
   30   1          {
   31   2              MMCRDData[i] = 0xFF;
   32   2          }
   33   1          SPI_Send( MMCRDData, 10 );
   34   1          /* Use MMCRDData as a temporary buffer for SPI_Send() */
   35   1      
   36   1          IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
   37   1      
   38   1          /* send CMD0(RESET or GO_IDLE_STATE) command, all the arguments
   39   1          are 0x00 for the reset command, precalculated checksum */
   40   1          MMCCmd[0] = 0x40;
   41   1          MMCCmd[1] = 0x00;
   42   1          MMCCmd[2] = 0x00;
   43   1          MMCCmd[3] = 0x00;
   44   1          MMCCmd[4] = 0x00;
   45   1          MMCCmd[5] = 0x95;
   46   1          SPI_Send( MMCCmd, MMC_CMD_SIZE );
   47   1          /* if = 1 then there was a timeout waiting for 0x01 from the MMC */
   48   1          if( mmc_response(0x01) == 1 )
   49   1          {
   50   2              MMCStatus = IDLE_STATE_TIMEOUT;
   51   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
   52   2              return MMCStatus;
   53   2          } 
   54   1          
   55   1          /* Send some dummy clocks after GO_IDLE_STATE */
   56   1          IOSET0 |= SPI_SEL; /* set SPI SSEL */
   57   1          SPI_ReceiveByte();
   58   1          IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
   59   1          
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 2   

   60   1          /* must keep sending command until zero response ia back. */
   61   1          i = MAX_TIMEOUT;
   62   1          do
   63   1          {
   64   2              /* send mmc CMD1(SEND_OP_COND) to bring out of idle state */
   65   2              /* all the arguments are 0x00 for command one */
   66   2              MMCCmd[0] = 0x41;
   67   2              MMCCmd[1] = 0x00;
   68   2              MMCCmd[2] = 0x00;
   69   2              MMCCmd[3] = 0x00;
   70   2              MMCCmd[4] = 0x00;
   71   2              /* checksum is no longer required but we always send 0xFF */
   72   2              MMCCmd[5] = 0xFF;
   73   2              SPI_Send( MMCCmd, MMC_CMD_SIZE );
   74   2              i--;
   75   2          } while ( (mmc_response(0x00) != 0) && (i>0) );
   76   1          
   77   1          /* timeout waiting for 0x00 from the MMC */
   78   1          if ( i == 0 )
   79   1          {
   80   2              MMCStatus = OP_COND_TIMEOUT;
   81   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
   82   2              return MMCStatus;
   83   2          }
   84   1          
   85   1          /* Send some dummy clocks after SEND_OP_COND */
   86   1          IOSET0 |= SPI_SEL; /* set SPI SSEL */
   87   1          SPI_ReceiveByte();
   88   1          IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
   89   1          
   90   1          /* send MMC CMD16(SET_BLOCKLEN) to set the block length */
   91   1          MMCCmd[0] = 0x50;
   92   1          MMCCmd[1] = 0x00; /* 4 bytes from here is the block length */
   93   1                          /* LSB is first */
   94   1                          /* 00 00 00 10 set to 16 bytes */
   95   1                          /* 00 00 02 00 set to 512 bytes */
   96   1          MMCCmd[2] = 0x00;
   97   1          /* high block length bits - 512 bytes */
   98   1          MMCCmd[3] = 0x02;
   99   1          /* low block length bits */
  100   1          MMCCmd[4] = 0x00;
  101   1          /* checksum is no longer required but we always send 0xFF */
  102   1          MMCCmd[5] = 0xFF;
  103   1          SPI_Send( MMCCmd, MMC_CMD_SIZE );
  104   1      
  105   1          if( (mmc_response(0x00))==1 )
  106   1          {
  107   2              MMCStatus = SET_BLOCKLEN_TIMEOUT;
  108   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  109   2              return MMCStatus;
  110   2          }
  111   1      
  112   1          IOSET0 |= SPI_SEL; /* set SPI SSEL */
  113   1          SPI_ReceiveByte();
  114   1          return 0;
  115   1      }
  116          
  117          /************************** MMC Write Block ***************************/
  118          /* write a block of data based on the length that has been set
  119          * in the SET_BLOCKLEN command.
  120          * Send the WRITE_SINGLE_BLOCK command out first, check the
  121          * R1 response, then send the data start token(bit 0 to 0) followed by
  122          * the block of data. The test program sets the block length to 512
  123          * bytes. When the data write finishs, the response should come back
  124          * as 0xX5 bit 3 to 0 as 0101B, then another non-zero value indicating
  125          * that MMC card is in idle state again.
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 3   

  126          *
  127          */
  128          int mmc_write_block_int(WORD block_number,int MMCWRData[MMC_DATA_SIZE/4])
  129          {  
  130   1          DWORD blockaddress;
  131   1          BYTE Status;
  132   1      
  133   1          IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
  134   1      
  135   1          /* block size has been set in mmc_init() */
  136   1          blockaddress=(block_number<<9);
  137   1      
  138   1          /* send mmc CMD24(WRITE_SINGLE_BLOCK) to write the data to MMC card */
  139   1          MMCCmd[0] = 0x58;
  140   1          /* high block address bits, varh HIGH and LOW */
  141   1          MMCCmd[1] = blockaddress >> 24;
  142   1          MMCCmd[2] = blockaddress >> 16;
  143   1          /* low block address bits, varl HIGH and LOW */
  144   1          MMCCmd[3] = blockaddress >> 8;
  145   1          MMCCmd[4] = blockaddress;
  146   1          /* checksum is no longer required but we always send 0xFF */
  147   1          MMCCmd[5] = 0xFF;
  148   1          SPI_Send(MMCCmd, MMC_CMD_SIZE );
  149   1      
  150   1          /* if mmc_response returns 1 then we failed to get a 0x00 response */
  151   1          if((mmc_response(0x00))==1)
  152   1          {
  153   2              MMCStatus = WRITE_BLOCK_TIMEOUT;
  154   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  155   2              return MMCStatus;
  156   2          }
  157   1      
  158   1          /* Set bit 0 to 0 which indicates the beginning of the data block */
  159   1          MMCCmd[0] = 0xFE;
  160   1          SPI_Send( MMCCmd, 1 );
  161   1      
  162   1          /* send data, pattern as 0x00,0x01,0x02,0x03,0x04,0x05 ...*/
  163   1          SPI_Send( (char *) &MMCWRData[0], MMC_DATA_SIZE );
  164   1      
  165   1          /* Send dummy checksum */
  166   1          /* when the last check sum is sent, the response should come back
  167   1          immediately. So, check the SPI FIFO MISO and make sure the status
  168   1          return 0xX5, the bit 3 through 0 should be 0x05 */
  169   1          MMCCmd[0] = 0xFF;
  170   1          MMCCmd[1] = 0xFF;
  171   1          SPI_Send( MMCCmd, 2 );
  172   1          
  173   1          Status = SPI_ReceiveByte();
  174   1          if ( (Status & 0x0F) != 0x05 )
  175   1          {
  176   2              MMCStatus = WRITE_BLOCK_FAIL;
  177   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  178   2              return MMCStatus;
  179   2          }
  180   1      
  181   1          /* if the status is already zero, the write hasn't finished
  182   1          yet and card is busy */
  183   1          if(mmc_wait_for_write_finish()==1)
  184   1          {
  185   2              MMCStatus = WRITE_BLOCK_FAIL;
  186   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  187   2              return MMCStatus;
  188   2          }
  189   1      
  190   1          IOSET0 |= SPI_SEL; /* set SPI SSEL */
  191   1          SPI_ReceiveByte();
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 4   

  192   1          return 0;
  193   1      }
  194          
  195          int mmc_write_block_char(WORD block_number,char MMCWRData[MMC_DATA_SIZE])
  196          {  
  197   1          DWORD blockaddress;
  198   1          BYTE Status;
  199   1      
  200   1          IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
  201   1      
  202   1          /* block size has been set in mmc_init() */
  203   1          blockaddress=(block_number<<9);
  204   1      
  205   1          /* send mmc CMD24(WRITE_SINGLE_BLOCK) to write the data to MMC card */
  206   1          MMCCmd[0] = 0x58;
  207   1          /* high block address bits, varh HIGH and LOW */
  208   1          MMCCmd[1] = blockaddress >> 24;
  209   1          MMCCmd[2] = blockaddress >> 16;
  210   1          /* low block address bits, varl HIGH and LOW */
  211   1          MMCCmd[3] = blockaddress >> 8;
  212   1          MMCCmd[4] = blockaddress;
  213   1          /* checksum is no longer required but we always send 0xFF */
  214   1          MMCCmd[5] = 0xFF;
  215   1          SPI_Send(MMCCmd, MMC_CMD_SIZE );
  216   1      
  217   1          /* if mmc_response returns 1 then we failed to get a 0x00 response */
  218   1          if((mmc_response(0x00))==1)
  219   1          {
  220   2              MMCStatus = WRITE_BLOCK_TIMEOUT;
  221   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  222   2              return MMCStatus;
  223   2          }
  224   1      
  225   1          /* Set bit 0 to 0 which indicates the beginning of the data block */
  226   1          MMCCmd[0] = 0xFE;
  227   1          SPI_Send( MMCCmd, 1 );
  228   1      
  229   1          /* send data, pattern as 0x00,0x01,0x02,0x03,0x04,0x05 ...*/
  230   1          SPI_Send(&MMCWRData[0], MMC_DATA_SIZE );
  231   1      
  232   1          /* Send dummy checksum */
  233   1          /* when the last check sum is sent, the response should come back
  234   1          immediately. So, check the SPI FIFO MISO and make sure the status
  235   1          return 0xX5, the bit 3 through 0 should be 0x05 */
  236   1          MMCCmd[0] = 0xFF;
  237   1          MMCCmd[1] = 0xFF;
  238   1          SPI_Send( MMCCmd, 2 );
  239   1          
  240   1          Status = SPI_ReceiveByte();
  241   1          if ( (Status & 0x0F) != 0x05 )
  242   1          {
  243   2              MMCStatus = WRITE_BLOCK_FAIL;
  244   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  245   2              return MMCStatus;
  246   2          }
  247   1      
  248   1          /* if the status is already zero, the write hasn't finished
  249   1          yet and card is busy */
  250   1          if(mmc_wait_for_write_finish()==1)
  251   1          {
  252   2              MMCStatus = WRITE_BLOCK_FAIL;
  253   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  254   2              return MMCStatus;
  255   2          }
  256   1      
  257   1          IOSET0 |= SPI_SEL; /* set SPI SSEL */
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 5   

  258   1          SPI_ReceiveByte();
  259   1          return 0;
  260   1      }
  261          
  262          /************************** MMC Read Block ****************************/
  263          /*
  264          * Reads a 512 Byte block from the MMC
  265          * Send READ_SINGLE_BLOCK command first, wait for response come back
  266          * 0x00 followed by 0xFE. The call SPI_Receive() to read the data
  267          * block back followed by the checksum.
  268          *
  269          */
  270          int mmc_read_block_int(WORD block_number,int MMCRDData[MMC_DATA_SIZE/4])
  271          {
  272   1          WORD Checksum;
  273   1          DWORD blockaddress;
  274   1      
  275   1          IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
  276   1      
  277   1          blockaddress=(block_number<<9);
  278   1      
  279   1          /* send MMC CMD17(READ_SINGLE_BLOCK) to read the data from MMC card */
  280   1          MMCCmd[0] = 0x51;
  281   1          /* high block address bits, varh HIGH and LOW */
  282   1          MMCCmd[1] = blockaddress >> 24;
  283   1          MMCCmd[2] = blockaddress >> 16;
  284   1          /* low block address bits, varl HIGH and LOW */
  285   1          MMCCmd[3] = blockaddress >> 8;
  286   1          MMCCmd[4] = blockaddress;
  287   1          /* checksum is no longer required but we always send 0xFF */
  288   1          MMCCmd[5] = 0xFF;
  289   1          SPI_Send(MMCCmd, MMC_CMD_SIZE );
  290   1          /* if mmc_response returns 1 then we failed to get a 0x00 response */
  291   1          
  292   1          if((mmc_response(0x00))==1)
  293   1          {
  294   2              MMCStatus = READ_BLOCK_TIMEOUT;
  295   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  296   2              return MMCStatus;
  297   2          }
  298   1          
  299   1          /* wait for data token */
  300   1          if((mmc_response(0xFE))==1)
  301   1          {
  302   2              MMCStatus = READ_BLOCK_DATA_TOKEN_MISSING;
  303   2              IOSET0 |= SPI_SEL;
  304   2              return MMCStatus;
  305   2          }
  306   1      
  307   1          /* Get the block of data based on the length */
  308   1          SPI_Receive((char *) &MMCRDData[0], MMC_DATA_SIZE );
  309   1          /* CRC bytes that are not needed */
  310   1      
  311   1          Checksum = SPI_ReceiveByte();
  312   1          Checksum = Checksum << 0x08 | SPI_ReceiveByte();
  313   1      
  314   1          IOSET0 |= SPI_SEL; /* set SPI SSEL */
  315   1          SPI_ReceiveByte();
  316   1          return 0;
  317   1      }
  318          
  319          int mmc_read_block_char(WORD block_number,char MMCRDData[MMC_DATA_SIZE])
  320          {
  321   1          WORD Checksum;
  322   1          DWORD blockaddress;
  323   1      
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 6   

  324   1          IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
  325   1      
  326   1          blockaddress=(block_number<<9);
  327   1      
  328   1          /* send MMC CMD17(READ_SINGLE_BLOCK) to read the data from MMC card */
  329   1          MMCCmd[0] = 0x51;
  330   1          /* high block address bits, varh HIGH and LOW */
  331   1          MMCCmd[1] = blockaddress >> 24;
  332   1          MMCCmd[2] = blockaddress >> 16;
  333   1          /* low block address bits, varl HIGH and LOW */
  334   1          MMCCmd[3] = blockaddress >> 8;
  335   1          MMCCmd[4] = blockaddress;
  336   1          /* checksum is no longer required but we always send 0xFF */
  337   1          MMCCmd[5] = 0xFF;
  338   1          SPI_Send(MMCCmd, MMC_CMD_SIZE );
  339   1          /* if mmc_response returns 1 then we failed to get a 0x00 response */
  340   1          
  341   1          if((mmc_response(0x00))==1)
  342   1          {
  343   2              MMCStatus = READ_BLOCK_TIMEOUT;
  344   2              IOSET0 |= SPI_SEL; /* set SPI SSEL */
  345   2              return MMCStatus;
  346   2          }
  347   1          
  348   1          /* wait for data token */
  349   1          if((mmc_response(0xFE))==1)
  350   1          {
  351   2              MMCStatus = READ_BLOCK_DATA_TOKEN_MISSING;
  352   2              IOSET0 |= SPI_SEL;
  353   2              return MMCStatus;
  354   2          }
  355   1      
  356   1          /* Get the block of data based on the length */
  357   1          SPI_Receive(&MMCRDData[0], MMC_DATA_SIZE );
  358   1          /* CRC bytes that are not needed */
  359   1      
  360   1          Checksum = SPI_ReceiveByte();
  361   1          Checksum = Checksum << 0x08 | SPI_ReceiveByte();
  362   1      
  363   1          IOSET0 |= SPI_SEL; /* set SPI SSEL */
  364   1          SPI_ReceiveByte();
  365   1          return 0;
  366   1      }
  367          
  368          /***************** MMC get response *******************/
  369          /*
  370          * Repeatedly reads the MMC until we get the
  371          * response we want or timeout
  372          */
  373          int mmc_response( BYTE response)
  374          {
  375   1          DWORD count = 0xFFF;
  376   1          BYTE result;
  377   1      
  378   1          while( count > 0 )
  379   1          {
  380   2              result = SPI_ReceiveByte();
  381   2              if ( result == response )
  382   2              {
  383   3                  break;
  384   3              }
  385   2              count--;
  386   2          }
  387   1          if ( count == 0 )
  388   1              return 1; /* Failure, loop was exited due to timeout */
  389   1          else
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 7   

  390   1              return 0; /* Normal, loop was exited before timeout */
  391   1      }
  392          
  393          /***************** MMC wait for write finish *******************/
  394          /*
  395          * Repeatedly reads the MMC until we get a non-zero value (after
  396          * a zero value) indicating the write has finished and card is no
  397          * longer busy.
  398          *
  399          */
  400          int mmc_wait_for_write_finish( void )
  401          {
  402   1          DWORD count = 0xFFFF; /* The delay is set to maximum considering
  403   1          the longest data block length to handle */
  404   1      
  405   1          BYTE result = 0;
  406   1      
  407   1          while( (result == 0) && count )
  408   1          {
  409   2              result = SPI_ReceiveByte();
  410   2              count--;
  411   2          }
  412   1          if ( count == 0 )
  413   1              return 1; /* Failure, loop was exited due to timeout */
  414   1          else
  415   1              return 0; /* Normal, loop was exited before timeout */
  416   1      }
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 8   

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN CODE16 (SPI_Send?T)
 EXTERN CODE16 (SPI_Receive?T)
 EXTERN CODE16 (SPI_ReceiveByte?T)



*** PUBLICS:
 PUBLIC         mmc_init?T
 PUBLIC         mmc_response?T
 PUBLIC         mmc_read_block_int?T
 PUBLIC         mmc_read_block_char?T
 PUBLIC         mmc_write_block_int?T
 PUBLIC         mmc_write_block_char?T
 PUBLIC         mmc_wait_for_write_finish?T
 PUBLIC         MMCCmd
 PUBLIC         MMCStatus



*** DATA SEGMENT '?DT0?mmc':
 00000000          MMCCmd:
 00000000            DS          6
 00000006          MMCStatus:
 00000006           BEGIN_INIT
 00000006  00        DB          0x0
 00000007           END_INIT



*** CODE SEGMENT '?PR?mmc_init?T?mmc':
   16: int mmc_init()
 00000000  B510      PUSH        {R4,LR}
 00000002  B083      SUB         R13,#0xC
   17: {
 00000004            ; SCOPE-START
   21:     MMCStatus = 0;
 00000004  2100      MOV         R1,#0x0
 00000006  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000008  7001      STRB        R1,[R0,#0x0] ; MMCStatus
   24:     PINSEL1 &= 0xFFFFFCFF;
 0000000A  4AC0      LDR         R2,=0x300
 0000000C  4800      LDR         R0,=0xE002C004
 0000000E  6801      LDR         R1,[R0,#0x0]
 00000010  4391      BIC         R1,R2
 00000012  6001      STR         R1,[R0,#0x0]
   25:     IODIR0 |= SPI_SEL; /* SSEL is output */
 00000014  4800      LDR         R2,=0x100000
 00000016  4800      LDR         R0,=0xE0028008
 00000018  6801      LDR         R1,[R0,#0x0]
 0000001A  4311      ORR         R1,R2
 0000001C  6001      STR         R1,[R0,#0x0]
   26:     IOSET0 |= SPI_SEL; /* set SSEL to high */
 0000001E  4800      LDR         R2,=0x100000
 00000020  4800      LDR         R0,=0xE0028004
 00000022  6801      LDR         R1,[R0,#0x0]
 00000024  4311      ORR         R1,R2
 00000026  6001      STR         R1,[R0,#0x0]
   29:     for(i=0; i<10; i++)
 00000028  2400      MOV         R4,#0x0
 0000002A  ---- Variable 'i' assigned to Register 'R4' ----
 0000002A          L_4:
   31:         MMCRDData[i] = 0xFF;
 0000002A  20FF      MOV         R0,#0xFF
 0000002C  1C22      MOV         R2,R4 ; i
 0000002E  A900      ADD         R1,R13,#0x0
 00000030  5488      STRB        R0,[R1,R2]
   32:     }
 00000032  3401      ADD         R4,#0x1
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 9   

 00000034  1C20      MOV         R0,R4 ; i
 00000036  280A      CMP         R0,#0xA ; i
 00000038  D3F7      BCC         L_4  ; T=0x0000002A
   33:     SPI_Send( MMCRDData, 10 );
 0000003A  A800      ADD         R0,R13,#0x0
 0000003C  210A      MOV         R1,#0xA
 0000003E  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000040  FFDF      BL          SPI_Send?T  ; T=0x0001  (2)
   36:     IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
 00000042  4800      LDR         R2,=0x100000
 00000044  4800      LDR         R0,=0xE002800C
 00000046  6801      LDR         R1,[R0,#0x0]
 00000048  4311      ORR         R1,R2
 0000004A  6001      STR         R1,[R0,#0x0]
   40:     MMCCmd[0] = 0x40;
 0000004C  2140      MOV         R1,#0x40
 0000004E  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000050  7001      STRB        R1,[R0,#0x0] ; MMCCmd
   41:     MMCCmd[1] = 0x00;
 00000052  2100      MOV         R1,#0x0
 00000054  4800      LDR         R0,=MMCCmd + 0x1 ; MMCCmd+1
 00000056  7001      STRB        R1,[R0,#0x0] ; MMCCmd+1
   42:     MMCCmd[2] = 0x00;
 00000058  2100      MOV         R1,#0x0
 0000005A  4800      LDR         R0,=MMCCmd + 0x2 ; MMCCmd+2
 0000005C  7001      STRB        R1,[R0,#0x0] ; MMCCmd+2
   43:     MMCCmd[3] = 0x00;
 0000005E  2100      MOV         R1,#0x0
 00000060  4800      LDR         R0,=MMCCmd + 0x3 ; MMCCmd+3
 00000062  7001      STRB        R1,[R0,#0x0] ; MMCCmd+3
   44:     MMCCmd[4] = 0x00;
 00000064  2100      MOV         R1,#0x0
 00000066  4800      LDR         R0,=MMCCmd + 0x4 ; MMCCmd+4
 00000068  7001      STRB        R1,[R0,#0x0] ; MMCCmd+4
   45:     MMCCmd[5] = 0x95;
 0000006A  2195      MOV         R1,#0x95
 0000006C  4800      LDR         R0,=MMCCmd + 0x5 ; MMCCmd+5
 0000006E  7001      STRB        R1,[R0,#0x0] ; MMCCmd+5
   46:     SPI_Send( MMCCmd, MMC_CMD_SIZE );
 00000070  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000072  2106      MOV         R1,#0x6
 00000074  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000076  FFC4      BL          SPI_Send?T  ; T=0x0001  (2)
   48:     if( mmc_response(0x01) == 1 )
 00000078  2001      MOV         R0,#0x1
 0000007A  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 0000007C  FFC1      BL          mmc_response?T  ; T=0x0001  (2)
 0000007E  2801      CMP         R0,#0x1 ; mmc_response?T
 00000080  D10A      BNE         L_6  ; T=0x00000098
   50:         MMCStatus = IDLE_STATE_TIMEOUT;
 00000082  2101      MOV         R1,#0x1
 00000084  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000086  7001      STRB        R1,[R0,#0x0] ; MMCStatus
   51:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 00000088  4800      LDR         R2,=0x100000
 0000008A  4800      LDR         R0,=0xE0028004
 0000008C  6801      LDR         R1,[R0,#0x0]
 0000008E  4311      ORR         R1,R2
 00000090  6001      STR         R1,[R0,#0x0]
   52:         return MMCStatus;
 00000092  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000094  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 00000096  E073      B           L_7  ; T=0x00000180
   53:     } 
 00000098          L_6:
   56:     IOSET0 |= SPI_SEL; /* set SPI SSEL */
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 10  

 00000098  4800      LDR         R2,=0x100000
 0000009A  4800      LDR         R0,=0xE0028004
 0000009C  6801      LDR         R1,[R0,#0x0]
 0000009E  4311      ORR         R1,R2
 000000A0  6001      STR         R1,[R0,#0x0]
   57:     SPI_ReceiveByte();
 000000A2  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 000000A4  FFAD      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
   58:     IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
 000000A6  4800      LDR         R2,=0x100000
 000000A8  4800      LDR         R0,=0xE002800C
 000000AA  6801      LDR         R1,[R0,#0x0]
 000000AC  4311      ORR         R1,R2
 000000AE  6001      STR         R1,[R0,#0x0]
   61:     i = MAX_TIMEOUT;
 000000B0  24FF      MOV         R4,#0xFF
   62:     do
 000000B2          L_8:
   66:         MMCCmd[0] = 0x41;
 000000B2  2141      MOV         R1,#0x41
 000000B4  4800      LDR         R0,=MMCCmd ; MMCCmd
 000000B6  7001      STRB        R1,[R0,#0x0] ; MMCCmd
   67:         MMCCmd[1] = 0x00;
 000000B8  2100      MOV         R1,#0x0
 000000BA  4800      LDR         R0,=MMCCmd + 0x1 ; MMCCmd+1
 000000BC  7001      STRB        R1,[R0,#0x0] ; MMCCmd+1
   68:         MMCCmd[2] = 0x00;
 000000BE  2100      MOV         R1,#0x0
 000000C0  4800      LDR         R0,=MMCCmd + 0x2 ; MMCCmd+2
 000000C2  7001      STRB        R1,[R0,#0x0] ; MMCCmd+2
   69:         MMCCmd[3] = 0x00;
 000000C4  2100      MOV         R1,#0x0
 000000C6  4800      LDR         R0,=MMCCmd + 0x3 ; MMCCmd+3
 000000C8  7001      STRB        R1,[R0,#0x0] ; MMCCmd+3
   70:         MMCCmd[4] = 0x00;
 000000CA  2100      MOV         R1,#0x0
 000000CC  4800      LDR         R0,=MMCCmd + 0x4 ; MMCCmd+4
 000000CE  7001      STRB        R1,[R0,#0x0] ; MMCCmd+4
   72:         MMCCmd[5] = 0xFF;
 000000D0  21FF      MOV         R1,#0xFF
 000000D2  4800      LDR         R0,=MMCCmd + 0x5 ; MMCCmd+5
 000000D4  7001      STRB        R1,[R0,#0x0] ; MMCCmd+5
   73:         SPI_Send( MMCCmd, MMC_CMD_SIZE );
 000000D6  4800      LDR         R0,=MMCCmd ; MMCCmd
 000000D8  2106      MOV         R1,#0x6
 000000DA  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 000000DC  FF91      BL          SPI_Send?T  ; T=0x0001  (2)
   74:         i--;
 000000DE  3C01      SUB         R4,#0x1
   75:     } while ( (mmc_response(0x00) != 0) && (i>0) );
 000000E0  2000      MOV         R0,#0x0
 000000E2  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 000000E4  FF8D      BL          mmc_response?T  ; T=0x0001  (2)
 000000E6  2800      CMP         R0,#0x0 ; mmc_response?T
 000000E8  D002      BEQ         L_11  ; T=0x000000F0
 000000EA  1C20      MOV         R0,R4 ; i
 000000EC  2800      CMP         R0,#0x0 ; i
 000000EE  D8E0      BHI         L_8  ; T=0x000000B2
 000000F0          L_11:
   78:     if ( i == 0 )
 000000F0  1C20      MOV         R0,R4 ; i
 000000F2  2800      CMP         R0,#0x0 ; i
 000000F4  D10A      BNE         L_13  ; T=0x0000010C
   80:         MMCStatus = OP_COND_TIMEOUT;
 000000F6  2102      MOV         R1,#0x2
 000000F8  4800      LDR         R0,=MMCStatus ; MMCStatus
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 11  

 000000FA  7001      STRB        R1,[R0,#0x0] ; MMCStatus
   81:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000FC  4800      LDR         R2,=0x100000
 000000FE  4800      LDR         R0,=0xE0028004
 00000100  6801      LDR         R1,[R0,#0x0]
 00000102  4311      ORR         R1,R2
 00000104  6001      STR         R1,[R0,#0x0]
   82:         return MMCStatus;
 00000106  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000108  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 0000010A  E039      B           L_7  ; T=0x00000180
   83:     }
 0000010C          L_13:
   86:     IOSET0 |= SPI_SEL; /* set SPI SSEL */
 0000010C  4800      LDR         R2,=0x100000
 0000010E  4800      LDR         R0,=0xE0028004
 00000110  6801      LDR         R1,[R0,#0x0]
 00000112  4311      ORR         R1,R2
 00000114  6001      STR         R1,[R0,#0x0]
   87:     SPI_ReceiveByte();
 00000116  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 00000118  FF73      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
   88:     IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
 0000011A  4800      LDR         R2,=0x100000
 0000011C  4800      LDR         R0,=0xE002800C
 0000011E  6801      LDR         R1,[R0,#0x0]
 00000120  4311      ORR         R1,R2
 00000122  6001      STR         R1,[R0,#0x0]
   91:     MMCCmd[0] = 0x50;
 00000124  2150      MOV         R1,#0x50
 00000126  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000128  7001      STRB        R1,[R0,#0x0] ; MMCCmd
   92:     MMCCmd[1] = 0x00; /* 4 bytes from here is the block length */
 0000012A  2100      MOV         R1,#0x0
 0000012C  4800      LDR         R0,=MMCCmd + 0x1 ; MMCCmd+1
 0000012E  7001      STRB        R1,[R0,#0x0] ; MMCCmd+1
   96:     MMCCmd[2] = 0x00;
 00000130  2100      MOV         R1,#0x0
 00000132  4800      LDR         R0,=MMCCmd + 0x2 ; MMCCmd+2
 00000134  7001      STRB        R1,[R0,#0x0] ; MMCCmd+2
   98:     MMCCmd[3] = 0x02;
 00000136  2102      MOV         R1,#0x2
 00000138  4800      LDR         R0,=MMCCmd + 0x3 ; MMCCmd+3
 0000013A  7001      STRB        R1,[R0,#0x0] ; MMCCmd+3
  100:     MMCCmd[4] = 0x00;
 0000013C  2100      MOV         R1,#0x0
 0000013E  4800      LDR         R0,=MMCCmd + 0x4 ; MMCCmd+4
 00000140  7001      STRB        R1,[R0,#0x0] ; MMCCmd+4
  102:     MMCCmd[5] = 0xFF;
 00000142  21FF      MOV         R1,#0xFF
 00000144  4800      LDR         R0,=MMCCmd + 0x5 ; MMCCmd+5
 00000146  7001      STRB        R1,[R0,#0x0] ; MMCCmd+5
  103:     SPI_Send( MMCCmd, MMC_CMD_SIZE );
 00000148  4800      LDR         R0,=MMCCmd ; MMCCmd
 0000014A  2106      MOV         R1,#0x6
 0000014C  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 0000014E  FF58      BL          SPI_Send?T  ; T=0x0001  (2)
  105:     if( (mmc_response(0x00))==1 )
 00000150  2000      MOV         R0,#0x0
 00000152  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 00000154  FF55      BL          mmc_response?T  ; T=0x0001  (2)
 00000156  2801      CMP         R0,#0x1 ; mmc_response?T
 00000158  D10A      BNE         L_14  ; T=0x00000170
  107:         MMCStatus = SET_BLOCKLEN_TIMEOUT;
 0000015A  2103      MOV         R1,#0x3
 0000015C  4800      LDR         R0,=MMCStatus ; MMCStatus
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 12  

 0000015E  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  108:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 00000160  4800      LDR         R2,=0x100000
 00000162  4800      LDR         R0,=0xE0028004
 00000164  6801      LDR         R1,[R0,#0x0]
 00000166  4311      ORR         R1,R2
 00000168  6001      STR         R1,[R0,#0x0]
  109:         return MMCStatus;
 0000016A  4800      LDR         R0,=MMCStatus ; MMCStatus
 0000016C  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 0000016E  E007      B           L_7  ; T=0x00000180
  110:     }
 00000170          L_14:
  112:     IOSET0 |= SPI_SEL; /* set SPI SSEL */
 00000170  4800      LDR         R2,=0x100000
 00000172  4800      LDR         R0,=0xE0028004
 00000174  6801      LDR         R1,[R0,#0x0]
 00000176  4311      ORR         R1,R2
 00000178  6001      STR         R1,[R0,#0x0]
  113:     SPI_ReceiveByte();
 0000017A  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 0000017C  FF41      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
  114:     return 0;
 0000017E  2000      MOV         R0,#0x0
 00000180            ; SCOPE-END
  115: }
 00000180          L_7:
 00000180  B003      ADD         R13,#0xC
 00000182  BC10      POP         {R4}
 00000184  BC08      POP         {R3}
 00000186  4718      BX          R3
 00000188          ENDP ; 'mmc_init?T'


*** CODE SEGMENT '?PR?mmc_write_block_int?T?mmc':
  128: int mmc_write_block_int(WORD block_number,int MMCWRData[MMC_DATA_SIZE/4])
 00000000  B510      PUSH        {R4,LR}
 00000002  1C0C      MOV         R4,R1 ; MMCWRData
 00000004  ---- Variable 'MMCWRData' assigned to Register 'R4' ----
 00000004  1C01      MOV         R1,R0 ; block_number
 00000006  ---- Variable 'block_number' assigned to Register 'R1' ----
  129: {  
 00000006            ; SCOPE-START
  133:     IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
 00000006  4800      LDR         R3,=0x100000
 00000008  4800      LDR         R0,=0xE002800C
 0000000A  6802      LDR         R2,[R0,#0x0]
 0000000C  431A      ORR         R2,R3
 0000000E  6002      STR         R2,[R0,#0x0]
  136:     blockaddress=(block_number<<9);
 00000010  1C08      MOV         R0,R1 ; block_number
 00000012  0400      LSL         R0,R0,#0x10 ; block_number
 00000014  0C00      LSR         R0,R0,#0x10
 00000016  0240      LSL         R0,R0,#0x9
 00000018  ---- Variable 'blockaddress' assigned to Register 'R0' ----
  139:     MMCCmd[0] = 0x58;
 00000018  2258      MOV         R2,#0x58
 0000001A  4800      LDR         R1,=MMCCmd ; MMCCmd
 0000001C  700A      STRB        R2,[R1,#0x0] ; MMCCmd
  141:     MMCCmd[1] = blockaddress >> 24;
 0000001E  1C02      MOV         R2,R0 ; blockaddress
 00000020  0E12      LSR         R2,R2,#0x18 ; blockaddress
 00000022  4800      LDR         R1,=MMCCmd + 0x1 ; MMCCmd+1
 00000024  700A      STRB        R2,[R1,#0x0] ; MMCCmd+1
  142:     MMCCmd[2] = blockaddress >> 16;
 00000026  1C02      MOV         R2,R0 ; blockaddress
 00000028  0C12      LSR         R2,R2,#0x10 ; blockaddress
 0000002A  4800      LDR         R1,=MMCCmd + 0x2 ; MMCCmd+2
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 13  

 0000002C  700A      STRB        R2,[R1,#0x0] ; MMCCmd+2
  144:     MMCCmd[3] = blockaddress >> 8;
 0000002E  1C02      MOV         R2,R0 ; blockaddress
 00000030  0A12      LSR         R2,R2,#0x8 ; blockaddress
 00000032  4800      LDR         R1,=MMCCmd + 0x3 ; MMCCmd+3
 00000034  700A      STRB        R2,[R1,#0x0] ; MMCCmd+3
  145:     MMCCmd[4] = blockaddress;
 00000036  1C01      MOV         R1,R0 ; blockaddress
 00000038  4800      LDR         R0,=MMCCmd + 0x4 ; MMCCmd+4
 0000003A  7001      STRB        R1,[R0,#0x0] ; MMCCmd+4
  147:     MMCCmd[5] = 0xFF;
 0000003C  21FF      MOV         R1,#0xFF
 0000003E  4800      LDR         R0,=MMCCmd + 0x5 ; MMCCmd+5
 00000040  7001      STRB        R1,[R0,#0x0] ; MMCCmd+5
  148:     SPI_Send(MMCCmd, MMC_CMD_SIZE );
 00000042  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000044  2106      MOV         R1,#0x6
 00000046  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000048  FFDB      BL          SPI_Send?T  ; T=0x0001  (2)
  151:     if((mmc_response(0x00))==1)
 0000004A  2000      MOV         R0,#0x0
 0000004C  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 0000004E  FFD8      BL          mmc_response?T  ; T=0x0001  (2)
 00000050  2801      CMP         R0,#0x1 ; mmc_response?T
 00000052  D10A      BNE         L_15  ; T=0x0000006A
  153:         MMCStatus = WRITE_BLOCK_TIMEOUT;
 00000054  2104      MOV         R1,#0x4
 00000056  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000058  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  154:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 0000005A  4800      LDR         R2,=0x100000
 0000005C  4800      LDR         R0,=0xE0028004
 0000005E  6801      LDR         R1,[R0,#0x0]
 00000060  4311      ORR         R1,R2
 00000062  6001      STR         R1,[R0,#0x0]
  155:         return MMCStatus;
 00000064  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000066  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 00000068  E040      B           L_16  ; T=0x000000EC
  156:     }
 0000006A          L_15:
  159:     MMCCmd[0] = 0xFE;
 0000006A  21FE      MOV         R1,#0xFE
 0000006C  4800      LDR         R0,=MMCCmd ; MMCCmd
 0000006E  7001      STRB        R1,[R0,#0x0] ; MMCCmd
  160:     SPI_Send( MMCCmd, 1 );
 00000070  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000072  2101      MOV         R1,#0x1
 00000074  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000076  FFC4      BL          SPI_Send?T  ; T=0x0001  (2)
  163:     SPI_Send( (char *) &MMCWRData[0], MMC_DATA_SIZE );
 00000078  1C20      MOV         R0,R4 ; MMCWRData
 0000007A  4980      LDR         R1,=0x200
 0000007C  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 0000007E  FFC0      BL          SPI_Send?T  ; T=0x0001  (2)
  169:     MMCCmd[0] = 0xFF;
 00000080  21FF      MOV         R1,#0xFF
 00000082  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000084  7001      STRB        R1,[R0,#0x0] ; MMCCmd
  170:     MMCCmd[1] = 0xFF;
 00000086  21FF      MOV         R1,#0xFF
 00000088  4800      LDR         R0,=MMCCmd + 0x1 ; MMCCmd+1
 0000008A  7001      STRB        R1,[R0,#0x0] ; MMCCmd+1
  171:     SPI_Send( MMCCmd, 2 );
 0000008C  4800      LDR         R0,=MMCCmd ; MMCCmd
 0000008E  2102      MOV         R1,#0x2
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 14  

 00000090  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000092  FFB6      BL          SPI_Send?T  ; T=0x0001  (2)
  173:     Status = SPI_ReceiveByte();
 00000094  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 00000096  FFB4      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 00000098  1C01      MOV         R1,R0 ; Status
 0000009A  ---- Variable 'Status' assigned to Register 'R1' ----
  174:     if ( (Status & 0x0F) != 0x05 )
 0000009A  1C08      MOV         R0,R1 ; Status
 0000009C  0600      LSL         R0,R0,#0x18 ; Status
 0000009E  0E00      LSR         R0,R0,#0x18
 000000A0  210F      MOV         R1,#0xF
 000000A2  4008      AND         R0,R1
 000000A4  2805      CMP         R0,#0x5
 000000A6  D00A      BEQ         L_17  ; T=0x000000BE
  176:         MMCStatus = WRITE_BLOCK_FAIL;
 000000A8  2105      MOV         R1,#0x5
 000000AA  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000AC  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  177:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000AE  4800      LDR         R2,=0x100000
 000000B0  4800      LDR         R0,=0xE0028004
 000000B2  6801      LDR         R1,[R0,#0x0]
 000000B4  4311      ORR         R1,R2
 000000B6  6001      STR         R1,[R0,#0x0]
  178:         return MMCStatus;
 000000B8  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000BA  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 000000BC  E016      B           L_16  ; T=0x000000EC
  179:     }
 000000BE          L_17:
  183:     if(mmc_wait_for_write_finish()==1)
 000000BE  F7FF      BL          mmc_wait_for_write_finish?T  ; T=0x0001  (1)
 000000C0  FF9F      BL          mmc_wait_for_write_finish?T  ; T=0x0001  (2)
 000000C2  2801      CMP         R0,#0x1 ; mmc_wait_for_write_finish?T
 000000C4  D10A      BNE         L_18  ; T=0x000000DC
  185:         MMCStatus = WRITE_BLOCK_FAIL;
 000000C6  2105      MOV         R1,#0x5
 000000C8  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000CA  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  186:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000CC  4800      LDR         R2,=0x100000
 000000CE  4800      LDR         R0,=0xE0028004
 000000D0  6801      LDR         R1,[R0,#0x0]
 000000D2  4311      ORR         R1,R2
 000000D4  6001      STR         R1,[R0,#0x0]
  187:         return MMCStatus;
 000000D6  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000D8  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 000000DA  E007      B           L_16  ; T=0x000000EC
  188:     }
 000000DC          L_18:
  190:     IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000DC  4800      LDR         R2,=0x100000
 000000DE  4800      LDR         R0,=0xE0028004
 000000E0  6801      LDR         R1,[R0,#0x0]
 000000E2  4311      ORR         R1,R2
 000000E4  6001      STR         R1,[R0,#0x0]
  191:     SPI_ReceiveByte();
 000000E6  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 000000E8  FF8B      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
  192:     return 0;
 000000EA  2000      MOV         R0,#0x0
 000000EC            ; SCOPE-END
  193: }
 000000EC          L_16:
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 15  

 000000EC  BC10      POP         {R4}
 000000EE  BC08      POP         {R3}
 000000F0  4718      BX          R3
 000000F2          ENDP ; 'mmc_write_block_int?T'


*** CODE SEGMENT '?PR?mmc_write_block_char?T?mmc':
  195: int mmc_write_block_char(WORD block_number,char MMCWRData[MMC_DATA_SIZE])
 00000000  B510      PUSH        {R4,LR}
 00000002  1C0C      MOV         R4,R1 ; MMCWRData
 00000004  ---- Variable 'MMCWRData' assigned to Register 'R4' ----
 00000004  1C01      MOV         R1,R0 ; block_number
 00000006  ---- Variable 'block_number' assigned to Register 'R1' ----
  196: {  
 00000006            ; SCOPE-START
  200:     IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
 00000006  4800      LDR         R3,=0x100000
 00000008  4800      LDR         R0,=0xE002800C
 0000000A  6802      LDR         R2,[R0,#0x0]
 0000000C  431A      ORR         R2,R3
 0000000E  6002      STR         R2,[R0,#0x0]
  203:     blockaddress=(block_number<<9);
 00000010  1C08      MOV         R0,R1 ; block_number
 00000012  0400      LSL         R0,R0,#0x10 ; block_number
 00000014  0C00      LSR         R0,R0,#0x10
 00000016  0240      LSL         R0,R0,#0x9
 00000018  ---- Variable 'blockaddress' assigned to Register 'R0' ----
  206:     MMCCmd[0] = 0x58;
 00000018  2258      MOV         R2,#0x58
 0000001A  4800      LDR         R1,=MMCCmd ; MMCCmd
 0000001C  700A      STRB        R2,[R1,#0x0] ; MMCCmd
  208:     MMCCmd[1] = blockaddress >> 24;
 0000001E  1C02      MOV         R2,R0 ; blockaddress
 00000020  0E12      LSR         R2,R2,#0x18 ; blockaddress
 00000022  4800      LDR         R1,=MMCCmd + 0x1 ; MMCCmd+1
 00000024  700A      STRB        R2,[R1,#0x0] ; MMCCmd+1
  209:     MMCCmd[2] = blockaddress >> 16;
 00000026  1C02      MOV         R2,R0 ; blockaddress
 00000028  0C12      LSR         R2,R2,#0x10 ; blockaddress
 0000002A  4800      LDR         R1,=MMCCmd + 0x2 ; MMCCmd+2
 0000002C  700A      STRB        R2,[R1,#0x0] ; MMCCmd+2
  211:     MMCCmd[3] = blockaddress >> 8;
 0000002E  1C02      MOV         R2,R0 ; blockaddress
 00000030  0A12      LSR         R2,R2,#0x8 ; blockaddress
 00000032  4800      LDR         R1,=MMCCmd + 0x3 ; MMCCmd+3
 00000034  700A      STRB        R2,[R1,#0x0] ; MMCCmd+3
  212:     MMCCmd[4] = blockaddress;
 00000036  1C01      MOV         R1,R0 ; blockaddress
 00000038  4800      LDR         R0,=MMCCmd + 0x4 ; MMCCmd+4
 0000003A  7001      STRB        R1,[R0,#0x0] ; MMCCmd+4
  214:     MMCCmd[5] = 0xFF;
 0000003C  21FF      MOV         R1,#0xFF
 0000003E  4800      LDR         R0,=MMCCmd + 0x5 ; MMCCmd+5
 00000040  7001      STRB        R1,[R0,#0x0] ; MMCCmd+5
  215:     SPI_Send(MMCCmd, MMC_CMD_SIZE );
 00000042  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000044  2106      MOV         R1,#0x6
 00000046  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000048  FFDB      BL          SPI_Send?T  ; T=0x0001  (2)
  218:     if((mmc_response(0x00))==1)
 0000004A  2000      MOV         R0,#0x0
 0000004C  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 0000004E  FFD8      BL          mmc_response?T  ; T=0x0001  (2)
 00000050  2801      CMP         R0,#0x1 ; mmc_response?T
 00000052  D10A      BNE         L_19  ; T=0x0000006A
  220:         MMCStatus = WRITE_BLOCK_TIMEOUT;
 00000054  2104      MOV         R1,#0x4
 00000056  4800      LDR         R0,=MMCStatus ; MMCStatus
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 16  

 00000058  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  221:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 0000005A  4800      LDR         R2,=0x100000
 0000005C  4800      LDR         R0,=0xE0028004
 0000005E  6801      LDR         R1,[R0,#0x0]
 00000060  4311      ORR         R1,R2
 00000062  6001      STR         R1,[R0,#0x0]
  222:         return MMCStatus;
 00000064  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000066  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 00000068  E040      B           L_20  ; T=0x000000EC
  223:     }
 0000006A          L_19:
  226:     MMCCmd[0] = 0xFE;
 0000006A  21FE      MOV         R1,#0xFE
 0000006C  4800      LDR         R0,=MMCCmd ; MMCCmd
 0000006E  7001      STRB        R1,[R0,#0x0] ; MMCCmd
  227:     SPI_Send( MMCCmd, 1 );
 00000070  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000072  2101      MOV         R1,#0x1
 00000074  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000076  FFC4      BL          SPI_Send?T  ; T=0x0001  (2)
  230:     SPI_Send(&MMCWRData[0], MMC_DATA_SIZE );
 00000078  1C20      MOV         R0,R4 ; MMCWRData
 0000007A  4980      LDR         R1,=0x200
 0000007C  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 0000007E  FFC0      BL          SPI_Send?T  ; T=0x0001  (2)
  236:     MMCCmd[0] = 0xFF;
 00000080  21FF      MOV         R1,#0xFF
 00000082  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000084  7001      STRB        R1,[R0,#0x0] ; MMCCmd
  237:     MMCCmd[1] = 0xFF;
 00000086  21FF      MOV         R1,#0xFF
 00000088  4800      LDR         R0,=MMCCmd + 0x1 ; MMCCmd+1
 0000008A  7001      STRB        R1,[R0,#0x0] ; MMCCmd+1
  238:     SPI_Send( MMCCmd, 2 );
 0000008C  4800      LDR         R0,=MMCCmd ; MMCCmd
 0000008E  2102      MOV         R1,#0x2
 00000090  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000092  FFB6      BL          SPI_Send?T  ; T=0x0001  (2)
  240:     Status = SPI_ReceiveByte();
 00000094  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 00000096  FFB4      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 00000098  1C01      MOV         R1,R0 ; Status
 0000009A  ---- Variable 'Status' assigned to Register 'R1' ----
  241:     if ( (Status & 0x0F) != 0x05 )
 0000009A  1C08      MOV         R0,R1 ; Status
 0000009C  0600      LSL         R0,R0,#0x18 ; Status
 0000009E  0E00      LSR         R0,R0,#0x18
 000000A0  210F      MOV         R1,#0xF
 000000A2  4008      AND         R0,R1
 000000A4  2805      CMP         R0,#0x5
 000000A6  D00A      BEQ         L_21  ; T=0x000000BE
  243:         MMCStatus = WRITE_BLOCK_FAIL;
 000000A8  2105      MOV         R1,#0x5
 000000AA  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000AC  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  244:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000AE  4800      LDR         R2,=0x100000
 000000B0  4800      LDR         R0,=0xE0028004
 000000B2  6801      LDR         R1,[R0,#0x0]
 000000B4  4311      ORR         R1,R2
 000000B6  6001      STR         R1,[R0,#0x0]
  245:         return MMCStatus;
 000000B8  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000BA  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 17  

 000000BC  E016      B           L_20  ; T=0x000000EC
  246:     }
 000000BE          L_21:
  250:     if(mmc_wait_for_write_finish()==1)
 000000BE  F7FF      BL          mmc_wait_for_write_finish?T  ; T=0x0001  (1)
 000000C0  FF9F      BL          mmc_wait_for_write_finish?T  ; T=0x0001  (2)
 000000C2  2801      CMP         R0,#0x1 ; mmc_wait_for_write_finish?T
 000000C4  D10A      BNE         L_22  ; T=0x000000DC
  252:         MMCStatus = WRITE_BLOCK_FAIL;
 000000C6  2105      MOV         R1,#0x5
 000000C8  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000CA  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  253:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000CC  4800      LDR         R2,=0x100000
 000000CE  4800      LDR         R0,=0xE0028004
 000000D0  6801      LDR         R1,[R0,#0x0]
 000000D2  4311      ORR         R1,R2
 000000D4  6001      STR         R1,[R0,#0x0]
  254:         return MMCStatus;
 000000D6  4800      LDR         R0,=MMCStatus ; MMCStatus
 000000D8  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 000000DA  E007      B           L_20  ; T=0x000000EC
  255:     }
 000000DC          L_22:
  257:     IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000DC  4800      LDR         R2,=0x100000
 000000DE  4800      LDR         R0,=0xE0028004
 000000E0  6801      LDR         R1,[R0,#0x0]
 000000E2  4311      ORR         R1,R2
 000000E4  6001      STR         R1,[R0,#0x0]
  258:     SPI_ReceiveByte();
 000000E6  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 000000E8  FF8B      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
  259:     return 0;
 000000EA  2000      MOV         R0,#0x0
 000000EC            ; SCOPE-END
  260: }
 000000EC          L_20:
 000000EC  BC10      POP         {R4}
 000000EE  BC08      POP         {R3}
 000000F0  4718      BX          R3
 000000F2          ENDP ; 'mmc_write_block_char?T'


*** CODE SEGMENT '?PR?mmc_read_block_int?T?mmc':
  270: int mmc_read_block_int(WORD block_number,int MMCRDData[MMC_DATA_SIZE/4])
 00000000  B510      PUSH        {R4,LR}
 00000002  1C0C      MOV         R4,R1 ; MMCRDData
 00000004  ---- Variable 'MMCRDData' assigned to Register 'R4' ----
 00000004  1C01      MOV         R1,R0 ; block_number
 00000006  ---- Variable 'block_number' assigned to Register 'R1' ----
  271: {
 00000006            ; SCOPE-START
  275:     IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
 00000006  4800      LDR         R3,=0x100000
 00000008  4800      LDR         R0,=0xE002800C
 0000000A  6802      LDR         R2,[R0,#0x0]
 0000000C  431A      ORR         R2,R3
 0000000E  6002      STR         R2,[R0,#0x0]
  277:     blockaddress=(block_number<<9);
 00000010  1C08      MOV         R0,R1 ; block_number
 00000012  0400      LSL         R0,R0,#0x10 ; block_number
 00000014  0C00      LSR         R0,R0,#0x10
 00000016  0240      LSL         R0,R0,#0x9
 00000018  ---- Variable 'blockaddress' assigned to Register 'R0' ----
  280:     MMCCmd[0] = 0x51;
 00000018  2251      MOV         R2,#0x51
 0000001A  4800      LDR         R1,=MMCCmd ; MMCCmd
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 18  

 0000001C  700A      STRB        R2,[R1,#0x0] ; MMCCmd
  282:     MMCCmd[1] = blockaddress >> 24;
 0000001E  1C02      MOV         R2,R0 ; blockaddress
 00000020  0E12      LSR         R2,R2,#0x18 ; blockaddress
 00000022  4800      LDR         R1,=MMCCmd + 0x1 ; MMCCmd+1
 00000024  700A      STRB        R2,[R1,#0x0] ; MMCCmd+1
  283:     MMCCmd[2] = blockaddress >> 16;
 00000026  1C02      MOV         R2,R0 ; blockaddress
 00000028  0C12      LSR         R2,R2,#0x10 ; blockaddress
 0000002A  4800      LDR         R1,=MMCCmd + 0x2 ; MMCCmd+2
 0000002C  700A      STRB        R2,[R1,#0x0] ; MMCCmd+2
  285:     MMCCmd[3] = blockaddress >> 8;
 0000002E  1C02      MOV         R2,R0 ; blockaddress
 00000030  0A12      LSR         R2,R2,#0x8 ; blockaddress
 00000032  4800      LDR         R1,=MMCCmd + 0x3 ; MMCCmd+3
 00000034  700A      STRB        R2,[R1,#0x0] ; MMCCmd+3
  286:     MMCCmd[4] = blockaddress;
 00000036  1C01      MOV         R1,R0 ; blockaddress
 00000038  4800      LDR         R0,=MMCCmd + 0x4 ; MMCCmd+4
 0000003A  7001      STRB        R1,[R0,#0x0] ; MMCCmd+4
  288:     MMCCmd[5] = 0xFF;
 0000003C  21FF      MOV         R1,#0xFF
 0000003E  4800      LDR         R0,=MMCCmd + 0x5 ; MMCCmd+5
 00000040  7001      STRB        R1,[R0,#0x0] ; MMCCmd+5
  289:     SPI_Send(MMCCmd, MMC_CMD_SIZE );
 00000042  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000044  2106      MOV         R1,#0x6
 00000046  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000048  FFDB      BL          SPI_Send?T  ; T=0x0001  (2)
  292:     if((mmc_response(0x00))==1)
 0000004A  2000      MOV         R0,#0x0
 0000004C  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 0000004E  FFD8      BL          mmc_response?T  ; T=0x0001  (2)
 00000050  2801      CMP         R0,#0x1 ; mmc_response?T
 00000052  D10A      BNE         L_23  ; T=0x0000006A
  294:         MMCStatus = READ_BLOCK_TIMEOUT;
 00000054  2106      MOV         R1,#0x6
 00000056  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000058  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  295:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 0000005A  4800      LDR         R2,=0x100000
 0000005C  4800      LDR         R0,=0xE0028004
 0000005E  6801      LDR         R1,[R0,#0x0]
 00000060  4311      ORR         R1,R2
 00000062  6001      STR         R1,[R0,#0x0]
  296:         return MMCStatus;
 00000064  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000066  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 00000068  E028      B           L_24  ; T=0x000000BC
  297:     }
 0000006A          L_23:
  300:     if((mmc_response(0xFE))==1)
 0000006A  20FE      MOV         R0,#0xFE
 0000006C  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 0000006E  FFC8      BL          mmc_response?T  ; T=0x0001  (2)
 00000070  2801      CMP         R0,#0x1 ; mmc_response?T
 00000072  D10A      BNE         L_25  ; T=0x0000008A
  302:         MMCStatus = READ_BLOCK_DATA_TOKEN_MISSING;
 00000074  2107      MOV         R1,#0x7
 00000076  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000078  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  303:         IOSET0 |= SPI_SEL;
 0000007A  4800      LDR         R2,=0x100000
 0000007C  4800      LDR         R0,=0xE0028004
 0000007E  6801      LDR         R1,[R0,#0x0]
 00000080  4311      ORR         R1,R2
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 19  

 00000082  6001      STR         R1,[R0,#0x0]
  304:         return MMCStatus;
 00000084  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000086  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 00000088  E018      B           L_24  ; T=0x000000BC
  305:     }
 0000008A          L_25:
  308:     SPI_Receive((char *) &MMCRDData[0], MMC_DATA_SIZE );
 0000008A  1C20      MOV         R0,R4 ; MMCRDData
 0000008C  4980      LDR         R1,=0x200
 0000008E  F7FF      BL          SPI_Receive?T  ; T=0x0001  (1)
 00000090  FFB7      BL          SPI_Receive?T  ; T=0x0001  (2)
  311:     Checksum = SPI_ReceiveByte();
 00000092  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 00000094  FFB5      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 00000096  0604      LSL         R4,R0,#0x18 ; SPI_ReceiveByte?T
 00000098  0E24      LSR         R4,R4,#0x18
 0000009A  ---- Variable 'Checksum' assigned to Register 'R4' ----
  312:     Checksum = Checksum << 0x08 | SPI_ReceiveByte();
 0000009A  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 0000009C  FFB1      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 0000009E  0600      LSL         R0,R0,#0x18 ; SPI_ReceiveByte?T
 000000A0  0E00      LSR         R0,R0,#0x18
 000000A2  1C21      MOV         R1,R4 ; Checksum
 000000A4  040C      LSL         R4,R1,#0x10 ; Checksum
 000000A6  0C24      LSR         R4,R4,#0x10
 000000A8  0224      LSL         R4,R4,#0x8
 000000AA  4304      ORR         R4,R0
  314:     IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000AC  4800      LDR         R2,=0x100000
 000000AE  4800      LDR         R0,=0xE0028004
 000000B0  6801      LDR         R1,[R0,#0x0]
 000000B2  4311      ORR         R1,R2
 000000B4  6001      STR         R1,[R0,#0x0]
  315:     SPI_ReceiveByte();
 000000B6  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 000000B8  FFA3      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
  316:     return 0;
 000000BA  2000      MOV         R0,#0x0
 000000BC            ; SCOPE-END
  317: }
 000000BC          L_24:
 000000BC  BC10      POP         {R4}
 000000BE  BC08      POP         {R3}
 000000C0  4718      BX          R3
 000000C2          ENDP ; 'mmc_read_block_int?T'


*** CODE SEGMENT '?PR?mmc_read_block_char?T?mmc':
  319: int mmc_read_block_char(WORD block_number,char MMCRDData[MMC_DATA_SIZE])
 00000000  B510      PUSH        {R4,LR}
 00000002  1C0C      MOV         R4,R1 ; MMCRDData
 00000004  ---- Variable 'MMCRDData' assigned to Register 'R4' ----
 00000004  1C01      MOV         R1,R0 ; block_number
 00000006  ---- Variable 'block_number' assigned to Register 'R1' ----
  320: {
 00000006            ; SCOPE-START
  324:     IOCLR0 |= SPI_SEL; /* clear SPI SSEL */
 00000006  4800      LDR         R3,=0x100000
 00000008  4800      LDR         R0,=0xE002800C
 0000000A  6802      LDR         R2,[R0,#0x0]
 0000000C  431A      ORR         R2,R3
 0000000E  6002      STR         R2,[R0,#0x0]
  326:     blockaddress=(block_number<<9);
 00000010  1C08      MOV         R0,R1 ; block_number
 00000012  0400      LSL         R0,R0,#0x10 ; block_number
 00000014  0C00      LSR         R0,R0,#0x10
 00000016  0240      LSL         R0,R0,#0x9
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 20  

 00000018  ---- Variable 'blockaddress' assigned to Register 'R0' ----
  329:     MMCCmd[0] = 0x51;
 00000018  2251      MOV         R2,#0x51
 0000001A  4800      LDR         R1,=MMCCmd ; MMCCmd
 0000001C  700A      STRB        R2,[R1,#0x0] ; MMCCmd
  331:     MMCCmd[1] = blockaddress >> 24;
 0000001E  1C02      MOV         R2,R0 ; blockaddress
 00000020  0E12      LSR         R2,R2,#0x18 ; blockaddress
 00000022  4800      LDR         R1,=MMCCmd + 0x1 ; MMCCmd+1
 00000024  700A      STRB        R2,[R1,#0x0] ; MMCCmd+1
  332:     MMCCmd[2] = blockaddress >> 16;
 00000026  1C02      MOV         R2,R0 ; blockaddress
 00000028  0C12      LSR         R2,R2,#0x10 ; blockaddress
 0000002A  4800      LDR         R1,=MMCCmd + 0x2 ; MMCCmd+2
 0000002C  700A      STRB        R2,[R1,#0x0] ; MMCCmd+2
  334:     MMCCmd[3] = blockaddress >> 8;
 0000002E  1C02      MOV         R2,R0 ; blockaddress
 00000030  0A12      LSR         R2,R2,#0x8 ; blockaddress
 00000032  4800      LDR         R1,=MMCCmd + 0x3 ; MMCCmd+3
 00000034  700A      STRB        R2,[R1,#0x0] ; MMCCmd+3
  335:     MMCCmd[4] = blockaddress;
 00000036  1C01      MOV         R1,R0 ; blockaddress
 00000038  4800      LDR         R0,=MMCCmd + 0x4 ; MMCCmd+4
 0000003A  7001      STRB        R1,[R0,#0x0] ; MMCCmd+4
  337:     MMCCmd[5] = 0xFF;
 0000003C  21FF      MOV         R1,#0xFF
 0000003E  4800      LDR         R0,=MMCCmd + 0x5 ; MMCCmd+5
 00000040  7001      STRB        R1,[R0,#0x0] ; MMCCmd+5
  338:     SPI_Send(MMCCmd, MMC_CMD_SIZE );
 00000042  4800      LDR         R0,=MMCCmd ; MMCCmd
 00000044  2106      MOV         R1,#0x6
 00000046  F7FF      BL          SPI_Send?T  ; T=0x0001  (1)
 00000048  FFDB      BL          SPI_Send?T  ; T=0x0001  (2)
  341:     if((mmc_response(0x00))==1)
 0000004A  2000      MOV         R0,#0x0
 0000004C  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 0000004E  FFD8      BL          mmc_response?T  ; T=0x0001  (2)
 00000050  2801      CMP         R0,#0x1 ; mmc_response?T
 00000052  D10A      BNE         L_26  ; T=0x0000006A
  343:         MMCStatus = READ_BLOCK_TIMEOUT;
 00000054  2106      MOV         R1,#0x6
 00000056  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000058  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  344:         IOSET0 |= SPI_SEL; /* set SPI SSEL */
 0000005A  4800      LDR         R2,=0x100000
 0000005C  4800      LDR         R0,=0xE0028004
 0000005E  6801      LDR         R1,[R0,#0x0]
 00000060  4311      ORR         R1,R2
 00000062  6001      STR         R1,[R0,#0x0]
  345:         return MMCStatus;
 00000064  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000066  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 00000068  E028      B           L_27  ; T=0x000000BC
  346:     }
 0000006A          L_26:
  349:     if((mmc_response(0xFE))==1)
 0000006A  20FE      MOV         R0,#0xFE
 0000006C  F7FF      BL          mmc_response?T  ; T=0x0001  (1)
 0000006E  FFC8      BL          mmc_response?T  ; T=0x0001  (2)
 00000070  2801      CMP         R0,#0x1 ; mmc_response?T
 00000072  D10A      BNE         L_28  ; T=0x0000008A
  351:         MMCStatus = READ_BLOCK_DATA_TOKEN_MISSING;
 00000074  2107      MOV         R1,#0x7
 00000076  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000078  7001      STRB        R1,[R0,#0x0] ; MMCStatus
  352:         IOSET0 |= SPI_SEL;
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 21  

 0000007A  4800      LDR         R2,=0x100000
 0000007C  4800      LDR         R0,=0xE0028004
 0000007E  6801      LDR         R1,[R0,#0x0]
 00000080  4311      ORR         R1,R2
 00000082  6001      STR         R1,[R0,#0x0]
  353:         return MMCStatus;
 00000084  4800      LDR         R0,=MMCStatus ; MMCStatus
 00000086  7800      LDRB        R0,[R0,#0x0] ; MMCStatus
 00000088  E018      B           L_27  ; T=0x000000BC
  354:     }
 0000008A          L_28:
  357:     SPI_Receive(&MMCRDData[0], MMC_DATA_SIZE );
 0000008A  1C20      MOV         R0,R4 ; MMCRDData
 0000008C  4980      LDR         R1,=0x200
 0000008E  F7FF      BL          SPI_Receive?T  ; T=0x0001  (1)
 00000090  FFB7      BL          SPI_Receive?T  ; T=0x0001  (2)
  360:     Checksum = SPI_ReceiveByte();
 00000092  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 00000094  FFB5      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 00000096  0604      LSL         R4,R0,#0x18 ; SPI_ReceiveByte?T
 00000098  0E24      LSR         R4,R4,#0x18
 0000009A  ---- Variable 'Checksum' assigned to Register 'R4' ----
  361:     Checksum = Checksum << 0x08 | SPI_ReceiveByte();
 0000009A  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 0000009C  FFB1      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 0000009E  0600      LSL         R0,R0,#0x18 ; SPI_ReceiveByte?T
 000000A0  0E00      LSR         R0,R0,#0x18
 000000A2  1C21      MOV         R1,R4 ; Checksum
 000000A4  040C      LSL         R4,R1,#0x10 ; Checksum
 000000A6  0C24      LSR         R4,R4,#0x10
 000000A8  0224      LSL         R4,R4,#0x8
 000000AA  4304      ORR         R4,R0
  363:     IOSET0 |= SPI_SEL; /* set SPI SSEL */
 000000AC  4800      LDR         R2,=0x100000
 000000AE  4800      LDR         R0,=0xE0028004
 000000B0  6801      LDR         R1,[R0,#0x0]
 000000B2  4311      ORR         R1,R2
 000000B4  6001      STR         R1,[R0,#0x0]
  364:     SPI_ReceiveByte();
 000000B6  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 000000B8  FFA3      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
  365:     return 0;
 000000BA  2000      MOV         R0,#0x0
 000000BC            ; SCOPE-END
  366: }
 000000BC          L_27:
 000000BC  BC10      POP         {R4}
 000000BE  BC08      POP         {R3}
 000000C0  4718      BX          R3
 000000C2          ENDP ; 'mmc_read_block_char?T'


*** CODE SEGMENT '?PR?mmc_response?T?mmc':
  373: int mmc_response( BYTE response)
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C05      MOV         R5,R0 ; response
 00000004  ---- Variable 'response' assigned to Register 'R5' ----
  374: {
 00000004            ; SCOPE-START
  375:     DWORD count = 0xFFF;
 00000004  4800      LDR         R4,=0xFFF
 00000006  ---- Variable 'count' assigned to Register 'R4' ----
  378:     while( count > 0 )
 00000006          L_31:
  380:         result = SPI_ReceiveByte();
 00000006  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 00000008  FFFB      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 0000000A  1C06      MOV         R6,R0 ; result
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 22  

 0000000C  ---- Variable 'result' assigned to Register 'R6' ----
  381:         if ( result == response )
 0000000C  1C28      MOV         R0,R5 ; response
 0000000E  0601      LSL         R1,R0,#0x18 ; response
 00000010  0E09      LSR         R1,R1,#0x18
 00000012  1C30      MOV         R0,R6 ; result
 00000014  0600      LSL         R0,R0,#0x18 ; result
 00000016  0E00      LSR         R0,R0,#0x18
 00000018  4288      CMP         R0,R1
 0000001A  D003      BEQ         L_30  ; T=0x00000024
  385:         count--;
 0000001C  3C01      SUB         R4,#0x1
  386:     }
 0000001E  1C20      MOV         R0,R4 ; count
 00000020  2800      CMP         R0,#0x0 ; count
 00000022  D8F0      BHI         L_31  ; T=0x00000006
 00000024          L_30:
  387:     if ( count == 0 )
 00000024  1C20      MOV         R0,R4 ; count
 00000026  2800      CMP         R0,#0x0 ; count
 00000028  D101      BNE         L_34  ; T=0x0000002E
  388:         return 1; /* Failure, loop was exited due to timeout */
 0000002A  2001      MOV         R0,#0x1
 0000002C  E000      B           L_35  ; T=0x00000030
 0000002E          L_34:
  390:         return 0; /* Normal, loop was exited before timeout */
 0000002E  2000      MOV         R0,#0x0
 00000030            ; SCOPE-END
  391: }
 00000030          L_35:
 00000030  BC70      POP         {R4-R6}
 00000032  BC08      POP         {R3}
 00000034  4718      BX          R3
 00000036          ENDP ; 'mmc_response?T'


*** CODE SEGMENT '?PR?mmc_wait_for_write_finish?T?mmc':
  400: int mmc_wait_for_write_finish( void )
 00000000  B530      PUSH        {R4-R5,LR}
  401: {
 00000002            ; SCOPE-START
  402:     DWORD count = 0xFFFF; /* The delay is set to maximum considering
 00000002  4800      LDR         R4,=0xFFFF
 00000004  ---- Variable 'count' assigned to Register 'R4' ----
  405:     BYTE result = 0;
 00000004  2500      MOV         R5,#0x0
 00000006  ---- Variable 'result' assigned to Register 'R5' ----
  407:     while( (result == 0) && count )
 00000006  E003      B           L_37  ; T=0x00000010
 00000008          L_39:
  409:         result = SPI_ReceiveByte();
 00000008  F7FF      BL          SPI_ReceiveByte?T  ; T=0x0001  (1)
 0000000A  FFFA      BL          SPI_ReceiveByte?T  ; T=0x0001  (2)
 0000000C  1C05      MOV         R5,R0 ; result
  410:         count--;
 0000000E  3C01      SUB         R4,#0x1
  411:     }
 00000010          L_37:
 00000010  1C28      MOV         R0,R5 ; result
 00000012  0600      LSL         R0,R0,#0x18 ; result
 00000014  0E00      LSR         R0,R0,#0x18
 00000016  2800      CMP         R0,#0x0
 00000018  D102      BNE         L_38  ; T=0x00000020
 0000001A  1C20      MOV         R0,R4 ; count
 0000001C  2800      CMP         R0,#0x0 ; count
 0000001E  D1F3      BNE         L_39  ; T=0x00000008
 00000020          L_38:
  412:     if ( count == 0 )
ARM COMPILER V2.32a,  mmc                                                                  18/05/08  02:36:15  PAGE 23  

 00000020  1C20      MOV         R0,R4 ; count
 00000022  2800      CMP         R0,#0x0 ; count
 00000024  D101      BNE         L_42  ; T=0x0000002A
  413:         return 1; /* Failure, loop was exited due to timeout */
 00000026  2001      MOV         R0,#0x1
 00000028  E000      B           L_43  ; T=0x0000002C
 0000002A          L_42:
  415:         return 0; /* Normal, loop was exited before timeout */
 0000002A  2000      MOV         R0,#0x0
 0000002C            ; SCOPE-END
 0000002C          L_43:
 0000002C  BC30      POP         {R4-R5}
 0000002E  BC08      POP         {R3}
 00000030  4718      BX          R3
 00000032          ENDP ; 'mmc_wait_for_write_finish?T'



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =         7
  const size           =    ------
End of Module Information.


ARM COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
