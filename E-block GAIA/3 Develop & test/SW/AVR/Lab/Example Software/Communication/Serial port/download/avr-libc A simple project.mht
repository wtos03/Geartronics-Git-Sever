From: <Saved by Microsoft Internet Explorer 5>
Subject: avr-libc: A simple project
Date: Tue, 21 Feb 2006 10:09:02 +0700
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0005_01C636CE.D729EDD0"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.2180

This is a multi-part message in MIME format.

------=_NextPart_000_0005_01C636CE.D729EDD0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-1.2.5/group__demo__project.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>avr-libc: A simple project</TITLE>
<META http-equiv=3DContent-Type =
content=3Dtext/html;charset=3Diso-8859-1><LINK=20
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/dox.css"=20
type=3Dtext/css rel=3Dstylesheet>
<META content=3D"MSHTML 6.00.2900.2180" name=3DGENERATOR></HEAD>
<BODY><!-- Generated by Doxygen 1.4.1 -->
<H1>A simple project<BR><SMALL>[<A class=3Del=20
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__demos.html">Demo=20
projects</A>]</SMALL> </H1>At this point, you should have the GNU tools=20
configured, built, and installed on your system. In this chapter, we =
present a=20
simple example of using the GNU tools in an AVR project. After reading =
this=20
chapter, you should have a better feel as to how the tools are used and =
how a=20
<CODE>Makefile</CODE> can be configured.
<H2><A class=3Danchor name=3Ddemo_project_desc>The Project</A></H2>This =
project will=20
use the pulse-width modulator ( <CODE>PWM</CODE> ) to ramp an LED on and =
off=20
every two seconds. An AT90S2313 processor will be used as the =
controller. The=20
circuit for this demonstration is shown in the <A class=3Del=20
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__demo__project.html#demo_project_schematic">schematic=20
diagram</A>. If you have a development kit, you should be able to use =
it, rather=20
than build the circuit, for this project.
<P><A class=3Danchor name=3Ddemo_project_schematic></A>
<DIV align=3Dcenter><IMG alt=3Ddemo.png=20
src=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-1=
.2.5/demo.png">=20

<P><STRONG>Schematic of circuit for demo project</STRONG></P></DIV>
<P>The source code is given in <A class=3Del=20
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__demo__project.html#demo_project_src">demo.c</A>.=20
For the sake of this example, create a file called <CODE><A class=3Del=20
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/demo_8c.html">demo.c</A></CODE>=20
containing this source code. Some of the more important parts of the =
code are:
<P>
<DL compact>
  <DT><B>Note [1]:</B>
  <DD>The <CODE>PWM</CODE> is being used in 10-bit mode, so we need a =
16-bit=20
  variable to remember the current value.</DD></DL>
<DL compact>
  <DT><B>Note [2]:</B>
  <DD><A class=3Del=20
  =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__interrupts.html#ga4">SIGNAL()</A>=20
  is a macro that marks the function as an interrupt routine. In this =
case, the=20
  function will get called when the timer overflows. Setting up =
interrupts is=20
  explained in greater detail in <A class=3Del=20
  =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__interrupts.html">Interrupts=20
  and Signals</A>.</DD></DL>
<DL compact>
  <DT><B>Note [3]:</B>
  <DD>This section determines the new value of the =
<CODE>PWM</CODE>.</DD></DL>
<DL compact>
  <DT><B>Note [4]:</B>
  <DD>Here's where the newly computed value is loaded into the =
<CODE>PWM</CODE>=20
  register. Since we are in an interrupt routine, it is safe to use a =
16-bit=20
  assignment to the register. Outside of an interrupt, the assignment =
should=20
  only be performed with interrupts disabled if there's a chance that an =

  interrupt routine could also access this register (or another register =
that=20
  uses <CODE>TEMP</CODE>), see the appropriate <A class=3Del=20
  =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/FAQ.html#faq_16bitio">FAQ=20
  entry</A>.</DD></DL>
<DL compact>
  <DT><B>Note [5]:</B>
  <DD>This routine gets called after a reset. It initializes the=20
  <CODE>PWM</CODE> and enables interrupts.</DD></DL>
<DL compact>
  <DT><B>Note [6]:</B>
  <DD>The main loop of the program does nothing -- all the work is done =
by the=20
  interrupt routine! If this was a real product, we'd probably put a=20
  <CODE>SLEEP</CODE> instruction in this loop to conserve =
power.</DD></DL>
<DL compact>
  <DT><B>Note [7]:</B>
  <DD>Early AVR devices saturate their outputs at rather low currents =
when=20
  sourcing current, so the LED can be connected directly, the resulting =
current=20
  through the LED will be about 15 mA. For modern parts (at least for =
the ATmega=20
  128), however Atmel has drastically increased the IO source =
capability, so=20
  when operating at 5 V Vcc, R2 is needed. Its value should be about 150 =
Ohms.=20
  When operating the circuit at 3 V, it can still be omitted =
though.</DD></DL>
<H2><A class=3Danchor name=3Ddemo_project_src>The Source Code</A></H2>
<DIV class=3Dfragment><PRE class=3Dfragment><SPAN =
class=3Dcomment>/*</SPAN>
<SPAN class=3Dcomment> * =
-------------------------------------------------------------------------=
---</SPAN>
<SPAN class=3Dcomment> * "THE BEER-WARE LICENSE" (Revision 42):</SPAN>
<SPAN class=3Dcomment> * &lt;joerg@FreeBSD.ORG&gt; wrote this file.  As =
long as you retain this notice you</SPAN>
<SPAN class=3Dcomment> * can do whatever you want with this stuff. If we =
meet some day, and you think</SPAN>
<SPAN class=3Dcomment> * this stuff is worth it, you can buy me a beer =
in return.        Joerg Wunsch</SPAN>
<SPAN class=3Dcomment> * =
-------------------------------------------------------------------------=
---</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * Simple AVR demonstration.  Controls a LED that =
can be directly</SPAN>
<SPAN class=3Dcomment> * connected from OC1/OC1A to GND.  The brightness =
of the LED is</SPAN>
<SPAN class=3Dcomment> * controlled with the PWM.  After each period of =
the PWM, the PWM</SPAN>
<SPAN class=3Dcomment> * value is either incremented or decremented, =
that's all.</SPAN>
<SPAN class=3Dcomment> *</SPAN>
<SPAN class=3Dcomment> * $Id: demo.c,v 1.4.2.1 2005/04/09 14:55:28 =
joerg_wunsch Exp $</SPAN>
<SPAN class=3Dcomment> */</SPAN>

<SPAN class=3Dpreprocessor>#include &lt;inttypes.h&gt;</SPAN>
<SPAN class=3Dpreprocessor>#include &lt;avr/io.h&gt;</SPAN>
<SPAN class=3Dpreprocessor>#include &lt;avr/interrupt.h&gt;</SPAN>
<SPAN class=3Dpreprocessor>#include &lt;avr/signal.h&gt;</SPAN>

<SPAN class=3Dpreprocessor>#if defined(__AVR_AT90S2313__)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OC1 PB3</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OCR OCR1</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
DDROC DDRB</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#elif =
defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OC1 PB1</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
DDROC DDRB</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OCR OCR1</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#elif =
defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || \</SPAN>
<SPAN class=3Dpreprocessor>      defined(__AVR_AT90S4434__) || =
defined(__AVR_AT90S8535__) || \</SPAN>
<SPAN class=3Dpreprocessor>      defined(__AVR_ATmega163__)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OC1 PD5</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
DDROC DDRD</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OCR OCR1A</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#elif =
defined(__AVR_ATmega8__)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OC1 PB1</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
DDROC DDRB</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OCR OCR1A</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
PWM10 WGM10</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
PWM11 WGM11</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#elif =
defined(__AVR_ATmega32__) || defined(__AVR_ATmega16__)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OC1 PD5</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
DDROC DDRD</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OCR OCR1A</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
PWM10 WGM10</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
PWM11 WGM11</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#elif =
defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OC1 PB5</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
DDROC DDRB</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
OCR OCR1A</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
PWM10 WGM10</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
PWM11 WGM11</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN =
class=3Dpreprocessor>#else</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  error =
"Don't know what kind of MCU you are compiling for"</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN =
class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
<SPAN class=3Dpreprocessor>#if defined(COM11)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
XCOM11 COM11</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#elif =
defined(COM1A1)</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  define =
XCOM11 COM1A1</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN =
class=3Dpreprocessor>#else</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor>#  error =
"need either COM1A1 or COM11"</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN =
class=3Dpreprocessor>#endif</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
<SPAN class=3Dkeyword>enum</SPAN> { UP, DOWN };

<SPAN class=3Dkeyword>volatile</SPAN> <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga3">uint16_t</A> pwm; <SPAN =
class=3Dcomment>/* Note [1] */</SPAN>
<SPAN class=3Dkeyword>volatile</SPAN> <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__stdint.html#ga1">uint8_t</A> direction;

<A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__interrupts.html#ga4">SIGNAL</A> (SIG_OVERFLOW1) <SPAN =
class=3Dcomment>/* Note [2] */</SPAN>
{
    <SPAN class=3Dkeywordflow>switch</SPAN> (direction) <SPAN =
class=3Dcomment>/* Note [3] */</SPAN>
    {
        <SPAN class=3Dkeywordflow>case</SPAN> UP:
            <SPAN class=3Dkeywordflow>if</SPAN> (++pwm =3D=3D 1023)
                direction =3D DOWN;
            break;

        case DOWN:
            if (--pwm =3D=3D 0)
                direction =3D UP;
            break;
    }

    OCR =3D pwm; <SPAN class=3Dcomment>/* Note [4] */</SPAN>
}

<SPAN class=3Dkeywordtype>void</SPAN>
ioinit (<SPAN class=3Dkeywordtype>void</SPAN>) <SPAN class=3Dcomment>/* =
Note [5] */</SPAN>
{
    <SPAN class=3Dcomment>/* tmr1 is 10-bit PWM */</SPAN>
    TCCR1A =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A> (PWM10) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A> (PWM11) | <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A> (XCOM11);

    <SPAN class=3Dcomment>/* tmr1 running on full MCU clock */</SPAN>
    TCCR1B =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A> (CS10);

    <SPAN class=3Dcomment>/* set PWM value to 0 */</SPAN>
    OCR =3D 0;

    <SPAN class=3Dcomment>/* enable OC1 and PB2 as output */</SPAN>
    DDROC =3D <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__sfr.html#ga0">_BV</A> (OC1);

    <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__interrupts.html#ga0">timer_enable_int</A> (_BV =
(TOIE1));

    <SPAN class=3Dcomment>/* enable interrupts */</SPAN>
    <A class=3Dcode =
href=3D"http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-=
1.2.5/group__avr__interrupts.html#ga1">sei</A> ();
}

<SPAN class=3Dkeywordtype>int</SPAN>
main (<SPAN class=3Dkeywordtype>void</SPAN>)
{
    ioinit ();

    <SPAN class=3Dcomment>/* loop forever, the interrupts are doing the =
rest */</SPAN>

    <SPAN class=3Dkeywordflow>for</SPAN> (;;) <SPAN class=3Dcomment>/* =
Note [6] */</SPAN>
        ;

    <SPAN class=3Dkeywordflow>return</SPAN> (0);
}
</PRE></DIV>
<H2><A class=3Danchor name=3Ddemo_project_compile>Compiling and =
Linking</A></H2>This=20
first thing that needs to be done is compile the source. When compiling, =
the=20
compiler needs to know the processor type so the <CODE>-mmcu</CODE> =
option is=20
specified. The <CODE>-Os</CODE> option will tell the compiler to =
optimize the=20
code for efficient space usage (at the possible expense of code =
execution=20
speed). The <CODE>-g</CODE> is used to embed debug info. The debug info =
is=20
useful for disassemblies and doesn't end up in the <CODE></CODE>.hex =
files, so I=20
usually specify it. Finally, the <CODE>-c</CODE> tells the compiler to =
compile=20
and stop -- don't link. This demo is small enough that we could compile =
and link=20
in one step. However, real-world projects will have several modules and =
will=20
typically need to break up the building of the project into several =
compiles and=20
one link.
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>    $ avr-gcc -g -Os =
-mmcu=3Dat90s2333 -c demo.c
</PRE></DIV>
<P>The compilation will create a <CODE>demo.o</CODE> file. Next we link =
it into=20
a binary called <CODE>demo.elf</CODE>.
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>    $ avr-gcc -g =
-mmcu=3Dat90s2333 -o demo.elf demo.o
</PRE></DIV>
<P>It is important to specify the MCU type when linking. The compiler =
uses the=20
<CODE>-mmcu</CODE> option to choose start-up files and run-time =
libraries that=20
get linked together. If this option isn't specified, the compiler =
defaults to=20
the 8515 processor environment, which is most certainly what you didn't =
want.
<H2><A class=3Danchor name=3Ddemo_project_obj>Examining the Object =
File</A></H2>
<P>Now we have a binary file. Can we do anything useful with it (besides =
put it=20
into the processor?) The GNU Binutils suite is made up of many useful =
tools for=20
manipulating object files that get generated. One tool is=20
<CODE>avr-objdump</CODE>, which takes information from the object file =
and=20
displays it in many useful ways. Typing the command by itself will cause =
it to=20
list out its options.
<P>For instance, to get a feel of the application's size, the =
<CODE>-h</CODE>=20
option can be used. The output of this option shows how much space is =
used in=20
each of the sections (the <CODE></CODE>.stab and <CODE></CODE>.stabstr =
sections=20
hold the debugging information and won't make it into the ROM file).
<P>An even more useful option is <CODE>-S</CODE>. This option =
disassembles the=20
binary file and intersperses the source code in the output! This method =
is much=20
better, in my opinion, than using the <CODE>-S</CODE> with the compiler =
because=20
this listing includes routines from the libraries and the vector table =
contents.=20
Also, all the "fix-ups" have been satisfied. In other words, the listing =

generated by this option reflects the actual code that the processor =
will run.
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>    $ avr-objdump -h -S =
demo.elf &gt; demo.lst
</PRE></DIV>
<P>Here's the output as saved in the <CODE>demo.lst</CODE> file:
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>demo.elf:     file format =
elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000cc  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000000cc  00000160  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00800060  00800060  00000160  2**0
                  ALLOC
  3 .noinit       00000000  00800063  00800063  00000160  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00000160  2**0
                  CONTENTS
  5 .stab         000005d0  00000000  00000000  00000160  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      000005c2  00000000  00000000  00000730  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 &lt;__vectors&gt;:
   0:	0a c0       	rjmp	.+20     	; 0x16 &lt;__ctors_end&gt;
   2:	63 c0       	rjmp	.+198    	; 0xca &lt;__bad_interrupt&gt;
   4:	62 c0       	rjmp	.+196    	; 0xca &lt;__bad_interrupt&gt;
   6:	61 c0       	rjmp	.+194    	; 0xca &lt;__bad_interrupt&gt;
   8:	60 c0       	rjmp	.+192    	; 0xca &lt;__bad_interrupt&gt;
   a:	5f c0       	rjmp	.+190    	; 0xca &lt;__bad_interrupt&gt;
   c:	5e c0       	rjmp	.+188    	; 0xca &lt;__bad_interrupt&gt;
   e:	5d c0       	rjmp	.+186    	; 0xca &lt;__bad_interrupt&gt;
  10:	07 c0       	rjmp	.+14     	; 0x20 &lt;__vector_8&gt;
  12:	5b c0       	rjmp	.+182    	; 0xca &lt;__bad_interrupt&gt;
  14:	5a c0       	rjmp	.+180    	; 0xca &lt;__bad_interrupt&gt;

00000016 &lt;__ctors_end&gt;:
  16:	11 24       	eor	r1, r1
  18:	1f be       	out	0x3f, r1	; 63
  1a:	cf ed       	ldi	r28, 0xDF	; 223
  1c:	cd bf       	out	0x3d, r28	; 61
  1e:	4f c0       	rjmp	.+158    	; 0xbe &lt;main&gt;

00000020 &lt;__vector_8&gt;:
volatile uint16_t pwm; /* Note [1] */
volatile uint8_t direction;

SIGNAL (SIG_OVERFLOW1) /* Note [2] */
{
  20:	1f 92       	push	r1
  22:	0f 92       	push	r0
  24:	0f b6       	in	r0, 0x3f	; 63
  26:	0f 92       	push	r0
  28:	11 24       	eor	r1, r1
  2a:	2f 93       	push	r18
  2c:	8f 93       	push	r24
  2e:	9f 93       	push	r25
    switch (direction) /* Note [3] */
  30:	80 91 60 00 	lds	r24, 0x0060
  34:	99 27       	eor	r25, r25
  36:	00 97       	sbiw	r24, 0x00	; 0
  38:	19 f0       	breq	.+6      	; 0x40 &lt;__SREG__+0x1&gt;
  3a:	01 97       	sbiw	r24, 0x01	; 1
  3c:	31 f5       	brne	.+76     	; 0x8a &lt;__SREG__+0x4b&gt;
  3e:	14 c0       	rjmp	.+40     	; 0x68 &lt;__SREG__+0x29&gt;
    {
        case UP:
            if (++pwm =3D=3D 1023)
  40:	80 91 61 00 	lds	r24, 0x0061
  44:	90 91 62 00 	lds	r25, 0x0062
  48:	01 96       	adiw	r24, 0x01	; 1
  4a:	90 93 62 00 	sts	0x0062, r25
  4e:	80 93 61 00 	sts	0x0061, r24
  52:	80 91 61 00 	lds	r24, 0x0061
  56:	90 91 62 00 	lds	r25, 0x0062
  5a:	8f 5f       	subi	r24, 0xFF	; 255
  5c:	93 40       	sbci	r25, 0x03	; 3
  5e:	a9 f4       	brne	.+42     	; 0x8a &lt;__SREG__+0x4b&gt;
                direction =3D DOWN;
  60:	81 e0       	ldi	r24, 0x01	; 1
  62:	80 93 60 00 	sts	0x0060, r24
  66:	11 c0       	rjmp	.+34     	; 0x8a &lt;__SREG__+0x4b&gt;
            break;

        case DOWN:
            if (--pwm =3D=3D 0)
  68:	80 91 61 00 	lds	r24, 0x0061
  6c:	90 91 62 00 	lds	r25, 0x0062
  70:	01 97       	sbiw	r24, 0x01	; 1
  72:	90 93 62 00 	sts	0x0062, r25
  76:	80 93 61 00 	sts	0x0061, r24
  7a:	80 91 61 00 	lds	r24, 0x0061
  7e:	90 91 62 00 	lds	r25, 0x0062
  82:	89 2b       	or	r24, r25
  84:	11 f4       	brne	.+4      	; 0x8a &lt;__SREG__+0x4b&gt;
                direction =3D UP;
  86:	10 92 60 00 	sts	0x0060, r1
            break;
    }

    OCR =3D pwm; /* Note [4] */
  8a:	80 91 61 00 	lds	r24, 0x0061
  8e:	90 91 62 00 	lds	r25, 0x0062
  92:	9b bd       	out	0x2b, r25	; 43
  94:	8a bd       	out	0x2a, r24	; 42
  96:	9f 91       	pop	r25
  98:	8f 91       	pop	r24
  9a:	2f 91       	pop	r18
  9c:	0f 90       	pop	r0
  9e:	0f be       	out	0x3f, r0	; 63
  a0:	0f 90       	pop	r0
  a2:	1f 90       	pop	r1
  a4:	18 95       	reti

000000a6 &lt;ioinit&gt;:
}

void
ioinit (void) /* Note [5] */
{
    /* tmr1 is 10-bit PWM */
    TCCR1A =3D _BV (PWM10) | _BV (PWM11) | _BV (XCOM11);
  a6:	83 e8       	ldi	r24, 0x83	; 131
  a8:	8f bd       	out	0x2f, r24	; 47

    /* tmr1 running on full MCU clock */
    TCCR1B =3D _BV (CS10);
  aa:	81 e0       	ldi	r24, 0x01	; 1
  ac:	8e bd       	out	0x2e, r24	; 46

    /* set PWM value to 0 */
    OCR =3D 0;
  ae:	1b bc       	out	0x2b, r1	; 43
  b0:	1a bc       	out	0x2a, r1	; 42

    /* enable OC1 and PB2 as output */
    DDROC =3D _BV (OC1);
  b2:	82 e0       	ldi	r24, 0x02	; 2
  b4:	87 bb       	out	0x17, r24	; 23

static __inline__ void timer_enable_int (unsigned char ints)
{
#ifdef TIMSK
    TIMSK =3D ints;
  b6:	84 e0       	ldi	r24, 0x04	; 4
  b8:	89 bf       	out	0x39, r24	; 57

    timer_enable_int (_BV (TOIE1));

    /* enable interrupts */
    sei ();
  ba:	78 94       	sei
  bc:	08 95       	ret

000000be &lt;main&gt;:
}

int
main (void)
{
  be:	cf ed       	ldi	r28, 0xDF	; 223
  c0:	d0 e0       	ldi	r29, 0x00	; 0
  c2:	de bf       	out	0x3e, r29	; 62
  c4:	cd bf       	out	0x3d, r28	; 61
    ioinit ();
  c6:	ef df       	rcall	.-34     	; 0xa6 &lt;ioinit&gt;
  c8:	ff cf       	rjmp	.-2      	; 0xc8 &lt;main+0xa&gt;

000000ca &lt;__bad_interrupt&gt;:
  ca:	9a cf       	rjmp	.-204    	; 0x0 &lt;__heap_end&gt;
</PRE></DIV>
<H2><A class=3Danchor name=3Ddemo_project_map>Linker Map=20
Files</A></H2><CODE>avr-objdump</CODE> is very useful, but sometimes =
it's=20
necessary to see information about the link that can only be generated =
by the=20
linker. A map file contains this information. A map file is useful for=20
monitoring the sizes of your code and data. It also shows where modules =
are=20
loaded and which modules were loaded from libraries. It is yet another =
view of=20
your application. To get a map file, I usually add=20
<CODE><B>-Wl,-Map,demo.map</B></CODE> to my link command. Relink the =
application=20
using the following command to generate <CODE>demo.map</CODE> (a portion =
of=20
which is shown below).
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>    $ avr-gcc -g =
-mmcu=3Dat90s2313 -Wl,-Map,demo.map -o demo.elf demo.o
</PRE></DIV>
<P>
<P>Some points of interest in the <CODE>demo.map</CODE> file are:
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>.rela.plt
 *(.rela.plt)

.text           0x00000000       0xcc
 *(.vectors)
 .vectors       0x00000000       0x16 ../../../build/crt1/crts2313.o
                0x00000000                __vectors
                0x00000000                __vector_default
                0x00000016                __ctors_start =3D .
</PRE></DIV>
<P>The <CODE></CODE>.text segment (where program instructions are =
stored) starts=20
at location 0x0.
<P>
<DIV class=3Dfragment><PRE class=3Dfragment> *(.fini2)
 *(.fini1)
 *(.fini0)
                0x000000cc                _etext =3D .

.data           0x00800060        0x0 load address 0x000000cc
                0x00800060                PROVIDE (__data_start, .)
 *(.data)
 *(.gnu.linkonce.d*)
                0x00800060                . =3D ALIGN (0x2)
                0x00800060                _edata =3D .
                0x00800060                PROVIDE (__data_end, .)

.bss            0x00800060        0x3
                0x00800060                PROVIDE (__bss_start, .)
 *(.bss)
 *(COMMON)
 COMMON         0x00800060        0x3 demo.o
                0x00800060                direction
                0x00800061                pwm
                0x00800063                PROVIDE (__bss_end, .)
                0x000000cc                __data_load_start =3D LOADADDR =
(.data)
                0x000000cc                __data_load_end =3D =
(__data_load_start + SIZEOF (.data))

.noinit         0x00800063        0x0
                0x00800063                PROVIDE (__noinit_start, .)
 *(.noinit*)
                0x00800063                PROVIDE (__noinit_end, .)
                0x00800063                _end =3D .
                0x00800063                PROVIDE (__heap_start, .)

.eeprom         0x00810000        0x0
 *(.eeprom*)
                0x00810000                __eeprom_end =3D .
</PRE></DIV>
<P>The last address in the <CODE></CODE>.text segment is location=20
<CODE>0xf2</CODE> ( denoted by <CODE>_etext</CODE> ), so the =
instructions use up=20
242 bytes of FLASH.
<P>The <CODE></CODE>.data segment (where initialized static variables =
are=20
stored) starts at location <CODE>0x60</CODE>, which is the first address =
after=20
the register bank on a 2313 processor.
<P>The next available address in the <CODE></CODE>.data segment is also =
location=20
<CODE>0x60</CODE>, so the application has no initialized data.
<P>The <CODE></CODE>.bss segment (where uninitialized data is stored) =
starts at=20
location <CODE>0x60</CODE>.
<P>The next available address in the <CODE></CODE>.bss segment is =
location 0x63,=20
so the application uses 3 bytes of uninitialized data.
<P>The <CODE></CODE>.eeprom segment (where EEPROM variables are stored) =
starts=20
at location 0x0.
<P>The next available address in the <CODE></CODE>.eeprom segment is =
also=20
location 0x0, so there aren't any EEPROM variables.
<H2><A class=3Danchor name=3DGenerating>Intel Hex Files</A></H2>We have =
a binary of=20
the application, but how do we get it into the processor? Most (if not =
all)=20
programmers will not accept a GNU executable as an input file, so we =
need to do=20
a little more processing. The next step is to extract portions of the =
binary and=20
save the information into <CODE></CODE>.hex files. The GNU utility that =
does=20
this is called <CODE>avr-objcopy</CODE>.
<P>The ROM contents can be pulled from our project's binary and put into =
the=20
file demo.hex using the following command:
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>    $ avr-objcopy -j .text =
-j .data -O ihex demo.elf demo.hex
</PRE></DIV>
<P>The resulting <CODE>demo.hex</CODE> file contains:
<P>
<DIV class=3Dfragment><PRE =
class=3Dfragment>:100000000AC063C062C061C060C05FC05EC05DC046
:1000100007C05BC05AC011241FBECFEDCDBF4FC07B
:100020001F920F920FB60F9211242F938F939F93CD
:10003000809160009927009719F0019731F514C05D
:10004000809161009091620001969093620080938C
:10005000610080916100909162008F5F9340A9F4EC
:1000600081E08093600011C08091610090916200F6
:10007000019790936200809361008091610090915C
:100080006200892B11F410926000809161009091C0
:1000900062009BBD8ABD9F918F912F910F900FBEE3
:1000A0000F901F90189583E88FBD81E08EBD1BBC1B
:1000B0001ABC82E087BB84E089BF78940895CFEDB5
:0C00C000D0E0DEBFCDBFEFDFFFCF9ACF56
:00000001FF
</PRE></DIV>
<P>The <CODE>-j</CODE> option indicates that we want the information =
from the=20
<CODE></CODE>.text and <CODE></CODE>.data segment extracted. If we =
specify the=20
EEPROM segment, we can generate a <CODE></CODE>.hex file that can be =
used to=20
program the EEPROM:
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>    $ avr-objcopy -j .eeprom =
--change-section-lma .eeprom=3D0 -O ihex demo.elf demo_eeprom.hex
</PRE></DIV>
<P>The resulting <CODE>demo_eeprom.hex</CODE> file contains:
<P>
<DIV class=3Dfragment><PRE class=3Dfragment>:00000001FF
</PRE></DIV>
<P>which is an empty <CODE></CODE>.hex file (which is expected, since we =
didn't=20
define any EEPROM variables).
<H2><A class=3Danchor name=3DLetting>Make Build the =
Project</A></H2>Rather than type=20
these commands over and over, they can all be placed in a make file. To =
build=20
the demo project using <CODE>make</CODE>, save the following in a file =
called=20
<CODE>Makefile</CODE>.
<P>
<DL compact>
  <DT><B>Note:</B>
  <DD>This <CODE>Makefile</CODE> can only be used as input for the GNU =
version=20
  of <CODE>make</CODE>.</DD></DL>
<DIV class=3Dfragment><PRE class=3Dfragment>PRG            =3D demo
OBJ            =3D demo.o
MCU_TARGET     =3D atmega8
OPTIMIZE       =3D -O2

DEFS           =3D
LIBS           =3D

<SPAN class=3Dpreprocessor># You should not have to change anything =
below here.</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
CC             =3D avr-gcc

<SPAN class=3Dpreprocessor># Override is only needed by avr-lib build =
system.</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
override CFLAGS        =3D -g -Wall $(OPTIMIZE) -mmcu=3D$(MCU_TARGET) =
$(DEFS)
override LDFLAGS       =3D -Wl,-Map,$(PRG).map

OBJCOPY        =3D avr-objcopy
OBJDUMP        =3D avr-objdump

all: $(PRG).elf lst text eeprom

$(PRG).elf: $(OBJ)
        $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)

clean:
        rm -rf *.o $(PRG).elf *.eps *.png *.pdf *.bak=20
        rm -rf *.lst *.map $(EXTRA_CLEAN_FILES)

lst:  $(PRG).lst

%.lst: %.elf
        $(OBJDUMP) -h -S $&lt; &gt; $@

<SPAN class=3Dpreprocessor># Rules for building the .text rom =
images</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
text: hex bin srec

hex:  $(PRG).hex
bin:  $(PRG).bin
srec: $(PRG).srec

%.hex: %.elf
        $(OBJCOPY) -j .text -j .data -O ihex $&lt; $@

%.srec: %.elf
        $(OBJCOPY) -j .text -j .data -O srec $&lt; $@

%.bin: %.elf
        $(OBJCOPY) -j .text -j .data -O binary $&lt; $@

<SPAN class=3Dpreprocessor># Rules for building the .eeprom rom =
images</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
eeprom: ehex ebin esrec

ehex:  $(PRG)_eeprom.hex
ebin:  $(PRG)_eeprom.bin
esrec: $(PRG)_eeprom.srec

%_eeprom.hex: %.elf
        $(OBJCOPY) -j .eeprom --change-section-lma .eeprom=3D0 -O ihex =
$&lt; $@

%_eeprom.srec: %.elf
        $(OBJCOPY) -j .eeprom --change-section-lma .eeprom=3D0 -O srec =
$&lt; $@

%_eeprom.bin: %.elf
        $(OBJCOPY) -j .eeprom --change-section-lma .eeprom=3D0 -O binary =
$&lt; $@

<SPAN class=3Dpreprocessor># Every thing below here is used by =
avr-libc's build system and can be ignored</SPAN>
<SPAN class=3Dpreprocessor></SPAN><SPAN class=3Dpreprocessor># by the =
casual user.</SPAN>
<SPAN class=3Dpreprocessor></SPAN>
FIG2DEV                 =3D fig2dev
EXTRA_CLEAN_FILES       =3D *.hex *.bin *.srec

dox: eps png pdf

eps: $(PRG).eps
png: $(PRG).png
pdf: $(PRG).pdf

%.eps: %.fig
        $(FIG2DEV) -L eps $&lt; $@

%.pdf: %.fig
        $(FIG2DEV) -L pdf $&lt; $@

%.png: %.fig
        $(FIG2DEV) -L png $&lt; $@

</PRE></DIV>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D0 border=3D0>
  <TBODY>
  <TR>
    <TD></TD></TR></TBODY></TABLE>
<HR width=3D"80%">

<P>
<CENTER>Automatically generated by Doxygen 1.4.1 on 1 Aug 2005.</CENTER>
<P></P></BODY></HTML>

------=_NextPart_000_0005_01C636CE.D729EDD0
Content-Type: application/octet-stream
Content-Transfer-Encoding: base64
Content-Location: http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-1.2.5/demo.png

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

------=_NextPart_000_0005_01C636CE.D729EDD0
Content-Type: text/css;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://ccrma.stanford.edu/courses/250a/docs/avr-libc-user-manual-1.2.5/dox.css

BODY {
	BACKGROUND-COLOR: #dddddd
}
H1 {
	TEXT-ALIGN: center
}
A.qindex {
=09
}
A.qindexRef {
=09
}
A.el {
	FONT-WEIGHT: bold; TEXT-DECORATION: none
}
A.elRef {
	FONT-WEIGHT: bold
}
A.code {
	FONT-WEIGHT: normal; COLOR: #4444ee; TEXT-DECORATION: none
}
A.codeRef {
	FONT-WEIGHT: normal; COLOR: #4444ee
}
A:hover {
	BACKGROUND-COLOR: #bbbbbb; TEXT-DECORATION: none
}
DL.el {
	MARGIN-LEFT: -1cm
}
DIV.fragment {
	BORDER-RIGHT: black thin solid; BORDER-TOP: black thin solid; =
PADDING-LEFT: 5px; BORDER-LEFT: black thin solid; MARGIN-RIGHT: 5px; =
BORDER-BOTTOM: black thin solid; BACKGROUND-COLOR: #d0d0d0
}
DIV.ah {
	MARGIN-TOP: 3px; FONT-WEIGHT: bold; MARGIN-BOTTOM: 3px; COLOR: #ffffff; =
BACKGROUND-COLOR: black
}
TD.mdRow {
	FONT-WEIGHT: bold; BACKGROUND-COLOR: #ccccbb
}
TD.md {
	FONT-WEIGHT: bold; BACKGROUND-COLOR: #ccccbb
}
TD.mdname1 {
	FONT-WEIGHT: bold; COLOR: #702020; BACKGROUND-COLOR: #ccccbb
}
TD.mdname {
	FONT-WEIGHT: bold; WIDTH: 600px; COLOR: #702020; BACKGROUND-COLOR: =
#ccccbb
}
DIV.groupHeader {
	MARGIN-TOP: 12px; FONT-WEIGHT: bold; MARGIN-BOTTOM: 6px; MARGIN-LEFT: =
16px
}
DIV.groupText {
	FONT-SIZE: smaller; MARGIN-LEFT: 16px; FONT-STYLE: italic
}
FONT.keyword {
	COLOR: #008000
}
FONT.keywordtype {
	COLOR: #604020
}
FONT.keywordflow {
	COLOR: #e08000
}
FONT.comment {
	COLOR: #800000
}
FONT.preprocessor {
	COLOR: #806020
}
FONT.stringliteral {
	COLOR: #002080
}
FONT.charliteral {
	COLOR: #008080
}

------=_NextPart_000_0005_01C636CE.D729EDD0--
