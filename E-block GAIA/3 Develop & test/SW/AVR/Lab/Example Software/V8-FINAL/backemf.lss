
backemf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000012ce  00000000  00000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000168  00800060  000012ce  00001382  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000317  008001c8  008001c8  000014ea  2**0
                  ALLOC
  3 .noinit       00000000  008004df  008004df  000015e4  2**0
                  CONTENTS
  4 .eeprom       000000fa  00810000  00810000  000014ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .stab         00002970  00000000  00000000  000015e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00001097  00000000  00000000  00003f54  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 51 00 	jmp	0xa2
       4:	0c 94 6c 00 	jmp	0xd8
       8:	0c 94 6c 00 	jmp	0xd8
       c:	0c 94 6c 00 	jmp	0xd8
      10:	0c 94 fb 03 	jmp	0x7f6
      14:	0c 94 f0 03 	jmp	0x7e0
      18:	0c 94 98 04 	jmp	0x930
      1c:	0c 94 6c 00 	jmp	0xd8
      20:	0c 94 6c 00 	jmp	0xd8
      24:	0c 94 6c 00 	jmp	0xd8
      28:	0c 94 e5 03 	jmp	0x7ca
      2c:	0c 94 b7 03 	jmp	0x76e
      30:	0c 94 6c 00 	jmp	0xd8
      34:	0c 94 2a 04 	jmp	0x854
      38:	0c 94 6f 04 	jmp	0x8de
      3c:	0c 94 6c 00 	jmp	0xd8
      40:	0c 94 6c 00 	jmp	0xd8
      44:	0c 94 6c 00 	jmp	0xd8
      48:	0c 94 6c 00 	jmp	0xd8
      4c:	0c 94 6c 00 	jmp	0xd8
      50:	0c 94 6c 00 	jmp	0xd8

00000054 <__ctors_end>:
      54:	3d 22       	and	r3, r29
      56:	20 09       	sbc	r18, r0
      58:	2c 0d       	add	r18, r12
      5a:	0a 00       	.word	0x000a	; ????

0000005c <text_cmd>:
      5c:	6d 6f 74 6f 72 00 00 00 00 00 73 70 65 65 64 00     motor.....speed.
      6c:	00 00 00 00 61 6e 67 6c 65 00 00 00 00 00 70 72     ....angle.....pr
      7c:	6f 67 72 61 6d 00 00 00 73 61 76 65 00 00 00 00     ogram...save....
      8c:	00 00 72 75 6e 00 00 00 00 00 00 00 00 00 00 00     ..run...........
      9c:	00 00 00 00 00 00                                   ......

000000a2 <__init>:
      a2:	11 24       	eor	r1, r1
      a4:	1f be       	out	0x3f, r1	; 63
      a6:	cf e5       	ldi	r28, 0x5F	; 95
      a8:	d8 e0       	ldi	r29, 0x08	; 8
      aa:	de bf       	out	0x3e, r29	; 62
      ac:	cd bf       	out	0x3d, r28	; 61

000000ae <__do_copy_data>:
      ae:	11 e0       	ldi	r17, 0x01	; 1
      b0:	a0 e6       	ldi	r26, 0x60	; 96
      b2:	b0 e0       	ldi	r27, 0x00	; 0
      b4:	ee ec       	ldi	r30, 0xCE	; 206
      b6:	f2 e1       	ldi	r31, 0x12	; 18
      b8:	02 c0       	rjmp	.+4      	; 0xbe

000000ba <.do_copy_data_loop>:
      ba:	05 90       	lpm	r0, Z+
      bc:	0d 92       	st	X+, r0

000000be <.do_copy_data_start>:
      be:	a8 3c       	cpi	r26, 0xC8	; 200
      c0:	b1 07       	cpc	r27, r17
      c2:	d9 f7       	brne	.-10     	; 0xba

000000c4 <__do_clear_bss>:
      c4:	14 e0       	ldi	r17, 0x04	; 4
      c6:	a8 ec       	ldi	r26, 0xC8	; 200
      c8:	b1 e0       	ldi	r27, 0x01	; 1
      ca:	01 c0       	rjmp	.+2      	; 0xce

000000cc <.do_clear_bss_loop>:
      cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
      ce:	af 3d       	cpi	r26, 0xDF	; 223
      d0:	b1 07       	cpc	r27, r17
      d2:	e1 f7       	brne	.-8      	; 0xcc
      d4:	0c 94 f7 04 	jmp	0x9ee

000000d8 <__bad_interrupt>:
      d8:	0c 94 00 00 	jmp	0x0

000000dc <delay>:

void delay ( uint16_t  time)
{
   uint16_t i;
   for (i = 0 ; i < time; i++);
      dc:	00 97       	sbiw	r24, 0x00	; 0
      de:	11 f0       	breq	.+4      	; 0xe4
      e0:	01 97       	sbiw	r24, 0x01	; 1
      e2:	fc cf       	rjmp	.-8      	; 0xdc
      e4:	08 95       	ret

000000e6 <set_motor_parameter>:

}

void  set_motor_parameter ( uint8_t mode)
{
   switch (mode)
      e6:	99 27       	eor	r25, r25
      e8:	82 30       	cpi	r24, 0x02	; 2
      ea:	91 05       	cpc	r25, r1
      ec:	81 f0       	breq	.+32     	; 0x10e
      ee:	83 30       	cpi	r24, 0x03	; 3
      f0:	91 05       	cpc	r25, r1
      f2:	2c f4       	brge	.+10     	; 0xfe
      f4:	00 97       	sbiw	r24, 0x00	; 0
      f6:	79 f1       	breq	.+94     	; 0x156
      f8:	01 97       	sbiw	r24, 0x01	; 1
      fa:	39 f0       	breq	.+14     	; 0x10a
      fc:	2c c0       	rjmp	.+88     	; 0x156
      fe:	84 30       	cpi	r24, 0x04	; 4
     100:	91 05       	cpc	r25, r1
     102:	f9 f0       	breq	.+62     	; 0x142
     104:	05 97       	sbiw	r24, 0x05	; 5
     106:	11 f1       	breq	.+68     	; 0x14c
     108:	26 c0       	rjmp	.+76     	; 0x156
   {
    case  MOTOR_FORWARD:
        g_mode[0] = MOTOR_FORWARD;		
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	01 c0       	rjmp	.+2      	; 0x110
		g_mode[1] = MOTOR_FORWARD;
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case  MOTOR_BACKWARD:
		g_mode[0] = MOTOR_BACKWARD;
     10e:	82 e0       	ldi	r24, 0x02	; 2
     110:	80 93 d6 01 	sts	0x01D6, r24
		g_mode[1] = MOTOR_BACKWARD;
     114:	80 93 d7 01 	sts	0x01D7, r24
		g_angle[0] = 1;
     118:	81 e0       	ldi	r24, 0x01	; 1
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	a0 e0       	ldi	r26, 0x00	; 0
     11e:	b0 e0       	ldi	r27, 0x00	; 0
     120:	80 93 e4 01 	sts	0x01E4, r24
     124:	90 93 e5 01 	sts	0x01E5, r25
     128:	a0 93 e6 01 	sts	0x01E6, r26
     12c:	b0 93 e7 01 	sts	0x01E7, r27
		g_angle[1] = 1;
     130:	80 93 e8 01 	sts	0x01E8, r24
     134:	90 93 e9 01 	sts	0x01E9, r25
     138:	a0 93 ea 01 	sts	0x01EA, r26
     13c:	b0 93 eb 01 	sts	0x01EB, r27
		break;
     140:	08 95       	ret
    case MOTOR_STOP:
		g_mode[0]  = MOTOR_STOP;
		g_mode[1]  = MOTOR_STOP;
		g_angle[0] = 0;
		g_angle[1] = 0;
		break;
	case MOTOR_TURN_LEFT:
		g_mode[0] = MOTOR_FORWARD;		
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	80 93 d6 01 	sts	0x01D6, r24
		g_mode[1] = MOTOR_BACKWARD;
     148:	82 e0       	ldi	r24, 0x02	; 2
     14a:	e4 cf       	rjmp	.-56     	; 0x114
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	case MOTOR_TURN_RIGHT:
		g_mode[0] = MOTOR_BACKWARD;
     14c:	82 e0       	ldi	r24, 0x02	; 2
     14e:	80 93 d6 01 	sts	0x01D6, r24
		g_mode[1] = MOTOR_FORWARD;
     152:	81 e0       	ldi	r24, 0x01	; 1
     154:	df cf       	rjmp	.-66     	; 0x114
		g_angle[0] = 1;
		g_angle[1] = 1;
		break;
	 default:
	 	g_mode[0]  = MOTOR_STOP;
     156:	10 92 d6 01 	sts	0x01D6, r1
		g_mode[1]  = MOTOR_STOP;
     15a:	10 92 d7 01 	sts	0x01D7, r1
		g_angle[0] = 0;
     15e:	10 92 e4 01 	sts	0x01E4, r1
     162:	10 92 e5 01 	sts	0x01E5, r1
     166:	10 92 e6 01 	sts	0x01E6, r1
     16a:	10 92 e7 01 	sts	0x01E7, r1
		g_angle[1] = 0;
     16e:	10 92 e8 01 	sts	0x01E8, r1
     172:	10 92 e9 01 	sts	0x01E9, r1
     176:	10 92 ea 01 	sts	0x01EA, r1
     17a:	10 92 eb 01 	sts	0x01EB, r1
     17e:	08 95       	ret
     180:	08 95       	ret

00000182 <cmd_decode>:
		break;
   }
  
}

 
// Run program which save in eeprom or g_program_buff
//  Mode =1 run from eeprom
//  Mode =2 run from buffer
void program_run (void)
{
   uint16_t i;
   uint8_t ch,j;
   uint8_t  buff[MAX_BUFF];
   
      i = 0;
 	  while ((ch = eeprom_read_byte(&g_program_eeprom[i])))   //Get EEPROM BYTE/BYTE
	  {
			g_program_buff[i] = ch;
			i++;
	  }
	  g_program_index = i;
   
 
   i = 0;
   j = 0;
   
   while ((ch = g_program_buff[i]))
   {
 		buff[j] = ch;
		j++;
		if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
		{	
// Copy to buffer 
			buff[j]  = 0;   // End with null for decode
			uart_puts(buff);
		    cmd_decode(buff);
 
// Check both finish before proceed next command		
 			while ((g_status[0] | g_status[1]))    
			{
 				delay (15000);                    // Need to put delay  to make it work. DOn't have time to figure out why ???
			}
			j = 0;
 		}
		
		i++;	 
   }
}



/* Command decode from g_rcv_buffer  will decode and action according to command in buffer
 
*/

int16_t cmd_decode (uint8_t *buffer_ptr)
{
     182:	df 92       	push	r13
     184:	ef 92       	push	r14
     186:	ff 92       	push	r15
     188:	0f 93       	push	r16
     18a:	1f 93       	push	r17
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
     190:	7c 01       	movw	r14, r24

 uint8_t  cmd_no =0;
 uint8_t  *cmd_argument;
 uint8_t   i,j ;
 
// Should repeat until end of buffer
 
// Loop until end of text

   cmd_argument = buffer_ptr;
     
   while ( cmd_no !=  CMD_LINE_END)     // Until end of line which mean g_motor will change
   {
 		cmd_no =  text_decode (buffer_ptr,cmd_argument);
     192:	b7 01       	movw	r22, r14
     194:	c7 01       	movw	r24, r14
     196:	0e 94 66 07 	call	0xecc
     19a:	d8 2e       	mov	r13, r24
#ifdef DEBUG		
//		uart_puts("Command :");
 		uart_putc(0x30+cmd_no);
     19c:	80 5d       	subi	r24, 0xD0	; 208
     19e:	0e 94 e0 06 	call	0xdc0
 		uart_putc('*');
     1a2:	8a e2       	ldi	r24, 0x2A	; 42
     1a4:	0e 94 e0 06 	call	0xdc0
 		uart_puts(cmd_argument);
     1a8:	c7 01       	movw	r24, r14
     1aa:	0e 94 e6 06 	call	0xdcc
#endif        
 		switch (cmd_no)
     1ae:	8d 2d       	mov	r24, r13
     1b0:	99 27       	eor	r25, r25
     1b2:	83 30       	cpi	r24, 0x03	; 3
     1b4:	91 05       	cpc	r25, r1
     1b6:	09 f4       	brne	.+2      	; 0x1ba
     1b8:	42 c0       	rjmp	.+132    	; 0x23e
     1ba:	84 30       	cpi	r24, 0x04	; 4
     1bc:	91 05       	cpc	r25, r1
     1be:	34 f4       	brge	.+12     	; 0x1cc
     1c0:	81 30       	cpi	r24, 0x01	; 1
     1c2:	91 05       	cpc	r25, r1
     1c4:	79 f0       	breq	.+30     	; 0x1e4
     1c6:	02 97       	sbiw	r24, 0x02	; 2
     1c8:	e1 f0       	breq	.+56     	; 0x202
     1ca:	f6 c0       	rjmp	.+492    	; 0x3b8
     1cc:	85 30       	cpi	r24, 0x05	; 5
     1ce:	91 05       	cpc	r25, r1
     1d0:	09 f4       	brne	.+2      	; 0x1d4
     1d2:	b3 c0       	rjmp	.+358    	; 0x33a
     1d4:	85 30       	cpi	r24, 0x05	; 5
     1d6:	91 05       	cpc	r25, r1
     1d8:	0c f4       	brge	.+2      	; 0x1dc
     1da:	a0 c0       	rjmp	.+320    	; 0x31c
     1dc:	06 97       	sbiw	r24, 0x06	; 6
     1de:	09 f4       	brne	.+2      	; 0x1e2
     1e0:	e8 c0       	rjmp	.+464    	; 0x3b2
     1e2:	ea c0       	rjmp	.+468    	; 0x3b8
		{
			case MOTOR_CMD: 
				g_motor = (uint8_t)atoi(cmd_argument);
     1e4:	c7 01       	movw	r24, r14
     1e6:	0e 94 4b 08 	call	0x1096
     1ea:	80 93 ec 01 	sts	0x01EC, r24
				if (g_motor > 0)
     1ee:	28 2f       	mov	r18, r24
     1f0:	88 23       	and	r24, r24
     1f2:	21 f0       	breq	.+8      	; 0x1fc
				   g_motor--;                //  > 0 Start from 0 need -1
     1f4:	21 50       	subi	r18, 0x01	; 1
     1f6:	20 93 ec 01 	sts	0x01EC, r18
     1fa:	e4 c0       	rjmp	.+456    	; 0x3c4
				else
				   g_motor = 0;
     1fc:	80 93 ec 01 	sts	0x01EC, r24
 				break;
     200:	e1 c0       	rjmp	.+450    	; 0x3c4
			case  SPEED_CMD:	
				i = (uint8_t)atoi(cmd_argument);
     202:	c7 01       	movw	r24, r14
     204:	0e 94 4b 08 	call	0x1096
     208:	18 2f       	mov	r17, r24
				if ( i >=  MOTOR_MAX_SPEED)
     20a:	89 30       	cpi	r24, 0x09	; 9
     20c:	10 f0       	brcs	.+4      	; 0x212
						i = MOTOR_MAX_SPEED;    // Start from 0
     20e:	19 e0       	ldi	r17, 0x09	; 9
     210:	01 c0       	rjmp	.+2      	; 0x214
				if (i)   // i > 0; 		
     212:	81 11       	cpse	r24, r1
					i--;   //Start from 0;		
     214:	11 50       	subi	r17, 0x01	; 1
				g_speed[g_motor] =  g_speed_table[i];
     216:	80 91 ec 01 	lds	r24, 0x01EC
     21a:	c8 2f       	mov	r28, r24
     21c:	dd 27       	eor	r29, r29
     21e:	de 01       	movw	r26, r28
     220:	a7 51       	subi	r26, 0x17	; 23
     222:	bd 4f       	sbci	r27, 0xFD	; 253
     224:	e1 2f       	mov	r30, r17
     226:	ff 27       	eor	r31, r31
     228:	e4 5a       	subi	r30, 0xA4	; 164
     22a:	fe 4f       	sbci	r31, 0xFE	; 254
     22c:	20 81       	ld	r18, Z
     22e:	2c 93       	st	X, r18
				if (g_speed[g_motor] == 0)
     230:	22 23       	and	r18, r18
     232:	09 f0       	breq	.+2      	; 0x236
     234:	c7 c0       	rjmp	.+398    	; 0x3c4
				        g_mode[g_motor] = MOTOR_STOP;
     236:	ca 52       	subi	r28, 0x2A	; 42
     238:	de 4f       	sbci	r29, 0xFE	; 254
     23a:	28 83       	st	Y, r18
  				break;
     23c:	c3 c0       	rjmp	.+390    	; 0x3c4
			case  ANGLE_CMD:   // Can be - 	             			 
     			g_angle[g_motor] = atoi(cmd_argument);
     23e:	80 91 ec 01 	lds	r24, 0x01EC
     242:	c8 2f       	mov	r28, r24
     244:	dd 27       	eor	r29, r29
     246:	8e 01       	movw	r16, r28
     248:	00 0f       	add	r16, r16
     24a:	11 1f       	adc	r17, r17
     24c:	00 0f       	add	r16, r16
     24e:	11 1f       	adc	r17, r17
     250:	0c 51       	subi	r16, 0x1C	; 28
     252:	1e 4f       	sbci	r17, 0xFE	; 254
     254:	c7 01       	movw	r24, r14
     256:	0e 94 4b 08 	call	0x1096
     25a:	9c 01       	movw	r18, r24
     25c:	44 27       	eor	r20, r20
     25e:	37 fd       	sbrc	r19, 7
     260:	40 95       	com	r20
     262:	54 2f       	mov	r21, r20
     264:	f8 01       	movw	r30, r16
     266:	20 83       	st	Z, r18
     268:	31 83       	std	Z+1, r19	; 0x01
     26a:	42 83       	std	Z+2, r20	; 0x02
     26c:	53 83       	std	Z+3, r21	; 0x03
				if (g_angle[g_motor] < 0)
     26e:	57 ff       	sbrs	r21, 7
     270:	12 c0       	rjmp	.+36     	; 0x296
				{   
						g_mode[g_motor] = MOTOR_BACKWARD;
     272:	fe 01       	movw	r30, r28
     274:	ea 52       	subi	r30, 0x2A	; 42
     276:	fe 4f       	sbci	r31, 0xFE	; 254
     278:	82 e0       	ldi	r24, 0x02	; 2
     27a:	80 83       	st	Z, r24
 
// Set g_angle to positive value by invert all bit and +1                
                        g_angle[g_motor] = (~(g_angle[g_motor])+1);
     27c:	66 27       	eor	r22, r22
     27e:	77 27       	eor	r23, r23
     280:	cb 01       	movw	r24, r22
     282:	62 1b       	sub	r22, r18
     284:	73 0b       	sbc	r23, r19
     286:	84 0b       	sbc	r24, r20
     288:	95 0b       	sbc	r25, r21
     28a:	f8 01       	movw	r30, r16
     28c:	60 83       	st	Z, r22
     28e:	71 83       	std	Z+1, r23	; 0x01
     290:	82 83       	std	Z+2, r24	; 0x02
     292:	93 83       	std	Z+3, r25	; 0x03
     294:	18 c0       	rjmp	.+48     	; 0x2c6
                        if  (g_angle[g_motor] > 1)
						{
 						   g_angle[g_motor] *= MOTOR_ANGLE_COEF;
						   g_status[g_motor] = 1;
 						   g_speed[g_motor] = g_speed_table[MOTOR_ANGLE_SPEED] ;
						}		
				}	
				else  if (g_angle[g_motor] == 0)
     296:	21 15       	cp	r18, r1
     298:	31 05       	cpc	r19, r1
     29a:	41 05       	cpc	r20, r1
     29c:	51 05       	cpc	r21, r1
     29e:	21 f4       	brne	.+8      	; 0x2a8
				       {  	
							g_mode[g_motor] = MOTOR_STOP;
     2a0:	ca 52       	subi	r28, 0x2A	; 42
     2a2:	de 4f       	sbci	r29, 0xFE	; 254
     2a4:	18 82       	st	Y, r1
     2a6:	2b c0       	rjmp	.+86     	; 0x2fe
 					   }
				else	  
				{
					if ((g_angle[g_motor] > 0))   //  +
     2a8:	12 16       	cp	r1, r18
     2aa:	13 06       	cpc	r1, r19
     2ac:	14 06       	cpc	r1, r20
     2ae:	15 06       	cpc	r1, r21
     2b0:	2c f4       	brge	.+10     	; 0x2bc
					{
						g_mode[g_motor] = MOTOR_FORWARD;
     2b2:	fe 01       	movw	r30, r28
     2b4:	ea 52       	subi	r30, 0x2A	; 42
     2b6:	fe 4f       	sbci	r31, 0xFE	; 254
     2b8:	81 e0       	ldi	r24, 0x01	; 1
     2ba:	80 83       	st	Z, r24
 					}
					if  (g_angle[g_motor] > 1)
     2bc:	f8 01       	movw	r30, r16
     2be:	60 81       	ld	r22, Z
     2c0:	71 81       	ldd	r23, Z+1	; 0x01
     2c2:	82 81       	ldd	r24, Z+2	; 0x02
     2c4:	93 81       	ldd	r25, Z+3	; 0x03
     2c6:	62 30       	cpi	r22, 0x02	; 2
     2c8:	71 05       	cpc	r23, r1
     2ca:	81 05       	cpc	r24, r1
     2cc:	91 05       	cpc	r25, r1
     2ce:	bc f0       	brlt	.+46     	; 0x2fe
					{
 						g_angle[g_motor] *=  MOTOR_ANGLE_COEF;	
     2d0:	24 e6       	ldi	r18, 0x64	; 100
     2d2:	30 e0       	ldi	r19, 0x00	; 0
     2d4:	40 e0       	ldi	r20, 0x00	; 0
     2d6:	50 e0       	ldi	r21, 0x00	; 0
     2d8:	0e 94 12 09 	call	0x1224
     2dc:	dc 01       	movw	r26, r24
     2de:	cb 01       	movw	r24, r22
     2e0:	f8 01       	movw	r30, r16
     2e2:	80 83       	st	Z, r24
     2e4:	91 83       	std	Z+1, r25	; 0x01
     2e6:	a2 83       	std	Z+2, r26	; 0x02
     2e8:	b3 83       	std	Z+3, r27	; 0x03
						g_status[g_motor] = 1;
     2ea:	fe 01       	movw	r30, r28
     2ec:	e4 53       	subi	r30, 0x34	; 52
     2ee:	fe 4f       	sbci	r31, 0xFE	; 254
     2f0:	81 e0       	ldi	r24, 0x01	; 1
     2f2:	80 83       	st	Z, r24
  						g_speed[g_motor]  = g_speed_table[MOTOR_ANGLE_SPEED] ;
     2f4:	c7 51       	subi	r28, 0x17	; 23
     2f6:	dd 4f       	sbci	r29, 0xFD	; 253
     2f8:	80 91 5f 01 	lds	r24, 0x015F
     2fc:	88 83       	st	Y, r24
					}
 				}
                g_pos[g_motor] = 0;
     2fe:	80 91 ec 01 	lds	r24, 0x01EC
     302:	e8 2f       	mov	r30, r24
     304:	ff 27       	eor	r31, r31
     306:	ee 0f       	add	r30, r30
     308:	ff 1f       	adc	r31, r31
     30a:	ee 0f       	add	r30, r30
     30c:	ff 1f       	adc	r31, r31
     30e:	e2 53       	subi	r30, 0x32	; 50
     310:	fe 4f       	sbci	r31, 0xFE	; 254
     312:	10 82       	st	Z, r1
     314:	11 82       	std	Z+1, r1	; 0x01
     316:	12 82       	std	Z+2, r1	; 0x02
     318:	13 82       	std	Z+3, r1	; 0x03
				break;	
     31a:	54 c0       	rjmp	.+168    	; 0x3c4
			case PROGRAM_CMD:
				g_program_flag = (uint8_t)atoi(cmd_argument);
     31c:	c7 01       	movw	r24, r14
     31e:	0e 94 4b 08 	call	0x1096
     322:	80 93 ca 01 	sts	0x01CA, r24
				if (g_program_flag)   // Start  program save in buffer
     326:	88 23       	and	r24, r24
     328:	19 f0       	breq	.+6      	; 0x330
				{
					uart_puts ("Program Start to save : ");
     32a:	85 e6       	ldi	r24, 0x65	; 101
     32c:	91 e0       	ldi	r25, 0x01	; 1
     32e:	3a c0       	rjmp	.+116    	; 0x3a4
				     g_program_index = 0;
				}
				else
				{  
					uart_puts ("Program End : ");
     330:	8e e7       	ldi	r24, 0x7E	; 126
     332:	91 e0       	ldi	r25, 0x01	; 1
     334:	0e 94 e6 06 	call	0xdcc
				}
				break;
     338:	45 c0       	rjmp	.+138    	; 0x3c4
 			case SAVE_CMD:
				j = (uint8_t)atoi(cmd_argument);
     33a:	c7 01       	movw	r24, r14
     33c:	0e 94 4b 08 	call	0x1096
				if ( j > 0)    // Save commmand to eeprom
     340:	88 23       	and	r24, r24
     342:	09 f4       	brne	.+2      	; 0x346
     344:	3f c0       	rjmp	.+126    	; 0x3c4
                {
					g_program_buff[g_program_index] = 0x00 ;  // Put null at the end
     346:	80 91 c8 01 	lds	r24, 0x01C8
     34a:	90 91 c9 01 	lds	r25, 0x01C9
     34e:	fc 01       	movw	r30, r24
     350:	e0 5a       	subi	r30, 0xA0	; 160
     352:	ff 4f       	sbci	r31, 0xFF	; 255
     354:	10 82       	st	Z, r1
                    g_program_index++;   
     356:	01 96       	adiw	r24, 0x01	; 1
     358:	90 93 c9 01 	sts	0x01C9, r25
     35c:	80 93 c8 01 	sts	0x01C8, r24
                    for ( i =0; i < g_program_index; i++)
     360:	10 81       	ld	r17, Z
     362:	89 2b       	or	r24, r25
     364:	b1 f0       	breq	.+44     	; 0x392
                    {
						while (!eeprom_is_ready());
     366:	e1 99       	sbic	0x1c, 1	; 28
     368:	fe cf       	rjmp	.-4      	; 0x366
							eeprom_write_byte(&g_program_eeprom[i],g_program_buff[i]);
     36a:	81 2f       	mov	r24, r17
     36c:	99 27       	eor	r25, r25
     36e:	fc 01       	movw	r30, r24
     370:	e0 5a       	subi	r30, 0xA0	; 160
     372:	ff 4f       	sbci	r31, 0xFF	; 255
     374:	60 81       	ld	r22, Z
     376:	80 50       	subi	r24, 0x00	; 0
     378:	90 40       	sbci	r25, 0x00	; 0
     37a:	0e 94 80 08 	call	0x1100
     37e:	1f 5f       	subi	r17, 0xFF	; 255
     380:	21 2f       	mov	r18, r17
     382:	33 27       	eor	r19, r19
     384:	80 91 c8 01 	lds	r24, 0x01C8
     388:	90 91 c9 01 	lds	r25, 0x01C9
     38c:	28 17       	cp	r18, r24
     38e:	39 07       	cpc	r19, r25
     390:	50 f3       	brcs	.-44     	; 0x366
					}
					debug_value( g_program_index,10);
     392:	6a e0       	ldi	r22, 0x0A	; 10
     394:	80 91 c8 01 	lds	r24, 0x01C8
     398:	90 91 c9 01 	lds	r25, 0x01C9
     39c:	0e 94 f9 06 	call	0xdf2
					uart_puts ("Save complete ");
     3a0:	8d e8       	ldi	r24, 0x8D	; 141
     3a2:	91 e0       	ldi	r25, 0x01	; 1
     3a4:	0e 94 e6 06 	call	0xdcc
					g_program_index = 0;	
     3a8:	10 92 c9 01 	sts	0x01C9, r1
     3ac:	10 92 c8 01 	sts	0x01C8, r1
				}
				break;
     3b0:	09 c0       	rjmp	.+18     	; 0x3c4
		    case RUN_CMD:
			    program_run();
     3b2:	0e 94 f0 01 	call	0x3e0
			    break;
     3b6:	06 c0       	rjmp	.+12     	; 0x3c4
 			default:
			    uart_putc(0x0D);
     3b8:	8d e0       	ldi	r24, 0x0D	; 13
     3ba:	0e 94 e0 06 	call	0xdc0
				uart_putc(0x0A);
     3be:	8a e0       	ldi	r24, 0x0A	; 10
     3c0:	0e 94 e0 06 	call	0xdc0
//			    uart_puts("Command not found ");
 		        break;	  
     3c4:	ff ef       	ldi	r31, 0xFF	; 255
     3c6:	df 16       	cp	r13, r31
     3c8:	09 f0       	breq	.+2      	; 0x3cc
     3ca:	e3 ce       	rjmp	.-570    	; 0x192
		}		
    }
 
 return 0; 
}
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	1f 91       	pop	r17
     3d6:	0f 91       	pop	r16
     3d8:	ff 90       	pop	r15
     3da:	ef 90       	pop	r14
     3dc:	df 90       	pop	r13
     3de:	08 95       	ret

000003e0 <program_run>:
     3e0:	cf 92       	push	r12
     3e2:	df 92       	push	r13
     3e4:	ef 92       	push	r14
     3e6:	ff 92       	push	r15
     3e8:	0f 93       	push	r16
     3ea:	1f 93       	push	r17
     3ec:	cf 93       	push	r28
     3ee:	df 93       	push	r29
     3f0:	cd b7       	in	r28, 0x3d	; 61
     3f2:	de b7       	in	r29, 0x3e	; 62
     3f4:	ca 5f       	subi	r28, 0xFA	; 250
     3f6:	d0 40       	sbci	r29, 0x00	; 0
     3f8:	0f b6       	in	r0, 0x3f	; 63
     3fa:	f8 94       	cli
     3fc:	de bf       	out	0x3e, r29	; 62
     3fe:	0f be       	out	0x3f, r0	; 63
     400:	cd bf       	out	0x3d, r28	; 61
     402:	ee 24       	eor	r14, r14
     404:	ff 24       	eor	r15, r15
     406:	30 e6       	ldi	r19, 0x60	; 96
     408:	c3 2e       	mov	r12, r19
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	d3 2e       	mov	r13, r19
     40e:	00 e0       	ldi	r16, 0x00	; 0
     410:	10 e0       	ldi	r17, 0x00	; 0
     412:	08 c0       	rjmp	.+16     	; 0x424
     414:	f6 01       	movw	r30, r12
     416:	81 93       	st	Z+, r24
     418:	6f 01       	movw	r12, r30
     41a:	08 94       	sec
     41c:	e1 1c       	adc	r14, r1
     41e:	f1 1c       	adc	r15, r1
     420:	0f 5f       	subi	r16, 0xFF	; 255
     422:	1f 4f       	sbci	r17, 0xFF	; 255
     424:	c8 01       	movw	r24, r16
     426:	0e 94 78 08 	call	0x10f0
     42a:	88 23       	and	r24, r24
     42c:	99 f7       	brne	.-26     	; 0x414
     42e:	f0 92 c9 01 	sts	0x01C9, r15
     432:	e0 92 c8 01 	sts	0x01C8, r14
     436:	98 2f       	mov	r25, r24
     438:	80 91 60 00 	lds	r24, 0x0060
     43c:	88 23       	and	r24, r24
     43e:	69 f1       	breq	.+90     	; 0x49a
     440:	20 e6       	ldi	r18, 0x60	; 96
     442:	e2 2e       	mov	r14, r18
     444:	20 e0       	ldi	r18, 0x00	; 0
     446:	f2 2e       	mov	r15, r18
     448:	8e 01       	movw	r16, r28
     44a:	0f 5f       	subi	r16, 0xFF	; 255
     44c:	1f 4f       	sbci	r17, 0xFF	; 255
     44e:	f8 01       	movw	r30, r16
     450:	e9 0f       	add	r30, r25
     452:	f1 1d       	adc	r31, r1
     454:	80 83       	st	Z, r24
     456:	9f 5f       	subi	r25, 0xFF	; 255
     458:	8d 30       	cpi	r24, 0x0D	; 13
     45a:	11 f0       	breq	.+4      	; 0x460
     45c:	8a 30       	cpi	r24, 0x0A	; 10
     45e:	b1 f4       	brne	.+44     	; 0x48c
     460:	f8 01       	movw	r30, r16
     462:	e9 0f       	add	r30, r25
     464:	f1 1d       	adc	r31, r1
     466:	10 82       	st	Z, r1
     468:	c8 01       	movw	r24, r16
     46a:	0e 94 e6 06 	call	0xdcc
     46e:	c8 01       	movw	r24, r16
     470:	0e 94 c1 00 	call	0x182
     474:	80 91 cc 01 	lds	r24, 0x01CC
     478:	90 91 cd 01 	lds	r25, 0x01CD
     47c:	89 2b       	or	r24, r25
     47e:	29 f0       	breq	.+10     	; 0x48a
     480:	88 e9       	ldi	r24, 0x98	; 152
     482:	9a e3       	ldi	r25, 0x3A	; 58
     484:	0e 94 6e 00 	call	0xdc
     488:	f5 cf       	rjmp	.-22     	; 0x474
     48a:	90 e0       	ldi	r25, 0x00	; 0
     48c:	08 94       	sec
     48e:	e1 1c       	adc	r14, r1
     490:	f1 1c       	adc	r15, r1
     492:	f7 01       	movw	r30, r14
     494:	80 81       	ld	r24, Z
     496:	88 23       	and	r24, r24
     498:	b9 f6       	brne	.-82     	; 0x448
     49a:	c6 50       	subi	r28, 0x06	; 6
     49c:	df 4f       	sbci	r29, 0xFF	; 255
     49e:	0f b6       	in	r0, 0x3f	; 63
     4a0:	f8 94       	cli
     4a2:	de bf       	out	0x3e, r29	; 62
     4a4:	0f be       	out	0x3f, r0	; 63
     4a6:	cd bf       	out	0x3d, r28	; 61
     4a8:	df 91       	pop	r29
     4aa:	cf 91       	pop	r28
     4ac:	1f 91       	pop	r17
     4ae:	0f 91       	pop	r16
     4b0:	ff 90       	pop	r15
     4b2:	ef 90       	pop	r14
     4b4:	df 90       	pop	r13
     4b6:	cf 90       	pop	r12
     4b8:	08 95       	ret

000004ba <calculate_backemf>:





/* Calculate backemf and save in g_pos

*/
void  calculate_backemf (uint8_t motor)
{
     4ba:	cf 92       	push	r12
     4bc:	df 92       	push	r13
     4be:	ef 92       	push	r14
     4c0:	ff 92       	push	r15
     4c2:	0f 93       	push	r16
     4c4:	1f 93       	push	r17
     4c6:	cf 93       	push	r28
     4c8:	df 93       	push	r29
     4ca:	18 2f       	mov	r17, r24
     int16_t backemf=0;
  // Read backemf
     static uint8_t  i = 0;

	adc_init(1);
     4cc:	81 e0       	ldi	r24, 0x01	; 1
     4ce:	0e 94 43 07 	call	0xe86
	backemf = read_adc(g_adc_channel[motor]);	
     4d2:	c1 2f       	mov	r28, r17
     4d4:	dd 27       	eor	r29, r29
     4d6:	fe 01       	movw	r30, r28
     4d8:	e6 5a       	subi	r30, 0xA6	; 166
     4da:	fe 4f       	sbci	r31, 0xFE	; 254
     4dc:	80 81       	ld	r24, Z
     4de:	0e 94 58 07 	call	0xeb0
     4e2:	9c 01       	movw	r18, r24
// Cut offset	
	if ((backemf > 0) && (backemf < MOTOR_OFFSET))
     4e4:	01 97       	sbiw	r24, 0x01	; 1
     4e6:	c1 97       	sbiw	r24, 0x31	; 49
     4e8:	10 f4       	brcc	.+4      	; 0x4ee
			backemf =0;
     4ea:	20 e0       	ldi	r18, 0x00	; 0
     4ec:	30 e0       	ldi	r19, 0x00	; 0
			
// Negative convert to positive with 2 complement	
	if (g_mode[motor] == MOTOR_STOP)   
     4ee:	fe 01       	movw	r30, r28
     4f0:	ea 52       	subi	r30, 0x2A	; 42
     4f2:	fe 4f       	sbci	r31, 0xFE	; 254
     4f4:	80 81       	ld	r24, Z
     4f6:	88 23       	and	r24, r24
     4f8:	59 f4       	brne	.+22     	; 0x510
    {	
		if (backemf & 0x200)
     4fa:	c9 01       	movw	r24, r18
     4fc:	89 2f       	mov	r24, r25
     4fe:	99 27       	eor	r25, r25
     500:	86 95       	lsr	r24
     502:	80 ff       	sbrs	r24, 0
     504:	05 c0       	rjmp	.+10     	; 0x510
		{
		    backemf = (~(backemf) & (0x03FF))+1;
     506:	20 95       	com	r18
     508:	30 95       	com	r19
     50a:	33 70       	andi	r19, 0x03	; 3
     50c:	2f 5f       	subi	r18, 0xFF	; 255
     50e:	3f 4f       	sbci	r19, 0xFF	; 255
 		}		
	}		
			
	if (g_mode[motor] == MOTOR_FORWARD)   // Motor stop backemf -  Forward backemf +
     510:	fe 01       	movw	r30, r28
     512:	ea 52       	subi	r30, 0x2A	; 42
     514:	fe 4f       	sbci	r31, 0xFE	; 254
     516:	80 81       	ld	r24, Z
     518:	81 30       	cpi	r24, 0x01	; 1
     51a:	81 f4       	brne	.+32     	; 0x53c
    {	
		if (backemf & 0x200)
     51c:	c9 01       	movw	r24, r18
     51e:	89 2f       	mov	r24, r25
     520:	99 27       	eor	r25, r25
     522:	86 95       	lsr	r24
     524:	ac 01       	movw	r20, r24
     526:	41 70       	andi	r20, 0x01	; 1
     528:	50 70       	andi	r21, 0x00	; 0
     52a:	80 ff       	sbrs	r24, 0
     52c:	06 c0       	rjmp	.+12     	; 0x53a
		{
		    backemf = (~(backemf) & (0x03FF))+1;
     52e:	20 95       	com	r18
     530:	30 95       	com	r19
     532:	33 70       	andi	r19, 0x03	; 3
     534:	2f 5f       	subi	r18, 0xFF	; 255
     536:	3f 4f       	sbci	r19, 0xFF	; 255
     538:	01 c0       	rjmp	.+2      	; 0x53c
 		}
		else
			backemf = 0;
     53a:	9a 01       	movw	r18, r20
    }
	if (g_mode[motor] == MOTOR_BACKWARD)   // Motor stop backemf +  backward backemf -
     53c:	fe 01       	movw	r30, r28
     53e:	ea 52       	subi	r30, 0x2A	; 42
     540:	fe 4f       	sbci	r31, 0xFE	; 254
     542:	80 81       	ld	r24, Z
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	41 f4       	brne	.+16     	; 0x558
    {	
		if (backemf & 0x200)
     548:	c9 01       	movw	r24, r18
     54a:	89 2f       	mov	r24, r25
     54c:	99 27       	eor	r25, r25
     54e:	86 95       	lsr	r24
     550:	80 ff       	sbrs	r24, 0
     552:	02 c0       	rjmp	.+4      	; 0x558
		{
			backemf =0;
     554:	20 e0       	ldi	r18, 0x00	; 0
     556:	30 e0       	ldi	r19, 0x00	; 0
		}
    }
	
	g_pos[motor] += backemf;
     558:	fe 01       	movw	r30, r28
     55a:	ee 0f       	add	r30, r30
     55c:	ff 1f       	adc	r31, r31
     55e:	ee 0f       	add	r30, r30
     560:	ff 1f       	adc	r31, r31
     562:	8f 01       	movw	r16, r30
     564:	02 53       	subi	r16, 0x32	; 50
     566:	1e 4f       	sbci	r17, 0xFE	; 254
     568:	69 01       	movw	r12, r18
     56a:	ee 24       	eor	r14, r14
     56c:	d7 fc       	sbrc	r13, 7
     56e:	e0 94       	com	r14
     570:	fe 2c       	mov	r15, r14
     572:	d8 01       	movw	r26, r16
     574:	2d 91       	ld	r18, X+
     576:	3d 91       	ld	r19, X+
     578:	4d 91       	ld	r20, X+
     57a:	5c 91       	ld	r21, X
     57c:	13 97       	sbiw	r26, 0x03	; 3
     57e:	2c 0d       	add	r18, r12
     580:	3d 1d       	adc	r19, r13
     582:	4e 1d       	adc	r20, r14
     584:	5f 1d       	adc	r21, r15
     586:	2d 93       	st	X+, r18
     588:	3d 93       	st	X+, r19
     58a:	4d 93       	st	X+, r20
     58c:	5c 93       	st	X, r21
     58e:	13 97       	sbiw	r26, 0x03	; 3
    if (g_mode[motor] != MOTOR_STOP)	
     590:	be 01       	movw	r22, r28
     592:	6a 52       	subi	r22, 0x2A	; 42
     594:	7e 4f       	sbci	r23, 0xFE	; 254
     596:	db 01       	movw	r26, r22
     598:	fc 90       	ld	r15, X
     59a:	ff 20       	and	r15, r15
     59c:	11 f0       	breq	.+4      	; 0x5a2
 	{   
//	    i++;
//		if (i == 100 )
		{
//		    uart_putc(motor+0x30);
//			uart_putc('-');
//			debug_value(backemf,10);
			i = 0;
     59e:	10 92 d8 01 	sts	0x01D8, r1
		}
	}	
//Compare voltage	
	if (((g_angle[motor] > 1)) && ( g_mode[motor] != MOTOR_STOP))
     5a2:	ec 51       	subi	r30, 0x1C	; 28
     5a4:	fe 4f       	sbci	r31, 0xFE	; 254
     5a6:	80 81       	ld	r24, Z
     5a8:	91 81       	ldd	r25, Z+1	; 0x01
     5aa:	a2 81       	ldd	r26, Z+2	; 0x02
     5ac:	b3 81       	ldd	r27, Z+3	; 0x03
     5ae:	82 30       	cpi	r24, 0x02	; 2
     5b0:	91 05       	cpc	r25, r1
     5b2:	a1 05       	cpc	r26, r1
     5b4:	b1 05       	cpc	r27, r1
     5b6:	ec f0       	brlt	.+58     	; 0x5f2
     5b8:	ff 20       	and	r15, r15
     5ba:	d9 f0       	breq	.+54     	; 0x5f2
	{   
//Compare voltage sum	
		if ( g_pos[motor]  >= (g_angle[motor]))  //  Check for position
     5bc:	28 17       	cp	r18, r24
     5be:	39 07       	cpc	r19, r25
     5c0:	4a 07       	cpc	r20, r26
     5c2:	5b 07       	cpc	r21, r27
     5c4:	b4 f0       	brlt	.+44     	; 0x5f2
		{
			g_mode[motor] = MOTOR_STOP;			
     5c6:	fb 01       	movw	r30, r22
     5c8:	10 82       	st	Z, r1
 			uart_puts ("Voltage SUM");
     5ca:	8c e9       	ldi	r24, 0x9C	; 156
     5cc:	91 e0       	ldi	r25, 0x01	; 1
     5ce:	0e 94 e6 06 	call	0xdcc
			debug_lvalue(g_pos[motor],10);
     5d2:	4a e0       	ldi	r20, 0x0A	; 10
     5d4:	d8 01       	movw	r26, r16
     5d6:	6d 91       	ld	r22, X+
     5d8:	7d 91       	ld	r23, X+
     5da:	8d 91       	ld	r24, X+
     5dc:	9c 91       	ld	r25, X
     5de:	0e 94 18 07 	call	0xe30
			g_pos[motor] =0;	
     5e2:	f8 01       	movw	r30, r16
     5e4:	10 82       	st	Z, r1
     5e6:	11 82       	std	Z+1, r1	; 0x01
     5e8:	12 82       	std	Z+2, r1	; 0x02
     5ea:	13 82       	std	Z+3, r1	; 0x03
            g_status[motor] = 0;    // Clear status proceed with next command			
     5ec:	c4 53       	subi	r28, 0x34	; 52
     5ee:	de 4f       	sbci	r29, 0xFE	; 254
     5f0:	18 82       	st	Y, r1
     5f2:	df 91       	pop	r29
     5f4:	cf 91       	pop	r28
     5f6:	1f 91       	pop	r17
     5f8:	0f 91       	pop	r16
     5fa:	ff 90       	pop	r15
     5fc:	ef 90       	pop	r14
     5fe:	df 90       	pop	r13
     600:	cf 90       	pop	r12
     602:	08 95       	ret

00000604 <remote_decode>:
		}
	}
 		
}



/* This subroutine will handle IR remote decode by getting remote code from Interrupt handle for input capture
and will response  to each remote key. For other applications user can modified here for different remote active
However this routine support Sony remote control only
   global effect   g_irint;
*/

void remote_decode ( uint16_t ircode)
{ 
     604:	cf 93       	push	r28

  uint8_t set_speed = 8 ;
     606:	c8 e0       	ldi	r28, 0x08	; 8
  switch ( ircode)
     608:	28 e0       	ldi	r18, 0x08	; 8
     60a:	80 31       	cpi	r24, 0x10	; 16
     60c:	92 07       	cpc	r25, r18
     60e:	09 f4       	brne	.+2      	; 0x612
     610:	57 c0       	rjmp	.+174    	; 0x6c0
     612:	28 e0       	ldi	r18, 0x08	; 8
     614:	81 31       	cpi	r24, 0x11	; 17
     616:	92 07       	cpc	r25, r18
     618:	30 f5       	brcc	.+76     	; 0x666
     61a:	22 e0       	ldi	r18, 0x02	; 2
     61c:	80 31       	cpi	r24, 0x10	; 16
     61e:	92 07       	cpc	r25, r18
     620:	09 f4       	brne	.+2      	; 0x624
     622:	54 c0       	rjmp	.+168    	; 0x6cc
     624:	22 e0       	ldi	r18, 0x02	; 2
     626:	81 31       	cpi	r24, 0x11	; 17
     628:	92 07       	cpc	r25, r18
     62a:	60 f4       	brcc	.+24     	; 0x644
     62c:	80 39       	cpi	r24, 0x90	; 144
     62e:	91 05       	cpc	r25, r1
     630:	09 f4       	brne	.+2      	; 0x634
     632:	86 c0       	rjmp	.+268    	; 0x740
     634:	81 39       	cpi	r24, 0x91	; 145
     636:	91 05       	cpc	r25, r1
     638:	08 f0       	brcs	.+2      	; 0x63c
     63a:	8e c0       	rjmp	.+284    	; 0x758
     63c:	40 97       	sbiw	r24, 0x10	; 16
     63e:	09 f4       	brne	.+2      	; 0x642
     640:	3d c0       	rjmp	.+122    	; 0x6bc
     642:	8a c0       	rjmp	.+276    	; 0x758
     644:	24 e0       	ldi	r18, 0x04	; 4
     646:	80 39       	cpi	r24, 0x90	; 144
     648:	92 07       	cpc	r25, r18
     64a:	09 f4       	brne	.+2      	; 0x64e
     64c:	80 c0       	rjmp	.+256    	; 0x74e
     64e:	24 e0       	ldi	r18, 0x04	; 4
     650:	81 39       	cpi	r24, 0x91	; 145
     652:	92 07       	cpc	r25, r18
     654:	20 f4       	brcc	.+8      	; 0x65e
     656:	80 51       	subi	r24, 0x10	; 16
     658:	94 40       	sbci	r25, 0x04	; 4
     65a:	a1 f1       	breq	.+104    	; 0x6c4
     65c:	7d c0       	rjmp	.+250    	; 0x758
     65e:	80 51       	subi	r24, 0x10	; 16
     660:	96 40       	sbci	r25, 0x06	; 6
     662:	c1 f1       	breq	.+112    	; 0x6d4
     664:	79 c0       	rjmp	.+242    	; 0x758
     666:	2a e0       	ldi	r18, 0x0A	; 10
     668:	80 35       	cpi	r24, 0x50	; 80
     66a:	92 07       	cpc	r25, r18
     66c:	09 f4       	brne	.+2      	; 0x670
     66e:	6c c0       	rjmp	.+216    	; 0x748
     670:	2a e0       	ldi	r18, 0x0A	; 10
     672:	81 35       	cpi	r24, 0x51	; 81
     674:	92 07       	cpc	r25, r18
     676:	88 f4       	brcc	.+34     	; 0x69a
     678:	29 e0       	ldi	r18, 0x09	; 9
     67a:	80 31       	cpi	r24, 0x10	; 16
     67c:	92 07       	cpc	r25, r18
     67e:	71 f1       	breq	.+92     	; 0x6dc
     680:	29 e0       	ldi	r18, 0x09	; 9
     682:	81 31       	cpi	r24, 0x11	; 17
     684:	92 07       	cpc	r25, r18
     686:	28 f4       	brcc	.+10     	; 0x692
     688:	80 59       	subi	r24, 0x90	; 144
     68a:	98 40       	sbci	r25, 0x08	; 8
     68c:	09 f4       	brne	.+2      	; 0x690
     68e:	5a c0       	rjmp	.+180    	; 0x744
     690:	63 c0       	rjmp	.+198    	; 0x758
     692:	80 51       	subi	r24, 0x10	; 16
     694:	9a 40       	sbci	r25, 0x0A	; 10
     696:	e1 f0       	breq	.+56     	; 0x6d0
     698:	5f c0       	rjmp	.+190    	; 0x758
     69a:	2c e0       	ldi	r18, 0x0C	; 12
     69c:	80 39       	cpi	r24, 0x90	; 144
     69e:	92 07       	cpc	r25, r18
     6a0:	09 f4       	brne	.+2      	; 0x6a4
     6a2:	57 c0       	rjmp	.+174    	; 0x752
     6a4:	2c e0       	ldi	r18, 0x0C	; 12
     6a6:	81 39       	cpi	r24, 0x91	; 145
     6a8:	92 07       	cpc	r25, r18
     6aa:	20 f4       	brcc	.+8      	; 0x6b4
     6ac:	80 51       	subi	r24, 0x10	; 16
     6ae:	9c 40       	sbci	r25, 0x0C	; 12
     6b0:	59 f0       	breq	.+22     	; 0x6c8
     6b2:	52 c0       	rjmp	.+164    	; 0x758
     6b4:	80 51       	subi	r24, 0x10	; 16
     6b6:	9e 40       	sbci	r25, 0x0E	; 14
     6b8:	79 f0       	breq	.+30     	; 0x6d8
     6ba:	4e c0       	rjmp	.+156    	; 0x758
	   {
	    case IR_TV_1:	
 			set_speed = 0;
     6bc:	c0 e0       	ldi	r28, 0x00	; 0
			 break;
     6be:	4c c0       	rjmp	.+152    	; 0x758
		case IR_TV_2:
			set_speed =1;
     6c0:	c1 e0       	ldi	r28, 0x01	; 1
			break;
     6c2:	4a c0       	rjmp	.+148    	; 0x758
	    case IR_TV_3:
 			set_speed =2;			
     6c4:	c2 e0       	ldi	r28, 0x02	; 2
			break;
     6c6:	48 c0       	rjmp	.+144    	; 0x758
		case IR_TV_4:
 			set_speed =3;			
     6c8:	c3 e0       	ldi	r28, 0x03	; 3
			 break;
     6ca:	46 c0       	rjmp	.+140    	; 0x758
	    case IR_TV_5:
 			set_speed =4;			
     6cc:	c4 e0       	ldi	r28, 0x04	; 4
			 break;
     6ce:	44 c0       	rjmp	.+136    	; 0x758
		case IR_TV_6:
 			set_speed = 5;			
     6d0:	c5 e0       	ldi	r28, 0x05	; 5
			 break;
     6d2:	42 c0       	rjmp	.+132    	; 0x758
	    case IR_TV_7:
 			set_speed = 6;			
     6d4:	c6 e0       	ldi	r28, 0x06	; 6
			break;
     6d6:	40 c0       	rjmp	.+128    	; 0x758
		case IR_TV_8:
 			set_speed = 7;			
     6d8:	c7 e0       	ldi	r28, 0x07	; 7
			break;
     6da:	3e c0       	rjmp	.+124    	; 0x758
	    case IR_TV_9:
 			set_speed =8;			
			break;
		case IR_TV_0:
			set_motor_parameter (MOTOR_STOP);
     6dc:	80 e0       	ldi	r24, 0x00	; 0
     6de:	0e 94 73 00 	call	0xe6
			uart_puts ("Voltage SUM 1");
     6e2:	88 ea       	ldi	r24, 0xA8	; 168
     6e4:	91 e0       	ldi	r25, 0x01	; 1
     6e6:	0e 94 e6 06 	call	0xdcc
			debug_lvalue(g_pos[0],10);
     6ea:	4a e0       	ldi	r20, 0x0A	; 10
     6ec:	60 91 ce 01 	lds	r22, 0x01CE
     6f0:	70 91 cf 01 	lds	r23, 0x01CF
     6f4:	80 91 d0 01 	lds	r24, 0x01D0
     6f8:	90 91 d1 01 	lds	r25, 0x01D1
     6fc:	0e 94 18 07 	call	0xe30
			g_pos[0] =0;
     700:	10 92 ce 01 	sts	0x01CE, r1
     704:	10 92 cf 01 	sts	0x01CF, r1
     708:	10 92 d0 01 	sts	0x01D0, r1
     70c:	10 92 d1 01 	sts	0x01D1, r1
			uart_puts ("Voltage SUM 2");
     710:	86 eb       	ldi	r24, 0xB6	; 182
     712:	91 e0       	ldi	r25, 0x01	; 1
     714:	0e 94 e6 06 	call	0xdcc
			debug_lvalue(g_pos[1],10);
     718:	4a e0       	ldi	r20, 0x0A	; 10
     71a:	60 91 d2 01 	lds	r22, 0x01D2
     71e:	70 91 d3 01 	lds	r23, 0x01D3
     722:	80 91 d4 01 	lds	r24, 0x01D4
     726:	90 91 d5 01 	lds	r25, 0x01D5
     72a:	0e 94 18 07 	call	0xe30
			g_pos[1] =0;
     72e:	10 92 d2 01 	sts	0x01D2, r1
     732:	10 92 d3 01 	sts	0x01D3, r1
     736:	10 92 d4 01 	sts	0x01D4, r1
     73a:	10 92 d5 01 	sts	0x01D5, r1
			break;
     73e:	0c c0       	rjmp	.+24     	; 0x758
		case IR_TV_CHUP:
			set_motor_parameter(MOTOR_FORWARD);
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	08 c0       	rjmp	.+16     	; 0x754
			break;
		case IR_TV_CHDOWN:							
			set_motor_parameter(MOTOR_BACKWARD);
     744:	82 e0       	ldi	r24, 0x02	; 2
     746:	06 c0       	rjmp	.+12     	; 0x754
			break;
		case IR_TV_TVMUTE:
			break;
		case  IR_TV_TVPOWER:
		  	break;
		case   IR_TV_TVAV:
		    program_run();
     748:	0e 94 f0 01 	call	0x3e0
		    break;
     74c:	05 c0       	rjmp	.+10     	; 0x758
		case  IR_TV_VOLUP:
            set_motor_parameter(MOTOR_TURN_LEFT);
     74e:	84 e0       	ldi	r24, 0x04	; 4
     750:	01 c0       	rjmp	.+2      	; 0x754
			break;
		case  IR_TV_VOLDOWN:                 			
		    set_motor_parameter(MOTOR_TURN_RIGHT);
     752:	85 e0       	ldi	r24, 0x05	; 5
     754:	0e 94 73 00 	call	0xe6
			break;
 		default:
			break;
 	   }
	   g_speed[1] = g_speed_table[set_speed]; 
     758:	ec 2f       	mov	r30, r28
     75a:	ff 27       	eor	r31, r31
     75c:	e4 5a       	subi	r30, 0xA4	; 164
     75e:	fe 4f       	sbci	r31, 0xFE	; 254
     760:	80 81       	ld	r24, Z
     762:	80 93 ea 02 	sts	0x02EA, r24
	   g_speed[0] = g_speed[1];
     766:	80 93 e9 02 	sts	0x02E9, r24
     76a:	cf 91       	pop	r28
     76c:	08 95       	ret

0000076e <__vector_11>:

}


// Interrupt Vector table
// Couter timer 0 reach top  
//    ON Motor   0 - OCR0  ON   OCR0 - 0xFF OFF
 SIGNAL (SIG_OVERFLOW0)   
{ 
     76e:	1f 92       	push	r1
     770:	0f 92       	push	r0
     772:	0f b6       	in	r0, 0x3f	; 63
     774:	0f 92       	push	r0
     776:	11 24       	eor	r1, r1
     778:	2f 93       	push	r18
     77a:	3f 93       	push	r19
     77c:	4f 93       	push	r20
     77e:	5f 93       	push	r21
     780:	6f 93       	push	r22
     782:	7f 93       	push	r23
     784:	8f 93       	push	r24
     786:	9f 93       	push	r25
     788:	af 93       	push	r26
     78a:	bf 93       	push	r27
     78c:	ef 93       	push	r30
     78e:	ff 93       	push	r31
    calculate_backemf(0); 
     790:	80 e0       	ldi	r24, 0x00	; 0
     792:	0e 94 5d 02 	call	0x4ba
	OCR0 =  g_speed[0];
     796:	80 91 e9 02 	lds	r24, 0x02E9
     79a:	8c bf       	out	0x3c, r24	; 60
    motor_control(1, g_mode[0]);
     79c:	60 91 d6 01 	lds	r22, 0x01D6
     7a0:	81 e0       	ldi	r24, 0x01	; 1
     7a2:	0e 94 ee 05 	call	0xbdc
	MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;  // Enable Motor control
     7a6:	95 9a       	sbi	0x12, 5	; 18
     7a8:	ff 91       	pop	r31
     7aa:	ef 91       	pop	r30
     7ac:	bf 91       	pop	r27
     7ae:	af 91       	pop	r26
     7b0:	9f 91       	pop	r25
     7b2:	8f 91       	pop	r24
     7b4:	7f 91       	pop	r23
     7b6:	6f 91       	pop	r22
     7b8:	5f 91       	pop	r21
     7ba:	4f 91       	pop	r20
     7bc:	3f 91       	pop	r19
     7be:	2f 91       	pop	r18
     7c0:	0f 90       	pop	r0
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	0f 90       	pop	r0
     7c6:	1f 90       	pop	r1
     7c8:	18 95       	reti

000007ca <__vector_10>:
		
}

// Counter timer 0 reach OCR0  OFF MOTOR
 SIGNAL (SIG_OUTPUT_COMPARE0)
{
     7ca:	1f 92       	push	r1
     7cc:	0f 92       	push	r0
     7ce:	0f b6       	in	r0, 0x3f	; 63
     7d0:	0f 92       	push	r0
     7d2:	11 24       	eor	r1, r1
		MOTOR_ENABLE12_CONTROL   &= ~(MOTOR_ENABLE12);   // Disable Motor control Float motor 
     7d4:	95 98       	cbi	0x12, 5	; 18
     7d6:	0f 90       	pop	r0
     7d8:	0f be       	out	0x3f, r0	; 63
     7da:	0f 90       	pop	r0
     7dc:	1f 90       	pop	r1
     7de:	18 95       	reti

000007e0 <__vector_5>:
//		motor_control(1, MOTOR_STOP);
}
 
// TIMER2 will opposite with timer 0 to balance calculate backemf between timer0 and timer2
// Couter timer 2 reach top  
//    ON Motor   0 - OCR2  ON   OCR2 - 0xFF FF
 SIGNAL (SIG_OVERFLOW2)   
{
     7e0:	1f 92       	push	r1
     7e2:	0f 92       	push	r0
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	0f 92       	push	r0
     7e8:	11 24       	eor	r1, r1
 	MOTOR_ENABLE34_CONTROL  &= ~(MOTOR_ENABLE34);   // Disable Motor control Float motor 
     7ea:	94 98       	cbi	0x12, 4	; 18
     7ec:	0f 90       	pop	r0
     7ee:	0f be       	out	0x3f, r0	; 63
     7f0:	0f 90       	pop	r0
     7f2:	1f 90       	pop	r1
     7f4:	18 95       	reti

000007f6 <__vector_4>:
//	motor_control(2, MOTOR_STOP);
   
}

// Counter timer 2 reach OCR2  ON MOTOR
 SIGNAL (SIG_OUTPUT_COMPARE2)
{
     7f6:	1f 92       	push	r1
     7f8:	0f 92       	push	r0
     7fa:	0f b6       	in	r0, 0x3f	; 63
     7fc:	0f 92       	push	r0
     7fe:	11 24       	eor	r1, r1
     800:	2f 93       	push	r18
     802:	3f 93       	push	r19
     804:	4f 93       	push	r20
     806:	5f 93       	push	r21
     808:	6f 93       	push	r22
     80a:	7f 93       	push	r23
     80c:	8f 93       	push	r24
     80e:	9f 93       	push	r25
     810:	af 93       	push	r26
     812:	bf 93       	push	r27
     814:	ef 93       	push	r30
     816:	ff 93       	push	r31
	calculate_backemf(1);
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	0e 94 5d 02 	call	0x4ba
  	OCR2 =  0xFF - g_speed[1];   // Because opposite with timer0
     81e:	80 91 ea 02 	lds	r24, 0x02EA
     822:	80 95       	com	r24
     824:	83 bd       	out	0x23, r24	; 35
    motor_control(2, g_mode[1]);
     826:	60 91 d7 01 	lds	r22, 0x01D7
     82a:	82 e0       	ldi	r24, 0x02	; 2
     82c:	0e 94 ee 05 	call	0xbdc
 	MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
     830:	94 9a       	sbi	0x12, 4	; 18
     832:	ff 91       	pop	r31
     834:	ef 91       	pop	r30
     836:	bf 91       	pop	r27
     838:	af 91       	pop	r26
     83a:	9f 91       	pop	r25
     83c:	8f 91       	pop	r24
     83e:	7f 91       	pop	r23
     840:	6f 91       	pop	r22
     842:	5f 91       	pop	r21
     844:	4f 91       	pop	r20
     846:	3f 91       	pop	r19
     848:	2f 91       	pop	r18
     84a:	0f 90       	pop	r0
     84c:	0f be       	out	0x3f, r0	; 63
     84e:	0f 90       	pop	r0
     850:	1f 90       	pop	r1
     852:	18 95       	reti

00000854 <__vector_13>:
 
}
 
   
/* UART receiver ready
*/

SIGNAL(SIG_UART_RECV)
{
     854:	1f 92       	push	r1
     856:	0f 92       	push	r0
     858:	0f b6       	in	r0, 0x3f	; 63
     85a:	0f 92       	push	r0
     85c:	11 24       	eor	r1, r1
     85e:	2f 93       	push	r18
     860:	8f 93       	push	r24
     862:	9f 93       	push	r25
     864:	ef 93       	push	r30
     866:	ff 93       	push	r31
  static uint16_t i= 0;
  uint8_t ch;
  ch = UDR;
     868:	2c b1       	in	r18, 0x0c	; 12

  if (g_program_flag)   // Save into buffer
     86a:	80 91 ca 01 	lds	r24, 0x01CA
     86e:	88 23       	and	r24, r24
     870:	81 f0       	breq	.+32     	; 0x892
  {
    g_program_buff[g_program_index] = ch;
     872:	80 91 c8 01 	lds	r24, 0x01C8
     876:	90 91 c9 01 	lds	r25, 0x01C9
     87a:	fc 01       	movw	r30, r24
     87c:	e0 5a       	subi	r30, 0xA0	; 160
     87e:	ff 4f       	sbci	r31, 0xFF	; 255
     880:	20 83       	st	Z, r18
	if (g_program_index < MAX_PROGRAM)
     882:	8a 3f       	cpi	r24, 0xFA	; 250
     884:	91 05       	cpc	r25, r1
     886:	28 f4       	brcc	.+10     	; 0x892
	{
		g_program_index++; 
     888:	01 96       	adiw	r24, 0x01	; 1
     88a:	90 93 c9 01 	sts	0x01C9, r25
     88e:	80 93 c8 01 	sts	0x01C8, r24
	}	
  }
	g_rcv_buff[i] = ch;    
     892:	80 91 d9 01 	lds	r24, 0x01D9
     896:	90 91 da 01 	lds	r25, 0x01DA
     89a:	fc 01       	movw	r30, r24
     89c:	e3 51       	subi	r30, 0x13	; 19
     89e:	fe 4f       	sbci	r31, 0xFE	; 254
     8a0:	20 83       	st	Z, r18
	i++;
     8a2:	fc 01       	movw	r30, r24
     8a4:	31 96       	adiw	r30, 0x01	; 1
     8a6:	f0 93 da 01 	sts	0x01DA, r31
     8aa:	e0 93 d9 01 	sts	0x01D9, r30
// Found 0xOD or 0x0A end with null
   if ((ch == 0x0D) || (ch == 0x0A)) // CANNOT USE UDR to compare
     8ae:	2d 30       	cpi	r18, 0x0D	; 13
     8b0:	11 f0       	breq	.+4      	; 0x8b6
     8b2:	2a 30       	cpi	r18, 0x0A	; 10
     8b4:	51 f4       	brne	.+20     	; 0x8ca
   {	
		g_rcv_buff[i]  = 0;   // End with null
     8b6:	e3 51       	subi	r30, 0x13	; 19
     8b8:	fe 4f       	sbci	r31, 0xFE	; 254
     8ba:	10 82       	st	Z, r1
		i = 0;
     8bc:	10 92 da 01 	sts	0x01DA, r1
     8c0:	10 92 d9 01 	sts	0x01D9, r1
		g_cmd_decode = 1;
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	80 93 cb 01 	sts	0x01CB, r24
     8ca:	ff 91       	pop	r31
     8cc:	ef 91       	pop	r30
     8ce:	9f 91       	pop	r25
     8d0:	8f 91       	pop	r24
     8d2:	2f 91       	pop	r18
     8d4:	0f 90       	pop	r0
     8d6:	0f be       	out	0x3f, r0	; 63
     8d8:	0f 90       	pop	r0
     8da:	1f 90       	pop	r1
     8dc:	18 95       	reti

000008de <__vector_14>:
   }
}

  

/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/

SIGNAL(SIG_UART_DATA)
{ 
     8de:	1f 92       	push	r1
     8e0:	0f 92       	push	r0
     8e2:	0f b6       	in	r0, 0x3f	; 63
     8e4:	0f 92       	push	r0
     8e6:	11 24       	eor	r1, r1
     8e8:	2f 93       	push	r18
     8ea:	3f 93       	push	r19
     8ec:	4f 93       	push	r20
     8ee:	5f 93       	push	r21
     8f0:	6f 93       	push	r22
     8f2:	7f 93       	push	r23
     8f4:	8f 93       	push	r24
     8f6:	9f 93       	push	r25
     8f8:	af 93       	push	r26
     8fa:	bf 93       	push	r27
     8fc:	ef 93       	push	r30
     8fe:	ff 93       	push	r31
    uint8_t  ch;
	if ((ch = uart_get_TX()))
     900:	0e 94 c0 06 	call	0xd80
     904:	88 23       	and	r24, r24
     906:	11 f0       	breq	.+4      	; 0x90c
	{
 		UDR = ch;
     908:	8c b9       	out	0x0c, r24	; 12
     90a:	01 c0       	rjmp	.+2      	; 0x90e
	}	
	else 
// No character disable  interrupt to avoid repetable call Enable again when
//	send character in putc procedure
	{
	    UCSRB &=  ~(1<<UDRIE);
     90c:	55 98       	cbi	0x0a, 5	; 10
     90e:	ff 91       	pop	r31
     910:	ef 91       	pop	r30
     912:	bf 91       	pop	r27
     914:	af 91       	pop	r26
     916:	9f 91       	pop	r25
     918:	8f 91       	pop	r24
     91a:	7f 91       	pop	r23
     91c:	6f 91       	pop	r22
     91e:	5f 91       	pop	r21
     920:	4f 91       	pop	r20
     922:	3f 91       	pop	r19
     924:	2f 91       	pop	r18
     926:	0f 90       	pop	r0
     928:	0f be       	out	0x3f, r0	; 63
     92a:	0f 90       	pop	r0
     92c:	1f 90       	pop	r1
     92e:	18 95       	reti

00000930 <__vector_6>:
	}
	
}

 
 
/* Interrupt handle for Input Capture
This routine will detect/ process the Sony IR remote command. Protocol using Sony remote control
INPUT   :  Infrared signal from  ICP pin
		   Command table 
		  

OUTPUT 	: g_num  Number of message to display
		: g_control.display_mode   Display mode of message
		: g_start_bit
		

*/
SIGNAL(SIG_INPUT_CAPTURE1)
{
     930:	1f 92       	push	r1
     932:	0f 92       	push	r0
     934:	0f b6       	in	r0, 0x3f	; 63
     936:	0f 92       	push	r0
     938:	11 24       	eor	r1, r1
     93a:	2f 93       	push	r18
     93c:	3f 93       	push	r19
     93e:	4f 93       	push	r20
     940:	5f 93       	push	r21
     942:	6f 93       	push	r22
     944:	7f 93       	push	r23
     946:	8f 93       	push	r24
     948:	9f 93       	push	r25
     94a:	af 93       	push	r26
     94c:	bf 93       	push	r27
     94e:	ef 93       	push	r30
     950:	ff 93       	push	r31
	uint16_t  ir_code;
    ir_code = ICR1;
     952:	26 b5       	in	r18, 0x26	; 38
     954:	37 b5       	in	r19, 0x27	; 39
// 	cli(); 

    TCCR1B  |= _BV(ICES1);	     // Rising edge
     956:	8e b5       	in	r24, 0x2e	; 46
     958:	80 64       	ori	r24, 0x40	; 64
     95a:	8e bd       	out	0x2e, r24	; 46
 	ir_code  = sony_ir_decode(ir_code);  
     95c:	c9 01       	movw	r24, r18
     95e:	0e 94 24 06 	call	0xc48
 	if (ir_code)
     962:	00 97       	sbiw	r24, 0x00	; 0
     964:	39 f0       	breq	.+14     	; 0x974
	{       //End code dispatch command    
 
        g_ircode = ir_code;
     966:	90 93 e8 02 	sts	0x02E8, r25
     96a:	80 93 e7 02 	sts	0x02E7, r24
// Return to falling edge for Start		
		TCCR1B  &= ~(_BV(ICES1));
     96e:	8e b5       	in	r24, 0x2e	; 46
     970:	8f 7b       	andi	r24, 0xBF	; 191
     972:	8e bd       	out	0x2e, r24	; 46
 
	} 
    sei();
     974:	78 94       	sei
     976:	ff 91       	pop	r31
     978:	ef 91       	pop	r30
     97a:	bf 91       	pop	r27
     97c:	af 91       	pop	r26
     97e:	9f 91       	pop	r25
     980:	8f 91       	pop	r24
     982:	7f 91       	pop	r23
     984:	6f 91       	pop	r22
     986:	5f 91       	pop	r21
     988:	4f 91       	pop	r20
     98a:	3f 91       	pop	r19
     98c:	2f 91       	pop	r18
     98e:	0f 90       	pop	r0
     990:	0f be       	out	0x3f, r0	; 63
     992:	0f 90       	pop	r0
     994:	1f 90       	pop	r1
     996:	18 95       	reti

00000998 <init_board>:
 
}


void init_board()
{
    uint8_t i;
	d7segment_init();
     998:	0e 94 d2 05 	call	0xba4
	init_ir();
     99c:	0e 94 1b 06 	call	0xc36
	init_motor();
     9a0:	0e 94 dc 05 	call	0xbb8
	uart_init(); 
     9a4:	0e 94 66 06 	call	0xccc
    adc_init(3);   // 2.56 BG as reference 
     9a8:	83 e0       	ldi	r24, 0x03	; 3
     9aa:	0e 94 43 07 	call	0xe86
	
	g_cmd_decode = 0; 
     9ae:	10 92 cb 01 	sts	0x01CB, r1
	g_motor= 0;
     9b2:	10 92 ec 01 	sts	0x01EC, r1
	g_program_index =0;
     9b6:	10 92 c9 01 	sts	0x01C9, r1
     9ba:	10 92 c8 01 	sts	0x01C8, r1
	g_ircode =0;
     9be:	10 92 e8 02 	sts	0x02E8, r1
     9c2:	10 92 e7 02 	sts	0x02E7, r1
     9c6:	91 e0       	ldi	r25, 0x01	; 1
     9c8:	21 e0       	ldi	r18, 0x01	; 1
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	40 e0       	ldi	r20, 0x00	; 0
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	a4 ee       	ldi	r26, 0xE4	; 228
     9d2:	b1 e0       	ldi	r27, 0x01	; 1
     9d4:	e9 ee       	ldi	r30, 0xE9	; 233
     9d6:	f2 e0       	ldi	r31, 0x02	; 2
     9d8:	89 2f       	mov	r24, r25
	
	for ( i = 0 ; i< MOTOR_MAX ;i++)
	{
		g_speed[i] = 1;
     9da:	91 93       	st	Z+, r25
		g_angle[i] = 1;
     9dc:	2d 93       	st	X+, r18
     9de:	3d 93       	st	X+, r19
     9e0:	4d 93       	st	X+, r20
     9e2:	5d 93       	st	X+, r21
     9e4:	81 50       	subi	r24, 0x01	; 1
     9e6:	87 ff       	sbrs	r24, 7
     9e8:	f8 cf       	rjmp	.-16     	; 0x9da
 	} 
	sei();
     9ea:	78 94       	sei
     9ec:	08 95       	ret

000009ee <main>:
 
}

     





void main()
{
     9ee:	cc e5       	ldi	r28, 0x5C	; 92
     9f0:	d8 e0       	ldi	r29, 0x08	; 8
     9f2:	de bf       	out	0x3e, r29	; 62
     9f4:	cd bf       	out	0x3d, r28	; 61
  uint8_t sw1,sw2,i;
   uint16_t k;
   int16_t backemf;
  int8_t d1,d2;
  uint8_t show[3] = {0,'f','b'};
     9f6:	6e 01       	movw	r12, r28
     9f8:	08 94       	sec
     9fa:	c1 1c       	adc	r12, r1
     9fc:	d1 1c       	adc	r13, r1
     9fe:	83 e0       	ldi	r24, 0x03	; 3
     a00:	e4 ec       	ldi	r30, 0xC4	; 196
     a02:	f1 e0       	ldi	r31, 0x01	; 1
     a04:	d6 01       	movw	r26, r12
     a06:	01 90       	ld	r0, Z+
     a08:	0d 92       	st	X+, r0
     a0a:	8a 95       	dec	r24
     a0c:	e1 f7       	brne	.-8      	; 0xa06
   init_board();
     a0e:	0e 94 cc 04 	call	0x998
  d1 = 0;
     a12:	ff 24       	eor	r15, r15
  d2 = 0;
     a14:	ef 2c       	mov	r14, r15
  backemf =0;
  while (1)
  {
   sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
     a16:	80 b3       	in	r24, 0x10	; 16
   
   if (!sw1) // SW1  Press
     a18:	98 2f       	mov	r25, r24
     a1a:	98 70       	andi	r25, 0x08	; 8
     a1c:	83 fd       	sbrc	r24, 3
     a1e:	1d c0       	rjmp	.+58     	; 0xa5a
    {   	
		d1++;
     a20:	e3 94       	inc	r14
	     if (d1 > MOTOR_BACKWARD)
     a22:	b2 e0       	ldi	r27, 0x02	; 2
     a24:	be 15       	cp	r27, r14
     a26:	0c f4       	brge	.+2      	; 0xa2a
			d1 = MOTOR_STOP;
     a28:	e9 2e       	mov	r14, r25
     a2a:	03 ef       	ldi	r16, 0xF3	; 243
     a2c:	11 e0       	ldi	r17, 0x01	; 1
		for (k = 0; k < 500 ;k++)                         // Delay for key bounce
				delay(6000);						
     a2e:	80 e7       	ldi	r24, 0x70	; 112
     a30:	97 e1       	ldi	r25, 0x17	; 23
     a32:	0e 94 6e 00 	call	0xdc
     a36:	01 50       	subi	r16, 0x01	; 1
     a38:	10 40       	sbci	r17, 0x00	; 0
     a3a:	17 ff       	sbrs	r17, 7
     a3c:	f8 cf       	rjmp	.-16     	; 0xa2e
		g_mode[0] = d1;
     a3e:	e0 92 d6 01 	sts	0x01D6, r14
		g_angle[0] = 1;    // Continuous move
     a42:	81 e0       	ldi	r24, 0x01	; 1
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	a0 e0       	ldi	r26, 0x00	; 0
     a48:	b0 e0       	ldi	r27, 0x00	; 0
     a4a:	80 93 e4 01 	sts	0x01E4, r24
     a4e:	90 93 e5 01 	sts	0x01E5, r25
     a52:	a0 93 e6 01 	sts	0x01E6, r26
     a56:	b0 93 e7 01 	sts	0x01E7, r27

	}
   
   sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
     a5a:	83 b3       	in	r24, 0x13	; 19
   if (!sw2) // SW2 Press
     a5c:	98 2f       	mov	r25, r24
     a5e:	94 70       	andi	r25, 0x04	; 4
     a60:	82 fd       	sbrc	r24, 2
     a62:	1d c0       	rjmp	.+58     	; 0xa9e
   {
        d2++;
     a64:	f3 94       	inc	r15
		if (d2 > MOTOR_BACKWARD)
     a66:	82 e0       	ldi	r24, 0x02	; 2
     a68:	8f 15       	cp	r24, r15
     a6a:	0c f4       	brge	.+2      	; 0xa6e
			d2 = MOTOR_STOP;
     a6c:	f9 2e       	mov	r15, r25
     a6e:	03 ef       	ldi	r16, 0xF3	; 243
     a70:	11 e0       	ldi	r17, 0x01	; 1
 		for (k = 0; k < 500 ;k++)                         // Delay for key bounce		
 				delay(6000);
     a72:	80 e7       	ldi	r24, 0x70	; 112
     a74:	97 e1       	ldi	r25, 0x17	; 23
     a76:	0e 94 6e 00 	call	0xdc
     a7a:	01 50       	subi	r16, 0x01	; 1
     a7c:	10 40       	sbci	r17, 0x00	; 0
     a7e:	17 ff       	sbrs	r17, 7
     a80:	f8 cf       	rjmp	.-16     	; 0xa72
		g_mode[1] = d2;
     a82:	f0 92 d7 01 	sts	0x01D7, r15
		g_angle[1] = 1;    // Continuous move	
     a86:	81 e0       	ldi	r24, 0x01	; 1
     a88:	90 e0       	ldi	r25, 0x00	; 0
     a8a:	a0 e0       	ldi	r26, 0x00	; 0
     a8c:	b0 e0       	ldi	r27, 0x00	; 0
     a8e:	80 93 e8 01 	sts	0x01E8, r24
     a92:	90 93 e9 01 	sts	0x01E9, r25
     a96:	a0 93 ea 01 	sts	0x01EA, r26
     a9a:	b0 93 eb 01 	sts	0x01EB, r27
   }

// Command decode
    if ( g_cmd_decode)
     a9e:	80 91 cb 01 	lds	r24, 0x01CB
     aa2:	88 23       	and	r24, r24
     aa4:	31 f0       	breq	.+12     	; 0xab2
	{
// Decode command	
   	    cmd_decode (g_rcv_buff);
     aa6:	8d ee       	ldi	r24, 0xED	; 237
     aa8:	91 e0       	ldi	r25, 0x01	; 1
     aaa:	0e 94 c1 00 	call	0x182
		g_cmd_decode = 0; 
     aae:	10 92 cb 01 	sts	0x01CB, r1
//  		g_pos[g_motor] = 0;
  	}
	if(g_ircode)
     ab2:	80 91 e7 02 	lds	r24, 0x02E7
     ab6:	90 91 e8 02 	lds	r25, 0x02E8
     aba:	00 97       	sbiw	r24, 0x00	; 0
     abc:	31 f0       	breq	.+12     	; 0xaca
	{
	   remote_decode (g_ircode);
     abe:	0e 94 02 03 	call	0x604
	   g_ircode =0;
     ac2:	10 92 e8 02 	sts	0x02E8, r1
     ac6:	10 92 e7 02 	sts	0x02E7, r1
	}
 
    for (i = 0 ; i < MOTOR_MAX ; i++)
     aca:	e0 e0       	ldi	r30, 0x00	; 0
	{
// 7 Segments display	
		d7segment_display(show[g_mode[i]],i+1);
     acc:	1e 2f       	mov	r17, r30
     ace:	1f 5f       	subi	r17, 0xFF	; 255
     ad0:	ff 27       	eor	r31, r31
     ad2:	ea 52       	subi	r30, 0x2A	; 42
     ad4:	fe 4f       	sbci	r31, 0xFE	; 254
     ad6:	80 81       	ld	r24, Z
     ad8:	f6 01       	movw	r30, r12
     ada:	e8 0f       	add	r30, r24
     adc:	f1 1d       	adc	r31, r1
     ade:	61 2f       	mov	r22, r17
     ae0:	80 81       	ld	r24, Z
     ae2:	0e 94 7b 05 	call	0xaf6
        delay(500);
     ae6:	84 ef       	ldi	r24, 0xF4	; 244
     ae8:	91 e0       	ldi	r25, 0x01	; 1
     aea:	0e 94 6e 00 	call	0xdc
     aee:	e1 2f       	mov	r30, r17
     af0:	12 30       	cpi	r17, 0x02	; 2
     af2:	60 f3       	brcs	.-40     	; 0xacc
     af4:	90 cf       	rjmp	.-224    	; 0xa16

00000af6 <d7segment_display>:
#include "Dual_7Segment.h"

void d7segment_display( int8_t num, uint8_t digit)
{
 switch (num)
     af6:	99 27       	eor	r25, r25
     af8:	87 fd       	sbrc	r24, 7
     afa:	90 95       	com	r25
     afc:	86 30       	cpi	r24, 0x06	; 6
     afe:	91 05       	cpc	r25, r1
     b00:	09 f4       	brne	.+2      	; 0xb04
     b02:	41 c0       	rjmp	.+130    	; 0xb86
     b04:	87 30       	cpi	r24, 0x07	; 7
     b06:	91 05       	cpc	r25, r1
     b08:	8c f4       	brge	.+34     	; 0xb2c
     b0a:	82 30       	cpi	r24, 0x02	; 2
     b0c:	91 05       	cpc	r25, r1
     b0e:	59 f1       	breq	.+86     	; 0xb66
     b10:	83 30       	cpi	r24, 0x03	; 3
     b12:	91 05       	cpc	r25, r1
     b14:	2c f4       	brge	.+10     	; 0xb20
     b16:	00 97       	sbiw	r24, 0x00	; 0
     b18:	11 f1       	breq	.+68     	; 0xb5e
     b1a:	01 97       	sbiw	r24, 0x01	; 1
     b1c:	11 f1       	breq	.+68     	; 0xb62
     b1e:	37 c0       	rjmp	.+110    	; 0xb8e
     b20:	84 30       	cpi	r24, 0x04	; 4
     b22:	91 05       	cpc	r25, r1
     b24:	21 f1       	breq	.+72     	; 0xb6e
     b26:	05 97       	sbiw	r24, 0x05	; 5
     b28:	24 f5       	brge	.+72     	; 0xb72
     b2a:	1f c0       	rjmp	.+62     	; 0xb6a
     b2c:	89 30       	cpi	r24, 0x09	; 9
     b2e:	91 05       	cpc	r25, r1
     b30:	31 f1       	breq	.+76     	; 0xb7e
     b32:	8a 30       	cpi	r24, 0x0A	; 10
     b34:	91 05       	cpc	r25, r1
     b36:	34 f4       	brge	.+12     	; 0xb44
     b38:	87 30       	cpi	r24, 0x07	; 7
     b3a:	91 05       	cpc	r25, r1
     b3c:	e1 f0       	breq	.+56     	; 0xb76
     b3e:	08 97       	sbiw	r24, 0x08	; 8
     b40:	e1 f0       	breq	.+56     	; 0xb7a
     b42:	25 c0       	rjmp	.+74     	; 0xb8e
     b44:	82 36       	cpi	r24, 0x62	; 98
     b46:	91 05       	cpc	r25, r1
     b48:	f1 f0       	breq	.+60     	; 0xb86
     b4a:	83 36       	cpi	r24, 0x63	; 99
     b4c:	91 05       	cpc	r25, r1
     b4e:	1c f4       	brge	.+6      	; 0xb56
     b50:	0a 97       	sbiw	r24, 0x0a	; 10
     b52:	d9 f0       	breq	.+54     	; 0xb8a
     b54:	1c c0       	rjmp	.+56     	; 0xb8e
     b56:	86 36       	cpi	r24, 0x66	; 102
     b58:	91 05       	cpc	r25, r1
     b5a:	99 f0       	breq	.+38     	; 0xb82
     b5c:	18 c0       	rjmp	.+48     	; 0xb8e
 {
	case 0:
		_7SEGMENT_PORT = _7SEGMENT_0;
     b5e:	8f e3       	ldi	r24, 0x3F	; 63
     b60:	15 c0       	rjmp	.+42     	; 0xb8c
		break;
	case 1:
		_7SEGMENT_PORT = _7SEGMENT_1;
     b62:	86 e0       	ldi	r24, 0x06	; 6
     b64:	13 c0       	rjmp	.+38     	; 0xb8c
		break;
	case 2:
		_7SEGMENT_PORT = _7SEGMENT_2;
     b66:	8b e5       	ldi	r24, 0x5B	; 91
     b68:	11 c0       	rjmp	.+34     	; 0xb8c
		break;
	case 3:
		_7SEGMENT_PORT = _7SEGMENT_3;
     b6a:	8f e4       	ldi	r24, 0x4F	; 79
     b6c:	0f c0       	rjmp	.+30     	; 0xb8c
		break;
	case 4:
		_7SEGMENT_PORT = _7SEGMENT_4;
     b6e:	86 e6       	ldi	r24, 0x66	; 102
     b70:	0d c0       	rjmp	.+26     	; 0xb8c
		break;
	case 5:
		_7SEGMENT_PORT = _7SEGMENT_5;
     b72:	8d e6       	ldi	r24, 0x6D	; 109
     b74:	0b c0       	rjmp	.+22     	; 0xb8c
		break;
	case 6:
		_7SEGMENT_PORT = _7SEGMENT_6;
		break;
	case 7:
		_7SEGMENT_PORT = _7SEGMENT_7;
     b76:	87 e0       	ldi	r24, 0x07	; 7
     b78:	09 c0       	rjmp	.+18     	; 0xb8c
		break;
	case 8:
		_7SEGMENT_PORT = _7SEGMENT_8;
     b7a:	8f e7       	ldi	r24, 0x7F	; 127
     b7c:	07 c0       	rjmp	.+14     	; 0xb8c
		break;
	case 9:
		_7SEGMENT_PORT = _7SEGMENT_9;
     b7e:	87 e6       	ldi	r24, 0x67	; 103
     b80:	05 c0       	rjmp	.+10     	; 0xb8c
	    break;
	case 'f':
	    _7SEGMENT_PORT = _7SEGMENT_C_F;
     b82:	81 e7       	ldi	r24, 0x71	; 113
     b84:	03 c0       	rjmp	.+6      	; 0xb8c
		break;
	case 'b':
	    _7SEGMENT_PORT = _7SEGMENT_C_B;
     b86:	8c e7       	ldi	r24, 0x7C	; 124
     b88:	01 c0       	rjmp	.+2      	; 0xb8c
		break;
	case DOT:
		_7SEGMENT_PORT = _7SEGMENT_DOT;
     b8a:	80 e8       	ldi	r24, 0x80	; 128
     b8c:	88 bb       	out	0x18, r24	; 24
		break;
 
 }
// Out digit
	 
    if ( digit == 1 )
     b8e:	61 30       	cpi	r22, 0x01	; 1
     b90:	19 f4       	brne	.+6      	; 0xb98
	{  // ON Digit 1 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT1);
     b92:	ab 98       	cbi	0x15, 3	; 21
	   // OFF Digit 2 
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT2;
     b94:	ac 9a       	sbi	0x15, 4	; 21
     b96:	08 95       	ret
	}
	if ( digit == 2 )
     b98:	62 30       	cpi	r22, 0x02	; 2
     b9a:	11 f4       	brne	.+4      	; 0xba0
	{  // ON Digit 2 OFF  ( 1 Off  0 On)
		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT2);
     b9c:	ac 98       	cbi	0x15, 4	; 21
	   // OFF Digit 1
	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT1;
     b9e:	ab 9a       	sbi	0x15, 3	; 21
     ba0:	08 95       	ret
     ba2:	08 95       	ret

00000ba4 <d7segment_init>:
	}	

}	


/* Initial 7 Segments. Set port to output before use 
*/
void d7segment_init (void)
{
// Set direction for output for 7 Segment
	_7SEGMENT_DIGIT_DIR   = 0xFF;
     ba4:	8f ef       	ldi	r24, 0xFF	; 255
     ba6:	87 bb       	out	0x17, r24	; 23
	_7SEGMENT_PORT_DIR	  |= _7SEGMENT_DIGIT1 | _7SEGMENT_DIGIT2;
     ba8:	84 b3       	in	r24, 0x14	; 20
     baa:	88 61       	ori	r24, 0x18	; 24
     bac:	84 bb       	out	0x14, r24	; 20
 
// Set direction for input for SW 
	_7SEGMENT_SW1_DIR	&=  ~(_7SEGMENT_SW1);
     bae:	8b 98       	cbi	0x11, 3	; 17
	_7SEGMENT_SW2_DIR	&=  ~(_7SEGMENT_SW2);
     bb0:	a2 98       	cbi	0x14, 2	; 20

// Enable pull up
    _7SEGMENT_SW1_PORT   |= _7SEGMENT_SW1;
     bb2:	93 9a       	sbi	0x12, 3	; 18
    _7SEGMENT_SW2_PORT   |= _7SEGMENT_SW2;
     bb4:	aa 9a       	sbi	0x15, 2	; 21
     bb6:	08 95       	ret

00000bb8 <init_motor>:
 

//   TIMER0
//     TCCR0  |= _BV(WGM00) |_BV(WGM01) | _BV(CS01) | _BV(CS00)  ;   // Clk/64 Fast Pwm
    TCCR0  |= _BV(WGM00) |_BV(WGM01) | _BV(CS02)    ;   // Clk/256 Pwm
     bb8:	83 b7       	in	r24, 0x33	; 51
     bba:	8c 64       	ori	r24, 0x4C	; 76
     bbc:	83 bf       	out	0x33, r24	; 51
    OCR0    = 0x80;
     bbe:	90 e8       	ldi	r25, 0x80	; 128
     bc0:	9c bf       	out	0x3c, r25	; 60
	
	
//   TIMER2
//     TCCR2  |= _BV(WGM20) | _BV(CS22) ;   // Clk/64 Pwm
     TCCR2  |= _BV(WGM20) |_BV(WGM21) | _BV(CS22) | _BV(CS21) ;   // Clk/256 Pwm
     bc2:	85 b5       	in	r24, 0x25	; 37
     bc4:	8e 64       	ori	r24, 0x4E	; 78
     bc6:	85 bd       	out	0x25, r24	; 37
      OCR2   = 0x80;
     bc8:	93 bd       	out	0x23, r25	; 35
	
	
	
// Enable Interrupt 	Watch out nest interrupt 
	TIMSK  |=  _BV(OCIE0) | _BV(TOIE0) | _BV(OCIE2) | _BV(TOIE2);	
     bca:	89 b7       	in	r24, 0x39	; 57
     bcc:	83 6c       	ori	r24, 0xC3	; 195
     bce:	89 bf       	out	0x39, r24	; 57
 
    MOTOR_DIRECTION_DIR  |= 	MOTORA_1 | MOTORA_2 | MOTORB_1 | MOTORB_2;
     bd0:	8a b3       	in	r24, 0x1a	; 26
     bd2:	80 6f       	ori	r24, 0xF0	; 240
     bd4:	8a bb       	out	0x1a, r24	; 26
	MOTOR_ENABLE12_DIR	 |= 	MOTOR_ENABLE12;
     bd6:	8d 9a       	sbi	0x11, 5	; 17
	MOTOR_ENABLE34_DIR	 |=  	MOTOR_ENABLE34;		
     bd8:	8c 9a       	sbi	0x11, 4	; 17
     bda:	08 95       	ret

00000bdc <motor_control>:
}


// speed from 1 - 10

void  motor_control (uint8_t port, uint8_t direction) 
{
     bdc:	38 2f       	mov	r19, r24
     bde:	86 2f       	mov	r24, r22
  
   uint8_t  controlA,controlB;
   
   switch (direction)
     be0:	99 27       	eor	r25, r25
     be2:	81 30       	cpi	r24, 0x01	; 1
     be4:	91 05       	cpc	r25, r1
     be6:	31 f0       	breq	.+12     	; 0xbf4
     be8:	82 30       	cpi	r24, 0x02	; 2
     bea:	91 05       	cpc	r25, r1
     bec:	4c f0       	brlt	.+18     	; 0xc00
     bee:	02 97       	sbiw	r24, 0x02	; 2
     bf0:	21 f0       	breq	.+8      	; 0xbfa
     bf2:	06 c0       	rjmp	.+12     	; 0xc00
   {
     case MOTOR_FORWARD:
	    controlA = 0;
     bf4:	20 e0       	ldi	r18, 0x00	; 0
		controlB = 0xFF;
     bf6:	9f ef       	ldi	r25, 0xFF	; 255
		break;
     bf8:	05 c0       	rjmp	.+10     	; 0xc04
	 case MOTOR_BACKWARD:
        controlA = 0xFF;
     bfa:	2f ef       	ldi	r18, 0xFF	; 255
		controlB = 0;
     bfc:	90 e0       	ldi	r25, 0x00	; 0
		break;
     bfe:	02 c0       	rjmp	.+4      	; 0xc04
	 case MOTOR_STOP:
	    controlA = 0;
		controlB = 0;
		break;
	default:
	    controlA = 0;
     c00:	90 e0       	ldi	r25, 0x00	; 0
		controlB = 0;
     c02:	29 2f       	mov	r18, r25
   }
 if (port == 1)
     c04:	31 30       	cpi	r19, 0x01	; 1
     c06:	51 f4       	brne	.+20     	; 0xc1c
   {
//       MOTOR_ENABLE12_CONTROL  |= MOTOR_ENABLE12;
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORA_1 | MOTORA_2); 
     c08:	8b b3       	in	r24, 0x1b	; 27
     c0a:	8f 7c       	andi	r24, 0xCF	; 207
     c0c:	8b bb       	out	0x1b, r24	; 27
	  MOTOR_DIRECTION_CONTROL |= ((MOTORA_1 & controlA ) | (MOTORA_2 & controlB));
     c0e:	20 71       	andi	r18, 0x10	; 16
     c10:	90 72       	andi	r25, 0x20	; 32
     c12:	29 2b       	or	r18, r25
     c14:	8b b3       	in	r24, 0x1b	; 27
     c16:	82 2b       	or	r24, r18
     c18:	8b bb       	out	0x1b, r24	; 27
     c1a:	08 95       	ret
  }
  if (port == 2)
     c1c:	32 30       	cpi	r19, 0x02	; 2
     c1e:	49 f4       	brne	.+18     	; 0xc32
   {
//  	  MOTOR_ENABLE34_CONTROL  |= MOTOR_ENABLE34;
	  MOTOR_DIRECTION_CONTROL &= ~(MOTORB_1 | MOTORB_2); 
     c20:	8b b3       	in	r24, 0x1b	; 27
     c22:	8f 73       	andi	r24, 0x3F	; 63
     c24:	8b bb       	out	0x1b, r24	; 27
  	  MOTOR_DIRECTION_CONTROL |= ((MOTORB_1 & controlA ) | (MOTORB_2 & controlB));
     c26:	20 74       	andi	r18, 0x40	; 64
     c28:	90 78       	andi	r25, 0x80	; 128
     c2a:	29 2b       	or	r18, r25
     c2c:	8b b3       	in	r24, 0x1b	; 27
     c2e:	82 2b       	or	r24, r18
     c30:	8b bb       	out	0x1b, r24	; 27
     c32:	08 95       	ret
     c34:	08 95       	ret

00000c36 <init_ir>:

void init_ir()
{
 //Set Direction
    IR_DDR_PORT &= ~IR_ICP; 
     c36:	8e 98       	cbi	0x11, 6	; 17
	
	TCCR1B  |= ( _BV(ICNC1) | _BV(CS12) | _BV(CS10));			// Time 1 input to clock/1024 input capture on falling edge  noise cancel
     c38:	8e b5       	in	r24, 0x2e	; 46
     c3a:	85 68       	ori	r24, 0x85	; 133
     c3c:	8e bd       	out	0x2e, r24	; 46
	TIMSK   |= _BV(TICIE1);   								// Enable input capture enable 
     c3e:	89 b7       	in	r24, 0x39	; 57
     c40:	80 62       	ori	r24, 0x20	; 32
     c42:	89 bf       	out	0x39, r24	; 57
	sei();
     c44:	78 94       	sei
     c46:	08 95       	ret

00000c48 <sony_ir_decode>:
}
/*  Decode for Sony remote TV IR 
			Input  Input capturn counter 16 bit register
		   Output  0  = no code detect
				   ir_decode  = detect IR code 
				   
	Algorithm
		Calculate pulse width by substract ICP counter. from pulse width 
		can determine whether it is  START BIT 		 =  XX
									  BIT1 			 =  XX
		until 12 bits then return ir code							  
									 
*/

uint16_t sony_ir_decode ( uint16_t capture_counter)
{
     c48:	bc 01       	movw	r22, r24
  static 	uint16_t  	prev_capture_counter = 0;
  static 	uint8_t   	stop_bit = 0;
  static	uint16_t	ir_code = 0;
 			uint16_t	width  = 0;	  

      if ( capture_counter > prev_capture_counter)
     c4a:	80 91 db 01 	lds	r24, 0x01DB
     c4e:	90 91 dc 01 	lds	r25, 0x01DC
     c52:	9b 01       	movw	r18, r22
     c54:	28 1b       	sub	r18, r24
     c56:	39 0b       	sbc	r19, r25
			width = capture_counter - prev_capture_counter;
	  else
			width = capture_counter+(MAX_INT16 - prev_capture_counter);
//Check for start bit
     if ( width > IR_TV_PULSE_WIDTH)
     c58:	2a 30       	cpi	r18, 0x0A	; 10
     c5a:	31 05       	cpc	r19, r1
     c5c:	20 f1       	brcs	.+72     	; 0xca6
	 {
		  if (width > IR_TV_START_BIT)  			//  Found Start bit 
     c5e:	26 32       	cpi	r18, 0x26	; 38
     c60:	31 05       	cpc	r19, r1
     c62:	58 f0       	brcs	.+22     	; 0xc7a
			    {
				  stop_bit = 0;
     c64:	10 92 dd 01 	sts	0x01DD, r1
				  prev_capture_counter = 0;
     c68:	10 92 dc 01 	sts	0x01DC, r1
     c6c:	10 92 db 01 	sts	0x01DB, r1
				  ir_code = 0;     			// New code
     c70:	10 92 df 01 	sts	0x01DF, r1
     c74:	10 92 de 01 	sts	0x01DE, r1
     c78:	16 c0       	rjmp	.+44     	; 0xca6
     c7a:	80 91 de 01 	lds	r24, 0x01DE
     c7e:	90 91 df 01 	lds	r25, 0x01DF
     c82:	40 91 dd 01 	lds	r20, 0x01DD
				}
		  else if (width > IR_TV_BIT1)	  		// bit 1 (3T)
     c86:	2a 31       	cpi	r18, 0x1A	; 26
     c88:	31 05       	cpc	r19, r1
     c8a:	20 f0       	brcs	.+8      	; 0xc94
				{
				   ir_code <<= 1;    			//Shift right
     c8c:	88 0f       	add	r24, r24
     c8e:	99 1f       	adc	r25, r25
				   ir_code  |= 1;    			// Or 1
     c90:	81 60       	ori	r24, 0x01	; 1
     c92:	02 c0       	rjmp	.+4      	; 0xc98
				    stop_bit++;
				}
		        else 	  // bit 0
				{
					ir_code  <<=  1;  //Shift right
     c94:	88 0f       	add	r24, r24
     c96:	99 1f       	adc	r25, r25
     c98:	90 93 df 01 	sts	0x01DF, r25
     c9c:	80 93 de 01 	sts	0x01DE, r24
					stop_bit++;
     ca0:	4f 5f       	subi	r20, 0xFF	; 255
     ca2:	40 93 dd 01 	sts	0x01DD, r20
				}
	}
	prev_capture_counter = capture_counter;
     ca6:	70 93 dc 01 	sts	0x01DC, r23
     caa:	60 93 db 01 	sts	0x01DB, r22
	if (stop_bit == IR_TV_STOP_BIT)
     cae:	80 91 dd 01 	lds	r24, 0x01DD
     cb2:	8c 30       	cpi	r24, 0x0C	; 12
     cb4:	39 f4       	brne	.+14     	; 0xcc4
	{       //End code dispatch command
  	    stop_bit = 0;
     cb6:	10 92 dd 01 	sts	0x01DD, r1

		return ir_code;
     cba:	80 91 de 01 	lds	r24, 0x01DE
     cbe:	90 91 df 01 	lds	r25, 0x01DF
     cc2:	08 95       	ret
			
//Note if  SELFTEST is selected g_irint = 0;
	}   
	else
		return 0;		// No code detect yet
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	90 e0       	ldi	r25, 0x00	; 0
}
     cc8:	08 95       	ret
     cca:	08 95       	ret

00000ccc <uart_init>:
{
 
// Initialize UART  
    
    UCSRC  = 0x86;    // 8 bit non parity  1 stop bit
     ccc:	86 e8       	ldi	r24, 0x86	; 134
     cce:	80 bd       	out	0x20, r24	; 32
     UCSRB  = 0x98;    // Enable RX Interrupt and Enable TX, RX pin
     cd0:	88 e9       	ldi	r24, 0x98	; 152
     cd2:	8a b9       	out	0x0a, r24	; 10
//    UCSRB  = 0B8;    // Enable RX Interrupt, Data registerempty interrupt enable and Enable TX, RX pin 1011-1000
	UBRRL  = 0x67;    // Speed 9600 UBRR = 103 at 16 MHZ
     cd4:	87 e6       	ldi	r24, 0x67	; 103
     cd6:	89 b9       	out	0x09, r24	; 9
//	UBRRL  = 51;      // Speed = 19.2 K at 16 Mhz
	UBRRH  = 0;
     cd8:	10 bc       	out	0x20, r1	; 32
//    DDRD = 0x00;	 
 
	g_rx_ptr = 0;
     cda:	10 92 e1 01 	sts	0x01E1, r1
	g_tx_ptr = 0;
     cde:	10 92 e0 01 	sts	0x01E0, r1
     ce2:	08 95       	ret

00000ce4 <uart_put_RX>:
 /* Set baud rate */
 
}

/*
Put character into Rx buffer

Return  = Success 0
        = Fail   Buffer Full
		
*/
uint8_t uart_put_RX ( uint8_t ch)
{
     ce4:	98 2f       	mov	r25, r24
   if ((g_rx_ptr < MAX_BUFF)) 
     ce6:	80 91 e1 01 	lds	r24, 0x01E1
     cea:	8a 3f       	cpi	r24, 0xFA	; 250
     cec:	80 f4       	brcc	.+32     	; 0xd0e
   {
//  End with Null
		g_rx_buff[g_rx_ptr] = ch;
     cee:	e8 2f       	mov	r30, r24
     cf0:	ff 27       	eor	r31, r31
     cf2:	e5 51       	subi	r30, 0x15	; 21
     cf4:	fd 4f       	sbci	r31, 0xFD	; 253
     cf6:	90 83       	st	Z, r25
		g_rx_ptr++;
     cf8:	8f 5f       	subi	r24, 0xFF	; 255
     cfa:	80 93 e1 01 	sts	0x01E1, r24
		g_rx_buff[g_rx_ptr] = 0;   // End with null characters
     cfe:	e8 2f       	mov	r30, r24
     d00:	ff 27       	eor	r31, r31
     d02:	e5 51       	subi	r30, 0x15	; 21
     d04:	fd 4f       	sbci	r31, 0xFD	; 253
     d06:	10 82       	st	Z, r1
		return 0;
     d08:	80 e0       	ldi	r24, 0x00	; 0
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	08 95       	ret
    }
   else  // Buffer full do nothing  return error
   {
        return UART_BUFFER_FULL;
     d0e:	82 e0       	ldi	r24, 0x02	; 2
     d10:	90 e0       	ldi	r25, 0x00	; 0
   }
}
     d12:	08 95       	ret
     d14:	08 95       	ret

00000d16 <uart_get_RX>:

// Get character from RX buffer

uint8_t uart_get_RX (void)
{
   uint8_t  i,j,ch;
   if (g_rx_ptr)
     d16:	80 91 e1 01 	lds	r24, 0x01E1
     d1a:	88 23       	and	r24, r24
     d1c:	a1 f0       	breq	.+40     	; 0xd46
   {
		ch = g_rx_buff[0];
     d1e:	90 91 eb 02 	lds	r25, 0x02EB
        i =  g_rx_ptr;
     d22:	28 2f       	mov	r18, r24
        g_rx_ptr--;
     d24:	21 50       	subi	r18, 0x01	; 1
     d26:	20 93 e1 01 	sts	0x01E1, r18
     d2a:	2f 5f       	subi	r18, 0xFF	; 255
		j = 0;
     d2c:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_rx_buff[j] =  g_rx_buff[j+1];
     d2e:	e3 2f       	mov	r30, r19
     d30:	ff 27       	eor	r31, r31
     d32:	e5 51       	subi	r30, 0x15	; 21
     d34:	fd 4f       	sbci	r31, 0xFD	; 253
     d36:	81 81       	ldd	r24, Z+1	; 0x01
     d38:	80 83       	st	Z, r24
	      j++;
     d3a:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
     d3c:	21 50       	subi	r18, 0x01	; 1
     d3e:	b9 f7       	brne	.-18     	; 0xd2e
		}
		return ch;
     d40:	89 2f       	mov	r24, r25
     d42:	99 27       	eor	r25, r25
     d44:	08 95       	ret
   }
   return 0;
     d46:	80 e0       	ldi	r24, 0x00	; 0
     d48:	90 e0       	ldi	r25, 0x00	; 0
}
     d4a:	08 95       	ret
     d4c:	08 95       	ret

00000d4e <uart_put_TX>:

/* Put character into g_tx_buff
    INPUT  : Character to put in buffer
	Output : 0  OK
		   : UART_BUFFER_FULL  Buffer full
*/

uint8_t uart_put_TX ( uint8_t ch)
{
     d4e:	98 2f       	mov	r25, r24
// If exceed buffer do nothing until buffer is flushed
    if ((g_tx_ptr > MAX_BUFF)) 
     d50:	80 91 e0 01 	lds	r24, 0x01E0
     d54:	8b 3f       	cpi	r24, 0xFB	; 251
     d56:	18 f0       	brcs	.+6      	; 0xd5e
    {
		return UART_BUFFER_FULL;   // No increase pointer
     d58:	82 e0       	ldi	r24, 0x02	; 2
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	08 95       	ret
    }
	g_tx_buff[g_tx_ptr]= ch;
     d5e:	e8 2f       	mov	r30, r24
     d60:	ff 27       	eor	r31, r31
     d62:	eb 51       	subi	r30, 0x1B	; 27
     d64:	fc 4f       	sbci	r31, 0xFC	; 252
     d66:	90 83       	st	Z, r25
	g_tx_ptr++;
     d68:	8f 5f       	subi	r24, 0xFF	; 255
     d6a:	80 93 e0 01 	sts	0x01E0, r24
	g_tx_buff[g_tx_ptr] = 0;    // Put null character at the end
     d6e:	e8 2f       	mov	r30, r24
     d70:	ff 27       	eor	r31, r31
     d72:	eb 51       	subi	r30, 0x1B	; 27
     d74:	fc 4f       	sbci	r31, 0xFC	; 252
     d76:	10 82       	st	Z, r1
	return 0;
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	90 e0       	ldi	r25, 0x00	; 0
}
     d7c:	08 95       	ret
     d7e:	08 95       	ret

00000d80 <uart_get_TX>:


// Get character from TX buffer
uint8_t uart_get_TX (void)
{
   uint8_t i,j,ch =0;
   
   if ( g_tx_ptr)
     d80:	80 91 e0 01 	lds	r24, 0x01E0
     d84:	88 23       	and	r24, r24
     d86:	a1 f0       	breq	.+40     	; 0xdb0
   {
		i  =  g_tx_ptr;
     d88:	28 2f       	mov	r18, r24
		g_tx_ptr--;
     d8a:	21 50       	subi	r18, 0x01	; 1
     d8c:	20 93 e0 01 	sts	0x01E0, r18
     d90:	2f 5f       	subi	r18, 0xFF	; 255
		ch =  g_tx_buff[0];   // Start from 0 FIFO
     d92:	90 91 e5 03 	lds	r25, 0x03E5
		j = 0;
     d96:	30 e0       	ldi	r19, 0x00	; 0
// Move left all characters
        while (i)
		{
	      g_tx_buff[j] =  g_tx_buff[j+1];
     d98:	e3 2f       	mov	r30, r19
     d9a:	ff 27       	eor	r31, r31
     d9c:	eb 51       	subi	r30, 0x1B	; 27
     d9e:	fc 4f       	sbci	r31, 0xFC	; 252
     da0:	81 81       	ldd	r24, Z+1	; 0x01
     da2:	80 83       	st	Z, r24
	      j++;
     da4:	3f 5f       	subi	r19, 0xFF	; 255
	 	  i--;
     da6:	21 50       	subi	r18, 0x01	; 1
     da8:	b9 f7       	brne	.-18     	; 0xd98
		}
		return ch;
     daa:	89 2f       	mov	r24, r25
     dac:	99 27       	eor	r25, r25
     dae:	08 95       	ret
   }
   return 0;
     db0:	80 e0       	ldi	r24, 0x00	; 0
     db2:	90 e0       	ldi	r25, 0x00	; 0
}
     db4:	08 95       	ret
     db6:	08 95       	ret

00000db8 <uart_getc>:


uint8_t uart_getc(void)
{
    uint8_t ch;
	ch = uart_get_RX();
     db8:	0e 94 8b 06 	call	0xd16
    return ch ;
}
     dbc:	99 27       	eor	r25, r25
     dbe:	08 95       	ret

00000dc0 <uart_putc>:

uint8_t uart_putc(uint8_t c)
{
  
  uart_put_TX(c);
     dc0:	0e 94 a7 06 	call	0xd4e
// Enable interrupt UART Data Register empty
  UCSRB  |=  (1<<UDRIE);	
     dc4:	55 9a       	sbi	0x0a, 5	; 10
//    while ( !(UCSRA & (1<< UDRE)));
//	UDR = c;
    return 0;

}
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	08 95       	ret

00000dcc <uart_puts>:


/*************************************************************************
Function: uart_puts()
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const uint8_t *s )
{
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	ec 01       	movw	r28, r24
    while (*s) 
      uart_putc(*s++);
     dd2:	88 81       	ld	r24, Y
     dd4:	88 23       	and	r24, r24
     dd6:	21 f0       	breq	.+8      	; 0xde0
     dd8:	89 91       	ld	r24, Y+
     dda:	0e 94 e0 06 	call	0xdc0
     dde:	f9 cf       	rjmp	.-14     	; 0xdd2
   uart_putc(0x0D); // CR
     de0:	8d e0       	ldi	r24, 0x0D	; 13
     de2:	0e 94 e0 06 	call	0xdc0
	uart_putc(0x0A); // LF
     de6:	8a e0       	ldi	r24, 0x0A	; 10
     de8:	0e 94 e0 06 	call	0xdc0
     dec:	df 91       	pop	r29
     dee:	cf 91       	pop	r28
     df0:	08 95       	ret

00000df2 <debug_value>:
}

/*
Show debug value
*/

void  debug_value ( int16_t value, uint8_t radix)
{
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	cd b7       	in	r28, 0x3d	; 61
     df8:	de b7       	in	r29, 0x3e	; 62
     dfa:	64 97       	sbiw	r28, 0x14	; 20
     dfc:	0f b6       	in	r0, 0x3f	; 63
     dfe:	f8 94       	cli
     e00:	de bf       	out	0x3e, r29	; 62
     e02:	0f be       	out	0x3f, r0	; 63
     e04:	cd bf       	out	0x3d, r28	; 61
     e06:	26 2f       	mov	r18, r22
   uint8_t  buff[20];
   
   itoa (value,buff, radix);
     e08:	33 27       	eor	r19, r19
     e0a:	a9 01       	movw	r20, r18
     e0c:	be 01       	movw	r22, r28
     e0e:	6f 5f       	subi	r22, 0xFF	; 255
     e10:	7f 4f       	sbci	r23, 0xFF	; 255
     e12:	0e 94 8b 08 	call	0x1116
    uart_puts ( buff);
     e16:	ce 01       	movw	r24, r28
     e18:	01 96       	adiw	r24, 0x01	; 1
     e1a:	0e 94 e6 06 	call	0xdcc
     e1e:	64 96       	adiw	r28, 0x14	; 20
     e20:	0f b6       	in	r0, 0x3f	; 63
     e22:	f8 94       	cli
     e24:	de bf       	out	0x3e, r29	; 62
     e26:	0f be       	out	0x3f, r0	; 63
     e28:	cd bf       	out	0x3d, r28	; 61
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	08 95       	ret

00000e30 <debug_lvalue>:

}



void  debug_lvalue ( int32_t value, uint8_t radix)
{
     e30:	ef 92       	push	r14
     e32:	ff 92       	push	r15
     e34:	0f 93       	push	r16
     e36:	1f 93       	push	r17
     e38:	cf 93       	push	r28
     e3a:	df 93       	push	r29
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
     e40:	a8 97       	sbiw	r28, 0x28	; 40
     e42:	0f b6       	in	r0, 0x3f	; 63
     e44:	f8 94       	cli
     e46:	de bf       	out	0x3e, r29	; 62
     e48:	0f be       	out	0x3f, r0	; 63
     e4a:	cd bf       	out	0x3d, r28	; 61
     e4c:	7b 01       	movw	r14, r22
     e4e:	8c 01       	movw	r16, r24
     e50:	84 2f       	mov	r24, r20
   uint8_t  buff[40];
   
   ltoa (value,buff, radix);
     e52:	99 27       	eor	r25, r25
     e54:	9c 01       	movw	r18, r24
     e56:	ae 01       	movw	r20, r28
     e58:	4f 5f       	subi	r20, 0xFF	; 255
     e5a:	5f 4f       	sbci	r21, 0xFF	; 255
     e5c:	c8 01       	movw	r24, r16
     e5e:	b7 01       	movw	r22, r14
     e60:	0e 94 b0 08 	call	0x1160
    uart_puts ( buff);
     e64:	ce 01       	movw	r24, r28
     e66:	01 96       	adiw	r24, 0x01	; 1
     e68:	0e 94 e6 06 	call	0xdcc
     e6c:	a8 96       	adiw	r28, 0x28	; 40
     e6e:	0f b6       	in	r0, 0x3f	; 63
     e70:	f8 94       	cli
     e72:	de bf       	out	0x3e, r29	; 62
     e74:	0f be       	out	0x3f, r0	; 63
     e76:	cd bf       	out	0x3d, r28	; 61
     e78:	df 91       	pop	r29
     e7a:	cf 91       	pop	r28
     e7c:	1f 91       	pop	r17
     e7e:	0f 91       	pop	r16
     e80:	ff 90       	pop	r15
     e82:	ef 90       	pop	r14
     e84:	08 95       	ret

00000e86 <adc_init>:
      Bit 5   left or right adjust bit in ADLAR
*/
void adc_init(uint8_t voltage)
{
    ADCSRA = 0xC7 | (1<< ADEN);
     e86:	97 ec       	ldi	r25, 0xC7	; 199
     e88:	96 b9       	out	0x06, r25	; 6
	
// Set voltage reference 	
	ADMUX  =  voltage << 6;
     e8a:	82 95       	swap	r24
     e8c:	88 0f       	add	r24, r24
     e8e:	88 0f       	add	r24, r24
     e90:	80 7c       	andi	r24, 0xC0	; 192
     e92:	87 b9       	out	0x07, r24	; 7

// Set input for ADC pin
    DDRA    &= 0xF0;	
     e94:	8a b3       	in	r24, 0x1a	; 26
     e96:	80 7f       	andi	r24, 0xF0	; 240
     e98:	8a bb       	out	0x1a, r24	; 26
     e9a:	08 95       	ret

00000e9c <adc_enable_int>:

}

/*
  Input mode = 0  Disable
        mode > 0  Enable


*/
void  adc_enable_int (uint8_t mode)
{
    if (mode)
     e9c:	88 23       	and	r24, r24
     e9e:	19 f0       	breq	.+6      	; 0xea6
	{
		ADCSRA  |= ( (1 << ADEN) | (1 << ADIE) | (1<< ADSC));
     ea0:	86 b1       	in	r24, 0x06	; 6
     ea2:	88 6c       	ori	r24, 0xC8	; 200
     ea4:	02 c0       	rjmp	.+4      	; 0xeaa
    }
	else
	{
		ADCSRA  &= ~((1 << ADIE) | (1<< ADSC));
     ea6:	86 b1       	in	r24, 0x06	; 6
     ea8:	87 7b       	andi	r24, 0xB7	; 183
     eaa:	86 b9       	out	0x06, r24	; 6
     eac:	08 95       	ret
     eae:	08 95       	ret

00000eb0 <read_adc>:
	}
}


/*
Read adc value		
	
	INPUT :  channel  to read adc  ( See table for Differential INput and Gain)
    Polling mode 
*/

int16_t read_adc(uint8_t channel)
{
  int16_t  value;
  
 
// Before that need to clear ADATE and ADEN
    ADCSRA &= ~((1 << ADEN) | (1<< ADATE));
     eb0:	96 b1       	in	r25, 0x06	; 6
     eb2:	9f 75       	andi	r25, 0x5F	; 95
     eb4:	96 b9       	out	0x06, r25	; 6

// Set channel
    ADMUX |= channel;
     eb6:	97 b1       	in	r25, 0x07	; 7
     eb8:	98 2b       	or	r25, r24
     eba:	97 b9       	out	0x07, r25	; 7
	
// Enable conversion
	ADCSRA |= (1<<ADEN);
     ebc:	37 9a       	sbi	0x06, 7	; 6
// Start conversion
 
    
// Check whether conversion is complete
 
    ADCSRA |= (1<<ADSC);         // do single conversion
     ebe:	36 9a       	sbi	0x06, 6	; 6
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
     ec0:	34 9b       	sbis	0x06, 4	; 6
     ec2:	fe cf       	rjmp	.-4      	; 0xec0

//Read value
//      value = ADCL;            // read out ADCL register
//      value += (ADCH << 8);    // read out ADCH register        
	value = ADCW;
     ec4:	84 b1       	in	r24, 0x04	; 4
     ec6:	95 b1       	in	r25, 0x05	; 5
// Stop conversion
    ADCSRA &= ~(1 << ADEN);
     ec8:	37 98       	cbi	0x06, 7	; 6
     eca:	08 95       	ret

00000ecc <text_decode>:

*/ 

uint8_t text_decode (uint8_t *buffer, uint8_t *cmd_argument)
{
     ecc:	cf 92       	push	r12
     ece:	df 92       	push	r13
     ed0:	ef 92       	push	r14
     ed2:	ff 92       	push	r15
     ed4:	0f 93       	push	r16
     ed6:	1f 93       	push	r17
     ed8:	cf 93       	push	r28
     eda:	7c 01       	movw	r14, r24

 uint8_t  found,ch,ch2,cmd_no,j,k,index,cmd_complete;
 uint8_t  state = WAIT_CMD_STATE, quote  = 0;
     edc:	51 e0       	ldi	r21, 0x01	; 1
 static uint16_t i=0; // Keep pointer for next command decode
 cmd_complete = 0;
     ede:	cc 24       	eor	r12, r12
 cmd_no 	= 0;
     ee0:	dc 2c       	mov	r13, r12
 index 		= 0;
     ee2:	4c 2d       	mov	r20, r12
 
 cmd_argument  = buffer;
 
 while (*(buffer+i))	  		//End with NULL
 {
// Check with delimiter

 	 j = 0;
	 found = 0;
	
	switch (state)
	{
	  case WAIT_CMD_STATE:   // If found first character in command table  then go to get_cmd state
 		j = 0;
		while ((ch = pgm_read_byte(&text_cmd[j][0])))     //Check first charaters in cmd table
		{ 
		  if (*(buffer+i) == ch)
		  {
			state = GET_CMD_STATE;   // Found delimiter
			*(cmd_argument) = ch;
			index = 1;
			break; 
		  }
		 j++;
		}  
	    break;
	  case GET_CMD_STATE:
	    ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
		if (found)
		{
        	*(cmd_argument+index) = 0x00;
		     if (ch == '=')
			 {
// Check command number 
  				for (k = 0; k < CMD_NUM ; k++)
				{
					if (!(strcasecmp_P(cmd_argument,&text_cmd[k][0])))  // Found then keep command
					{
						cmd_no  = k+1;   // Start from 0 
						break;
					}
				}
// clear index
  				index = 0;
			    state = WAIT_ARG_STATE;	
			 }	
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}
		break;
		
	  case WAIT_ARG_STATE:
		ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
				
		if ( ch == '"')   // Start quote
		{
			quote ^= 1;   // Toggle quote	
			state = GET_ARG_STATE;   
 			index = 0;
		}
		
		if (!found)    // Not delimiter start get Argument
		{
			state = GET_ARG_STATE;   
			*(cmd_argument) = ch;
			index = 1;
		}
		break;	
	  case	GET_ARG_STATE:
	  	ch = *(buffer+i);
        j = 0; 
		found = 0;
	  	while ((ch2 = pgm_read_byte(&delimiter[j])))   //Check delimiter End with NULL
		{  
		   if ( ch == ch2)
		   {
              found = 1;
              break;
		   } 	 
           j++;	
		}
 		if ( ch == '"')     // End quote
		{
			quote ^= 1;   // Toggle quote	
   		}
		if ( quote)
		{
         	found = 0; //  ignore all characters after the quote until found quote again
// Cancel quote
            
		}	
		if (found)
		{	
            cmd_complete = 1;
			*(cmd_argument+index) = 0;
		    state = WAIT_CMD_STATE;
		}
		else
		{
			*(cmd_argument+index) = ch;
			index++;		
		}  
		break;
	}
	
	if(cmd_complete)   // COmmand both cmd number and argument
	{
		return cmd_no;	 	 
	}
	i++;
     ee4:	e0 91 e2 01 	lds	r30, 0x01E2
     ee8:	f0 91 e3 01 	lds	r31, 0x01E3
     eec:	ee 0d       	add	r30, r14
     eee:	ff 1d       	adc	r31, r15
     ef0:	80 81       	ld	r24, Z
     ef2:	88 23       	and	r24, r24
     ef4:	09 f4       	brne	.+2      	; 0xef8
     ef6:	c1 c0       	rjmp	.+386    	; 0x107a
     ef8:	30 e0       	ldi	r19, 0x00	; 0
     efa:	85 2f       	mov	r24, r21
     efc:	99 27       	eor	r25, r25
     efe:	82 30       	cpi	r24, 0x02	; 2
     f00:	91 05       	cpc	r25, r1
     f02:	79 f1       	breq	.+94     	; 0xf62
     f04:	83 30       	cpi	r24, 0x03	; 3
     f06:	91 05       	cpc	r25, r1
     f08:	1c f4       	brge	.+6      	; 0xf10
     f0a:	01 97       	sbiw	r24, 0x01	; 1
     f0c:	59 f0       	breq	.+22     	; 0xf24
     f0e:	ab c0       	rjmp	.+342    	; 0x1066
     f10:	83 30       	cpi	r24, 0x03	; 3
     f12:	91 05       	cpc	r25, r1
     f14:	09 f4       	brne	.+2      	; 0xf18
     f16:	5a c0       	rjmp	.+180    	; 0xfcc
     f18:	04 97       	sbiw	r24, 0x04	; 4
     f1a:	09 f4       	brne	.+2      	; 0xf1e
     f1c:	7b c0       	rjmp	.+246    	; 0x1014
     f1e:	a3 c0       	rjmp	.+326    	; 0x1066
     f20:	52 e0       	ldi	r21, 0x02	; 2
     f22:	72 c0       	rjmp	.+228    	; 0x1008
     f24:	23 2f       	mov	r18, r19
     f26:	ec e5       	ldi	r30, 0x5C	; 92
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	94 91       	lpm	r25, Z
     f2c:	99 23       	and	r25, r25
     f2e:	09 f4       	brne	.+2      	; 0xf32
     f30:	9a c0       	rjmp	.+308    	; 0x1066
     f32:	e0 91 e2 01 	lds	r30, 0x01E2
     f36:	f0 91 e3 01 	lds	r31, 0x01E3
     f3a:	ee 0d       	add	r30, r14
     f3c:	ff 1d       	adc	r31, r15
     f3e:	80 81       	ld	r24, Z
     f40:	3a e0       	ldi	r19, 0x0A	; 10
     f42:	89 17       	cp	r24, r25
     f44:	69 f3       	breq	.-38     	; 0xf20
     f46:	2f 5f       	subi	r18, 0xFF	; 255
     f48:	23 9f       	mul	r18, r19
     f4a:	f0 01       	movw	r30, r0
     f4c:	11 24       	eor	r1, r1
     f4e:	e4 5a       	subi	r30, 0xA4	; 164
     f50:	ff 4f       	sbci	r31, 0xFF	; 255
     f52:	94 91       	lpm	r25, Z
     f54:	99 23       	and	r25, r25
     f56:	a9 f7       	brne	.-22     	; 0xf42
     f58:	86 c0       	rjmp	.+268    	; 0x1066
     f5a:	31 e0       	ldi	r19, 0x01	; 1
     f5c:	17 c0       	rjmp	.+46     	; 0xf8c
     f5e:	c2 2e       	mov	r12, r18
     f60:	30 c0       	rjmp	.+96     	; 0xfc2
     f62:	e0 91 e2 01 	lds	r30, 0x01E2
     f66:	f0 91 e3 01 	lds	r31, 0x01E3
     f6a:	ee 0d       	add	r30, r14
     f6c:	ff 1d       	adc	r31, r15
     f6e:	90 81       	ld	r25, Z
     f70:	23 2f       	mov	r18, r19
     f72:	e4 e5       	ldi	r30, 0x54	; 84
     f74:	f0 e0       	ldi	r31, 0x00	; 0
     f76:	84 91       	lpm	r24, Z
     f78:	88 23       	and	r24, r24
     f7a:	41 f0       	breq	.+16     	; 0xf8c
     f7c:	98 17       	cp	r25, r24
     f7e:	69 f3       	breq	.-38     	; 0xf5a
     f80:	2f 5f       	subi	r18, 0xFF	; 255
     f82:	e2 2f       	mov	r30, r18
     f84:	ff 27       	eor	r31, r31
     f86:	ec 5a       	subi	r30, 0xAC	; 172
     f88:	ff 4f       	sbci	r31, 0xFF	; 255
     f8a:	f5 cf       	rjmp	.-22     	; 0xf76
     f8c:	e4 2f       	mov	r30, r20
     f8e:	ff 27       	eor	r31, r31
     f90:	33 23       	and	r19, r19
     f92:	09 f4       	brne	.+2      	; 0xf96
     f94:	64 c0       	rjmp	.+200    	; 0x105e
     f96:	ee 0d       	add	r30, r14
     f98:	ff 1d       	adc	r31, r15
     f9a:	10 82       	st	Z, r1
     f9c:	9d 33       	cpi	r25, 0x3D	; 61
     f9e:	09 f0       	breq	.+2      	; 0xfa2
     fa0:	62 c0       	rjmp	.+196    	; 0x1066
     fa2:	c0 81       	ld	r28, Z
     fa4:	0c e5       	ldi	r16, 0x5C	; 92
     fa6:	10 e0       	ldi	r17, 0x00	; 0
     fa8:	b8 01       	movw	r22, r16
     faa:	c7 01       	movw	r24, r14
     fac:	0e 94 ef 08 	call	0x11de
     fb0:	2c 2f       	mov	r18, r28
     fb2:	2f 5f       	subi	r18, 0xFF	; 255
     fb4:	89 2b       	or	r24, r25
     fb6:	99 f2       	breq	.-90     	; 0xf5e
     fb8:	c2 2f       	mov	r28, r18
     fba:	06 5f       	subi	r16, 0xF6	; 246
     fbc:	1f 4f       	sbci	r17, 0xFF	; 255
     fbe:	27 30       	cpi	r18, 0x07	; 7
     fc0:	98 f3       	brcs	.-26     	; 0xfa8
     fc2:	40 e0       	ldi	r20, 0x00	; 0
     fc4:	53 e0       	ldi	r21, 0x03	; 3
     fc6:	4f c0       	rjmp	.+158    	; 0x1066
     fc8:	31 e0       	ldi	r19, 0x01	; 1
     fca:	15 c0       	rjmp	.+42     	; 0xff6
     fcc:	e0 91 e2 01 	lds	r30, 0x01E2
     fd0:	f0 91 e3 01 	lds	r31, 0x01E3
     fd4:	ee 0d       	add	r30, r14
     fd6:	ff 1d       	adc	r31, r15
     fd8:	90 81       	ld	r25, Z
     fda:	23 2f       	mov	r18, r19
     fdc:	e4 e5       	ldi	r30, 0x54	; 84
     fde:	f0 e0       	ldi	r31, 0x00	; 0
     fe0:	84 91       	lpm	r24, Z
     fe2:	88 23       	and	r24, r24
     fe4:	41 f0       	breq	.+16     	; 0xff6
     fe6:	98 17       	cp	r25, r24
     fe8:	79 f3       	breq	.-34     	; 0xfc8
     fea:	2f 5f       	subi	r18, 0xFF	; 255
     fec:	e2 2f       	mov	r30, r18
     fee:	ff 27       	eor	r31, r31
     ff0:	ec 5a       	subi	r30, 0xAC	; 172
     ff2:	ff 4f       	sbci	r31, 0xFF	; 255
     ff4:	f5 cf       	rjmp	.-22     	; 0xfe0
     ff6:	92 32       	cpi	r25, 0x22	; 34
     ff8:	21 f4       	brne	.+8      	; 0x1002
     ffa:	81 e0       	ldi	r24, 0x01	; 1
     ffc:	d8 26       	eor	r13, r24
     ffe:	54 e0       	ldi	r21, 0x04	; 4
    1000:	40 e0       	ldi	r20, 0x00	; 0
    1002:	33 23       	and	r19, r19
    1004:	81 f5       	brne	.+96     	; 0x1066
    1006:	54 e0       	ldi	r21, 0x04	; 4
    1008:	f7 01       	movw	r30, r14
    100a:	90 83       	st	Z, r25
    100c:	41 e0       	ldi	r20, 0x01	; 1
    100e:	2b c0       	rjmp	.+86     	; 0x1066
    1010:	31 e0       	ldi	r19, 0x01	; 1
    1012:	15 c0       	rjmp	.+42     	; 0x103e
    1014:	e0 91 e2 01 	lds	r30, 0x01E2
    1018:	f0 91 e3 01 	lds	r31, 0x01E3
    101c:	ee 0d       	add	r30, r14
    101e:	ff 1d       	adc	r31, r15
    1020:	90 81       	ld	r25, Z
    1022:	23 2f       	mov	r18, r19
    1024:	e4 e5       	ldi	r30, 0x54	; 84
    1026:	f0 e0       	ldi	r31, 0x00	; 0
    1028:	84 91       	lpm	r24, Z
    102a:	88 23       	and	r24, r24
    102c:	41 f0       	breq	.+16     	; 0x103e
    102e:	98 17       	cp	r25, r24
    1030:	79 f3       	breq	.-34     	; 0x1010
    1032:	2f 5f       	subi	r18, 0xFF	; 255
    1034:	e2 2f       	mov	r30, r18
    1036:	ff 27       	eor	r31, r31
    1038:	ec 5a       	subi	r30, 0xAC	; 172
    103a:	ff 4f       	sbci	r31, 0xFF	; 255
    103c:	f5 cf       	rjmp	.-22     	; 0x1028
    103e:	92 32       	cpi	r25, 0x22	; 34
    1040:	11 f4       	brne	.+4      	; 0x1046
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	d8 26       	eor	r13, r24
    1046:	d1 10       	cpse	r13, r1
    1048:	30 e0       	ldi	r19, 0x00	; 0
    104a:	e4 2f       	mov	r30, r20
    104c:	ff 27       	eor	r31, r31
    104e:	33 23       	and	r19, r19
    1050:	31 f0       	breq	.+12     	; 0x105e
    1052:	ee 0d       	add	r30, r14
    1054:	ff 1d       	adc	r31, r15
    1056:	10 82       	st	Z, r1
    1058:	8c 2d       	mov	r24, r12
    105a:	99 27       	eor	r25, r25
    105c:	14 c0       	rjmp	.+40     	; 0x1086
    105e:	ee 0d       	add	r30, r14
    1060:	ff 1d       	adc	r31, r15
    1062:	90 83       	st	Z, r25
    1064:	4f 5f       	subi	r20, 0xFF	; 255
    1066:	e0 91 e2 01 	lds	r30, 0x01E2
    106a:	f0 91 e3 01 	lds	r31, 0x01E3
    106e:	31 96       	adiw	r30, 0x01	; 1
    1070:	f0 93 e3 01 	sts	0x01E3, r31
    1074:	e0 93 e2 01 	sts	0x01E2, r30
    1078:	39 cf       	rjmp	.-398    	; 0xeec
 }
  i = 0;
    107a:	10 92 e3 01 	sts	0x01E3, r1
    107e:	10 92 e2 01 	sts	0x01E2, r1
  return 0xFF;  // End of Buffer
    1082:	8f ef       	ldi	r24, 0xFF	; 255
    1084:	90 e0       	ldi	r25, 0x00	; 0
    1086:	cf 91       	pop	r28
    1088:	1f 91       	pop	r17
    108a:	0f 91       	pop	r16
    108c:	ff 90       	pop	r15
    108e:	ef 90       	pop	r14
    1090:	df 90       	pop	r13
    1092:	cf 90       	pop	r12
    1094:	08 95       	ret

00001096 <atoi>:
    1096:	fc 01       	movw	r30, r24
    1098:	88 27       	eor	r24, r24
    109a:	99 27       	eor	r25, r25
    109c:	e8 94       	clt

0000109e <.atoi_loop>:
    109e:	21 91       	ld	r18, Z+
    10a0:	22 23       	and	r18, r18
    10a2:	f1 f0       	breq	.+60     	; 0x10e0
    10a4:	20 32       	cpi	r18, 0x20	; 32
    10a6:	d9 f3       	breq	.-10     	; 0x109e
    10a8:	29 30       	cpi	r18, 0x09	; 9
    10aa:	c9 f3       	breq	.-14     	; 0x109e
    10ac:	2a 30       	cpi	r18, 0x0A	; 10
    10ae:	b9 f3       	breq	.-18     	; 0x109e
    10b0:	2c 30       	cpi	r18, 0x0C	; 12
    10b2:	a9 f3       	breq	.-22     	; 0x109e
    10b4:	2d 30       	cpi	r18, 0x0D	; 13
    10b6:	99 f3       	breq	.-26     	; 0x109e
    10b8:	26 37       	cpi	r18, 0x76	; 118
    10ba:	89 f3       	breq	.-30     	; 0x109e
    10bc:	2b 32       	cpi	r18, 0x2B	; 43
    10be:	19 f0       	breq	.+6      	; 0x10c6
    10c0:	2d 32       	cpi	r18, 0x2D	; 45
    10c2:	21 f4       	brne	.+8      	; 0x10cc

000010c4 <.atoi_neg>:
    10c4:	68 94       	set

000010c6 <.atoi_loop2>:
    10c6:	21 91       	ld	r18, Z+
    10c8:	22 23       	and	r18, r18
    10ca:	51 f0       	breq	.+20     	; 0x10e0

000010cc <.atoi_digit>:
    10cc:	20 33       	cpi	r18, 0x30	; 48
    10ce:	44 f0       	brlt	.+16     	; 0x10e0
    10d0:	2a 33       	cpi	r18, 0x3A	; 58
    10d2:	34 f4       	brge	.+12     	; 0x10e0
    10d4:	20 53       	subi	r18, 0x30	; 48
    10d6:	0e 94 e7 08 	call	0x11ce
    10da:	82 0f       	add	r24, r18
    10dc:	91 1d       	adc	r25, r1
    10de:	f3 cf       	rjmp	.-26     	; 0x10c6

000010e0 <.atoi_sig>:
    10e0:	81 15       	cp	r24, r1
    10e2:	91 05       	cpc	r25, r1
    10e4:	21 f0       	breq	.+8      	; 0x10ee
    10e6:	1e f4       	brtc	.+6      	; 0x10ee
    10e8:	80 95       	com	r24
    10ea:	90 95       	com	r25
    10ec:	01 96       	adiw	r24, 0x01	; 1

000010ee <.atoi_done>:
    10ee:	08 95       	ret

000010f0 <eeprom_read_byte>:
    10f0:	e1 99       	sbic	0x1c, 1	; 28
    10f2:	fe cf       	rjmp	.-4      	; 0x10f0
    10f4:	9f bb       	out	0x1f, r25	; 31
    10f6:	8e bb       	out	0x1e, r24	; 30
    10f8:	e0 9a       	sbi	0x1c, 0	; 28
    10fa:	99 27       	eor	r25, r25
    10fc:	8d b3       	in	r24, 0x1d	; 29
    10fe:	08 95       	ret

00001100 <eeprom_write_byte>:
    1100:	e1 99       	sbic	0x1c, 1	; 28
    1102:	fe cf       	rjmp	.-4      	; 0x1100
    1104:	9f bb       	out	0x1f, r25	; 31
    1106:	8e bb       	out	0x1e, r24	; 30
    1108:	6d bb       	out	0x1d, r22	; 29
    110a:	0f b6       	in	r0, 0x3f	; 63
    110c:	f8 94       	cli
    110e:	e2 9a       	sbi	0x1c, 2	; 28
    1110:	e1 9a       	sbi	0x1c, 1	; 28
    1112:	0f be       	out	0x3f, r0	; 63
    1114:	08 95       	ret

00001116 <itoa>:
    1116:	e6 2f       	mov	r30, r22
    1118:	f7 2f       	mov	r31, r23
    111a:	2e 2f       	mov	r18, r30
    111c:	3f 2f       	mov	r19, r31
    111e:	e8 94       	clt
    1120:	42 30       	cpi	r20, 0x02	; 2
    1122:	cc f0       	brlt	.+50     	; 0x1156
    1124:	45 32       	cpi	r20, 0x25	; 37
    1126:	bc f4       	brge	.+46     	; 0x1156
    1128:	4a 30       	cpi	r20, 0x0A	; 10
    112a:	29 f4       	brne	.+10     	; 0x1136
    112c:	97 fb       	bst	r25, 7
    112e:	1e f4       	brtc	.+6      	; 0x1136
    1130:	90 95       	com	r25
    1132:	81 95       	neg	r24
    1134:	9f 4f       	sbci	r25, 0xFF	; 255

00001136 <divide_loop>:
    1136:	64 2f       	mov	r22, r20
    1138:	77 27       	eor	r23, r23
    113a:	0e 94 31 09 	call	0x1262
    113e:	80 5d       	subi	r24, 0xD0	; 208
    1140:	8a 33       	cpi	r24, 0x3A	; 58
    1142:	0c f0       	brlt	.+2      	; 0x1146
    1144:	89 5d       	subi	r24, 0xD9	; 217

00001146 <L_10>:
    1146:	81 93       	st	Z+, r24
    1148:	86 2f       	mov	r24, r22
    114a:	97 2f       	mov	r25, r23
    114c:	00 97       	sbiw	r24, 0x00	; 0
    114e:	99 f7       	brne	.-26     	; 0x1136
    1150:	16 f4       	brtc	.+4      	; 0x1156
    1152:	5d e2       	ldi	r21, 0x2D	; 45
    1154:	51 93       	st	Z+, r21

00001156 <terminate>:
    1156:	93 2f       	mov	r25, r19
    1158:	82 2f       	mov	r24, r18
    115a:	10 82       	st	Z, r1
    115c:	0c 94 02 09 	jmp	0x1204

00001160 <ltoa>:
    1160:	f5 2f       	mov	r31, r21
    1162:	e4 2f       	mov	r30, r20
    1164:	cf 93       	push	r28
    1166:	ff 93       	push	r31
    1168:	ef 93       	push	r30
    116a:	22 30       	cpi	r18, 0x02	; 2
    116c:	54 f1       	brlt	.+84     	; 0x11c2
    116e:	25 32       	cpi	r18, 0x25	; 37
    1170:	44 f5       	brge	.+80     	; 0x11c2
    1172:	c2 2f       	mov	r28, r18
    1174:	e8 94       	clt
    1176:	ca 30       	cpi	r28, 0x0A	; 10
    1178:	49 f4       	brne	.+18     	; 0x118c
    117a:	97 fb       	bst	r25, 7
    117c:	3e f4       	brtc	.+14     	; 0x118c
    117e:	90 95       	com	r25
    1180:	80 95       	com	r24
    1182:	70 95       	com	r23
    1184:	61 95       	neg	r22
    1186:	7f 4f       	sbci	r23, 0xFF	; 255
    1188:	8f 4f       	sbci	r24, 0xFF	; 255
    118a:	9f 4f       	sbci	r25, 0xFF	; 255

0000118c <divide_loop>:
    118c:	2c 2f       	mov	r18, r28
    118e:	33 27       	eor	r19, r19
    1190:	44 27       	eor	r20, r20
    1192:	55 27       	eor	r21, r21
    1194:	ff 93       	push	r31
    1196:	ef 93       	push	r30
    1198:	0e 94 45 09 	call	0x128a
    119c:	ef 91       	pop	r30
    119e:	ff 91       	pop	r31
    11a0:	60 5d       	subi	r22, 0xD0	; 208
    11a2:	6a 33       	cpi	r22, 0x3A	; 58
    11a4:	0c f0       	brlt	.+2      	; 0x11a8
    11a6:	69 5d       	subi	r22, 0xD9	; 217

000011a8 <L_10>:
    11a8:	61 93       	st	Z+, r22
    11aa:	62 2f       	mov	r22, r18
    11ac:	73 2f       	mov	r23, r19
    11ae:	84 2f       	mov	r24, r20
    11b0:	95 2f       	mov	r25, r21
    11b2:	60 50       	subi	r22, 0x00	; 0
    11b4:	70 40       	sbci	r23, 0x00	; 0
    11b6:	80 40       	sbci	r24, 0x00	; 0
    11b8:	90 40       	sbci	r25, 0x00	; 0
    11ba:	41 f7       	brne	.-48     	; 0x118c
    11bc:	16 f4       	brtc	.+4      	; 0x11c2
    11be:	cd e2       	ldi	r28, 0x2D	; 45
    11c0:	c1 93       	st	Z+, r28

000011c2 <conv_finished>:
    11c2:	10 82       	st	Z, r1
    11c4:	8f 91       	pop	r24
    11c6:	9f 91       	pop	r25
    11c8:	cf 91       	pop	r28
    11ca:	0c 94 02 09 	jmp	0x1204

000011ce <__mulhi_const_10>:
    11ce:	7a e0       	ldi	r23, 0x0A	; 10
    11d0:	97 9f       	mul	r25, r23
    11d2:	90 2d       	mov	r25, r0
    11d4:	87 9f       	mul	r24, r23
    11d6:	80 2d       	mov	r24, r0
    11d8:	91 0d       	add	r25, r1
    11da:	11 24       	eor	r1, r1
    11dc:	08 95       	ret

000011de <strcasecmp_P>:
    11de:	fb 01       	movw	r30, r22
    11e0:	dc 01       	movw	r26, r24

000011e2 <.strcasecmp_P_loop>:
    11e2:	8d 91       	ld	r24, X+
    11e4:	05 90       	lpm	r0, Z+
    11e6:	60 2d       	mov	r22, r0
    11e8:	50 2d       	mov	r21, r0
    11ea:	50 62       	ori	r21, 0x20	; 32
    11ec:	51 36       	cpi	r21, 0x61	; 97
    11ee:	24 f0       	brlt	.+8      	; 0x11f8
    11f0:	5b 37       	cpi	r21, 0x7B	; 123
    11f2:	14 f4       	brge	.+4      	; 0x11f8
    11f4:	60 62       	ori	r22, 0x20	; 32
    11f6:	80 62       	ori	r24, 0x20	; 32

000011f8 <.strcasecmp_P_tst>:
    11f8:	86 1b       	sub	r24, r22
    11fa:	11 f4       	brne	.+4      	; 0x1200
    11fc:	00 20       	and	r0, r0
    11fe:	89 f7       	brne	.-30     	; 0x11e2

00001200 <.strcasecmp_P_done>:
    1200:	99 0b       	sbc	r25, r25
    1202:	08 95       	ret

00001204 <strrev>:
    1204:	dc 01       	movw	r26, r24
    1206:	fc 01       	movw	r30, r24

00001208 <.strrev_eos>:
    1208:	01 90       	ld	r0, Z+
    120a:	00 20       	and	r0, r0
    120c:	e9 f7       	brne	.-6      	; 0x1208
    120e:	32 97       	sbiw	r30, 0x02	; 2

00001210 <.strrev_loop>:
    1210:	ae 17       	cp	r26, r30
    1212:	bf 07       	cpc	r27, r31
    1214:	30 f4       	brcc	.+12     	; 0x1222
    1216:	7c 91       	ld	r23, X
    1218:	60 81       	ld	r22, Z
    121a:	70 83       	st	Z, r23
    121c:	31 97       	sbiw	r30, 0x01	; 1
    121e:	6d 93       	st	X+, r22
    1220:	f7 cf       	rjmp	.-18     	; 0x1210

00001222 <.strrev_done>:
    1222:	08 95       	ret

00001224 <__mulsi3>:
    1224:	62 9f       	mul	r22, r18
    1226:	d0 01       	movw	r26, r0
    1228:	73 9f       	mul	r23, r19
    122a:	f0 01       	movw	r30, r0
    122c:	82 9f       	mul	r24, r18
    122e:	e0 0d       	add	r30, r0
    1230:	f1 1d       	adc	r31, r1
    1232:	64 9f       	mul	r22, r20
    1234:	e0 0d       	add	r30, r0
    1236:	f1 1d       	adc	r31, r1
    1238:	92 9f       	mul	r25, r18
    123a:	f0 0d       	add	r31, r0
    123c:	83 9f       	mul	r24, r19
    123e:	f0 0d       	add	r31, r0
    1240:	74 9f       	mul	r23, r20
    1242:	f0 0d       	add	r31, r0
    1244:	65 9f       	mul	r22, r21
    1246:	f0 0d       	add	r31, r0
    1248:	99 27       	eor	r25, r25
    124a:	72 9f       	mul	r23, r18
    124c:	b0 0d       	add	r27, r0
    124e:	e1 1d       	adc	r30, r1
    1250:	f9 1f       	adc	r31, r25
    1252:	63 9f       	mul	r22, r19
    1254:	b0 0d       	add	r27, r0
    1256:	e1 1d       	adc	r30, r1
    1258:	f9 1f       	adc	r31, r25
    125a:	bd 01       	movw	r22, r26
    125c:	cf 01       	movw	r24, r30
    125e:	11 24       	eor	r1, r1
    1260:	08 95       	ret

00001262 <__udivmodhi4>:
    1262:	aa 1b       	sub	r26, r26
    1264:	bb 1b       	sub	r27, r27
    1266:	51 e1       	ldi	r21, 0x11	; 17
    1268:	07 c0       	rjmp	.+14     	; 0x1278

0000126a <__udivmodhi4_loop>:
    126a:	aa 1f       	adc	r26, r26
    126c:	bb 1f       	adc	r27, r27
    126e:	a6 17       	cp	r26, r22
    1270:	b7 07       	cpc	r27, r23
    1272:	10 f0       	brcs	.+4      	; 0x1278
    1274:	a6 1b       	sub	r26, r22
    1276:	b7 0b       	sbc	r27, r23

00001278 <__udivmodhi4_ep>:
    1278:	88 1f       	adc	r24, r24
    127a:	99 1f       	adc	r25, r25
    127c:	5a 95       	dec	r21
    127e:	a9 f7       	brne	.-22     	; 0x126a
    1280:	80 95       	com	r24
    1282:	90 95       	com	r25
    1284:	bc 01       	movw	r22, r24
    1286:	cd 01       	movw	r24, r26
    1288:	08 95       	ret

0000128a <__udivmodsi4>:
    128a:	a1 e2       	ldi	r26, 0x21	; 33
    128c:	1a 2e       	mov	r1, r26
    128e:	aa 1b       	sub	r26, r26
    1290:	bb 1b       	sub	r27, r27
    1292:	fd 01       	movw	r30, r26
    1294:	0d c0       	rjmp	.+26     	; 0x12b0

00001296 <__udivmodsi4_loop>:
    1296:	aa 1f       	adc	r26, r26
    1298:	bb 1f       	adc	r27, r27
    129a:	ee 1f       	adc	r30, r30
    129c:	ff 1f       	adc	r31, r31
    129e:	a2 17       	cp	r26, r18
    12a0:	b3 07       	cpc	r27, r19
    12a2:	e4 07       	cpc	r30, r20
    12a4:	f5 07       	cpc	r31, r21
    12a6:	20 f0       	brcs	.+8      	; 0x12b0
    12a8:	a2 1b       	sub	r26, r18
    12aa:	b3 0b       	sbc	r27, r19
    12ac:	e4 0b       	sbc	r30, r20
    12ae:	f5 0b       	sbc	r31, r21

000012b0 <__udivmodsi4_ep>:
    12b0:	66 1f       	adc	r22, r22
    12b2:	77 1f       	adc	r23, r23
    12b4:	88 1f       	adc	r24, r24
    12b6:	99 1f       	adc	r25, r25
    12b8:	1a 94       	dec	r1
    12ba:	69 f7       	brne	.-38     	; 0x1296
    12bc:	60 95       	com	r22
    12be:	70 95       	com	r23
    12c0:	80 95       	com	r24
    12c2:	90 95       	com	r25
    12c4:	9b 01       	movw	r18, r22
    12c6:	ac 01       	movw	r20, r24
    12c8:	bd 01       	movw	r22, r26
    12ca:	cf 01       	movw	r24, r30
    12cc:	08 95       	ret
