   1               		.file	"main.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  69               	.global	jump_to_app
  70               	.global	jump_to_app
  71               		.section .bss
  74               	jump_to_app:
  75 0000 0000      		.skip 2,0
  76               		.text
  78               	.global	send_boot
  80               	send_boot:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.7 (Feb. 2005)
   5:main.c        **** * Compiler : avr-gcc 3.4.1 / avr-libc 1.0.2 
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *
  10:main.c        **** * License  : Copyright (c) 2005 Martin Thomas
  11:main.c        **** *            Free to use. You have to mention the copyright 
  12:main.c        **** *            owners in source-code and documentation of derived 
  13:main.c        **** *            work. No warranty.
  14:main.c        **** *
  15:main.c        **** * Tested with ATmega8, ATmega16, ATmega32, ATmega128
  16:main.c        **** *
  17:main.c        **** * - based on the Butterfly Bootloader-Code
  18:main.c        **** *   Copyright (C) 1996-1998 Atmel Corporation
  19:main.c        **** *   Author(s)     : BBrandal, PKastnes, ARodland, LHM
  20:main.c        **** *   The orignal code has been made available by ATMEL together with the 
  21:main.c        **** *   Butterfly application code. Since ATMEL.NO had no problem with 
  22:main.c        **** *   the application gcc-port they hopefully will not have any concerns about
  23:main.c        **** *   publishing this port. A lot of things have been change but the ATMEL
  24:main.c        **** *   "skeleton" is still in this code. Make sure to keep the copyright notice 
  25:main.c        **** *   in derived work to avoid trouble.
  26:main.c        **** *
  27:main.c        **** * - based on boot.h from the avr-libc (c) Eric Weddington
  28:main.c        **** *
  29:main.c        **** * - Modified by Wichai Tossamartvorakul 23/8/2006  To change checking booloader condition 
  30:main.c        **** *   By press two switch on PD3,PC2 at once  ( For E-block I/O project)
  31:main.c        **** * 
  32:main.c        **** ****************************************************************************
  33:main.c        **** *
  34:main.c        **** *  The boot interrupt vector is included (this bootloader is completly in
  35:main.c        **** *  ".text" section). If you need this space for further functions you have to
  36:main.c        **** *  add a separate section for the bootloader-functions and add an attribute
  37:main.c        **** *  for this section to _all_ function prototypes of functions in the loader. 
  38:main.c        **** *  With this the interrupt vector will be placed at .0000 and the bootloader 
  39:main.c        **** *  code (without interrupt vector) at the adress you define in the linker
  40:main.c        **** *  options for the newly created section. See the avr-libc FAQ, the avr-
  41:main.c        **** *  libc's avr/boot.h documentation and the makefile for further details.
  42:main.c        **** *
  43:main.c        **** *  See the makefile for information how to adopt the linker-settings to 
  44:main.c        **** *  the selected Boot Size (_Bxxx below)
  45:main.c        **** *
  46:main.c        **** *  With BOOT_SIMPLE this bootloader has 0x3DE bytes size and should fit
  47:main.c        **** *  into a 512word bootloader-section.
  48:main.c        **** *
  49:main.c        **** *  Set AVR clock-frequency and the baudrate below, set MCU-type in 
  50:main.c        **** *  makefile.
  51:main.c        **** *
  52:main.c        **** ****************************************************************************/
  53:main.c        **** /*
  54:main.c        **** 	Does not work reliably so far:
  55:main.c        **** 	- lock bits set
  56:main.c        **** */
  57:main.c        **** 
  58:main.c        **** // programmers-notepad tabsize 4
  59:main.c        **** #define VERSION_HIGH '0'
  60:main.c        **** #define VERSION_LOW  '7'
  61:main.c        **** 
  62:main.c        **** #include <inttypes.h>
  63:main.c        **** #include <avr/io.h>
  64:main.c        **** #include <avr/interrupt.h>
  65:main.c        **** #include <avr/wdt.h>
  66:main.c        **** #include <avr/boot.h>
  67:main.c        **** #include <avr/pgmspace.h>
  68:main.c        **** //#include <avr/delay.h>
  69:main.c        **** // function not found in boot.h to read lock/fuses
  70:main.c        **** #include "lowlevel.h"
  71:main.c        **** #include "Dual_7Segment.h"
  72:main.c        **** 
  73:main.c        **** 
  74:main.c        **** /* Pin "BLPNUM" on port "BLPORT" in this port has to grounded 
  75:main.c        ****    (active low) to start the bootloader */
  76:main.c        **** #define BLPORT1  PORTC
  77:main.c        **** #define BLDDR1   DDRC
  78:main.c        **** #define BLPIN1   PINC
  79:main.c        **** #define BLPNUM1  PINC2
  80:main.c        **** 
  81:main.c        **** // Add another SW
  82:main.c        **** #define BLPORT2  PORTD
  83:main.c        **** #define BLDDR2   DDRD
  84:main.c        **** #define BLPIN2   PIND
  85:main.c        **** #define BLPNUM2  PIND3
  86:main.c        **** 
  87:main.c        **** 	
  88:main.c        **** /* 
  89:main.c        ****    Select startup-mode
  90:main.c        ****    * SIMPLE-Mode - Jump to bootloader main BL-loop if key is 
  91:main.c        ****      pressed (Pin grounded) "during" reset or jump to the 
  92:main.c        **** 	 application if the pin is not grounded (=pulled up by
  93:main.c        **** 	 internal pull-up-resistor)
  94:main.c        ****    * POWERSAVE-Mode - Startup is separated in two loops
  95:main.c        ****      which makes power-saving a little easier if no firmware
  96:main.c        **** 	 is on the chip. Needs more memory
  97:main.c        ****    * BOOTICE-Mode - to flash the JTAGICE upgrade.ebn file.
  98:main.c        ****      No startup-sequence in this mode. Jump directly to the
  99:main.c        ****      parser-loop on reset 
 100:main.c        ****      XTAL in BOOTICEMODE must be 7372800 Hz to be compatible
 101:main.c        ****      with the org. JTAGICE-Firmware */
 102:main.c        **** 	 
 103:main.c        **** #define START_SIMPLE
 104:main.c        **** //#define START_POWERSAVE
 105:main.c        **** //#define START_BOOTICE
 106:main.c        **** 
 107:main.c        **** #ifndef START_BOOTICE
 108:main.c        **** //#define XTAL 3686400
 109:main.c        ****  #define XTAL 16000000UL
 110:main.c        **** #else
 111:main.c        **** #warning "BOOTICE mode - External Crystal/Oszillator must be 7,3728 MHz"
 112:main.c        **** #define XTAL 7372800
 113:main.c        **** #endif
 114:main.c        **** 
 115:main.c        **** // UART handling - some definitions from P. Fleury's Library - thanks
 116:main.c        **** #define BAUDRATE 19200
 117:main.c        **** 
 118:main.c        **** #include "uart.h"
 119:main.c        **** 
 120:main.c        **** /* enable/disable readout of fuse and lock-bits 
 121:main.c        ****   (will not work for Mega169 since not supported by AVRPROG 1.37 */
 122:main.c        **** #define ENABLEREADFUSELOCK 
 123:main.c        **** 
 124:main.c        **** /* enable/disable write of lock-bits 
 125:main.c        ****   WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 126:main.c        ****   Only protection no unprotection, "chip erase" from bootloader only
 127:main.c        ****   clears the flash but does no real "chip erase" (this is not possible
 128:main.c        ****   with a bootloader as far as I know)
 129:main.c        ****   Keep this undefined!
 130:main.c        ****  */
 131:main.c        **** // #define WRITELOCKBITS
 132:main.c        **** 
 133:main.c        **** /* Select Boot Size (select one, comment out the others) */
 134:main.c        **** // NO! #define _B128
 135:main.c        **** // NO! #define _B256  
 136:main.c        **** // MAYBE: #define _B512 
 137:main.c        **** //#define _B1024 
 138:main.c        **** #define _B2048
 139:main.c        **** 
 140:main.c        **** #include "chipdef.h"
 141:main.c        **** 
 142:main.c        **** #define UART_RX_BUFFER_SIZE SPM_PAGESIZE
 143:main.c        **** unsigned char gBuffer[UART_RX_BUFFER_SIZE];
 144:main.c        **** 
 145:main.c        **** #define eeprom_is_ready()             bit_is_clear(EECR, EEWE)
 146:main.c        **** #define my_eeprom_busy_wait()         do{}while(!eeprom_is_ready())
 147:main.c        **** 
 148:main.c        **** 
 149:main.c        **** 
 150:main.c        **** unsigned char BufferLoad(unsigned int , unsigned char ) ;
 151:main.c        **** void BlockRead(unsigned int , unsigned char ) ;
 152:main.c        **** 
 153:main.c        **** uint32_t address;
 154:main.c        **** unsigned char device;
 155:main.c        **** 
 156:main.c        **** void send_boot(void)
 157:main.c        **** {
  82               	.LM1:
  83               	/* prologue: frame size=0 */
  84               	/* prologue end (size=0) */
 158:main.c        **** 	sendchar('A');
  86               	.LM2:
  87 0000 81E4      		ldi r24,lo8(65)
  88 0002 0E94 0000 		call sendchar
 159:main.c        **** 	sendchar('V');
  90               	.LM3:
  91 0006 86E5      		ldi r24,lo8(86)
  92 0008 0E94 0000 		call sendchar
 160:main.c        **** 	sendchar('R');
  94               	.LM4:
  95 000c 82E5      		ldi r24,lo8(82)
  96 000e 0E94 0000 		call sendchar
 161:main.c        **** 	sendchar('B');
  98               	.LM5:
  99 0012 82E4      		ldi r24,lo8(66)
 100 0014 0E94 0000 		call sendchar
 162:main.c        **** 	sendchar('O');
 102               	.LM6:
 103 0018 8FE4      		ldi r24,lo8(79)
 104 001a 0E94 0000 		call sendchar
 163:main.c        **** 	sendchar('O');
 106               	.LM7:
 107 001e 8FE4      		ldi r24,lo8(79)
 108 0020 0E94 0000 		call sendchar
 164:main.c        **** 	sendchar('T');
 110               	.LM8:
 111 0024 84E5      		ldi r24,lo8(84)
 112 0026 0E94 0000 		call sendchar
 113               	/* epilogue: frame size=0 */
 114 002a 0895      		ret
 115               	/* epilogue end (size=1) */
 116               	/* function send_boot size 22 (21) */
 118               	.Lscope0:
 120               	.global	d7segment_init
 122               	d7segment_init:
 165:main.c        **** }
 166:main.c        **** 
 167:main.c        **** void (*jump_to_app)(void) = 0x0000;
 168:main.c        **** 
 169:main.c        **** // Show output to 7 Segments
 170:main.c        **** 
 171:main.c        **** 
 172:main.c        **** void d7segment_init (void)
 173:main.c        **** {
 124               	.LM9:
 125               	/* prologue: frame size=0 */
 126               	/* prologue end (size=0) */
 174:main.c        **** // Set direction for output for 7 Segment
 175:main.c        **** 	_7SEGMENT_DIGIT_DIR   = 0xFF;
 128               	.LM10:
 129 002c 8FEF      		ldi r24,lo8(-1)
 130 002e 87BB      		out 55-0x20,r24
 176:main.c        **** 	_7SEGMENT_PORT_DIR	  |= _7SEGMENT_DIGIT1 | _7SEGMENT_DIGIT2;
 132               	.LM11:
 133 0030 84B3      		in r24,52-0x20
 134 0032 8861      		ori r24,lo8(24)
 135 0034 84BB      		out 52-0x20,r24
 177:main.c        ****  
 178:main.c        **** // Set direction for input for SW 
 179:main.c        **** 	_7SEGMENT_SW1_DIR	&=  ~(_7SEGMENT_SW1);
 137               	.LM12:
 138 0036 8B98      		cbi 49-0x20,3
 180:main.c        **** 	_7SEGMENT_SW2_DIR	&=  ~(_7SEGMENT_SW2);
 140               	.LM13:
 141 0038 A298      		cbi 52-0x20,2
 181:main.c        **** 
 182:main.c        **** // Enable pull up
 183:main.c        ****     _7SEGMENT_SW1_PORT   |= _7SEGMENT_SW1;
 143               	.LM14:
 144 003a 939A      		sbi 50-0x20,3
 184:main.c        ****     _7SEGMENT_SW2_PORT   |= _7SEGMENT_SW2;
 146               	.LM15:
 147 003c AA9A      		sbi 53-0x20,2
 148               	/* epilogue: frame size=0 */
 149 003e 0895      		ret
 150               	/* epilogue end (size=1) */
 151               	/* function d7segment_init size 10 (9) */
 153               	.Lscope1:
 157               	.global	d7segment_display
 159               	d7segment_display:
 185:main.c        **** 	
 186:main.c        **** }
 187:main.c        **** 
 188:main.c        ****  /* Display numeric 0-9  on  digit 0 or 1 
 189:main.c        ****   
 190:main.c        **** 	INPUT
 191:main.c        **** 	num		:	number to show
 192:main.c        **** 	digit 	: 	Digit  to show
 193:main.c        **** 	
 194:main.c        **** 	OUTPUT	:	null
 195:main.c        **** 	
 196:main.c        **** */  
 197:main.c        **** 
 198:main.c        **** #include "Dual_7Segment.h"
 199:main.c        **** 
 200:main.c        **** void d7segment_display( uint8_t num, uint8_t digit)
 201:main.c        **** {
 161               	.LM16:
 162               	/* prologue: frame size=0 */
 163               	/* prologue end (size=0) */
 202:main.c        ****  
 203:main.c        ****    _7SEGMENT_PORT = num;
 165               	.LM17:
 166 0040 88BB      		out 56-0x20,r24
 204:main.c        **** // Out digit
 205:main.c        **** 	 
 206:main.c        ****     if ( digit == 1 )
 168               	.LM18:
 169 0042 6130      		cpi r22,lo8(1)
 170 0044 19F4      		brne .L4
 207:main.c        **** 	{  // ON Digit 1 OFF  ( 1 Off  0 On)
 208:main.c        **** 		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT1);
 172               	.LM19:
 173 0046 AB98      		cbi 53-0x20,3
 209:main.c        **** 	   // OFF Digit 2 
 210:main.c        **** 	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT2;
 175               	.LM20:
 176 0048 AC9A      		sbi 53-0x20,4
 177 004a 0895      		ret
 178               	.L4:
 211:main.c        **** 	}
 212:main.c        **** 	if ( digit == 2 )
 180               	.LM21:
 181 004c 6230      		cpi r22,lo8(2)
 182 004e 11F4      		brne .L3
 213:main.c        **** 	{  // ON Digit 2 OFF  ( 1 Off  0 On)
 214:main.c        **** 		_7SEGMENT_DIGIT_PORT &= ~(_7SEGMENT_DIGIT2);
 184               	.LM22:
 185 0050 AC98      		cbi 53-0x20,4
 215:main.c        **** 	   // OFF Digit 1
 216:main.c        **** 	   _7SEGMENT_DIGIT_PORT |= _7SEGMENT_DIGIT1;
 187               	.LM23:
 188 0052 AB9A      		sbi 53-0x20,3
 189               	.L3:
 190 0054 0895      		ret
 191               	/* epilogue: frame size=0 */
 192 0056 0895      		ret
 193               	/* epilogue end (size=1) */
 194               	/* function d7segment_display size 12 (11) */
 196               	.Lscope2:
 200               	.global	BufferLoad
 202               	BufferLoad:
 217:main.c        **** 	}	
 218:main.c        **** 
 219:main.c        **** }	
 220:main.c        **** 
 221:main.c        **** 
 222:main.c        **** int main(void)
 223:main.c        **** {
 224:main.c        ****  
 225:main.c        **** 	unsigned  tempi;
 226:main.c        **** 	char val;
 227:main.c        ****     uint8_t sw1,sw2;
 228:main.c        **** 	
 229:main.c        **** 	#ifdef START_POWERSAVE
 230:main.c        **** 	char OK = 1;    
 231:main.c        **** 	#endif
 232:main.c        ****     
 233:main.c        **** 	cli();
 234:main.c        **** 	
 235:main.c        **** 	MCUCR = (1<<IVCE);       
 236:main.c        **** 	MCUCR = (1<<IVSEL);             //move interruptvectors to the Boot sector    
 237:main.c        ****  
 238:main.c        **** 	USART_Init(UART_BAUD_SELECT(BAUDRATE,XTAL),UARTSINGLE); 	// single speed
 239:main.c        **** 	// USART_Init(UART_BAUD_SELECT(BAUDRATE/2,XTAL),UARTDOUBLE);  // double speed
 240:main.c        **** 	d7segment_init();
 241:main.c        **** 	
 242:main.c        **** 
 243:main.c        **** 
 244:main.c        **** 
 245:main.c        **** 	
 246:main.c        **** 
 247:main.c        **** #if defined(START_POWERSAVE)
 248:main.c        **** 	/* 
 249:main.c        **** 		This is an adoption of the Butterfly Bootloader startup-sequence.
 250:main.c        **** 		It may look a little strange but separating the login-loop from
 251:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 252:main.c        **** 	    etc.).
 253:main.c        **** 	*/		
 254:main.c        ****  
 255:main.c        **** 	
 256:main.c        **** 	for(;OK;)
 257:main.c        **** 	{
 258:main.c        **** 		if((BLPIN1 & (1<<BLPNUM1)) || (BLPIN2 & (1<<BLPNUM2)))	 // Either one of two switch press still g
 259:main.c        **** 		{  
 260:main.c        **** 			// jump to main app if pin is not grounded
 261:main.c        **** 			BLPORT1 &= ~(1<<BLPNUM1);  // set to default
 262:main.c        **** 			MCUCR = (1<<IVCE); 
 263:main.c        **** 			MCUCR = (0<<IVSEL);      // move interruptvectors to the Application sector
 264:main.c        **** 			jump_to_app();			 // Jump to application sector
 265:main.c        **** 		}
 266:main.c        **** 		else
 267:main.c        **** 		{	
 268:main.c        **** 			val = recchar();
 269:main.c        **** 		
 270:main.c        **** 			if( val == 0x1B ) /* ESC */
 271:main.c        **** 	        {				// AVRPROG connection
 272:main.c        **** 				while (val != 'S')	// Wait for signon 
 273:main.c        **** 				{
 274:main.c        **** 					val = recchar();
 275:main.c        **** 				}
 276:main.c        **** 				send_boot();					// Report signon
 277:main.c        **** 				OK = 0;
 278:main.c        **** 			}
 279:main.c        **** 			else
 280:main.c        **** 				sendchar('?');
 281:main.c        **** 	        }
 282:main.c        **** 		// Power-Save code here
 283:main.c        **** 	}
 284:main.c        **** 	
 285:main.c        **** #elif defined(START_SIMPLE)
 286:main.c        ****  
 287:main.c        **** 
 288:main.c        ****    sw1 = _7SEGMENT_SW1_IN_PORT & _7SEGMENT_SW1; 
 289:main.c        ****    sw2 = _7SEGMENT_SW2_IN_PORT & _7SEGMENT_SW2; 
 290:main.c        ****    
 291:main.c        ****     if ((sw1) ) //&&  (!sw2)) // SW1, SW2 Press
 292:main.c        **** //	if((BLPIN1 & (1<<BLPNUM1)) || (BLPIN2 & (1<<BLPNUM2))) 
 293:main.c        **** 	{  
 294:main.c        **** // jump to main app if pin is  grounded
 295:main.c        **** //		BLPORT1 &= ~(1<<BLPNUM1);  		// set to default  ??
 296:main.c        **** //		BLPORT2 &= ~(1<<BLPNUM2);  		// set to default  ??
 297:main.c        **** 		MCUCR = (1<<IVCE); 
 298:main.c        **** 		MCUCR = (0<<IVSEL);             //move interruptvectors to the Application sector
 299:main.c        **** 
 300:main.c        **** 		d7segment_display(_7SEGMENT_C_P,1);
 301:main.c        **** 		jump_to_app();					// Jump to application sector
 302:main.c        **** 	}
 303:main.c        **** 	
 304:main.c        **** 	#elif defined(START_BOOTICE)
 305:main.c        **** 	#warning "BOOTICE mode - no startup-condition"
 306:main.c        **** 
 307:main.c        **** 	#else
 308:main.c        **** 	#error "Select START_ condition for bootloader in main.c"
 309:main.c        **** 	#endif
 310:main.c        **** 
 311:main.c        ****   
 312:main.c        **** 	
 313:main.c        ****     for(;;)                             
 314:main.c        ****     {   
 315:main.c        **** 	    d7segment_display(_7SEGMENT_C_B,1);
 316:main.c        **** 		val=recchar();
 317:main.c        ****          
 318:main.c        ****         if(val=='a')                         //Autoincrement?
 319:main.c        ****         {
 320:main.c        ****           sendchar('Y');					  //Autoincrement is quicker
 321:main.c        ****         }
 322:main.c        ****  
 323:main.c        ****         else if(val=='A')                    //write address 
 324:main.c        ****         {
 325:main.c        **** 			address=recchar();                //read address 8 MSB
 326:main.c        **** 			address=(address<<8)|recchar();
 327:main.c        **** 			
 328:main.c        **** 			address=address<<1;               // !! convert from word address to byte address
 329:main.c        **** 			sendchar('\r');
 330:main.c        ****         }
 331:main.c        ****         
 332:main.c        ****         else if(val=='b')
 333:main.c        **** 		{									// Buffer load support
 334:main.c        **** 			sendchar('Y');					// Report buffer load supported
 335:main.c        **** 			sendchar((UART_RX_BUFFER_SIZE >> 8) & 0xFF);
 336:main.c        **** 											// Report buffer size in bytes
 337:main.c        **** 			sendchar(UART_RX_BUFFER_SIZE & 0xFF);
 338:main.c        **** 		}
 339:main.c        **** 
 340:main.c        **** 		else if(val=='B')					// Start buffer load
 341:main.c        **** 		{
 342:main.c        **** 			tempi = recchar() << 8;			// Load high byte of buffersize
 343:main.c        **** 			tempi |= recchar();				// Load low byte of buffersize
 344:main.c        **** 			val = recchar();				// Load memory type ('E' or 'F')
 345:main.c        **** 			sendchar (BufferLoad(tempi,val));
 346:main.c        **** 											// Start downloading of buffer
 347:main.c        **** 		}
 348:main.c        **** 		
 349:main.c        **** 		else if(val == 'g')					// Block read
 350:main.c        **** 		{
 351:main.c        **** 			tempi = (recchar() << 8) | recchar();
 352:main.c        **** 
 353:main.c        **** 			val = recchar();				// Get memtype
 354:main.c        **** 			BlockRead(tempi,val);			// Perform the block read
 355:main.c        **** 		}		
 356:main.c        **** 
 357:main.c        ****         else if(val=='e')                   //Chip erase 
 358:main.c        ****         {
 359:main.c        **** 			if (device == devtype)
 360:main.c        **** 			{
 361:main.c        **** 				// erase only main section (bootloader protection)
 362:main.c        **** 				address = 0; 
 363:main.c        **** 				while ( APP_END > address )
 364:main.c        **** 				{
 365:main.c        **** 					boot_page_erase(address);	// Perform page erase
 366:main.c        **** 					boot_spm_busy_wait();		// Wait until the memory is erased.
 367:main.c        **** 					address += SPM_PAGESIZE;
 368:main.c        **** 				}
 369:main.c        **** 			}
 370:main.c        **** 			boot_rww_enable();
 371:main.c        **** 			sendchar('\r');  
 372:main.c        **** 
 373:main.c        ****         }
 374:main.c        **** 
 375:main.c        ****         else if(val=='E')                   //Exit upgrade
 376:main.c        ****         {
 377:main.c        **** //			wdt_enable(WDTO_15MS); // Enable Watchdog Timer to give reset
 378:main.c        **** 			sendchar('\r');
 379:main.c        **** 			MCUCR = (1<<IVCE); 
 380:main.c        **** 			MCUCR = (0<<IVSEL);             //move interruptvectors to the Application sector
 381:main.c        **** 			jump_to_app();					// Jump to application sector
 382:main.c        ****         }
 383:main.c        ****        
 384:main.c        **** 	   #ifdef WRITELOCKBITS
 385:main.c        **** 	   #warning "Extension 'WriteLockBits' enabled"
 386:main.c        **** 	   // TODO: does not work reliably
 387:main.c        ****         else if(val=='l')                   // write lockbits 
 388:main.c        ****         {
 389:main.c        **** 			if (device == devtype)
 390:main.c        **** 			{
 391:main.c        **** 				// write_lock_bits(recchar());
 392:main.c        **** 				boot_lock_bits_set(recchar());	// boot.h takes care of mask
 393:main.c        **** 				boot_spm_busy_wait();
 394:main.c        **** 			}
 395:main.c        **** 			sendchar('\r');
 396:main.c        **** 		}
 397:main.c        **** 		#endif
 398:main.c        ****         
 399:main.c        ****         else if(val=='P')     // Enter programming mode 
 400:main.c        ****         {
 401:main.c        **** 			sendchar('\r');
 402:main.c        ****         }
 403:main.c        ****         
 404:main.c        ****         else if(val=='L')   // Leave programming mode
 405:main.c        ****         { 
 406:main.c        **** 			sendchar('\r');
 407:main.c        ****         }
 408:main.c        ****         
 409:main.c        ****         else if (val=='p')		// return programmer type
 410:main.c        ****         {
 411:main.c        ****           sendchar('S');		// always serial programmer
 412:main.c        ****         } 
 413:main.c        **** 		
 414:main.c        **** #ifdef ENABLEREADFUSELOCK
 415:main.c        **** #warning "Extension 'ReadFuseLock' enabled"
 416:main.c        ****         else if(val=='F')                   // read "low" fuse bits
 417:main.c        ****         {
 418:main.c        **** 			sendchar( read_fuse_lock(0x0000, _BV(BLBSET)|_BV(SPMEN)) );
 419:main.c        ****         }
 420:main.c        **** 
 421:main.c        ****         else if(val=='r')                   // read lock bits
 422:main.c        ****         { 
 423:main.c        **** 			sendchar( read_fuse_lock(0x0001, _BV(BLBSET)|_BV(SPMEN)) );
 424:main.c        ****         }        
 425:main.c        **** 
 426:main.c        ****         else if(val=='N')                   // read high fuse bits
 427:main.c        ****         {
 428:main.c        **** 			sendchar( read_fuse_lock(0x0003,_BV(BLBSET)|_BV(SPMEN)) );
 429:main.c        ****         }        
 430:main.c        **** 
 431:main.c        ****         else if(val=='Q')                   // read extended fuse bits
 432:main.c        ****         {
 433:main.c        **** 			sendchar( read_fuse_lock(0x0002,_BV(BLBSET)|_BV(SPMEN)) );
 434:main.c        ****         }
 435:main.c        **** #endif	
 436:main.c        **** // end of ENABLEREADFUSELOCK section
 437:main.c        **** 
 438:main.c        ****         else if(val=='t')                   // Return device type 
 439:main.c        ****         {
 440:main.c        **** 			sendchar(devtype);
 441:main.c        **** 			sendchar(0);
 442:main.c        ****         }
 443:main.c        **** 
 444:main.c        ****         else if ((val=='x')||(val=='y'))	// clear and set LED ignored
 445:main.c        ****         {
 446:main.c        **** 			recchar();
 447:main.c        **** 			sendchar('\r');
 448:main.c        ****         }
 449:main.c        ****   
 450:main.c        **** 		else if (val=='T')					// set device
 451:main.c        **** 		{
 452:main.c        **** 			device = recchar();
 453:main.c        **** 			sendchar('\r');
 454:main.c        **** 		}
 455:main.c        **** 		
 456:main.c        ****         else if (val=='S')                  // Return software identifier 
 457:main.c        ****         {
 458:main.c        **** 			send_boot();
 459:main.c        ****         }                
 460:main.c        ****         
 461:main.c        ****         else if (val=='V')                  // Return Software Version
 462:main.c        ****         {
 463:main.c        **** 			sendchar(VERSION_HIGH);
 464:main.c        **** 			sendchar(VERSION_LOW);
 465:main.c        ****         }        
 466:main.c        **** 
 467:main.c        ****         else if (val=='s')                  // Return Signature Byte
 468:main.c        ****         {
 469:main.c        **** 			sendchar(sig_byte1);
 470:main.c        **** 			sendchar(sig_byte2);
 471:main.c        **** 			sendchar(sig_byte3);
 472:main.c        ****         }       
 473:main.c        **** 
 474:main.c        ****         else if(val != 0x1b) /* ESC */
 475:main.c        ****         {
 476:main.c        **** 			sendchar('?');
 477:main.c        ****         }
 478:main.c        **** 
 479:main.c        **** 	}	// end of "parser" for-loop
 480:main.c        **** 
 481:main.c        **** 	return 0;
 482:main.c        **** }
 483:main.c        **** 
 484:main.c        **** 
 485:main.c        **** unsigned char BufferLoad(unsigned int size, unsigned char mem)
 486:main.c        **** {
 204               	.LM24:
 205               	/* prologue: frame size=0 */
 206 0058 BF92      		push r11
 207 005a CF92      		push r12
 208 005c DF92      		push r13
 209 005e EF92      		push r14
 210 0060 FF92      		push r15
 211 0062 0F93      		push r16
 212 0064 1F93      		push r17
 213 0066 CF93      		push r28
 214 0068 DF93      		push r29
 215               	/* prologue end (size=9) */
 216 006a 8C01      		movw r16,r24
 217 006c B62E      		mov r11,r22
 487:main.c        **** 	unsigned int data, cnt;
 488:main.c        **** 	uint32_t tempaddress;
 489:main.c        **** 		
 490:main.c        **** 	for (cnt=0; cnt<UART_RX_BUFFER_SIZE; cnt++)
 219               	.LM25:
 220 006e 20E0      		ldi r18,lo8(0)
 221 0070 30E0      		ldi r19,hi8(0)
 222               	.L12:
 223 0072 E901      		movw r28,r18
 224 0074 C050      		subi r28,lo8(-(gBuffer))
 225 0076 D040      		sbci r29,hi8(-(gBuffer))
 226 0078 7901      		movw r14,r18
 227 007a 0894      		sec
 228 007c E11C      		adc r14,__zero_reg__
 229 007e F11C      		adc r15,__zero_reg__
 491:main.c        **** 	{
 492:main.c        **** 		if (cnt<size) gBuffer[cnt]=recchar();
 231               	.LM26:
 232 0080 2017      		cp r18,r16
 233 0082 3107      		cpc r19,r17
 234 0084 18F4      		brsh .L10
 235 0086 0E94 0000 		call recchar
 236 008a 01C0      		rjmp .L33
 237               	.L10:
 493:main.c        **** 		else gBuffer[cnt]=0xFF;
 239               	.LM27:
 240 008c 8FEF      		ldi r24,lo8(-1)
 241               	.L33:
 242 008e 8883      		st Y,r24
 244               	.LM28:
 245 0090 9701      		movw r18,r14
 246 0092 2038      		cpi r18,128
 247 0094 3105      		cpc r19,__zero_reg__
 248 0096 68F3      		brlo .L12
 494:main.c        **** 	}
 495:main.c        **** 	cnt=0;
 250               	.LM29:
 251 0098 20E0      		ldi r18,lo8(0)
 252 009a 30E0      		ldi r19,hi8(0)
 496:main.c        **** 
 497:main.c        **** 	tempaddress = address;					// Store address in page
 254               	.LM30:
 255 009c C090 0000 		lds r12,address
 256 00a0 D090 0000 		lds r13,(address)+1
 257 00a4 E090 0000 		lds r14,(address)+2
 258 00a8 F090 0000 		lds r15,(address)+3
 259               	.L13:
 498:main.c        **** 	
 499:main.c        **** 	my_eeprom_busy_wait();
 261               	.LM31:
 262 00ac 8CB3      		in r24,60-0x20
 263 00ae 9927      		clr r25
 264 00b0 9695      		lsr r25
 265 00b2 8795      		ror r24
 266 00b4 AC01      		movw r20,r24
 267 00b6 4170      		andi r20,lo8(1)
 268 00b8 5070      		andi r21,hi8(1)
 269 00ba 80FD      		sbrc r24,0
 270 00bc F7CF      		rjmp .L13
 500:main.c        **** 	
 501:main.c        **** 	if (device == devtype)
 272               	.LM32:
 273 00be 8091 0000 		lds r24,device
 274 00c2 8337      		cpi r24,lo8(115)
 275 00c4 09F0      		breq .+2
 276 00c6 7FC0      		rjmp .L16
 502:main.c        **** 	{
 503:main.c        **** 		if (mem == 'F')		// Flash
 278               	.LM33:
 279 00c8 86E4      		ldi r24,lo8(70)
 280 00ca B816      		cp r11,r24
 281 00cc 09F0      		breq .+2
 282 00ce 39C0      		rjmp .L17
 283 00d0 41E0      		ldi r20,lo8(1)
 284 00d2 C0E0      		ldi r28,lo8(gBuffer)
 285 00d4 D0E0      		ldi r29,hi8(gBuffer)
 286               	.L18:
 504:main.c        **** 		{
 505:main.c        **** 			do {
 506:main.c        **** 				data=gBuffer[cnt++];
 288               	.LM34:
 289 00d6 8991      		ld r24,Y+
 290 00d8 282F      		mov r18,r24
 291 00da 3327      		clr r19
 507:main.c        **** 				data|=(gBuffer[cnt++]<<8);
 293               	.LM35:
 294 00dc 8991      		ld r24,Y+
 295 00de 9927      		clr r25
 296 00e0 982F      		mov r25,r24
 297 00e2 8827      		clr r24
 298 00e4 282B      		or r18,r24
 299 00e6 392B      		or r19,r25
 300               	.LBB2:
 508:main.c        **** 				boot_page_fill(address,data);
 302               	.LM36:
 303 00e8 8091 0000 		lds r24,address
 304 00ec 9091 0000 		lds r25,(address)+1
 305               	/* #APP */
 306 00f0 0901      		movw  r0, r18
 307 00f2 FC01      		movw r30, r24
 308 00f4 4093 5700 		sts 87, r20
 309 00f8 E895      		spm
 310 00fa 1124      		clr  r1
 311               		
 312               	/* #NOAPP */
 313               	.LBE2:
 509:main.c        **** 											//call asm routine. 
 510:main.c        **** 				address=address+2;  		// Select next word in memory
 315               	.LM37:
 316 00fc 8091 0000 		lds r24,address
 317 0100 9091 0000 		lds r25,(address)+1
 318 0104 A091 0000 		lds r26,(address)+2
 319 0108 B091 0000 		lds r27,(address)+3
 320 010c 0296      		adiw r24,2
 321 010e A11D      		adc r26,__zero_reg__
 322 0110 B11D      		adc r27,__zero_reg__
 323 0112 8093 0000 		sts address,r24
 324 0116 9093 0000 		sts (address)+1,r25
 325 011a A093 0000 		sts (address)+2,r26
 326 011e B093 0000 		sts (address)+3,r27
 511:main.c        **** 				size -= 2;					// Reduce number of bytes to write by two    
 328               	.LM38:
 329 0122 0250      		subi r16,lo8(-(-2))
 330 0124 1040      		sbci r17,hi8(-(-2))
 512:main.c        **** 			} while(size);					// Loop until all bytes written
 332               	.LM39:
 333 0126 B9F6      		brne .L18
 334               	.LBB3:
 513:main.c        **** 
 514:main.c        **** 			/* commented out since not compatible with mega8 - 
 515:main.c        **** 			   secondary benefit: saves memory 
 516:main.c        **** 			tempaddress &= 0xFF80;			// Ensure the address points to the first byte in the page
 517:main.c        **** 			*/
 518:main.c        **** 
 519:main.c        **** 			boot_page_write(tempaddress);
 336               	.LM40:
 337 0128 85E0      		ldi r24,lo8(5)
 338               	/* #APP */
 339 012a F601      		movw r30, r12
 340 012c 8093 5700 		sts 87, r24
 341 0130 E895      		spm
 342               		
 343               	/* #NOAPP */
 344               	.L21:
 345               	.LBE3:
 520:main.c        **** 			boot_spm_busy_wait();	
 347               	.LM41:
 348 0132 07B6      		in __tmp_reg__,87-0x20
 349 0134 00FC      		sbrc __tmp_reg__,0
 350 0136 FDCF      		rjmp .L21
 351               	.LBB4:
 521:main.c        **** 			boot_rww_enable();				//Re-enable the RWW section
 353               	.LM42:
 354 0138 81E1      		ldi r24,lo8(17)
 355               	/* #APP */
 356 013a 8093 5700 		sts 87, r24
 357 013e E895      		spm
 358               		
 359               	/* #NOAPP */
 360 0140 3FC0      		rjmp .L24
 361               	.L17:
 362               	.LBE4:
 522:main.c        **** 			
 523:main.c        **** 			/* commented out since not compatible with mega8
 524:main.c        **** 			if (address != (address & 0xFF80))
 525:main.c        **** 			{								// Ensure that the address points to the beginning of the next page
 526:main.c        **** 				address &= 0xFF80;
 527:main.c        **** 				address += SPM_PAGESIZE;
 528:main.c        **** 			}
 529:main.c        **** 			*/	
 530:main.c        **** 		}									// End FLASH
 531:main.c        **** 		
 532:main.c        **** 		if (mem == 'E')						// Start EEPROM
 364               	.LM43:
 365 0142 85E4      		ldi r24,lo8(69)
 366 0144 B816      		cp r11,r24
 367 0146 E1F5      		brne .L24
 533:main.c        ****         {
 534:main.c        **** 			address>>=1;
 369               	.LM44:
 370 0148 8091 0000 		lds r24,address
 371 014c 9091 0000 		lds r25,(address)+1
 372 0150 A091 0000 		lds r26,(address)+2
 373 0154 B091 0000 		lds r27,(address)+3
 374 0158 B695      		lsr r27
 375 015a A795      		ror r26
 376 015c 9795      		ror r25
 377 015e 8795      		ror r24
 378 0160 8093 0000 		sts address,r24
 379 0164 9093 0000 		sts (address)+1,r25
 380 0168 A093 0000 		sts (address)+2,r26
 381 016c B093 0000 		sts (address)+3,r27
 382 0170 F901      		movw r30,r18
 383 0172 E050      		subi r30,lo8(-(gBuffer-1))
 384 0174 F040      		sbci r31,hi8(-(gBuffer-1))
 385               	.L25:
 535:main.c        **** 			do {
 536:main.c        **** 	 	        EEARL = address;			// Setup EEPROM address
 387               	.LM45:
 388 0176 8091 0000 		lds r24,address
 389 017a 8EBB      		out 62-0x20,r24
 537:main.c        **** 	            EEARH = (address >> 8);
 391               	.LM46:
 392 017c 8091 0000 		lds r24,address
 393 0180 9091 0000 		lds r25,(address)+1
 394 0184 A091 0000 		lds r26,(address)+2
 395 0188 B091 0000 		lds r27,(address)+3
 396 018c 292F      		mov r18,r25
 397 018e 3A2F      		mov r19,r26
 398 0190 4B2F      		mov r20,r27
 399 0192 5527      		clr r21
 400 0194 2FBB      		out 63-0x20,r18
 538:main.c        **** 				address++;					// Select next byte
 402               	.LM47:
 403 0196 0196      		adiw r24,1
 404 0198 A11D      		adc r26,__zero_reg__
 405 019a B11D      		adc r27,__zero_reg__
 406 019c 8093 0000 		sts address,r24
 407 01a0 9093 0000 		sts (address)+1,r25
 408 01a4 A093 0000 		sts (address)+2,r26
 409 01a8 B093 0000 		sts (address)+3,r27
 539:main.c        **** 				EEDR=gBuffer[cnt++];
 411               	.LM48:
 412 01ac 3196      		adiw r30,1
 413 01ae 8081      		ld r24,Z
 414 01b0 8DBB      		out 61-0x20,r24
 540:main.c        **** 				
 541:main.c        **** 	            EECR |= (1<<EEMWE);			// Write data into EEPROM
 416               	.LM49:
 417 01b2 E29A      		sbi 60-0x20,2
 542:main.c        **** 	            EECR |= (1<<EEWE);
 419               	.LM50:
 420 01b4 E19A      		sbi 60-0x20,1
 421               	.L28:
 543:main.c        **** 	            
 544:main.c        **** 				while (EECR & (1<<EEWE));	// Wait for EEPROM write to finish
 423               	.LM51:
 424 01b6 E199      		sbic 60-0x20,1
 425 01b8 FECF      		rjmp .L28
 545:main.c        **** 				size--;						// Decreas number of bytes to write
 427               	.LM52:
 428 01ba 0150      		subi r16,lo8(-(-1))
 429 01bc 1040      		sbci r17,hi8(-(-1))
 546:main.c        **** 			} while(size);					// Loop until all bytes written
 431               	.LM53:
 432 01be D9F6      		brne .L25
 433               	.L24:
 547:main.c        **** 
 548:main.c        **** 		}
 549:main.c        **** 
 550:main.c        **** 		return '\r';						// Report programming OK
 435               	.LM54:
 436 01c0 8DE0      		ldi r24,lo8(13)
 437 01c2 90E0      		ldi r25,hi8(13)
 438 01c4 01C0      		rjmp .L6
 439               	.L16:
 551:main.c        **** 
 552:main.c        **** 	}
 553:main.c        **** 	
 554:main.c        **** 	return 0;								// Report programming failed
 441               	.LM55:
 442 01c6 CA01      		movw r24,r20
 443               	.L6:
 444               	/* epilogue: frame size=0 */
 445 01c8 DF91      		pop r29
 446 01ca CF91      		pop r28
 447 01cc 1F91      		pop r17
 448 01ce 0F91      		pop r16
 449 01d0 FF90      		pop r15
 450 01d2 EF90      		pop r14
 451 01d4 DF90      		pop r13
 452 01d6 CF90      		pop r12
 453 01d8 BF90      		pop r11
 454 01da 0895      		ret
 455               	/* epilogue end (size=10) */
 456               	/* function BufferLoad size 211 (192) */
 463               	.Lscope3:
 467               	.global	BlockRead
 469               	BlockRead:
 555:main.c        **** }
 556:main.c        **** 
 557:main.c        **** void BlockRead(unsigned int size, unsigned char mem)
 558:main.c        **** {
 471               	.LM56:
 472               	/* prologue: frame size=0 */
 473 01dc 0F93      		push r16
 474 01de 1F93      		push r17
 475 01e0 CF93      		push r28
 476 01e2 DF93      		push r29
 477               	/* prologue end (size=4) */
 478 01e4 EC01      		movw r28,r24
 479               	.L35:
 559:main.c        **** 	unsigned int data;
 560:main.c        **** 	
 561:main.c        **** 	my_eeprom_busy_wait();
 481               	.LM57:
 482 01e6 E199      		sbic 60-0x20,1
 483 01e8 FECF      		rjmp .L35
 562:main.c        **** 	
 563:main.c        **** 	if (mem == 'E')							// Read EEPROM
 485               	.LM58:
 486 01ea 6534      		cpi r22,lo8(69)
 487 01ec 11F5      		brne .L43
 488               	.L39:
 564:main.c        **** 	{
 565:main.c        **** 		// address>>=1; // not needed here - hmm, somehow inconsistant TODO
 566:main.c        **** 		do {
 567:main.c        **** 			EEARL = address;				// Setup EEPROM address
 490               	.LM59:
 491 01ee 8091 0000 		lds r24,address
 492 01f2 8EBB      		out 62-0x20,r24
 568:main.c        **** 			EEARH = (address >> 8);
 494               	.LM60:
 495 01f4 8091 0000 		lds r24,address
 496 01f8 9091 0000 		lds r25,(address)+1
 497 01fc A091 0000 		lds r26,(address)+2
 498 0200 B091 0000 		lds r27,(address)+3
 499 0204 292F      		mov r18,r25
 500 0206 3A2F      		mov r19,r26
 501 0208 4B2F      		mov r20,r27
 502 020a 5527      		clr r21
 503 020c 2FBB      		out 63-0x20,r18
 569:main.c        **** 			address++;						// Select next EEPROM byte
 505               	.LM61:
 506 020e 0196      		adiw r24,1
 507 0210 A11D      		adc r26,__zero_reg__
 508 0212 B11D      		adc r27,__zero_reg__
 509 0214 8093 0000 		sts address,r24
 510 0218 9093 0000 		sts (address)+1,r25
 511 021c A093 0000 		sts (address)+2,r26
 512 0220 B093 0000 		sts (address)+3,r27
 570:main.c        **** 			EECR |= (1<<EERE);				// Read EEPROM
 514               	.LM62:
 515 0224 E09A      		sbi 60-0x20,0
 571:main.c        **** 			sendchar(EEDR);					// Transmit EEPROM data to PC
 517               	.LM63:
 518 0226 8DB3      		in r24,61-0x20
 519 0228 0E94 0000 		call sendchar
 572:main.c        **** 			size--;							// Decrease number of bytes to read
 521               	.LM64:
 522 022c 2197      		sbiw r28,1
 573:main.c        **** 		} while (size);					// Repeat until all block has been read
 524               	.LM65:
 525 022e F9F6      		brne .L39
 526 0230 22C0      		rjmp .L34
 527               	.L43:
 528               	.LBB5:
 574:main.c        **** 	}
 575:main.c        **** 	else									// Read Flash
 576:main.c        **** 	{
 577:main.c        **** 		do {
 578:main.c        **** #if defined(RAMPZ)
 579:main.c        **** 			data = pgm_read_word_far(address);
 580:main.c        **** #else
 581:main.c        **** 			data = pgm_read_word_near((uint16_t)address);
 530               	.LM66:
 531 0232 E091 0000 		lds r30,address
 532 0236 F091 0000 		lds r31,(address)+1
 533               	/* #APP */
 534 023a 0591      		lpm r16, Z+
 535 023c 1491      		lpm r17, Z
 536               		
 537               	/* #NOAPP */
 538               	.LBE5:
 582:main.c        **** #endif
 583:main.c        **** 			sendchar((unsigned char)data);		//send LSB
 540               	.LM67:
 541 023e 802F      		mov r24,r16
 542 0240 0E94 0000 		call sendchar
 584:main.c        **** 			sendchar((unsigned char)(data >> 8));	//send MSB  
 544               	.LM68:
 545 0244 812F      		mov r24,r17
 546 0246 9927      		clr r25
 547 0248 0E94 0000 		call sendchar
 585:main.c        **** 			address += 2;  					// Select next word in memory
 549               	.LM69:
 550 024c 8091 0000 		lds r24,address
 551 0250 9091 0000 		lds r25,(address)+1
 552 0254 A091 0000 		lds r26,(address)+2
 553 0258 B091 0000 		lds r27,(address)+3
 554 025c 0296      		adiw r24,2
 555 025e A11D      		adc r26,__zero_reg__
 556 0260 B11D      		adc r27,__zero_reg__
 557 0262 8093 0000 		sts address,r24
 558 0266 9093 0000 		sts (address)+1,r25
 559 026a A093 0000 		sts (address)+2,r26
 560 026e B093 0000 		sts (address)+3,r27
 586:main.c        **** 			size -= 2;						// Subtract two bytes from number of bytes to read
 562               	.LM70:
 563 0272 2297      		sbiw r28,2
 587:main.c        **** 		} while (size);					// Repeat until all block has been read
 565               	.LM71:
 566 0274 F1F6      		brne .L43
 567               	.L34:
 568               	/* epilogue: frame size=0 */
 569 0276 DF91      		pop r29
 570 0278 CF91      		pop r28
 571 027a 1F91      		pop r17
 572 027c 0F91      		pop r16
 573 027e 0895      		ret
 574               	/* epilogue end (size=5) */
 575               	/* function BlockRead size 88 (79) */
 581               	.Lscope4:
 583               	.global	main
 585               	main:
 587               	.LM72:
 588               	/* prologue: frame size=0 */
 589 0280 C0E0      		ldi r28,lo8(__stack - 0)
 590 0282 D0E0      		ldi r29,hi8(__stack - 0)
 591 0284 DEBF      		out __SP_H__,r29
 592 0286 CDBF      		out __SP_L__,r28
 593               	/* prologue end (size=4) */
 595               	.LM73:
 596               	/* #APP */
 597 0288 F894      		cli
 599               	.LM74:
 600               	/* #NOAPP */
 601 028a 01E0      		ldi r16,lo8(1)
 602 028c 05BF      		out 85-0x20,r16
 604               	.LM75:
 605 028e 82E0      		ldi r24,lo8(2)
 606 0290 85BF      		out 85-0x20,r24
 608               	.LM76:
 609 0292 60E0      		ldi r22,lo8(0)
 610 0294 83E3      		ldi r24,lo8(51)
 611 0296 90E0      		ldi r25,hi8(51)
 612 0298 0E94 0000 		call USART_Init
 614               	.LM77:
 615 029c 0E94 0000 		call d7segment_init
 617               	.LM78:
 618 02a0 80B3      		in r24,48-0x20
 620               	.LM79:
 621 02a2 93B3      		in r25,51-0x20
 623               	.LM80:
 624 02a4 83FF      		sbrs r24,3
 625 02a6 0BC0      		rjmp .L106
 627               	.LM81:
 628 02a8 05BF      		out 85-0x20,r16
 630               	.LM82:
 631 02aa 15BE      		out 85-0x20,__zero_reg__
 633               	.LM83:
 634 02ac 602F      		mov r22,r16
 635 02ae 83E7      		ldi r24,lo8(115)
 636 02b0 0E94 0000 		call d7segment_display
 637               	.L103:
 639               	.LM84:
 640 02b4 E091 0000 		lds r30,jump_to_app
 641 02b8 F091 0000 		lds r31,(jump_to_app)+1
 642 02bc 0995      		icall
 643               	.L106:
 645               	.LM85:
 646 02be 61E0      		ldi r22,lo8(1)
 647 02c0 8CE7      		ldi r24,lo8(124)
 648 02c2 0E94 0000 		call d7segment_display
 650               	.LM86:
 651 02c6 0E94 0000 		call recchar
 652 02ca 682F      		mov r22,r24
 654               	.LM87:
 655 02cc 8136      		cpi r24,lo8(97)
 656 02ce 11F4      		brne .L50
 658               	.LM88:
 659 02d0 89E5      		ldi r24,lo8(89)
 660 02d2 ECC0      		rjmp .L102
 661               	.L50:
 663               	.LM89:
 664 02d4 8134      		cpi r24,lo8(65)
 665 02d6 39F5      		brne .L52
 667               	.LM90:
 668 02d8 0E94 0000 		call recchar
 669 02dc 9927      		clr r25
 670 02de AA27      		clr r26
 671 02e0 BB27      		clr r27
 672 02e2 8093 0000 		sts address,r24
 673 02e6 9093 0000 		sts (address)+1,r25
 674 02ea A093 0000 		sts (address)+2,r26
 675 02ee B093 0000 		sts (address)+3,r27
 677               	.LM91:
 678 02f2 EE24      		clr r14
 679 02f4 F82E      		mov r15,r24
 680 02f6 092F      		mov r16,r25
 681 02f8 1A2F      		mov r17,r26
 682 02fa 0E94 0000 		call recchar
 683 02fe 9927      		clr r25
 684 0300 AA27      		clr r26
 685 0302 BB27      		clr r27
 686 0304 E82A      		or r14,r24
 687 0306 F92A      		or r15,r25
 688 0308 0A2B      		or r16,r26
 689 030a 1B2B      		or r17,r27
 691               	.LM92:
 692 030c EE0C      		lsl r14
 693 030e FF1C      		rol r15
 694 0310 001F      		rol r16
 695 0312 111F      		rol r17
 696 0314 E092 0000 		sts address,r14
 697 0318 F092 0000 		sts (address)+1,r15
 698 031c 0093 0000 		sts (address)+2,r16
 699 0320 1093 0000 		sts (address)+3,r17
 700 0324 68C0      		rjmp .L104
 701               	.L52:
 703               	.LM93:
 704 0326 8236      		cpi r24,lo8(98)
 705 0328 41F4      		brne .L54
 707               	.LM94:
 708 032a 89E5      		ldi r24,lo8(89)
 709 032c 0E94 0000 		call sendchar
 711               	.LM95:
 712 0330 80E0      		ldi r24,lo8(0)
 713 0332 0E94 0000 		call sendchar
 715               	.LM96:
 716 0336 80E8      		ldi r24,lo8(-128)
 717 0338 B9C0      		rjmp .L102
 718               	.L54:
 720               	.LM97:
 721 033a 8234      		cpi r24,lo8(66)
 722 033c 89F4      		brne .L56
 724               	.LM98:
 725 033e 0E94 0000 		call recchar
 726 0342 9927      		clr r25
 727 0344 182F      		mov r17,r24
 728 0346 0027      		clr r16
 730               	.LM99:
 731 0348 0E94 0000 		call recchar
 732 034c 9927      		clr r25
 733 034e 082B      		or r16,r24
 734 0350 192B      		or r17,r25
 736               	.LM100:
 737 0352 0E94 0000 		call recchar
 738 0356 682F      		mov r22,r24
 740               	.LM101:
 741 0358 C801      		movw r24,r16
 742 035a 0E94 0000 		call BufferLoad
 743 035e A6C0      		rjmp .L102
 744               	.L56:
 746               	.LM102:
 747 0360 8736      		cpi r24,lo8(103)
 748 0362 89F4      		brne .L58
 750               	.LM103:
 751 0364 0E94 0000 		call recchar
 752 0368 9927      		clr r25
 753 036a 182F      		mov r17,r24
 754 036c 0027      		clr r16
 755 036e 0E94 0000 		call recchar
 756 0372 9927      		clr r25
 757 0374 082B      		or r16,r24
 758 0376 192B      		or r17,r25
 760               	.LM104:
 761 0378 0E94 0000 		call recchar
 762 037c 682F      		mov r22,r24
 764               	.LM105:
 765 037e C801      		movw r24,r16
 766 0380 0E94 0000 		call BlockRead
 767 0384 9CCF      		rjmp .L106
 768               	.L58:
 770               	.LM106:
 771 0386 8536      		cpi r24,lo8(101)
 772 0388 09F0      		breq .+2
 773 038a 37C0      		rjmp .L60
 775               	.LM107:
 776 038c 8091 0000 		lds r24,device
 777 0390 8337      		cpi r24,lo8(115)
 778 0392 69F5      		brne .L61
 780               	.LM108:
 781 0394 1092 0000 		sts address,__zero_reg__
 782 0398 1092 0000 		sts (address)+1,__zero_reg__
 783 039c 1092 0000 		sts (address)+2,__zero_reg__
 784 03a0 1092 0000 		sts (address)+3,__zero_reg__
 785 03a4 23E0      		ldi r18,lo8(3)
 786               	.L67:
 787               	.LBB6:
 789               	.LM109:
 790 03a6 8091 0000 		lds r24,address
 791 03aa 9091 0000 		lds r25,(address)+1
 792               	/* #APP */
 793 03ae FC01      		movw r30, r24
 794 03b0 2093 5700 		sts 87, r18
 795 03b4 E895      		spm
 796               		
 797               	/* #NOAPP */
 798               	.L64:
 799               	.LBE6:
 801               	.LM110:
 802 03b6 07B6      		in __tmp_reg__,87-0x20
 803 03b8 00FC      		sbrc __tmp_reg__,0
 804 03ba FDCF      		rjmp .L64
 806               	.LM111:
 807 03bc 8091 0000 		lds r24,address
 808 03c0 9091 0000 		lds r25,(address)+1
 809 03c4 A091 0000 		lds r26,(address)+2
 810 03c8 B091 0000 		lds r27,(address)+3
 811 03cc 8058      		subi r24,lo8(-(128))
 812 03ce 9F4F      		sbci r25,hi8(-(128))
 813 03d0 AF4F      		sbci r26,hlo8(-(128))
 814 03d2 BF4F      		sbci r27,hhi8(-(128))
 815 03d4 8093 0000 		sts address,r24
 816 03d8 9093 0000 		sts (address)+1,r25
 817 03dc A093 0000 		sts (address)+2,r26
 818 03e0 B093 0000 		sts (address)+3,r27
 819 03e4 8050      		subi r24,lo8(28672)
 820 03e6 9047      		sbci r25,hi8(28672)
 821 03e8 A040      		sbci r26,hlo8(28672)
 822 03ea B040      		sbci r27,hhi8(28672)
 823 03ec E0F2      		brlo .L67
 824               	.L61:
 825               	.LBB7:
 827               	.LM112:
 828 03ee 81E1      		ldi r24,lo8(17)
 829               	/* #APP */
 830 03f0 8093 5700 		sts 87, r24
 831 03f4 E895      		spm
 832               		
 833               	/* #NOAPP */
 834               	.L104:
 835               	.LBE7:
 837               	.LM113:
 838 03f6 8DE0      		ldi r24,lo8(13)
 839 03f8 59C0      		rjmp .L102
 840               	.L60:
 842               	.LM114:
 843 03fa 8534      		cpi r24,lo8(69)
 844 03fc 39F4      		brne .L69
 846               	.LM115:
 847 03fe 8DE0      		ldi r24,lo8(13)
 848 0400 0E94 0000 		call sendchar
 850               	.LM116:
 851 0404 81E0      		ldi r24,lo8(1)
 852 0406 85BF      		out 85-0x20,r24
 854               	.LM117:
 855 0408 15BE      		out 85-0x20,__zero_reg__
 856 040a 54CF      		rjmp .L103
 857               	.L69:
 859               	.LM118:
 860 040c 8035      		cpi r24,lo8(80)
 861 040e 99F3      		breq .L104
 863               	.LM119:
 864 0410 8C34      		cpi r24,lo8(76)
 865 0412 89F3      		breq .L104
 867               	.LM120:
 868 0414 8037      		cpi r24,lo8(112)
 869 0416 11F4      		brne .L75
 871               	.LM121:
 872 0418 83E5      		ldi r24,lo8(83)
 873 041a 48C0      		rjmp .L102
 874               	.L75:
 876               	.LM122:
 877 041c 8634      		cpi r24,lo8(70)
 878 041e 21F4      		brne .L77
 880               	.LM123:
 881 0420 69E0      		ldi r22,lo8(9)
 882 0422 80E0      		ldi r24,lo8(0)
 883 0424 90E0      		ldi r25,hi8(0)
 884 0426 05C0      		rjmp .L105
 885               	.L77:
 887               	.LM124:
 888 0428 8237      		cpi r24,lo8(114)
 889 042a 31F4      		brne .L79
 891               	.LM125:
 892 042c 69E0      		ldi r22,lo8(9)
 893 042e 81E0      		ldi r24,lo8(1)
 894 0430 90E0      		ldi r25,hi8(1)
 895               	.L105:
 896 0432 0E94 0000 		call read_fuse_lock
 897 0436 3AC0      		rjmp .L102
 898               	.L79:
 900               	.LM126:
 901 0438 8E34      		cpi r24,lo8(78)
 902 043a 21F4      		brne .L81
 904               	.LM127:
 905 043c 69E0      		ldi r22,lo8(9)
 906 043e 83E0      		ldi r24,lo8(3)
 907 0440 90E0      		ldi r25,hi8(3)
 908 0442 F7CF      		rjmp .L105
 909               	.L81:
 911               	.LM128:
 912 0444 8135      		cpi r24,lo8(81)
 913 0446 21F4      		brne .L83
 915               	.LM129:
 916 0448 69E0      		ldi r22,lo8(9)
 917 044a 82E0      		ldi r24,lo8(2)
 918 044c 90E0      		ldi r25,hi8(2)
 919 044e F1CF      		rjmp .L105
 920               	.L83:
 922               	.LM130:
 923 0450 8437      		cpi r24,lo8(116)
 924 0452 29F4      		brne .L85
 926               	.LM131:
 927 0454 83E7      		ldi r24,lo8(115)
 928 0456 0E94 0000 		call sendchar
 930               	.LM132:
 931 045a 80E0      		ldi r24,lo8(0)
 932 045c 27C0      		rjmp .L102
 933               	.L85:
 935               	.LM133:
 936 045e 8857      		subi r24,lo8(-(-120))
 937 0460 8230      		cpi r24,lo8(2)
 938 0462 18F4      		brsh .L87
 940               	.LM134:
 941 0464 0E94 0000 		call recchar
 942 0468 C6CF      		rjmp .L104
 943               	.L87:
 945               	.LM135:
 946 046a 6435      		cpi r22,lo8(84)
 947 046c 29F4      		brne .L89
 949               	.LM136:
 950 046e 0E94 0000 		call recchar
 951 0472 8093 0000 		sts device,r24
 952 0476 BFCF      		rjmp .L104
 953               	.L89:
 955               	.LM137:
 956 0478 6335      		cpi r22,lo8(83)
 957 047a 19F4      		brne .L91
 959               	.LM138:
 960 047c 0E94 0000 		call send_boot
 961 0480 1ECF      		rjmp .L106
 962               	.L91:
 964               	.LM139:
 965 0482 6635      		cpi r22,lo8(86)
 966 0484 29F4      		brne .L93
 968               	.LM140:
 969 0486 80E3      		ldi r24,lo8(48)
 970 0488 0E94 0000 		call sendchar
 972               	.LM141:
 973 048c 87E3      		ldi r24,lo8(55)
 974 048e 0EC0      		rjmp .L102
 975               	.L93:
 977               	.LM142:
 978 0490 6337      		cpi r22,lo8(115)
 979 0492 41F4      		brne .L95
 981               	.LM143:
 982 0494 82E0      		ldi r24,lo8(2)
 983 0496 0E94 0000 		call sendchar
 985               	.LM144:
 986 049a 85E9      		ldi r24,lo8(-107)
 987 049c 0E94 0000 		call sendchar
 989               	.LM145:
 990 04a0 8EE1      		ldi r24,lo8(30)
 991 04a2 04C0      		rjmp .L102
 992               	.L95:
 994               	.LM146:
 995 04a4 6B31      		cpi r22,lo8(27)
 996 04a6 09F4      		brne .+2
 997 04a8 0ACF      		rjmp .L106
 999               	.LM147:
 1000 04aa 8FE3      		ldi r24,lo8(63)
 1001               	.L102:
 1002 04ac 0E94 0000 		call sendchar
 1004               	.LM148:
 1005 04b0 06CF      		rjmp .L106
 1006               	/* epilogue: frame size=0 */
 1007               	/* epilogue: noreturn */
 1008               	/* epilogue end (size=0) */
 1009               	/* function main size 292 (288) */
 1015               	.Lscope5:
 1016               		.comm gBuffer,128,1
 1017               		.comm address,4,1
 1018               		.comm device,1,1
 1023               		.text
 1025               	Letext:
 1026               	/* File "main.c": code  635 = 0x027b ( 600), prologues  17, epilogues  18 */
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:74     .bss:00000000 jump_to_app
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:80     .text:00000000 send_boot
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:122    .text:0000002c d7segment_init
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:159    .text:00000040 d7segment_display
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:202    .text:00000058 BufferLoad
                            *COM*:00000080 gBuffer
                            *COM*:00000004 address
                            *COM*:00000001 device
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:469    .text:000001dc BlockRead
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:585    .text:00000280 main
C:\DOCUME~1\tos\LOCALS~1\Temp/ccA3aaaa.s:1025   .text:000004b2 Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
sendchar
recchar
__stack
USART_Init
read_fuse_lock
